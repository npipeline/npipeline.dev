"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3899],{3767:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"core-concepts/nodes/tap","title":"Tap Nodes","description":"Non-intrusive monitoring and side-channel processing using NPipeline\'s Tap Nodes.","source":"@site/docs/core-concepts/nodes/tap.md","sourceDirName":"core-concepts/nodes","slug":"/core-concepts/nodes/tap","permalink":"/docs/core-concepts/nodes/tap","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Tap Nodes","description":"Non-intrusive monitoring and side-channel processing using NPipeline\'s Tap Nodes.","sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Branch Nodes","permalink":"/docs/core-concepts/nodes/branch"},"next":{"title":"Type Conversion Nodes","permalink":"/docs/core-concepts/nodes/type-conversion"}}');var s=i(4848),t=i(8453);const r={title:"Tap Nodes",description:"Non-intrusive monitoring and side-channel processing using NPipeline's Tap Nodes.",sidebar_position:6},a="Tap Nodes",l={},d=[{value:"<code>TapNode&lt;T&gt;</code>: Non-Intrusive Monitoring",id:"tapnodet-non-intrusive-monitoring",level:2},{value:"Constructor",id:"constructor",level:3},{value:"Example: Logging Intermediate Data",id:"example-logging-intermediate-data",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Considerations for Tap Nodes",id:"considerations-for-tap-nodes",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"tap-nodes",children:"Tap Nodes"})}),"\n",(0,s.jsx)(n.p,{children:'Tap nodes allow you to "tap into" a data stream for non-intrusive monitoring, logging, or side-channel processing without affecting the primary flow of data. Data passing through a Tap node continues uninterrupted to the next node in the main pipeline path, while a copy is sent to a separate processing branch.'}),"\n",(0,s.jsx)(n.mermaid,{value:"graph LR\n    A[Source Data Stream] --\x3e B[TapNode]\n    B --\x3e C[Main Processing Path]\n    B --\x3e D[Monitoring Tap]\n\n    C --\x3e E[Main Sink]\n    D --\x3e F[Logging Sink]\n\n    style B fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\n    style D fill:#fff3e0,stroke:#e65100,stroke-width:2px,stroke-dasharray: 5 5"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Figure: TapNode pattern showing non-intrusive monitoring where the main data flow continues uninterrupted while a copy is sent to monitoring."})}),"\n",(0,s.jsxs)(n.p,{children:["NPipeline provides the specialized ",(0,s.jsx)(n.a,{href:"src/NPipeline/Nodes/TapNode.cs",children:(0,s.jsx)(n.code,{children:"TapNode<T>"})})," for this purpose."]}),"\n",(0,s.jsxs)(n.h2,{id:"tapnodet-non-intrusive-monitoring",children:[(0,s.jsx)(n.a,{href:"src/NPipeline/Nodes/TapNode.cs",children:(0,s.jsx)(n.code,{children:"TapNode<T>"})}),": Non-Intrusive Monitoring"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"src/NPipeline/Nodes/TapNode.cs",children:(0,s.jsx)(n.code,{children:"TapNode<T>"})}),' is a specialized form of a fan-out node designed for non-intrusive monitoring or logging. It allows you to "tap into" a data stream without affecting the primary flow of data. Data passing through a ',(0,s.jsx)(n.code,{children:"TapNode"})," also continues to the next node in the main pipeline path."]}),"\n",(0,s.jsx)(n.h3,{id:"constructor",children:"Constructor"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"TapNode<T>"})," constructor requires:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"sink"})," (",(0,s.jsx)(n.code,{children:"ISinkNode<T>"}),"): The sink node to which tapped data copies will be sent for processing."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Example of creating a TapNode with a custom sink\nvar loggingSink = new LoggingSink<MyData>();\nvar tapNode = new TapNode<MyData>(loggingSink);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"example-logging-intermediate-data",children:"Example: Logging Intermediate Data"}),"\n",(0,s.jsxs)(n.p,{children:["You can insert a ",(0,s.jsx)(n.code,{children:"TapNode"})," at any point in your pipeline to log or inspect data without altering the data itself or its flow to subsequent processing steps."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\nusing NPipeline.Nodes;\n\npublic sealed class LoggingTapSink<T> : SinkNode<T>\n{\n    private readonly string _label;\n    public LoggingTapSink(string label) => _label = label;\n\n    public async Task ExecuteAsync(IAsyncEnumerable<T> input, CancellationToken cancellationToken = default)\n    {\n        await foreach (var item in input.WithCancellation(cancellationToken))\n        {\n            Console.WriteLine($"Tap ({_label}): Logged {item}");\n        }\n    }\n}\n\npublic static class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var context = PipelineContext.Default;\n        var runner = new PipelineRunner();\n        \n        Console.WriteLine("Starting Tap pipeline...");\n        await runner.RunAsync<TapPipelineDefinition>(context);\n        Console.WriteLine("Tap pipeline finished.");\n    }\n}\n\npublic sealed class TapPipelineDefinition : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var sourceHandle = builder.AddSource<InMemorySourceNode<int>, int>("source");\n        var tap1Handle = builder.AddTap<LoggingTapSink<int>>("tap1Before");\n        var transformHandle = builder.AddTransform<SquareTransform, int, int>("transform");\n        var tap2Handle = builder.AddTap<LoggingTapSink<int>>("tap2After");\n        var sinkHandle = builder.AddSink<ConsoleSink<int>, int>("sink");\n\n        builder.Connect(sourceHandle, tap1Handle);\n        builder.Connect(tap1Handle, transformHandle);\n        builder.Connect(transformHandle, tap2Handle);\n        builder.Connect(tap2Handle, sinkHandle);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Usage"}),": Tap nodes maintain separate processing queues for tapped data. Be mindful of memory consumption when tapping high-throughput streams."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Backpressure"}),": If the tapped branch becomes slow, it can create backpressure that affects the main pipeline. Consider using appropriate buffering strategies or async processing in sink implementations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Throughput Impact"}),": Duplicating and processing a copy of the stream incurs overhead. For high-throughput scenarios, profile your pipeline to ensure the tap doesn't become a bottleneck."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Management"}),": Ensure the tapped sink properly disposes of resources, especially when maintaining connections or file handles."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"considerations-for-tap-nodes",children:"Considerations for Tap Nodes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Isolation"}),": Tap nodes provide isolation between the main pipeline and the monitoring/logging branch, allowing them to proceed independently."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"}),": Errors in the tapped branch will typically not affect the main pipeline path, allowing for isolated fault tolerance. However, an unhandled error in a ",(0,s.jsx)(n.a,{href:"src/NPipeline/Nodes/TapNode.cs",children:(0,s.jsx)(n.code,{children:"TapNode"})})," can still propagate and potentially halt the pipeline if not caught."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Observability"}),": Tap nodes are ideal for observability scenarios where you need to extract metrics, traces, or logs without modifying the core business logic."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Tap nodes are powerful tools for adding non-intrusive monitoring and side-channel processing to your NPipelines without disrupting the main data flow."}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/nodes/branch",children:"Branch Nodes"})}),": Learn about fan-out patterns for duplicating streams to multiple processing paths."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling-guide#advanced-patterns",children:"Advanced Error Handling Patterns"})}),": Learn more about handling errors in complex pipeline structures."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var o=i(6540);const s={},t=o.createContext(s);function r(e){const n=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);