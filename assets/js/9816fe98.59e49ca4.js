"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[5581],{8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>i});var t=r(6540);const a={},s=t.createContext(a);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(s.Provider,{value:n},e.children)}},8804:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"core-concepts/nodes/transform-nodes","title":"Transform Nodes","description":"Learn how to implement transform nodes and optimize for high performance using ValueTask<T>.","source":"@site/docs/core-concepts/nodes/transform-nodes.md","sourceDirName":"core-concepts/nodes","slug":"/core-concepts/nodes/transform-nodes","permalink":"/docs/core-concepts/nodes/transform-nodes","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Transform Nodes","description":"Learn how to implement transform nodes and optimize for high performance using ValueTask<T>.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Batching Nodes","permalink":"/docs/core-concepts/nodes/batching"},"next":{"title":"Join Nodes","permalink":"/docs/core-concepts/nodes/join"}}');var a=r(4848),s=r(8453);const o={title:"Transform Nodes",description:"Learn how to implement transform nodes and optimize for high performance using ValueTask<T>.",sidebar_position:2},i="Transform Nodes (ITransformNode<TIn, TOut>)",c={},l=[{value:"Interface Definition",id:"interface-definition",level:2},{value:"Stream Transform Nodes (<code>IStreamTransformNode&lt;TIn, TOut&gt;</code>)",id:"stream-transform-nodes-istreamtransformnodetin-tout",level:2},{value:"When to Use Stream Transforms",id:"when-to-use-stream-transforms",level:3},{value:"Interface Definition",id:"interface-definition-1",level:3},{value:"Choosing Between Transform Types",id:"choosing-between-transform-types",level:2},{value:"Implementation Example",id:"implementation-example",level:2},{value:"Batching Transform (Stream-based)",id:"batching-transform-stream-based",level:3},{value:"Unbatching Transform (Stream-based)",id:"unbatching-transform-stream-based",level:3},{value:"Implementation Example",id:"implementation-example-1",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Common Transform Patterns",id:"common-transform-patterns",level:2},{value:"Data Enrichment",id:"data-enrichment",level:3},{value:"Validation and Filtering",id:"validation-and-filtering",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsxs)(n.h1,{id:"transform-nodes-itransformnodetin-tout",children:["Transform Nodes (",(0,a.jsx)(n.code,{children:"ITransformNode<TIn, TOut>"}),")"]})}),"\n",(0,a.jsxs)(n.p,{children:["Transform nodes take an input stream of ",(0,a.jsx)(n.code,{children:"TInput"})," items, perform some operation on them, and then produce an output stream of ",(0,a.jsx)(n.code,{children:"TOutput"})," items. They are the workhorses of data manipulation within a pipeline."]}),"\n",(0,a.jsx)(n.h2,{id:"interface-definition",children:"Interface Definition"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public interface ITransformNode<TIn, TOut> : INode\r\n{\r\n    Task<TOut> ExecuteAsync(TIn item, PipelineContext context, CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"stream-transform-nodes-istreamtransformnodetin-tout",children:["Stream Transform Nodes (",(0,a.jsx)(n.code,{children:"IStreamTransformNode<TIn, TOut>"}),")"]}),"\n",(0,a.jsx)(n.p,{children:"Stream transform nodes operate on entire streams of data rather than individual items. They are designed for scenarios where you need to transform the stream itself - such as batching, unbatching, windowing, or other operations that change the cardinality or timing of data flow."}),"\n",(0,a.jsx)(n.h3,{id:"when-to-use-stream-transforms",children:"When to Use Stream Transforms"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"IStreamTransformNode"})," when your node needs to:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Change stream cardinality"})," - Convert one item to many, many to one, or many to many"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Process data in groups"})," - Apply operations to batches or windows of data"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Introduce timing elements"})," - Add temporal constraints to data flow"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimize for specific patterns"})," - Implement batching, buffering, or stream-aware algorithms"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"interface-definition-1",children:"Interface Definition"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public interface IStreamTransformNode<TIn, TOut> : INode\r\n{\r\n    IExecutionStrategy ExecutionStrategy { get; set; }\r\n    INodeErrorHandler? ErrorHandler { get; set; }\r\n\r\n    IAsyncEnumerable<TOut> ExecuteAsync(\r\n        IAsyncEnumerable<TIn> items,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"choosing-between-transform-types",children:"Choosing Between Transform Types"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Aspect"}),(0,a.jsx)(n.th,{children:"ITransformNode"}),(0,a.jsx)(n.th,{children:"IStreamTransformNode"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Processing Model"})}),(0,a.jsx)(n.td,{children:"One item at a time"}),(0,a.jsx)(n.td,{children:"Entire stream at once"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Return Type"})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"Task<TOut>"})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"IAsyncEnumerable<TOut>"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Use Cases"})}),(0,a.jsx)(n.td,{children:"Simple transformations, enrichment, validation"}),(0,a.jsx)(n.td,{children:"Batching, unbatching, windowing, filtering"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Memory Pattern"})}),(0,a.jsx)(n.td,{children:"Low memory footprint"}),(0,a.jsx)(n.td,{children:"Higher memory for stream processing"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Performance"})}),(0,a.jsx)(n.td,{children:"Low per-item overhead"}),(0,a.jsx)(n.td,{children:"Optimized for stream operations"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Table 1: Comparison of transform node types and their appropriate use cases."})}),"\n",(0,a.jsx)(n.h2,{id:"implementation-example",children:"Implementation Example"}),"\n",(0,a.jsx)(n.h3,{id:"batching-transform-stream-based",children:"Batching Transform (Stream-based)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Groups individual items into batches for efficient processing.\r\n/// Demonstrates IStreamTransformNode for stream-based transformations.\r\n/// </summary>\r\npublic sealed class BatchingTransform<T> : IStreamTransformNode<T, IReadOnlyCollection<T>>\r\n{\r\n    private readonly int _batchSize;\r\n    private readonly TimeSpan _timeout;\r\n\r\n    public BatchingTransform(int batchSize, TimeSpan timeout)\r\n    {\r\n        _batchSize = batchSize;\r\n        _timeout = timeout;\r\n    }\r\n\r\n    public IExecutionStrategy ExecutionStrategy { get; set; } = new BatchingExecutionStrategy();\r\n    public INodeErrorHandler? ErrorHandler { get; set; }\r\n\r\n    public IAsyncEnumerable<IReadOnlyCollection<T>> ExecuteAsync(\r\n        IAsyncEnumerable<T> items,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Use BatchAsync extension method for efficient batching\r\n        return items.BatchAsync(_batchSize, _timeout, cancellationToken);\r\n    }\r\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"unbatching-transform-stream-based",children:"Unbatching Transform (Stream-based)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Flattens a stream of batches back to individual items.\r\n/// Demonstrates reverse operation to batching transform.\r\n/// </summary>\r\npublic sealed class UnbatchingTransform<T> : IStreamTransformNode<IEnumerable<T>, T>\r\n{\r\n    public IExecutionStrategy ExecutionStrategy { get; set; } = new UnbatchingExecutionStrategy();\r\n    public INodeErrorHandler? ErrorHandler { get; set; }\r\n\r\n    public IAsyncEnumerable<T> ExecuteAsync(\r\n        IAsyncEnumerable<IEnumerable<T>> batches,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Use FlattenAsync extension method for efficient unbatching\r\n        return batches.FlattenAsync(cancellationToken);\r\n    }\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"implementation-example-1",children:"Implementation Example"}),"\n",(0,a.jsx)(n.p,{children:"A transform that squares each incoming number:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Basic transform that squares each incoming integer.\r\n/// Demonstrates the simplest possible transform implementation\r\n/// with synchronous work using Task.FromResult to avoid async overhead.\r\n/// </summary>\r\npublic sealed class SquareTransform : ITransformNode<int, int>\r\n{\r\n    /// <summary>\r\n    /// Processes each integer by squaring it.\r\n    /// Uses Task.FromResult for synchronous work to avoid unnecessary Task allocation.\r\n    /// </summary>\r\n    public Task<int> ExecuteAsync(int item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Synchronous calculation - no async work needed\r\n        return Task.FromResult(item * item);\r\n    }\r\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Transform that enriches order data with customer information.\r\n/// Demonstrates async transform pattern with external service dependency.\r\n/// </summary>\r\npublic sealed class EnrichmentTransform : ITransformNode<Order, EnrichedOrder>\r\n{\r\n    private readonly ILookupService _lookupService;\r\n\r\n    public EnrichmentTransform(ILookupService lookupService)\r\n    {\r\n        _lookupService = lookupService;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Enriches each order with customer information from lookup service.\r\n    /// Uses async/await pattern as external service call is inherently asynchronous.\r\n    /// </summary>\r\n    public async Task<EnrichedOrder> ExecuteAsync(Order order, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Fetch customer data from external service (async operation)\r\n        var customerInfo = await _lookupService.GetCustomerAsync(order.CustomerId, cancellationToken);\r\n        \r\n        // Create enriched order with customer details\r\n        return new EnrichedOrder\r\n        {\r\n            OrderId = order.OrderId,\r\n            CustomerId = order.CustomerId,\r\n            CustomerName = customerInfo.Name,\r\n            Total = order.Total\r\n        };\r\n    }\r\n}\r\n\r\n// Supporting types for the example\r\npublic record Order(string OrderId, string CustomerId, decimal Total);\r\npublic record EnrichedOrder(string OrderId, string CustomerId, string CustomerName, decimal Total);\r\npublic interface ILookupService\r\n{\r\n    Task<CustomerInfo> GetCustomerAsync(string customerId, CancellationToken cancellationToken);\r\n}\r\npublic record CustomerInfo(string Name);\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Transform that validates input data and converts to output format.\r\n/// Demonstrates ValueTask optimization for synchronous validation scenarios.\r\n/// In pipelines with high throughput, this eliminates Task allocations for validation.\r\n/// </summary>\r\npublic sealed class ValidationTransform : ITransformNode<RawData, ValidatedData>\r\n{\r\n    /// <summary>\r\n    /// Validates raw data and converts to validated format.\r\n    /// Uses ValueTask for synchronous validation to avoid heap allocation.\r\n    /// </summary>\r\n    public ValueTask<ValidatedData> ExecuteAsync(RawData item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Synchronous validation - check for empty or null values\r\n        if (string.IsNullOrWhiteSpace(item.Value))\r\n        {\r\n            throw new InvalidOperationException("Value cannot be empty or null");\r\n        }\r\n\r\n        // Create validated data with trimmed value\r\n        var validated = new ValidatedData\r\n        {\r\n            Id = item.Id,\r\n            Value = item.Value.Trim()\r\n        };\r\n\r\n        // Return via ValueTask - no heap allocation for synchronous work\r\n        return new ValueTask<ValidatedData>(validated);\r\n    }\r\n}\r\n\r\n// Supporting types for the example\r\npublic record RawData(string Id, string Value);\r\npublic record ValidatedData(string Id, string Value);\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Transform that converts string values to integers.\r\n/// Demonstrates ValueTask pattern for simple type conversions\r\n/// that can fail and throw exceptions.\r\n/// </summary>\r\npublic sealed class ConversionTransform : ITransformNode<string, int>\r\n{\r\n    /// <summary>\r\n    /// Converts string to integer with validation.\r\n    /// Uses ValueTask to avoid allocation when conversion succeeds synchronously.\r\n    /// </summary>\r\n    public ValueTask<int> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Try to parse the string to integer\r\n        if (int.TryParse(item, out var result))\r\n        {\r\n            // Success case: return immediately via ValueTask (no allocation)\r\n            return new ValueTask<int>(result);\r\n        }\r\n\r\n        // Failure case: throw exception for invalid format\r\n        throw new FormatException($\"Cannot convert '{item}' to integer\");\r\n    }\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsxs)(n.p,{children:["Transform nodes support both ",(0,a.jsx)(n.code,{children:"Task<T>"})," and ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," return types. For high-throughput\r\nscenarios where transforms often complete synchronously (cache hits, simple calculations),\r\n",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," can eliminate up to 90% of garbage collection pressure."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"See:"})," ",(0,a.jsx)(n.a,{href:"/docs/advanced-topics/synchronous-fast-paths",children:"Synchronous Fast Paths and ValueTask Optimization"}),"\r\nfor complete implementation guide, including critical constraints, real-world examples, and dangerous patterns you must understand."]}),"\n",(0,a.jsx)(n.h2,{id:"common-transform-patterns",children:"Common Transform Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"data-enrichment",children:"Data Enrichment"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public sealed class EnrichmentTransform : ITransformNode<Order, EnrichedOrder>\r\n{\r\n    private readonly ILookupService _lookupService;\r\n\r\n    public EnrichmentTransform(ILookupService lookupService)\r\n    {\r\n        _lookupService = lookupService;\r\n    }\r\n\r\n    public async Task<EnrichedOrder> ExecuteAsync(Order order, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        var customerInfo = await _lookupService.GetCustomerAsync(order.CustomerId, cancellationToken);\r\n        return new EnrichedOrder\r\n        {\r\n            OrderId = order.OrderId,\r\n            CustomerId = order.CustomerId,\r\n            CustomerName = customerInfo.Name,\r\n            Total = order.Total\r\n        };\r\n    }\r\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"validation-and-filtering",children:"Validation and Filtering"}),"\n",(0,a.jsxs)(n.p,{children:["For validation and filtering transforms that can complete synchronously, consider using ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," for optimal performance. See the ",(0,a.jsx)(n.a,{href:"/docs/advanced-topics/synchronous-fast-paths",children:"Synchronous Fast Paths guide"})," for complete implementation details and critical constraints."]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/core-concepts/nodes/sink-nodes",children:"Sink Nodes"})}),": Learn how to consume and finalize data at the end of your pipeline"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Hygiene"})}),": Dive deeper into optimization techniques"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/advanced-topics/synchronous-fast-paths",children:"Synchronous Fast Paths"})}),": Master the ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," pattern in detail"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);