"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[954],{8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>l});var i=n(6540);const o={},t=i.createContext(o);function a(e){const r=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(t.Provider,{value:r},e.children)}},9140:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"core-concepts/pipeline-execution/node-error-handling","title":"Node-level Error Handling","description":"Learn how to implement node-level error handling in NPipeline using INodeErrorHandler to manage errors that occur during individual item processing.","source":"@site/docs/core-concepts/pipeline-execution/node-error-handling.md","sourceDirName":"core-concepts/pipeline-execution","slug":"/core-concepts/pipeline-execution/node-error-handling","permalink":"/npipeline.dev/docs/core-concepts/pipeline-execution/node-error-handling","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Node-level Error Handling","description":"Learn how to implement node-level error handling in NPipeline using INodeErrorHandler to manage errors that occur during individual item processing.","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Error Handling","permalink":"/npipeline.dev/docs/core-concepts/pipeline-execution/error-handling"},"next":{"title":"Pipeline-level Error Handling","permalink":"/npipeline.dev/docs/core-concepts/pipeline-execution/pipeline-error-handling"}}');var o=n(4848),t=n(8453);const a={title:"Node-level Error Handling",description:"Learn how to implement node-level error handling in NPipeline using INodeErrorHandler to manage errors that occur during individual item processing.",sidebar_position:5},l="Node-level Error Handling",s={},d=[{value:"Overview",id:"overview",level:2},{value:"INodeErrorHandler Interface",id:"inodeerrorhandler-interface",level:2},{value:"NodeErrorDecision",id:"nodeerrordecision",level:2},{value:"Implementing a Custom Node Error Handler",id:"implementing-a-custom-node-error-handler",level:2},{value:"Registering a Node Error Handler",id:"registering-a-node-error-handler",level:2},{value:"Basic Error Handling in Nodes",id:"basic-error-handling-in-nodes",level:2},{value:"Example: Basic Error Handling in a Transform Node",id:"example-basic-error-handling-in-a-transform-node",level:3},{value:"Common Node Error Handling Scenarios",id:"common-node-error-handling-scenarios",level:2},{value:"Scenario 1: Handling Transient Network Errors",id:"scenario-1-handling-transient-network-errors",level:3},{value:"Scenario 2: Data Validation Errors",id:"scenario-2-data-validation-errors",level:3},{value:"\u2705 Best Practices",id:"white_check_mark-best-practices",level:2},{value:"\ud83d\udd17 Related Topics",id:"link-related-topics",level:2}];function c(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"node-level-error-handling",children:"Node-level Error Handling"})}),"\n",(0,o.jsx)(r.p,{children:"Node-level error handling in NPipeline allows you to manage errors that occur while processing individual items within a specific node. This granular approach enables you to define what happens to each problematic item without affecting the entire pipeline."}),"\n",(0,o.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsxs)(r.p,{children:["When an error occurs during the processing of an individual item in a node, NPipeline's error handling mechanism invokes the appropriate ",(0,o.jsx)(r.code,{children:"INodeErrorHandler"})," to determine how to proceed. This allows you to implement strategies like retrying the item, skipping it, or redirecting it to a dead-letter queue."]}),"\n",(0,o.jsx)(r.h2,{id:"inodeerrorhandler-interface",children:"INodeErrorHandler Interface"}),"\n",(0,o.jsxs)(r.p,{children:["To handle errors within a specific node, you implement ",(0,o.jsx)(r.a,{href:"../../../src/NPipeline/Abstractions/ErrorHandling/INodeErrorHandler.cs",children:(0,o.jsx)(r.code,{children:"INodeErrorHandler<in TNode, in TData>"})})," interface."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:'public interface INodeErrorHandler\r\n{\r\n}\r\n\r\n/// <summary>\r\n///     Defines the contract for handling errors that occur within a specific node.\r\n/// </summary>\r\n/// <typeparam name="TNode">The type of node where the error occurred.</typeparam>\r\n/// <typeparam name="TData">The type of the data item that failed.</typeparam>\r\npublic interface INodeErrorHandler<in TNode, in TData> : INodeErrorHandler where TNode : INode\r\n{\r\n    /// <summary>\r\n    ///     Handles an error that occurred during node execution.\r\n    /// </summary>\r\n    /// <param name="node">The instance of node that failed.</param>\r\n    /// <param name="failedItem">The data item that caused the error.</param>\r\n    /// <param name="error">The exception that was thrown.</param>\r\n    /// <param name="context">The current pipeline context.</param>\r\n    /// <param name="cancellationToken">A token to observe for cancellation requests.</param>\r\n    /// <returns>A <see cref="NodeErrorDecision" /> indicating how to proceed.</returns>\r\n    Task<NodeErrorDecision> HandleAsync(\r\n        TNode node,\r\n        TData failedItem,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken);\r\n}\n'})}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"INodeErrorHandler"})}),": Marker interface for dependency injection registration of node error handlers."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"INodeErrorHandler<in TNode, in TData>"})}),": Generic interface that inherits from the marker interface and defines the actual error handling logic."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"TNode"})}),": The type of node where the error occurred."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"TData"})}),": The type of the data item that caused the error."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"HandleAsync"})}),": This method is called when an error occurs. It receives the failing node, item, exception, and pipeline context. It must return a ",(0,o.jsx)(r.code,{children:"NodeErrorDecision"}),"."]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"nodeerrordecision",children:"NodeErrorDecision"}),"\n",(0,o.jsx)(r.p,{children:"This enum dictates how the pipeline should proceed after a node-level error:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"Skip"})}),": The failed item is discarded, and the pipeline continues processing subsequent items."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"Retry"})}),": The pipeline attempts to re-process the failed item. The number of retries is configured via ",(0,o.jsx)(r.code,{children:"PipelineRetryOptions"}),"."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"DeadLetter"})}),": The failed item is sent to a configured dead-letter sink, and the pipeline continues."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"Fail"})}),": The pipeline immediately terminates with an exception."]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"implementing-a-custom-node-error-handler",children:"Implementing a Custom Node Error Handler"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.ErrorHandling;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\npublic sealed class MyNodeErrorHandler : INodeErrorHandler<ITransformNode<string, string>, string>\r\n{\r\n    private readonly ILogger _logger;\r\n\r\n    public MyNodeErrorHandler(ILogger logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    public Task<NodeErrorDecision> HandleAsync(\r\n        ITransformNode<string, string> node,\r\n        string failedItem,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        _logger.LogError(error, "Error in node \'{NodeName}\' processing \'{FailedItem}\': {ErrorMessage}",\r\n            node.Name, failedItem, error.Message);\r\n\r\n        // Example logic:\r\n        // - If it\'s a specific transient error, maybe retry.\r\n        // - If it\'s a data validation error, skip or redirect.\r\n        if (error is FormatException)\r\n        {\r\n            _logger.LogWarning("Data format error, redirecting to dead-letter.");\r\n            return Task.FromResult(NodeErrorDecision.DeadLetter);\r\n        }\r\n        else if (failedItem.Contains("retry"))\r\n        {\r\n            _logger.LogInformation("Item marked for retry.");\r\n            return Task.FromResult(NodeErrorDecision.Retry);\r\n        }\r\n        else\r\n        {\r\n            _logger.LogWarning("Skipping item due to unexpected error.");\r\n            return Task.FromResult(NodeErrorDecision.Skip);\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(r.h2,{id:"registering-a-node-error-handler",children:"Registering a Node Error Handler"}),"\n",(0,o.jsxs)(r.p,{children:["You register a node error handler for a specific node using the ",(0,o.jsx)(r.code,{children:"WithErrorHandler"})," method on ",(0,o.jsx)(r.code,{children:"PipelineBuilder"}),":"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.ErrorHandling;\r\nusing NPipeline.Pipeline;\r\n\r\npublic sealed class ErrorHandlingPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<DataSource, string>();\r\n        var transformHandle = builder.AddTransform<DataTransform, string, string>();\r\n        var sinkHandle = builder.AddSink<DataSink, string>();\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n\r\n        // Configure retry options\r\n        builder.WithRetryOptions(new PipelineRetryOptions(\r\n            MaxItemRetries: 3,\r\n            MaxNodeRestartAttempts: 2,\r\n            MaxSequentialNodeAttempts: 5\r\n        ));\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var runner = new PipelineRunner();\r\n        var context = PipelineContext.Default;\r\n\r\n        var pipeline = PipelineBuilder.Create<ErrorHandlingPipelineDefinition>();\r\n\r\n        await runner.RunAsync<ErrorHandlingPipelineDefinition>(context);\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(r.p,{children:"You also need to register your custom error handler with your DI container:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"services.AddSingleton<INodeErrorHandler<ITransformNode<string, string>, string>, MyNodeErrorHandler>();\n"})}),"\n",(0,o.jsxs)(r.p,{children:["The marker interface ",(0,o.jsx)(r.code,{children:"INodeErrorHandler"})," (non-generic version) is used for dependency injection registration purposes, allowing the DI container to discover all node error handler implementations."]}),"\n",(0,o.jsx)(r.h2,{id:"basic-error-handling-in-nodes",children:"Basic Error Handling in Nodes"}),"\n",(0,o.jsxs)(r.p,{children:["Nodes that implement ",(0,o.jsx)(r.code,{children:"TransformNode<TInput, TOutput>"})," or ",(0,o.jsx)(r.code,{children:"SinkNode<TInput>"})," can incorporate error handling logic directly within their ",(0,o.jsx)(r.code,{children:"ExecuteAsync"})," or ",(0,o.jsx)(r.code,{children:"ExecuteAsync"})," methods. This typically involves ",(0,o.jsx)(r.code,{children:"try-catch"})," blocks to capture exceptions and decide on an appropriate response."]}),"\n",(0,o.jsx)(r.h3,{id:"example-basic-error-handling-in-a-transform-node",children:"Example: Basic Error Handling in a Transform Node"}),"\n",(0,o.jsxs)(r.p,{children:["Consider a transform node that attempts to parse a string into an integer. If the string is not a valid number, a ",(0,o.jsx)(r.code,{children:"FormatException"})," would occur."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:'using NPipeline;\r\n\r\npublic sealed record StringData(string Value);\r\npublic sealed record IntData(int Value);\r\npublic sealed record ErrorData(string OriginalValue, string ErrorMessage);\r\n\r\npublic sealed class ParsingTransform : TransformNode<StringData, IntData>\r\n{\r\n    public override Task<IntData> ExecuteAsync(\r\n        StringData item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken = default)\r\n    {\r\n        try\r\n        {\r\n            int parsedValue = int.Parse(item.Value);\r\n            return Task.FromResult(new IntData(parsedValue));\r\n        }\r\n        catch (FormatException ex)\r\n        {\r\n            // Log the error and handle it\r\n            Console.WriteLine($"Error parsing \'{item.Value}\': {ex.Message}");\r\n            // Re-throw to let the pipeline\'s error handling mechanism process it\r\n            throw;\r\n        }\r\n    }\r\n}\r\n\r\n// Example usage (simplified for brevity)\r\npublic sealed class ErrorHandlingPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var stringData = new[]\r\n        {\r\n            new StringData("1"),\r\n            new StringData("abc"), // This will cause an error\r\n            new StringData("2")\r\n        };\r\n\r\n        var sourceHandle = builder.AddSource<TestStringSource, StringData>();\r\n        var transformHandle = builder.AddTransform<ParsingTransform, StringData, IntData>();\r\n        var sinkHandle = builder.AddSink<TestIntSink, IntData>();\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n    }\r\n}\r\n\r\npublic sealed class TestStringSource : SourceNode<StringData>\r\n{\r\n    public IDataPipe<StringData> ExecuteAsync(\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken = default)\r\n    {\r\n        static IAsyncEnumerable<StringData> Stream()\r\n        {\r\n            return Generate();\r\n\r\n            async IAsyncEnumerable<StringData> Generate()\r\n            {\r\n                var data = new[]\r\n                {\r\n                    new StringData("1"),\r\n                    new StringData("abc"), // This will cause an error\r\n                    new StringData("2")\r\n                };\r\n\r\n                foreach (var item in data)\r\n                {\r\n                    yield return item;\r\n                }\r\n            }\r\n        }\r\n\r\n        return new StreamingDataPipe<StringData>(Stream());\r\n    }\r\n}\r\n\r\npublic sealed class TestIntSink : SinkNode<IntData>\r\n{\r\n    public async Task ExecuteAsync(\r\n        IDataPipe<IntData> input,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken = default)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            Console.WriteLine($"Successfully parsed: {item.Value}");\r\n        }\r\n    }\r\n}\r\n\r\n// To run the pipeline:\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        Console.WriteLine("Starting pipeline with error handling...");\r\n        var runner = new PipelineRunner();\r\n        try\r\n        {\r\n            await runner.RunAsync<ErrorHandlingPipeline>();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine($"Pipeline failed with error: {ex.Message}");\r\n        }\r\n        Console.WriteLine("Pipeline finished.");\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(r.h2,{id:"common-node-error-handling-scenarios",children:"Common Node Error Handling Scenarios"}),"\n",(0,o.jsx)(r.h3,{id:"scenario-1-handling-transient-network-errors",children:"Scenario 1: Handling Transient Network Errors"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:'public class NetworkErrorHandler : INodeErrorHandler<IApiTransformNode, string>\r\n{\r\n    private readonly ILogger _logger;\r\n    private int _retryCount = 0;\r\n\r\n    public NetworkErrorHandler(ILogger logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    public Task<NodeErrorDecision> HandleAsync(\r\n        IApiTransformNode node,\r\n        string failedItem,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        if (error is HttpRequestException httpEx)\r\n        {\r\n            _retryCount++;\r\n            _logger.LogWarning("Network error (attempt {RetryCount}): {ErrorMessage}", _retryCount, httpEx.Message);\r\n\r\n            // Retry up to 3 times for network errors\r\n            if (_retryCount <= 3)\r\n            {\r\n                return Task.FromResult(NodeErrorDecision.Retry);\r\n            }\r\n            else\r\n            {\r\n                _retryCount = 0; // Reset for next item\r\n                return Task.FromResult(NodeErrorDecision.DeadLetter);\r\n            }\r\n        }\r\n\r\n        return Task.FromResult(NodeErrorDecision.Skip);\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(r.h3,{id:"scenario-2-data-validation-errors",children:"Scenario 2: Data Validation Errors"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:'public class ValidationErrorHandler : INodeErrorHandler<IValidatorNode, string>\r\n{\r\n    private readonly ILogger _logger;\r\n\r\n    public ValidationErrorHandler(ILogger logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    public Task<NodeErrorDecision> HandleAsync(\r\n        IValidatorNode node,\r\n        string failedItem,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        if (error is ValidationException validationEx)\r\n        {\r\n            _logger.LogWarning("Validation failed for item: {Item}. Error: {Error}", failedItem, validationEx.Message);\r\n\r\n            // For validation errors, redirect to dead-letter queue for manual review\r\n            return Task.FromResult(NodeErrorDecision.DeadLetter);\r\n        }\r\n\r\n        // For other types of errors, skip the item\r\n        return Task.FromResult(NodeErrorDecision.Skip);\r\n    }\r\n}\n'})}),"\n",(0,o.jsxs)(r.h2,{id:"white_check_mark-best-practices",children:["\u2705"," Best Practices"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Be specific about error types"}),": Different error types should be handled differently. Transient errors (like network issues) might be worth retrying, while data validation errors should probably be redirected."]}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Implement retry limits"}),": Always limit the number of retries to prevent infinite loops and resource exhaustion."]}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Log detailed error information"}),": Include sufficient context in your error logs to help with troubleshooting."]}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Use dead-letter queues for problematic items"}),": Items that consistently fail should be redirected to a dead-letter queue for later analysis."]}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Consider performance implications"}),": Error handling logic adds overhead to normal processing, so keep it efficient."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(r.h2,{id:"link-related-topics",children:["\ud83d\udd17"," Related Topics"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/pipeline-error-handling",children:"Pipeline-level Error Handling"})}),": Learn about handling errors that affect entire node streams."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/retry-configuration",children:"Retry Configuration"})}),": Configure retry behavior for items and node restarts."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/circuit-breaker-configuration",children:"Circuit Breaker Configuration"})}),": Configure circuit breaker patterns."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/dead-letter-queues",children:"Dead-Letter Queues"})}),": Implement dead-letter queues for problematic items."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/error-handling",children:"Error Handling Overview"})}),": Return to the error handling overview."]}),"\n"]})]})}function p(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);