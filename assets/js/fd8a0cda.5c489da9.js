"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3034],{3610:(e,i,r)=>{r.r(i),r.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"core-concepts/pipeline-execution/circuit-breaker-configuration","title":"Circuit Breaker Configuration","description":"Learn how to configure circuit breaker patterns in NPipeline using PipelineCircuitBreakerOptions to prevent cascading failures.","source":"@site/docs/core-concepts/pipeline-execution/circuit-breaker-configuration.md","sourceDirName":"core-concepts/pipeline-execution","slug":"/core-concepts/pipeline-execution/circuit-breaker-configuration","permalink":"/npipeline.dev/docs/core-concepts/pipeline-execution/circuit-breaker-configuration","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"Circuit Breaker Configuration","description":"Learn how to configure circuit breaker patterns in NPipeline using PipelineCircuitBreakerOptions to prevent cascading failures.","sidebar_position":8},"sidebar":"docsSidebar","previous":{"title":"Retry Configuration","permalink":"/npipeline.dev/docs/core-concepts/pipeline-execution/retry-configuration"},"next":{"title":"Dead-Letter Queues","permalink":"/npipeline.dev/docs/core-concepts/pipeline-execution/dead-letter-queues"}}');var t=r(4848),s=r(8453);const o={title:"Circuit Breaker Configuration",description:"Learn how to configure circuit breaker patterns in NPipeline using PipelineCircuitBreakerOptions to prevent cascading failures.",sidebar_position:8},a="Circuit Breaker Configuration",l={},c=[{value:"Overview",id:"overview",level:2},{value:"PipelineCircuitBreakerOptions",id:"pipelinecircuitbreakeroptions",level:2},{value:"Configuration Parameters",id:"configuration-parameters",level:3},{value:"Threshold Types",id:"threshold-types",level:2},{value:"ConsecutiveFailures (Default)",id:"consecutivefailures-default",level:3},{value:"RollingWindowCount",id:"rollingwindowcount",level:3},{value:"RollingWindowRate",id:"rollingwindowrate",level:3},{value:"Hybrid",id:"hybrid",level:3},{value:"Circuit Breaker State Machine",id:"circuit-breaker-state-machine",level:2},{value:"State Descriptions",id:"state-descriptions",level:3},{value:"Basic Circuit Breaker Configuration",id:"basic-circuit-breaker-configuration",level:2},{value:"Advanced Configuration Examples",id:"advanced-configuration-examples",level:2},{value:"High-Tolerance Circuit Breaker",id:"high-tolerance-circuit-breaker",level:3},{value:"Sensitive Circuit Breaker",id:"sensitive-circuit-breaker",level:3},{value:"Rate-Based Circuit Breaker",id:"rate-based-circuit-breaker",level:3},{value:"Integration with ResilientExecutionStrategy",id:"integration-with-resilientexecutionstrategy",level:2},{value:"Monitoring Circuit Breaker Statistics",id:"monitoring-circuit-breaker-statistics",level:2},{value:"\u2705 Best Practices",id:"white_check_mark-best-practices",level:2},{value:"\u26a0\ufe0f Troubleshooting Circuit Breakers",id:"warning-troubleshooting-circuit-breakers",level:2},{value:"\u2139\ufe0f See Also",id:"information_source-see-also",level:2},{value:"\ud83d\udd17 Related Topics",id:"link-related-topics",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"circuit-breaker-configuration",children:"Circuit Breaker Configuration"})}),"\n",(0,t.jsx)(i.p,{children:"Circuit breaker configuration in NPipeline allows you to implement the circuit breaker pattern to prevent constantly failing nodes from continuously consuming resources or causing cascading failures throughout your pipeline."}),"\n",(0,t.jsx)(i.p,{children:"The enhanced CircuitBreaker implementation provides:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"State Machine"}),": Complete implementation with Closed, Open, and Half-Open states"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Rolling Window"}),": Time-based operation tracking for sophisticated failure analysis"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Multiple Threshold Types"}),": ConsecutiveFailures, RollingWindowCount, RollingWindowRate, and Hybrid"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Automatic Recovery"}),": Timer-based transition from Open to Half-Open state"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Thread Safety"}),": Safe for concurrent pipeline execution"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Backward Compatibility"}),": Existing configurations continue to work"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(i.p,{children:"The circuit breaker pattern is a design pattern used in software development to detect failures and encapsulate the logic of preventing a failure from constantly recurring. In NPipeline, this helps maintain system stability by temporarily stopping attempts to execute nodes that are experiencing persistent failures."}),"\n",(0,t.jsx)(i.h2,{id:"pipelinecircuitbreakeroptions",children:"PipelineCircuitBreakerOptions"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.a,{href:"../../../src/NPipeline/Configuration/PipelineCircuitBreakerOptions.cs",children:(0,t.jsx)(i.code,{children:"PipelineCircuitBreakerOptions"})})," record allows you to configure a circuit breaker pattern with enhanced functionality."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-csharp",children:'public sealed record PipelineCircuitBreakerOptions(\r\n    int FailureThreshold,\r\n    TimeSpan OpenDuration,\r\n    TimeSpan SamplingWindow,\r\n    bool Enabled = true,\r\n    CircuitBreakerThresholdType ThresholdType = CircuitBreakerThresholdType.ConsecutiveFailures,\r\n    double FailureRateThreshold = 0.5,\r\n    int HalfOpenSuccessThreshold = 1,\r\n    int HalfOpenMaxAttempts = 5,\r\n    bool TrackOperationsInWindow = true)\r\n{\r\n    public static PipelineCircuitBreakerOptions Disabled { get; } = new(int.MaxValue, TimeSpan.Zero, TimeSpan.Zero, false);\r\n    public static PipelineCircuitBreakerOptions Default { get; } = new(5, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(5));\r\n    \r\n    // Backward-compatible constructor\r\n    public PipelineCircuitBreakerOptions(int failureThreshold, TimeSpan openDuration, TimeSpan samplingWindow, bool enabled)\r\n        : this(failureThreshold, openDuration, samplingWindow, enabled, CircuitBreakerThresholdType.ConsecutiveFailures, 0.5, 1, 5, true)\r\n    {\r\n    }\r\n}\r\n\r\n/// <summary>\r\n///     Defines the type of failure threshold used for circuit breaking.\r\n/// </summary>\r\npublic enum CircuitBreakerThresholdType\r\n{\r\n    /// <summary>\r\n    ///     Uses consecutive failure count (default behavior).\r\n    /// </summary>\r\n    ConsecutiveFailures,\r\n\r\n    /// <summary>\r\n    ///     Uses failure count within the sampling window.\r\n    /// </summary>\r\n    RollingWindowCount,\r\n\r\n    /// <summary>\r\n    ///     Uses failure rate within the sampling window.\r\n    /// </summary>\r\n    RollingWindowRate,\r\n\r\n    /// <summary>\r\n    ///     Uses both count and rate thresholds.\r\n    /// </summary>\r\n    Hybrid\r\n}\r\n\r\n/// <summary>\r\n///     Exception thrown when the circuit breaker is open and blocks execution.\r\n/// </summary>\r\npublic sealed class CircuitBreakerOpenException : PipelineException\r\n{\r\n    public CircuitBreakerOpenException() : base("Circuit breaker is open and blocking execution.")\r\n    {\r\n        ErrorCode = "CIRCUIT_BREAKER_OPEN";\r\n    }\r\n\r\n    public CircuitBreakerOpenException(string message) : base(message)\r\n    {\r\n        ErrorCode = "CIRCUIT_BREAKER_OPEN";\r\n    }\r\n\r\n    public CircuitBreakerOpenException(string message, Exception innerException) : base(message, innerException)\r\n    {\r\n        ErrorCode = "CIRCUIT_BREAKER_OPEN";\r\n    }\r\n\r\n    /// <summary>\r\n    ///     Gets the error code associated with this exception.\r\n    /// </summary>\r\n    public string ErrorCode { get; }\r\n}\n'})}),"\n",(0,t.jsx)(i.h3,{id:"configuration-parameters",children:"Configuration Parameters"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"FailureThreshold"})}),": The threshold value used for circuit breaking (interpretation depends on ThresholdType)."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"OpenDuration"})}),": How long the breaker remains open before transitioning to Half-Open state."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"SamplingWindow"})}),": Time window for rolling window failure tracking."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"Enabled"})}),": Whether the circuit breaker is active."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"ThresholdType"})}),": Type of failure threshold to use (ConsecutiveFailures, RollingWindowCount, RollingWindowRate, Hybrid)."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"FailureRateThreshold"})}),": Failure rate threshold (0.0-1.0) when using RollingWindowRate or Hybrid threshold types."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"HalfOpenSuccessThreshold"})}),": Number of consecutive successes required in Half-Open state to transition to Closed."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"HalfOpenMaxAttempts"})}),": Maximum number of operation attempts allowed in Half-Open state."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"TrackOperationsInWindow"})}),": Whether to track operations in the rolling window for statistics."]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"threshold-types",children:"Threshold Types"}),"\n",(0,t.jsx)(i.h3,{id:"consecutivefailures-default",children:"ConsecutiveFailures (Default)"}),"\n",(0,t.jsx)(i.p,{children:"Tracks consecutive failures without considering time. This is the original behavior and maintains backward compatibility."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-csharp",children:"var options = new PipelineCircuitBreakerOptions(\r\n    failureThreshold: 5,\r\n    openDuration: TimeSpan.FromMinutes(1),\r\n    samplingWindow: TimeSpan.FromMinutes(5),\r\n    thresholdType: CircuitBreakerThresholdType.ConsecutiveFailures\r\n);\n"})}),"\n",(0,t.jsx)(i.h3,{id:"rollingwindowcount",children:"RollingWindowCount"}),"\n",(0,t.jsx)(i.p,{children:"Tracks the total number of failures within a time window, regardless of whether they're consecutive."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-csharp",children:"var options = new PipelineCircuitBreakerOptions(\r\n    failureThreshold: 10,\r\n    openDuration: TimeSpan.FromMinutes(2),\r\n    samplingWindow: TimeSpan.FromMinutes(5),\r\n    thresholdType: CircuitBreakerThresholdType.RollingWindowCount\r\n);\n"})}),"\n",(0,t.jsx)(i.h3,{id:"rollingwindowrate",children:"RollingWindowRate"}),"\n",(0,t.jsx)(i.p,{children:"Tracks the failure rate (failures/total operations) within a time window."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-csharp",children:"var options = new PipelineCircuitBreakerOptions(\r\n    failureThreshold: 5, // Minimum operations before rate is considered\r\n    openDuration: TimeSpan.FromMinutes(2),\r\n    samplingWindow: TimeSpan.FromMinutes(5),\r\n    thresholdType: CircuitBreakerThresholdType.RollingWindowRate,\r\n    failureRateThreshold: 0.3 // 30% failure rate\r\n);\n"})}),"\n",(0,t.jsx)(i.h3,{id:"hybrid",children:"Hybrid"}),"\n",(0,t.jsx)(i.p,{children:"Uses both count and rate thresholds - trips if either threshold is exceeded."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-csharp",children:"var options = new PipelineCircuitBreakerOptions(\r\n    failureThreshold: 5,\r\n    openDuration: TimeSpan.FromMinutes(2),\r\n    samplingWindow: TimeSpan.FromMinutes(5),\r\n    thresholdType: CircuitBreakerThresholdType.Hybrid,\r\n    failureRateThreshold: 0.3 // 30% failure rate\r\n);\n"})}),"\n",(0,t.jsx)(i.h2,{id:"circuit-breaker-state-machine",children:"Circuit Breaker State Machine"}),"\n",(0,t.jsx)(i.p,{children:"The circuit breaker has three main states with automatic transitions:"}),"\n",(0,t.jsx)(i.mermaid,{value:"stateDiagram-v2\r\n    [*] --\x3e Closed\r\n    Closed --\x3e Open: Failure threshold exceeded\r\n    Open --\x3e HalfOpen: OpenDuration elapsed\r\n    HalfOpen --\x3e Closed: Success threshold met\r\n    HalfOpen --\x3e Open: Any failure\r\n    Closed --\x3e Closed: Success (resets counters)"}),"\n",(0,t.jsx)(i.h3,{id:"state-descriptions",children:"State Descriptions"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Closed"}),": The circuit breaker allows operations to proceed normally. It tracks failures based on the configured threshold type and trips when the threshold is reached."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Open"}),": The circuit breaker has tripped and prevents operations from proceeding. After the OpenDuration expires, it automatically transitions to Half-Open state."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Half-Open"}),": The circuit breaker allows a limited number of operations to test if the underlying issue has been resolved. If enough operations succeed, it transitions to Closed. If any operation fails, it immediately returns to Open."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"basic-circuit-breaker-configuration",children:"Basic Circuit Breaker Configuration"}),"\n",(0,t.jsxs)(i.p,{children:["You configure the circuit breaker via the ",(0,t.jsx)(i.code,{children:"PipelineCircuitBreakerOptions"})," in ",(0,t.jsx)(i.code,{children:"PipelineRetryOptions"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-csharp",children:'public class BasicCircuitBreakerPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<DataSource, string>("source");\r\n        var transformHandle = builder.AddTransform<DataTransform, string, string>("transform");\r\n        var sinkHandle = builder.AddSink<DataSink, string>("sink");\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n    }\r\n}\r\n\r\n// Configure the circuit breaker via PipelineRetryOptions:\r\nvar retryOptions = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: 1000,\r\n    CircuitBreakerOptions: new PipelineCircuitBreakerOptions(\r\n        failureThreshold: 5, // Trip after 5 consecutive failures\r\n        openDuration: TimeSpan.FromMinutes(1),\r\n        samplingWindow: TimeSpan.FromMinutes(5),\r\n        thresholdType: CircuitBreakerThresholdType.ConsecutiveFailures\r\n    )\r\n);\r\n\r\nvar context = PipelineContext.WithRetry(retryOptions);\r\nvar runner = new PipelineRunner();\r\nawait runner.RunAsync<BasicCircuitBreakerPipelineDefinition>(context);\n'})}),"\n",(0,t.jsx)(i.h2,{id:"advanced-configuration-examples",children:"Advanced Configuration Examples"}),"\n",(0,t.jsx)(i.h3,{id:"high-tolerance-circuit-breaker",children:"High-Tolerance Circuit Breaker"}),"\n",(0,t.jsx)(i.p,{children:"For non-critical nodes where you want more resilience:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-csharp",children:"var tolerantOptions = new PipelineCircuitBreakerOptions(\r\n    failureThreshold: 20,\r\n    openDuration: TimeSpan.FromMinutes(5),\r\n    samplingWindow: TimeSpan.FromMinutes(10),\r\n    thresholdType: CircuitBreakerThresholdType.Hybrid,\r\n    failureRateThreshold: 0.4, // 40% failure rate\r\n    halfOpenSuccessThreshold: 3, // Require 3 consecutive successes\r\n    halfOpenMaxAttempts: 10 // Allow up to 10 attempts in Half-Open\r\n);\n"})}),"\n",(0,t.jsx)(i.h3,{id:"sensitive-circuit-breaker",children:"Sensitive Circuit Breaker"}),"\n",(0,t.jsx)(i.p,{children:"For critical nodes where you want quick failure detection:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-csharp",children:"var sensitiveOptions = new PipelineCircuitBreakerOptions(\r\n    failureThreshold: 3,\r\n    openDuration: TimeSpan.FromSeconds(30),\r\n    samplingWindow: TimeSpan.FromMinutes(1),\r\n    thresholdType: CircuitBreakerThresholdType.ConsecutiveFailures,\r\n    halfOpenSuccessThreshold: 1,\r\n    halfOpenMaxAttempts: 2\r\n);\n"})}),"\n",(0,t.jsx)(i.h3,{id:"rate-based-circuit-breaker",children:"Rate-Based Circuit Breaker"}),"\n",(0,t.jsx)(i.p,{children:"For nodes with high throughput where rate is more important than count:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-csharp",children:"var rateBasedOptions = new PipelineCircuitBreakerOptions(\r\n    failureThreshold: 100, // Minimum operations before rate is considered\r\n    openDuration: TimeSpan.FromMinutes(2),\r\n    samplingWindow: TimeSpan.FromMinutes(5),\r\n    thresholdType: CircuitBreakerThresholdType.RollingWindowRate,\r\n    failureRateThreshold: 0.1 // 10% failure rate\r\n);\n"})}),"\n",(0,t.jsx)(i.h2,{id:"integration-with-resilientexecutionstrategy",children:"Integration with ResilientExecutionStrategy"}),"\n",(0,t.jsx)(i.p,{children:"The CircuitBreaker is automatically integrated with the ResilientExecutionStrategy:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-csharp",children:"// The circuit breaker is automatically used when ResilientExecutionStrategy is enabled\r\n// and CircuitBreakerOptions are configured in the retry options\r\n\r\nvar resilientOptions = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 5,\r\n    CircuitBreakerOptions: new PipelineCircuitBreakerOptions(\r\n        failureThreshold: 3,\r\n        openDuration: TimeSpan.FromMinutes(1),\r\n        samplingWindow: TimeSpan.FromMinutes(5),\r\n        thresholdType: CircuitBreakerThresholdType.RollingWindowRate,\r\n        failureRateThreshold: 0.2\r\n    )\r\n);\r\n\r\n// The ResilientExecutionStrategy will automatically:\r\n// 1. Track operations in the rolling window\r\n// 2. Check circuit breaker state before each operation\r\n// 3. Record successes and failures\r\n// 4. Handle state transitions automatically\r\n// 5. Throw CircuitBreakerOpenException when the circuit is open\n"})}),"\n",(0,t.jsx)(i.h2,{id:"monitoring-circuit-breaker-statistics",children:"Monitoring Circuit Breaker Statistics"}),"\n",(0,t.jsx)(i.p,{children:"The CircuitBreaker provides detailed statistics that can be accessed for monitoring:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-csharp",children:"// The CircuitBreakerManager tracks circuit breakers for each node\r\n// You can access statistics through the circuit breaker instance\r\n\r\nWindowStatistics stats = circuitBreaker.GetStatistics();\r\n// stats.TotalOperations - Total operations in the window\r\n// stats.FailureCount - Number of failed operations\r\n// stats.SuccessCount - Number of successful operations\r\n// stats.FailureRate - Failure rate (0.0 to 1.0)\n"})}),"\n",(0,t.jsxs)(i.h2,{id:"white_check_mark-best-practices",children:["\u2705"," Best Practices"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Choose the right threshold type"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Use ",(0,t.jsx)(i.code,{children:"ConsecutiveFailures"})," for simple scenarios"]}),"\n",(0,t.jsxs)(i.li,{children:["Use ",(0,t.jsx)(i.code,{children:"RollingWindowCount"})," for high-volume operations"]}),"\n",(0,t.jsxs)(i.li,{children:["Use ",(0,t.jsx)(i.code,{children:"RollingWindowRate"})," for rate-sensitive scenarios"]}),"\n",(0,t.jsxs)(i.li,{children:["Use ",(0,t.jsx)(i.code,{children:"Hybrid"})," for comprehensive protection"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Set appropriate sampling windows"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Shorter windows (1-5 minutes) for quick detection"}),"\n",(0,t.jsx)(i.li,{children:"Longer windows (10-30 minutes) for stability in volatile environments"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Configure Half-Open parameters carefully"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Higher ",(0,t.jsx)(i.code,{children:"HalfOpenSuccessThreshold"})," for more conservative recovery"]}),"\n",(0,t.jsxs)(i.li,{children:["Lower ",(0,t.jsx)(i.code,{children:"HalfOpenMaxAttempts"})," to prevent flooding recovering services"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Monitor circuit breaker state transitions"}),": Track when circuit breakers open and close to identify systemic issues."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Use different thresholds for different nodes"}),": Critical nodes might have lower thresholds than non-critical ones."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Implement alerting"}),": Set up alerts when circuit breakers open to notify operations teams."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Consider graceful degradation"}),": Design your pipeline to continue functioning even when some nodes are isolated by circuit breakers."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Test circuit breaker behavior"}),": Include circuit breaker scenarios in your testing to ensure they work as expected."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.h2,{id:"warning-troubleshooting-circuit-breakers",children:["\u26a0\ufe0f"," Troubleshooting Circuit Breakers"]}),"\n",(0,t.jsxs)(i.p,{children:["If you're experiencing issues with circuit breaker behavior, such as unexpected trips or failure to open, see the ",(0,t.jsx)(i.a,{href:"/npipeline.dev/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting guide"})," in the resilience section for common issues and solutions."]}),"\n",(0,t.jsxs)(i.h2,{id:"information_source-see-also",children:["\u2139\ufe0f"," See Also"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.a,{href:"/npipeline.dev/docs/core-concepts/resilience/",children:"Resilience Overview"})}),": Comprehensive guide to building fault-tolerant pipelines"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.a,{href:"/npipeline.dev/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting"})}),": Diagnose and resolve common resilience issues"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.a,{href:"/npipeline.dev/docs/core-concepts/resilience/configuration-guide",children:"Configuration Guide"})}),": Practical implementation guidance with code examples"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.a,{href:"/npipeline.dev/docs/core-concepts/resilience/dependency-chains",children:"Dependency Chains"})}),": Understanding critical prerequisite relationships for resilience features"]}),"\n"]}),"\n",(0,t.jsxs)(i.h2,{id:"link-related-topics",children:["\ud83d\udd17"," Related Topics"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/node-error-handling",children:"Node-level Error Handling"})}),": Learn about handling errors for individual items."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/pipeline-error-handling",children:"Pipeline-level Error Handling"})}),": Learn about handling errors that affect entire node streams."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/retry-configuration",children:"Retry Configuration"})}),": Configure retry behavior for items and node restarts."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/dead-letter-queues",children:"Dead-Letter Queues"})}),": Implement dead-letter queues for problematic items."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/error-handling",children:"Error Handling Overview"})}),": Return to error handling overview."]}),"\n"]})]})}function u(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,i,r)=>{r.d(i,{R:()=>o,x:()=>a});var n=r(6540);const t={},s=n.createContext(t);function o(e){const i=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);