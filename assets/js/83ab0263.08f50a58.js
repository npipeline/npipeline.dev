"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[1874],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var r=i(96540);const t={},s=r.createContext(t);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(s.Provider,{value:n},e.children)}},42215:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"core-concepts/resilience/getting-started","title":"Resilience Quick Start","description":"Get started quickly with resilience in NPipeline. Covers node restarts and retry delay strategies.","source":"@site/docs/core-concepts/resilience/getting-started.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/getting-started","permalink":"/docs/core-concepts/resilience/getting-started","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Resilience Quick Start","description":"Get started quickly with resilience in NPipeline. Covers node restarts and retry delay strategies.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Error Handling in NPipeline","permalink":"/docs/core-concepts/resilience/error-handling"},"next":{"title":"Node-Level Error Handling","permalink":"/docs/core-concepts/resilience/node-error-handling"}}');var t=i(74848),s=i(28453);const o={title:"Resilience Quick Start",description:"Get started quickly with resilience in NPipeline. Covers node restarts and retry delay strategies.",sidebar_position:2},l="Resilience Quick Start",a={},c=[{value:"Node Restart - Quick Start Checklist",id:"node-restart---quick-start-checklist",level:2},{value:"The Three-Step Mandatory Checklist",id:"the-three-step-mandatory-checklist",level:3},{value:"STEP 1: Apply ResilientExecutionStrategy",id:"step-1-apply-resilientexecutionstrategy",level:4},{value:"STEP 2: Configure Maximum Restart Attempts",id:"step-2-configure-maximum-restart-attempts",level:4},{value:"STEP 3: Enable Input Materialization (\u26a0\ufe0f CRITICAL)",id:"step-3-enable-input-materialization-\ufe0f-critical",level:4},{value:"Conservative Starting Point",id:"conservative-starting-point",level:3},{value:"\u26a0\ufe0f CRITICAL WARNING: Unbounded Materialization",id:"warning-critical-warning-unbounded-materialization",level:4},{value:"Why Unbounded Memory Buffers Break Resilience Guarantees",id:"why-unbounded-memory-buffers-break-resilience-guarantees",level:3},{value:"Complete Configuration Example",id:"complete-configuration-example",level:3},{value:"Retry Delay Quick Start",id:"retry-delay-quick-start",level:2},{value:"Quick Start: Common Retry Patterns",id:"quick-start-common-retry-patterns",level:3},{value:"Web API Calls (Most Common)",id:"web-api-calls-most-common",level:4},{value:"Database Operations",id:"database-operations",level:4},{value:"File Processing",id:"file-processing",level:4},{value:"Decision Flow for Choosing Retry Strategy",id:"decision-flow-for-choosing-retry-strategy",level:3},{value:"Implementation Examples",id:"implementation-examples",level:3},{value:"Basic Pipeline with Retry Delays",id:"basic-pipeline-with-retry-delays",level:4},{value:"Per-Node Retry Configuration",id:"per-node-retry-configuration",level:4},{value:"Common Pitfalls to Avoid",id:"common-pitfalls-to-avoid",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"resilience-quick-start",children:"Resilience Quick Start"})}),"\n",(0,t.jsx)(n.p,{children:"This guide provides quick-start checklists and patterns for the two most common resilience scenarios: node restarts and retry delay strategies."}),"\n",(0,t.jsx)(n.h2,{id:"node-restart---quick-start-checklist",children:"Node Restart - Quick Start Checklist"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,t.jsxs)(n.strong,{children:["CRITICAL: READ THIS BEFORE USING ",(0,t.jsx)(n.code,{children:"PipelineErrorDecision.RestartNode"})]})]}),"\n",(0,t.jsxs)(n.p,{children:["Node restart is a powerful resilience feature, but it requires ",(0,t.jsx)(n.strong,{children:"three mandatory prerequisites"}),". Missing even one silently disables the feature and your entire pipeline fails."]}),"\n",(0,t.jsx)(n.p,{children:"If you've experienced mysterious pipeline failures where restart seemed enabled but didn't work, one of these requirements was missing."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Good news:"})," The NPipeline build-time analyzer (NP9001) automatically detects incomplete restart configurations at compile time. Enable ",(0,t.jsx)(n.a,{href:"/docs/analyzers/resilience",children:"NP9001"})," in your ",(0,t.jsx)(n.code,{children:".editorconfig"})," to catch these issues before deployment."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"the-three-step-mandatory-checklist",children:"The Three-Step Mandatory Checklist"}),"\n",(0,t.jsx)(n.h4,{id:"step-1-apply-resilientexecutionstrategy",children:"STEP 1: Apply ResilientExecutionStrategy"}),"\n",(0,t.jsxs)(n.p,{children:["Your node must be wrapped with ",(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"}),". This enables the restart capability at the node level."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"What it does:"})," Allows the pipeline to restart the node when an error occurs."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Without it:"})," Restart decisions are ignored; the node cannot recover."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How to configure:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'var nodeHandle = builder\n    .AddTransform<MyTransform, Input, Output>("myNode")\n    .WithExecutionStrategy(\n        builder,\n        new ResilientExecutionStrategy(new SequentialExecutionStrategy())\n    );\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Learn more:"})," ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/execution-strategies",children:"Execution Strategies"})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h4,{id:"step-2-configure-maximum-restart-attempts",children:"STEP 2: Configure Maximum Restart Attempts"}),"\n",(0,t.jsxs)(n.p,{children:["Set ",(0,t.jsx)(n.code,{children:"MaxNodeRestartAttempts > 0"})," in ",(0,t.jsx)(n.code,{children:"PipelineRetryOptions"}),". This tells the pipeline how many times to attempt restarting a failed node."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"What it does:"})," Limits how many restart attempts the pipeline will make before giving up."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Without it:"})," No restarts will be attempted."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How to configure:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineRetryOptions(\n    MaxItemRetries: 3,\n    MaxNodeRestartAttempts: 2,  // \u2190 At least 1\n    MaxMaterializedItems: 1000   // (see Step 3!)\n);\n\nvar context = PipelineContext.WithRetry(options);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Recommended starting values:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transient failures (network, temporary service issues):"})," 2-3 attempts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistent issues (resource exhaustion):"})," 3-5 attempts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Critical nodes:"})," 5+ attempts"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Learn more:"})," ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/retries",children:"Retry Configuration"})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h4,{id:"step-3-enable-input-materialization-\ufe0f-critical",children:"STEP 3: Enable Input Materialization (\u26a0\ufe0f CRITICAL)"}),"\n",(0,t.jsxs)(n.p,{children:["Set ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," to a ",(0,t.jsx)(n.strong,{children:"non-null, positive number"})," on the input to the node you want to be restartable. This is the replay buffer."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"What it does:"})," Buffers items from the input source so the node can be replayed from a known state if it fails."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["\ud83d\udea8 ",(0,t.jsx)(n.strong,{children:"CRITICAL ISSUE:"})," If ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," is ",(0,t.jsx)(n.code,{children:"null"})," (unbounded), the system silently falls back to ",(0,t.jsx)(n.code,{children:"FailPipeline"}),", even if you've configured restart logic. Your entire pipeline crashes instead of just restarting the node."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How to configure:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineRetryOptions(\n    MaxItemRetries: 3,\n    MaxNodeRestartAttempts: 2,\n    MaxMaterializedItems: 1000  // \u2190 Must be set! Not null!\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Choosing a value:"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Scenario"}),(0,t.jsx)(n.th,{children:"Recommended Value"}),(0,t.jsx)(n.th,{children:"Rationale"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Small objects (< 100 bytes)"}),(0,t.jsx)(n.td,{children:"5,000-10,000"}),(0,t.jsx)(n.td,{children:"Minimal memory overhead"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Medium objects (100-1KB)"}),(0,t.jsx)(n.td,{children:"1,000-5,000"}),(0,t.jsx)(n.td,{children:"Balanced buffer size"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Large objects (1KB+)"}),(0,t.jsx)(n.td,{children:"500-1,000"}),(0,t.jsx)(n.td,{children:"Respect memory constraints"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Critical/high-priority node"}),(0,t.jsx)(n.td,{children:"2,000-5,000"}),(0,t.jsx)(n.td,{children:"More replay buffer = higher restart success rate"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"conservative-starting-point",children:"Conservative Starting Point"}),"\n",(0,t.jsx)(n.p,{children:"Here's a good default configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineRetryOptions(\n    MaxItemRetries: 3,\n    MaxNodeRestartAttempts: 2,\n    MaxMaterializedItems: 1000  // \u2190 Good default: buffers ~1000 items\n);\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Learn more:"})," ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/materialization",children:"Materialization and Buffering"})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h4,{id:"warning-critical-warning-unbounded-materialization",children:["\u26a0\ufe0f"," CRITICAL WARNING: Unbounded Materialization"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Never set ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," to ",(0,t.jsx)(n.code,{children:"null"}),":"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// WRONG - This disables restart silently!\nvar options = new PipelineRetryOptions(\n    MaxItemRetries: 3,\n    MaxNodeRestartAttempts: 2,\n    MaxMaterializedItems: null  // \u2190 DANGER!\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"If you do:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Your pipeline will NOT restart on failures"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.strong,{children:["The system silently falls back to ",(0,t.jsx)(n.code,{children:"FailPipeline"})]})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Your entire pipeline will crash"})," (not just the failing node)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Risk of Out-of-Memory exceptions"})," with unbounded data streams"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Symptom:"})," You've configured restart logic, but when an error occurs, the pipeline fails completely instead of restarting the node."]}),"\n",(0,t.jsx)(n.h3,{id:"why-unbounded-memory-buffers-break-resilience-guarantees",children:"Why Unbounded Memory Buffers Break Resilience Guarantees"}),"\n",(0,t.jsxs)(n.p,{children:["Unbounded materialization (",(0,t.jsx)(n.code,{children:"MaxMaterializedItems: null"}),") creates a fundamental contradiction in the resilience model:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Memory Safety vs. Recovery Trade-off"}),": Unbounded buffers can consume all available memory, causing OutOfMemoryException that cannot be recovered from. This defeats the purpose of resilience."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Silent Failure Mode"}),": When the system detects unbounded materialization with a RestartNode decision, it cannot safely buffer items for replay. Instead of risking memory exhaustion, it silently falls back to ",(0,t.jsx)(n.code,{children:"FailPipeline"})," to protect the system."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Unpredictable Behavior"}),": In production, unbounded buffers lead to unpredictable memory usage patterns that can cause cascading failures across the entire system."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Resource Contention"}),": Unbounded buffers compete with other processes for memory, potentially causing system-wide instability."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The Design Philosophy"}),": NPipeline prioritizes system stability over incomplete recovery. An unbounded buffer represents an undefined recovery boundary, making safe restart impossible. By requiring explicit buffer limits, NPipeline ensures that restart operations have predictable memory footprints and can be safely executed."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Choosing Not to Set a Memory Cap = Choosing Complete Pipeline Failure"})}),"\n",(0,t.jsxs)(n.p,{children:["When you set ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems: null"}),", you are making an explicit choice to sacrifice restart capability in favor of unlimited buffering. This means:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"You accept that RestartNode will not work"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"You accept that your pipeline will fail completely on node errors"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"You accept the risk of OutOfMemoryException"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If you need node restart functionality, you ",(0,t.jsx)(n.strong,{children:"must"})," set a memory cap. The system cannot provide resilience guarantees without defined resource boundaries."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"complete-configuration-example",children:"Complete Configuration Example"}),"\n",(0,t.jsx)(n.p,{children:"Here's a complete example with all three requirements:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Step 1: Create retry options with ALL three settings\nvar options = new PipelineRetryOptions(\n    MaxItemRetries: 3,\n    MaxNodeRestartAttempts: 2,           // \u2190 Step 2: Restart attempts\n    MaxMaterializedItems: 1000            // \u2190 Step 3: Replay buffer\n);\n\nvar context = PipelineContext.WithRetry(options);\n\n// Step 2: Build pipeline with resilient nodes\nvar definition = new MyPipelineDefinition();\ndefinition.Define(builder, context);\n\n// In MyPipelineDefinition.Define():\n// \n//   Step 1: Wrap node with ResilientExecutionStrategy\n//   var nodeHandle = builder\n//       .AddTransform<MyTransform, Input, Output>("risky")\n//       .WithExecutionStrategy(\n//           builder,\n//           new ResilientExecutionStrategy(\n//               new SequentialExecutionStrategy()\n//           )\n//       );\n//\n//   Add error handler that returns RestartNode\n//   builder.AddPipelineErrorHandler<MyErrorHandler>();\n//\n// In MyErrorHandler.HandleNodeFailureAsync():\n//\n//   return error switch\n//   {\n//       TimeoutException => PipelineErrorDecision.RestartNode,\n//       _ => PipelineErrorDecision.FailPipeline\n//   };\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"retry-delay-quick-start",children:"Retry Delay Quick Start"}),"\n",(0,t.jsx)(n.p,{children:"Retry delays are essential for building resilient pipelines that can recover from transient failures without overwhelming downstream services."}),"\n",(0,t.jsx)(n.h3,{id:"quick-start-common-retry-patterns",children:"Quick Start: Common Retry Patterns"}),"\n",(0,t.jsx)(n.h4,{id:"web-api-calls-most-common",children:"Web API Calls (Most Common)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Recommended for external API calls\ncontext.UseExponentialBackoffDelay(\n    baseDelay: TimeSpan.FromSeconds(1),\n    multiplier: 2.0,\n    maxDelay: TimeSpan.FromMinutes(1));\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why this pattern:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Exponential backoff gives services time to recover"}),"\n",(0,t.jsx)(n.li,{children:"Prevents thundering herd problems"}),"\n",(0,t.jsx)(n.li,{children:"Balanced for typical API rate limits"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"database-operations",children:"Database Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Recommended for database retry scenarios\ncontext.UseLinearBackoffDelay(\n    baseDelay: TimeSpan.FromMilliseconds(100),\n    increment: TimeSpan.FromMilliseconds(200),\n    maxDelay: TimeSpan.FromSeconds(5));\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why this pattern:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Linear growth is predictable for database connection pools"}),"\n",(0,t.jsx)(n.li,{children:"Shorter delays work well for transient lock contention"}),"\n",(0,t.jsx)(n.li,{children:"Conservative max delay prevents long-running transactions"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"file-processing",children:"File Processing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Recommended for file system operations\ncontext.UseFixedDelay(TimeSpan.FromSeconds(2));\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why this pattern:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"File system recovery is typically immediate"}),"\n",(0,t.jsx)(n.li,{children:"Fixed delay provides predictable behavior"}),"\n",(0,t.jsx)(n.li,{children:"Simple and effective for I/O operations"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"decision-flow-for-choosing-retry-strategy",children:"Decision Flow for Choosing Retry Strategy"}),"\n",(0,t.jsx)(n.mermaid,{value:"flowchart TD\n    A[What type of operation?] --\x3e B{External Service?}\n    B --\x3e|Yes| C[Use Exponential Backoff]\n    B --\x3e|No| D{Database Operation?}\n    D --\x3e|Yes| E[Use Linear Backoff]\n    D --\x3e|No| F{File System?}\n    F --\x3e|Yes| G[Use Fixed Delay]\n    F --\x3e|No| H[Use Exponential Backoff<br>Default choice]\n    \n    C --\x3e I[Configure base delay: 1s<br>Configure multiplier: 2.0<br>Configure max delay: 1m]\n    E --\x3e J[Configure base delay: 100ms<br>Configure increment: 200ms<br>Configure max delay: 5s]\n    G --\x3e K[Configure delay: 2s]\n    H --\x3e I\n    \n    style A fill:#e1f5fe\n    style C fill:#e8f5e9\n    style E fill:#e8f5e9\n    style G fill:#e8f5e9\n    style I fill:#fff3e0\n    style J fill:#f3e5f5\n    style K fill:#f3e5f5"}),"\n",(0,t.jsx)(n.h3,{id:"implementation-examples",children:"Implementation Examples"}),"\n",(0,t.jsx)(n.h4,{id:"basic-pipeline-with-retry-delays",children:"Basic Pipeline with Retry Delays"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\nusing NPipeline.Pipeline;\n\npublic sealed class RetryQuickstartPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        // Configure retry delay strategy based on operation type\n        context.UseExponentialBackoffDelay(\n            baseDelay: TimeSpan.FromSeconds(1),\n            multiplier: 2.0,\n            maxDelay: TimeSpan.FromMinutes(1));\n\n        var source = builder.AddSource<ApiSource, ApiResponse>("api-source");\n        var transform = builder.AddTransform<DataTransform, ApiResponse, ProcessedData>("transform");\n        var sink = builder.AddSink<DataSink, ProcessedData>("sink");\n\n        builder.Connect(source, transform);\n        builder.Connect(transform, sink);\n\n        // Configure retry options\n        builder.WithRetryOptions(new PipelineRetryOptions(\n            MaxItemRetries: 3,\n            MaxNodeRestartAttempts: 2,\n            MaxSequentialNodeAttempts: 5\n        ));\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"per-node-retry-configuration",children:"Per-Node Retry Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public void Define(PipelineBuilder builder, PipelineContext context)\n{\n    var source = builder.AddSource<DataSource, string>("source");\n    \n    // Fast retries for in-memory operations\n    context.UseFixedDelay(TimeSpan.FromMilliseconds(50));\n    var memoryTransform = builder.AddTransform<MemoryTransform, string, string>("memory-ops");\n    \n    // Slower retries for external API calls\n    context.UseExponentialBackoffDelay(\n        baseDelay: TimeSpan.FromSeconds(1),\n        multiplier: 2.0,\n        maxDelay: TimeSpan.FromMinutes(1));\n    var apiTransform = builder.AddTransform<ApiTransform, string, string>("api-ops");\n    \n    // Default retries for other operations\n    var sink = builder.AddSink<DataSink, string>("sink");\n\n    builder.Connect(source, memoryTransform);\n    builder.Connect(memoryTransform, apiTransform);\n    builder.Connect(apiTransform, sink);\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"common-pitfalls-to-avoid",children:"Common Pitfalls to Avoid"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,t.jsx)(n.strong,{children:"Common Mistake"}),": Not configuring retry delays at all"]}),"\n",(0,t.jsx)(n.p,{children:"Without retry delays, failed operations retry immediately, which can overwhelm recovering services."}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,t.jsx)(n.strong,{children:"Common Mistake"}),": Using exponential backoff for in-memory operations"]}),"\n",(0,t.jsx)(n.p,{children:"In-memory operations typically recover immediately, so exponential backoff adds unnecessary delays."}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,t.jsx)(n.strong,{children:"Common Mistake"}),": Setting max delay too high"]}),"\n",(0,t.jsx)(n.p,{children:"Very high max delays can cause long recovery times. Consider your SLA requirements."}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pro Tip"}),": Always test retry behavior in development"]}),"\n",(0,t.jsx)(n.p,{children:"Use fixed delays in tests for predictable behavior, then switch to appropriate backoff in production."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling"})})," - Comprehensive error handling strategies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/retries",children:"Retry Configuration"})})," - Detailed configuration options and advanced patterns"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/circuit-breakers",children:"Circuit Breakers"})})," - Preventing cascading failures"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting"})})," - Common issues and solutions"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);