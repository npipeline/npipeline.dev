"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[1868],{3419:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>d,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"core-concepts/advanced-nodes/join","title":"Join Nodes","description":"Merge data from multiple input streams based on common keys or time windows using NPipeline\'s Join Nodes.","source":"@site/docs/core-concepts/advanced-nodes/join.md","sourceDirName":"core-concepts/advanced-nodes","slug":"/core-concepts/advanced-nodes/join","permalink":"/docs/core-concepts/advanced-nodes/join","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Join Nodes","description":"Merge data from multiple input streams based on common keys or time windows using NPipeline\'s Join Nodes.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Batching Nodes","permalink":"/docs/core-concepts/advanced-nodes/batching"},"next":{"title":"Lookup Nodes","permalink":"/docs/core-concepts/advanced-nodes/lookup"}}');var i=r(4848),o=r(8453);const d={title:"Join Nodes",description:"Merge data from multiple input streams based on common keys or time windows using NPipeline's Join Nodes.",sidebar_position:3},s="Join Nodes",l={},c=[{value:"<code>IJoinNode</code>",id:"ijoinnode",level:2},{value:"Keyed Join Nodes",id:"keyed-join-nodes",level:2},{value:"<code>KeyedJoinNode&lt;TKey, TIn1, TIn2, TOut&gt;</code>",id:"keyedjoinnodetkey-tin1-tin2-tout",level:3},{value:"Required Method Overrides",id:"required-method-overrides",level:4},{value:"Key Selection",id:"key-selection",level:4},{value:"Join Types",id:"join-types",level:4},{value:"Inner Join",id:"inner-join",level:5},{value:"Left Outer Join",id:"left-outer-join",level:5},{value:"Right Outer Join",id:"right-outer-join",level:5},{value:"Full Outer Join",id:"full-outer-join",level:5},{value:"Example: Joining Orders with Customer Data",id:"example-joining-orders-with-customer-data",level:3},{value:"Example: Composite Key Join",id:"example-composite-key-join",level:3},{value:"Time-Windowed Join Nodes",id:"time-windowed-join-nodes",level:2},{value:"<code>TimeWindowedJoinNode&lt;TLeft, TRight, TKey, TOutput&gt;</code>",id:"timewindowedjoinnodetleft-tright-tkey-toutput",level:3},{value:"Example: Correlating Events within a Time Window",id:"example-correlating-events-within-a-time-window",level:3},{value:"Key Configuration with <code>KeySelectorAttribute</code>",id:"key-configuration-with-keyselectorattribute",level:2},{value:"Next Steps",id:"next-steps",level:2}];function a(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"join-nodes",children:"Join Nodes"})}),"\n",(0,i.jsx)(n.p,{children:"Join nodes in NPipeline allow you to combine data from two or more independent input streams into a single output stream. This is a common operation in data processing, enabling the enrichment of data or the correlation of related events."}),"\n",(0,i.jsx)(n.p,{children:"NPipeline offers different types of join nodes to cater to various joining strategies, including keyed joins and time-windowed joins."}),"\n",(0,i.jsx)(n.h2,{id:"ijoinnode",children:(0,i.jsx)(n.code,{children:"IJoinNode"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"src/NPipeline/Interfaces/IJoinNode.cs",children:(0,i.jsx)(n.code,{children:"IJoinNode"})})," interface represents the contract for any node that performs a join operation. Implementations will typically take multiple input streams and produce a single output stream containing the combined data."]}),"\n",(0,i.jsx)(n.h2,{id:"keyed-join-nodes",children:"Keyed Join Nodes"}),"\n",(0,i.jsx)(n.p,{children:"Keyed join nodes merge items from different streams based on a common key. When an item arrives on any input stream, it is matched with existing items from other streams that share the same key."}),"\n",(0,i.jsx)(n.h3,{id:"keyedjoinnodetkey-tin1-tin2-tout",children:(0,i.jsx)(n.code,{children:"KeyedJoinNode<TKey, TIn1, TIn2, TOut>"})}),"\n",(0,i.jsxs)(n.p,{children:["This node performs a join based on a key selector and extends the ",(0,i.jsx)(n.a,{href:"src/NPipeline/Nodes/Join/BaseJoinNode.cs",children:(0,i.jsx)(n.code,{children:"BaseJoinNode<TKey, TIn1, TIn2, TOut>"})})," abstract base class, which provides common functionality for processing two input streams. You need to define how to extract the key from the left and right input items."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TKey"}),": The type of the join key."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TIn1"}),": The type of items from the first input stream."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TIn2"}),": The type of items from the second input stream."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TOut"}),": The type of the combined output item."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"required-method-overrides",children:"Required Method Overrides"}),"\n",(0,i.jsx)(n.p,{children:"To implement a custom keyed join, you must override the following methods:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"CreateOutput(TLeft leftItem, TRight rightItem)"})}),": Creates the output item when a match is found between left and right items."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Defines how to combine matching items from both streams into a single output item."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Called when"}),": A matching pair of items (one from each stream with the same key) is found."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),": The combined output item."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"CreateOutputFromLeft(TLeft leftItem)"})})," (Optional override): Creates an output item when there's no matching right item."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Handles unmatched items from the left stream in left outer and full outer joins."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Called when"}),": The stream ends and there are still unmatched left items."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Default behavior"}),": Attempts to automatically project the left item to the output type, but may throw ",(0,i.jsx)(n.code,{children:"NotSupportedException"})," if unable to do so."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),": An output item based solely on the left item."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"CreateOutputFromRight(TRight rightItem)"})})," (Optional override): Creates an output item when there's no matching left item."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Handles unmatched items from the right stream in right outer and full outer joins."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Called when"}),": The stream ends and there are still unmatched right items."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Default behavior"}),": Attempts to automatically project the right item to the output type, but may throw ",(0,i.jsx)(n.code,{children:"NotSupportedException"})," if unable to do so."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),": An output item based solely on the right item."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"key-selection",children:"Key Selection"}),"\n",(0,i.jsx)(n.p,{children:"Key extraction for the join can be defined in two ways:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Using KeySelectorAttribute"})," (Recommended): Apply the ",(0,i.jsx)(n.a,{href:"src/NPipeline/Attributes/Nodes/KeySelectorAttribute.cs",children:(0,i.jsx)(n.code,{children:"KeySelectorAttribute"})})," to your join class to specify which properties to use as keys for each input type."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Custom key extraction"}),": For more complex key extraction logic, you can override the key selection process."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"join-types",children:"Join Types"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"src/NPipeline/Nodes/Join/JoinType.cs",children:(0,i.jsx)(n.code,{children:"JoinType"})})," property controls how unmatched items are handled:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Inner"}),": Only produces output when there's a match in both streams (default)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"LeftOuter"}),": Produces all left items, with matching right items when available."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"RightOuter"}),": Produces all right items, with matching left items when available."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"FullOuter"}),": Produces all items from both streams, matching when possible."]}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"inner-join",children:"Inner Join"}),"\n",(0,i.jsx)(n.mermaid,{value:'graph TD\r\n    subgraph "Input Streams"\r\n        L[Left Stream<br/>A, B, C, D]\r\n        R[Right Stream<br/>B, C, E]\r\n    end\r\n\r\n    subgraph "Inner Join"\r\n        direction LR\r\n        LI[Left: A, B, C, D] --\x3e IJ{Join on Key}\r\n        RI[Right: B, C, E] --\x3e IJ\r\n        IJ --\x3e IO[Output: B, C<br/>Only matching items]\r\n    end\r\n\r\n    style L fill:#e1f5fe\r\n    style R fill:#e8f5e9\r\n    style IO fill:#fff3e0'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Figure: Inner join produces output only when there's a match in both streams."})}),"\n",(0,i.jsx)(n.h5,{id:"left-outer-join",children:"Left Outer Join"}),"\n",(0,i.jsx)(n.mermaid,{value:'graph TD\r\n    subgraph "Input Streams"\r\n        L[Left Stream<br/>A, B, C, D]\r\n        R[Right Stream<br/>B, C, E]\r\n    end\r\n\r\n    subgraph "Left Outer Join"\r\n        direction LR\r\n        LL[Left: A, B, C, D] --\x3e LJ{Join on Key}\r\n        RL[Right: B, C, E] --\x3e LJ\r\n        LJ --\x3e LO[Output: A, B, C, D<br/>All left items<br/>with null for non-matches]\r\n    end\r\n\r\n    style L fill:#e1f5fe\r\n    style R fill:#e8f5e9\r\n    style LO fill:#f3e5f5'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Figure: Left outer join produces all left items, with matching right items when available."})}),"\n",(0,i.jsx)(n.h5,{id:"right-outer-join",children:"Right Outer Join"}),"\n",(0,i.jsx)(n.mermaid,{value:'graph TD\r\n    subgraph "Input Streams"\r\n        L[Left Stream<br/>A, B, C, D]\r\n        R[Right Stream<br/>B, C, E]\r\n    end\r\n\r\n    subgraph "Right Outer Join"\r\n        direction LR\r\n        LR2[Left: A, B, C, D] --\x3e RJ{Join on Key}\r\n        RR[Right: B, C, E] --\x3e RJ\r\n        RJ --\x3e RO[Output: B, C, E<br/>All right items<br/>with null for non-matches]\r\n    end\r\n\r\n    style L fill:#e1f5fe\r\n    style R fill:#e8f5e9\r\n    style RO fill:#e0f2f1'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Figure: Right outer join produces all right items, with matching left items when available."})}),"\n",(0,i.jsx)(n.h5,{id:"full-outer-join",children:"Full Outer Join"}),"\n",(0,i.jsx)(n.mermaid,{value:'graph TD\r\n    subgraph "Input Streams"\r\n        L[Left Stream<br/>A, B, C, D]\r\n        R[Right Stream<br/>B, C, E]\r\n    end\r\n\r\n    subgraph "Full Outer Join"\r\n        direction LR\r\n        LF[Left: A, B, C, D] --\x3e FJ{Join on Key}\r\n        RF[Right: B, C, E] --\x3e FJ\r\n        FJ --\x3e FO[Output: A, B, C, D, E<br/>All items from both streams<br/>with null for non-matches]\r\n    end\r\n\r\n    style L fill:#e1f5fe\r\n    style R fill:#e8f5e9\r\n    style FO fill:#fce4ec'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Figure: Full outer join produces all items from both streams, matching when possible."})}),"\n",(0,i.jsx)(n.h3,{id:"example-joining-orders-with-customer-data",children:"Example: Joining Orders with Customer Data"}),"\n",(0,i.jsxs)(n.p,{children:["Let's imagine we have a stream of ",(0,i.jsx)(n.code,{children:"Order"})," items and a separate stream of ",(0,i.jsx)(n.code,{children:"Customer"})," items. We want to enrich the ",(0,i.jsx)(n.code,{children:"Order"})," with ",(0,i.jsx)(n.code,{children:"Customer"})," details."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\n\r\n// Define input data structures\r\npublic sealed record Order(int OrderId, int CustomerId, decimal Amount);\r\npublic sealed record Customer(int CustomerId, string Name, string Email);\r\npublic sealed record EnrichedOrder(int OrderId, int CustomerId, string CustomerName, decimal Amount);\r\n\r\n// Define the join node with KeySelectorAttributes\r\n[KeySelector(typeof(Order), nameof(Order.CustomerId))]\r\n[KeySelector(typeof(Customer), nameof(Customer.CustomerId))]\r\npublic sealed class CustomerOrderJoinNode : KeyedJoinNode<int, Order, Customer, EnrichedOrder>\r\n{\r\n    // Required: Combine matching items\r\n    protected override EnrichedOrder CreateOutput(Order leftItem, Customer rightItem)\r\n    {\r\n        return new EnrichedOrder(\r\n            leftItem.OrderId,\r\n            leftItem.CustomerId,\r\n            rightItem.Name,\r\n            leftItem.Amount\r\n        );\r\n    }\r\n\r\n    // Optional: Handle unmatched orders (for left outer or full outer joins)\r\n    protected override EnrichedOrder CreateOutputFromLeft(Order leftItem)\r\n    {\r\n        // Create an enriched order with placeholder customer data\r\n        return new EnrichedOrder(\r\n            leftItem.OrderId,\r\n            leftItem.CustomerId,\r\n            "Unknown Customer",\r\n            leftItem.Amount\r\n        );\r\n    }\r\n\r\n    // Optional: Handle unmatched customers (for right outer or full outer joins)\r\n    protected override EnrichedOrder CreateOutputFromRight(Customer rightItem)\r\n    {\r\n        // Create a placeholder order with just the customer information\r\n        return new EnrichedOrder(\r\n            0, // No OrderId\r\n            rightItem.CustomerId,\r\n            rightItem.Name,\r\n            0m // No amount\r\n        );\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var orderSource = new InMemorySourceNode<Order>(\r\n            new Order(101, 1, 100.00m),\r\n            new Order(102, 2, 250.00m),\r\n            new Order(103, 1, 50.00m),\r\n            new Order(104, 3, 75.00m) // This customer doesn\'t exist in our data\r\n        );\r\n\r\n        var customerSource = new InMemorySourceNode<Customer>(\r\n            new Customer(1, "Alice", "alice@example.com"),\r\n            new Customer(2, "Bob", "bob@example.com")\r\n            // Note: Customer 3 is missing\r\n        );\r\n\r\n        // Example with inner join (default)\r\n        var innerJoinContext = PipelineContext.Default;\r\n        var innerJoinRunner = new PipelineRunner();\r\n        Console.WriteLine("Running inner join pipeline...");\r\n        await innerJoinRunner.RunAsync<InnerJoinPipelineDefinition>(innerJoinContext);\r\n\r\n        // Example with left outer join\r\n        var leftOuterContext = PipelineContext.Default;\r\n        var leftOuterRunner = new PipelineRunner();\r\n        Console.WriteLine("\\nRunning left outer join pipeline...");\r\n        await leftOuterRunner.RunAsync<LeftOuterJoinPipelineDefinition>(leftOuterContext);\r\n\r\n        // Example with full outer join\r\n        var fullOuterContext = PipelineContext.Default;\r\n        var fullOuterRunner = new PipelineRunner();\r\n        Console.WriteLine("\\nRunning full outer join pipeline...");\r\n        await fullOuterRunner.RunAsync<FullOuterJoinPipelineDefinition>(fullOuterContext);\r\n    }\r\n}\r\n\r\npublic sealed class InnerJoinPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var orderSourceHandle = builder.AddSource<InMemorySourceNode<Order>, Order>("orderSource");\r\n        var customerSourceHandle = builder.AddSource<InMemorySourceNode<Customer>, Customer>("customerSource");\r\n        var joinHandle = builder.AddJoin<CustomerOrderJoinNode, Order, Customer, EnrichedOrder>("correlator");\r\n        var sinkHandle = builder.AddSink<ConsoleSink<EnrichedOrder>, EnrichedOrder>("sink");\r\n\r\n        builder.Connect(orderSourceHandle, joinHandle);\r\n        builder.Connect(customerSourceHandle, joinHandle);\r\n        builder.Connect(joinHandle, sinkHandle);\r\n    }\r\n}\r\n\r\npublic sealed class LeftOuterJoinPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var orderSourceHandle = builder.AddSource<InMemorySourceNode<Order>, Order>("orderSource");\r\n        var customerSourceHandle = builder.AddSource<InMemorySourceNode<Customer>, Customer>("customerSource");\r\n        var joinHandle = builder.AddJoin<CustomerOrderJoinNode, Order, Customer, EnrichedOrder>("correlator");\r\n        var sinkHandle = builder.AddSink<ConsoleSink<EnrichedOrder>, EnrichedOrder>("sink");\r\n\r\n        builder.Connect(orderSourceHandle, joinHandle);\r\n        builder.Connect(customerSourceHandle, joinHandle);\r\n        builder.Connect(joinHandle, sinkHandle);\r\n    }\r\n}\r\n\r\npublic sealed class FullOuterJoinPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var orderSourceHandle = builder.AddSource<InMemorySourceNode<Order>, Order>("orderSource");\r\n        var customerSourceHandle = builder.AddSource<InMemorySourceNode<Customer>, Customer>("customerSource");\r\n        var joinHandle = builder.AddJoin<CustomerOrderJoinNode, Order, Customer, EnrichedOrder>("correlator");\r\n        var sinkHandle = builder.AddSink<ConsoleSink<EnrichedOrder>, EnrichedOrder>("sink");\r\n\r\n        builder.Connect(orderSourceHandle, joinHandle);\r\n        builder.Connect(customerSourceHandle, joinHandle);\r\n        builder.Connect(joinHandle, sinkHandle);\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Expected Output:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'Running inner join pipeline...\r\nSink received: EnrichedOrder { OrderId = 101, CustomerId = 1, CustomerName = "Alice", Amount = 100.00 }\r\nSink received: EnrichedOrder { OrderId = 102, CustomerId = 2, CustomerName = "Bob", Amount = 250.00 }\r\nSink received: EnrichedOrder { OrderId = 103, CustomerId = 1, CustomerName = "Alice", Amount = 50.00 }\r\n\r\nRunning left outer join pipeline...\r\nSink received: EnrichedOrder { OrderId = 101, CustomerId = 1, CustomerName = "Alice", Amount = 100.00 }\r\nSink received: EnrichedOrder { OrderId = 102, CustomerId = 2, CustomerName = "Bob", Amount = 250.00 }\r\nSink received: EnrichedOrder { OrderId = 103, CustomerId = 1, CustomerName = "Alice", Amount = 50.00 }\r\nSink received: EnrichedOrder { OrderId = 104, CustomerId = 3, CustomerName = "Unknown Customer", Amount = 75.00 }\r\n\r\nRunning full outer join pipeline...\r\nSink received: EnrichedOrder { OrderId = 101, CustomerId = 1, CustomerName = "Alice", Amount = 100.00 }\r\nSink received: EnrichedOrder { OrderId = 102, CustomerId = 2, CustomerName = "Bob", Amount = 250.00 }\r\nSink received: EnrichedOrder { OrderId = 103, CustomerId = 1, CustomerName = "Alice", Amount = 50.00 }\r\nSink received: EnrichedOrder { OrderId = 104, CustomerId = 3, CustomerName = "Unknown Customer", Amount = 75.00 }\n'})}),"\n",(0,i.jsx)(n.h3,{id:"example-composite-key-join",children:"Example: Composite Key Join"}),"\n",(0,i.jsx)(n.p,{children:"For more complex scenarios, you can use composite keys:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\n\r\n// Define input data structures with composite keys\r\npublic sealed record OrderItem(int OrderId, string ProductCode, int Quantity, decimal Price);\r\npublic sealed record Product(string ProductCode, string Category, string Name);\r\npublic sealed record EnrichedOrderItem(int OrderId, string ProductCode, string ProductName, string Category, int Quantity, decimal Price);\r\n\r\n// Define a composite key type\r\npublic sealed record OrderProductKey(int OrderId, string ProductCode);\r\n\r\n// Define the join node with composite key selectors\r\n[KeySelector(typeof(OrderItem), nameof(OrderItem.OrderId), nameof(OrderItem.ProductCode))]\r\n[KeySelector(typeof(Product), nameof(Product.ProductCode))]\r\npublic sealed class OrderItemProductJoinNode : KeyedJoinNode<(int, string), OrderItem, Product, EnrichedOrderItem>\r\n{\r\n    protected override EnrichedOrderItem CreateOutput(OrderItem leftItem, Product rightItem)\r\n    {\r\n        return new EnrichedOrderItem(\r\n            leftItem.OrderId,\r\n            leftItem.ProductCode,\r\n            rightItem.Name,\r\n            rightItem.Category,\r\n            leftItem.Quantity,\r\n            leftItem.Price\r\n        );\r\n    }\r\n\r\n    protected override EnrichedOrderItem CreateOutputFromLeft(OrderItem leftItem)\r\n    {\r\n        // Handle order items with unknown products\r\n        return new EnrichedOrderItem(\r\n            leftItem.OrderId,\r\n            leftItem.ProductCode,\r\n            "Unknown Product",\r\n            "Unknown Category",\r\n            leftItem.Quantity,\r\n            leftItem.Price\r\n        );\r\n    }\r\n}\r\n\r\n// Alternative using ValueTuple for composite key\r\n[KeySelector(typeof(OrderItem), nameof(OrderItem.OrderId), nameof(OrderItem.ProductCode))]\r\n[KeySelector(typeof(Product), nameof(Product.ProductCode))]\r\npublic sealed class OrderItemProductJoinNodeWithTuple : KeyedJoinNode<(int OrderId, string ProductCode), OrderItem, Product, EnrichedOrderItem>\r\n{\r\n    protected override EnrichedOrderItem CreateOutput(OrderItem leftItem, Product rightItem)\r\n    {\r\n        return new EnrichedOrderItem(\r\n            leftItem.OrderId,\r\n            leftItem.ProductCode,\r\n            rightItem.Name,\r\n            rightItem.Category,\r\n            leftItem.Quantity,\r\n            leftItem.Price\r\n        );\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"time-windowed-join-nodes",children:"Time-Windowed Join Nodes"}),"\n",(0,i.jsx)(n.p,{children:"Time-windowed join nodes combine items from different streams that occur within a specified time window. This is common in real-time stream processing where events need to be correlated based on their temporal proximity."}),"\n",(0,i.jsx)(n.h3,{id:"timewindowedjoinnodetleft-tright-tkey-toutput",children:(0,i.jsx)(n.code,{children:"TimeWindowedJoinNode<TLeft, TRight, TKey, TOutput>"})}),"\n",(0,i.jsxs)(n.p,{children:["This node extends ",(0,i.jsx)(n.a,{href:"src/NPipeline/Nodes/Join/KeyedJoinNode.cs",children:(0,i.jsx)(n.code,{children:"KeyedJoinNode"})})," by adding a time window constraint. Items are considered for joining only if their timestamps fall within the defined window and their keys match."]}),"\n",(0,i.jsx)(n.h3,{id:"example-correlating-events-within-a-time-window",children:"Example: Correlating Events within a Time Window"}),"\n",(0,i.jsxs)(n.p,{children:["The repository includes time-windowed join support (see ",(0,i.jsx)(n.code,{children:"TimeWindowedJoinNode"})," and windowing primitives such as ",(0,i.jsx)(n.code,{children:"WindowAssigner"}),"). Higher-level extension packages may provide convenience helpers in the future, but basic time-windowed join patterns are available in core today."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Assuming EventA and EventB have a Timestamp property and a common CorrelationId\r\npublic sealed record EventA(Guid CorrelationId, DateTime Timestamp, string DataA);\r\npublic sealed record EventB(Guid CorrelationId, DateTime Timestamp, string DataB);\r\npublic sealed record CorrelatedEvent(Guid CorrelationId, DateTime Timestamp, string DataA, string DataB);\r\n\r\npublic sealed class EventCorrelationJoinNode : TimeWindowedJoinNode<EventA, EventB, Guid, CorrelatedEvent>\r\n{\r\n    public EventCorrelationJoinNode(TimeSpan windowSize) : base(windowSize) { }\r\n\r\n    protected override Guid GetLeftKey(EventA leftItem) => leftItem.CorrelationId;\r\n    protected override DateTime GetLeftTimestamp(EventA leftItem) => leftItem.Timestamp;\r\n\r\n    protected override Guid GetRightKey(EventB rightItem) => rightItem.CorrelationId;\r\n    protected override DateTime GetRightTimestamp(EventB rightItem) => rightItem.Timestamp;\r\n\r\n    protected override CorrelatedEvent JoinItems(EventA leftItem, EventB rightItem)\r\n    {\r\n        return new CorrelatedEvent(\r\n            leftItem.CorrelationId,\r\n            leftItem.Timestamp, // or rightItem.Timestamp, depending on logic\r\n            leftItem.DataA,\r\n            rightItem.DataB\r\n        );\r\n    }\r\n}\r\n\r\n// Pipeline construction would involve adding sources and a join node\r\n// var pipeline = new PipelineBuilder()\r\n//     .AddSource(new EventASource())\r\n//     .AddSource(new EventBSource())\r\n//     .Join(new EventCorrelationJoinNode(TimeSpan.FromSeconds(5))) // Join events within 5 seconds\r\n//     .AddSink(new ConsoleSink<CorrelatedEvent>())\r\n//     .Build();\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"key-configuration-with-keyselectorattribute",children:["Key Configuration with ",(0,i.jsx)(n.a,{href:"src/NPipeline/Attributes/Nodes/KeySelectorAttribute.cs",children:(0,i.jsx)(n.code,{children:"KeySelectorAttribute"})})]}),"\n",(0,i.jsxs)(n.p,{children:["Some join nodes may utilize the ",(0,i.jsx)(n.code,{children:"KeySelectorAttribute"})," to automatically infer key extraction logic based on property names or custom functions. This provides a declarative way to specify join keys."]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/core-concepts/advanced-nodes/lookup",children:"Lookup Nodes"})}),": Discover how to enrich data by querying external sources."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/core-concepts/advanced-nodes/branch",children:"Branch Nodes"})}),": Learn about duplicating data streams to multiple downstream paths."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>s});var t=r(6540);const i={},o=t.createContext(i);function d(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);