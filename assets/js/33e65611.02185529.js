"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[9851],{1898:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"reference/error-codes","title":"NPipeline Error Codes Reference","description":"This guide explains NPipeline error codes, their causes, and solutions.","source":"@site/docs/reference/error-codes.md","sourceDirName":"reference","slug":"/reference/error-codes","permalink":"/docs/reference/error-codes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Troubleshooting Guide","permalink":"/docs/reference/troubleshooting"},"next":{"title":"Tooling","permalink":"/docs/tooling/"}}');var s=r(4848),t=r(8453);const o={},l="NPipeline Error Codes Reference",c={},d=[{value:"NP01xx - Graph Validation Errors",id:"np01xx---graph-validation-errors",level:2},{value:"NP0101: Pipeline Requires At Least One Node",id:"np0101-pipeline-requires-at-least-one-node",level:3},{value:"NP0102: Node Missing Input Connection",id:"np0102-node-missing-input-connection",level:3},{value:"NP0103: Cyclic Dependency Detected",id:"np0103-cyclic-dependency-detected",level:3},{value:"NP0104: Node Already Added",id:"np0104-node-already-added",level:3},{value:"NP0105: Node Name Not Unique",id:"np0105-node-name-not-unique",level:3},{value:"NP02xx - Type Mismatch and Conversion Errors",id:"np02xx---type-mismatch-and-conversion-errors",level:2},{value:"NP0201: Type Mismatch in Connection",id:"np0201-type-mismatch-in-connection",level:3},{value:"NP0202: Input Data Pipe Wrong Type",id:"np0202-input-data-pipe-wrong-type",level:3},{value:"NP0203: Cannot Register Mappings After Execution",id:"np0203-cannot-register-mappings-after-execution",level:3},{value:"NP0204: Record Type Has No Public Constructor",id:"np0204-record-type-has-no-public-constructor",level:3},{value:"NP0205-2008: Member Access and Setter Errors",id:"np0205-2008-member-access-and-setter-errors",level:3},{value:"NP0210: Cannot Concatenate Streams Type Mismatch",id:"np0210-cannot-concatenate-streams-type-mismatch",level:3},{value:"NP03xx - Execution Errors",id:"np03xx---execution-errors",level:2},{value:"NP0301: Node Kind Not Supported",id:"np0301-node-kind-not-supported",level:3},{value:"NP0302: Output Not Found for Source Node",id:"np0302-output-not-found-for-source-node",level:3},{value:"NP0303-3004: Pipeline Execution Failed",id:"np0303-3004-pipeline-execution-failed",level:3},{value:"NP0305: Item Failed After Max Retries",id:"np0305-item-failed-after-max-retries",level:3},{value:"NP0306: Error Handling Failed",id:"np0306-error-handling-failed",level:3},{value:"NP0307: Lineage Cardinality Mismatch",id:"np0307-lineage-cardinality-mismatch",level:3},{value:"NP0310: Circuit Breaker Tripped",id:"np0310-circuit-breaker-tripped",level:3},{value:"NP0311: Retry Limit Exhausted",id:"np0311-retry-limit-exhausted",level:3},{value:"NP9302: SinkNode Input Not Consumed",id:"np9302-sinknode-input-not-consumed",level:3},{value:"NP9303: Unsafe PipelineContext Access",id:"np9303-unsafe-pipelinecontext-access",level:2},{value:"NP04xx - Configuration Errors",id:"np04xx---configuration-errors",level:2},{value:"NP9001: Incomplete Resilient Configuration",id:"np9001-incomplete-resilient-configuration",level:3},{value:"NP90xx-NP94xx - Analyzer Diagnostics",id:"np90xx-np94xx---analyzer-diagnostics",level:2},{value:"NP9205: Non-Streaming Patterns in SourceNode",id:"np9205-non-streaming-patterns-in-sourcenode",level:3},{value:"NP9401: Missing Dependency Injection",id:"np9401-missing-dependency-injection",level:3}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"npipeline-error-codes-reference",children:"NPipeline Error Codes Reference"})}),"\n",(0,s.jsx)(n.p,{children:"This guide explains NPipeline error codes, their causes, and solutions."}),"\n",(0,s.jsx)(n.p,{children:"Error codes are organized by category:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"NP01xx"}),": Graph Validation Errors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"NP02xx"}),": Type Mismatch and Conversion Errors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"NP03xx"}),": Execution Errors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"NP04xx"}),": Configuration Errors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"NP05xx"}),": Resource and Capacity Errors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"NP90xx-NP94xx"}),": Analyzer Diagnostics"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"np01xx---graph-validation-errors",children:"NP01xx - Graph Validation Errors"}),"\n",(0,s.jsx)(n.h3,{id:"np0101-pipeline-requires-at-least-one-node",children:"NP0101: Pipeline Requires At Least One Node"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0101] A pipeline must have at least one node. Add at least one node (source, transform, or sink) before building."})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," You attempted to build a pipeline with no nodes."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Add at least one node using methods like ",(0,s.jsx)(n.code,{children:"AddSource()"}),", ",(0,s.jsx)(n.code,{children:"AddTransform()"}),", ",(0,s.jsx)(n.code,{children:"AddSink()"}),", ",(0,s.jsx)(n.code,{children:"AddJoin()"}),", or ",(0,s.jsx)(n.code,{children:"AddAggregate()"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var builder = new PipelineBuilder();\r\n// builder.Build(); // \u274c Would throw NP0101\r\n\r\nbuilder.AddSource<MySourceNode>();\r\nvar pipeline = builder.Build(); // \u2705 Works\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0102-node-missing-input-connection",children:"NP0102: Node Missing Input Connection"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0102] Node '{nodeId}' ({nodeName}, {nodeKind}) is missing a required input connection..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," A transform or sink node has no incoming edges from other nodes. These node types require at least one input connection."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Connect an output node to this node using ",(0,s.jsx)(n.code,{children:"Connect()"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'builder.AddSource<SourceNode>("src");\r\nbuilder.AddTransform<MyTransform>("transform");\r\n// Missing: builder.Connect("src", "transform");\r\n\r\nbuilder.Build(); // \u274c Would throw NP0102\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0103-cyclic-dependency-detected",children:"NP0103: Cyclic Dependency Detected"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0103] Cyclic dependency detected in pipeline graph. Pipelines must be directed acyclic graphs (DAGs)..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Your pipeline connections form a cycle (circular reference). This is not allowed as pipelines must be directed acyclic graphs."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Review your connections and ensure no circular dependencies exist."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'builder.AddTransform<Transform1>("t1");\r\nbuilder.AddTransform<Transform2>("t2");\r\nbuilder.Connect("t1", "t2");\r\nbuilder.Connect("t2", "t1"); // \u274c Creates cycle\r\n\r\nbuilder.Build(); // Would throw NP0103\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0104-node-already-added",children:"NP0104: Node Already Added"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0104] A node with ID '{nodeId}' has already been added..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," You attempted to add a node with an ID that's already registered in the pipeline."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Use a different ID or don't add the same node twice."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'builder.AddTransform<MyTransform>("transform");\r\nbuilder.AddTransform<MyTransform>("transform"); // \u274c Duplicate ID\r\n\r\nbuilder.Build(); // Would throw NP0104\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0105-node-name-not-unique",children:"NP0105: Node Name Not Unique"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0105] A node with name '{name}' has already been added..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Node names must be unique within a pipeline. You used a duplicate name."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Either provide a different name or let the framework auto-generate one by not specifying a name."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'builder.AddTransform<Transform1>("step");\r\nbuilder.AddTransform<Transform2>("step"); // \u274c Duplicate name\r\n\r\nbuilder.Build(); // Would throw NP0105\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"np02xx---type-mismatch-and-conversion-errors",children:"NP02xx - Type Mismatch and Conversion Errors"}),"\n",(0,s.jsx)(n.h3,{id:"np0201-type-mismatch-in-connection",children:"NP0201: Type Mismatch in Connection"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0201] Type mismatch in connection between nodes..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," You connected two nodes with incompatible types. The output type of one doesn't match the input type of the other."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Add an appropriate transformation node between them to handle the type conversion, or adjust your node types to be compatible."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'builder.AddSource<StringSource>("src");     // Outputs: string\r\nbuilder.AddTransform<IntTransform>("trans"); // Inputs: int\r\nbuilder.Connect("src", "trans"); // \u274c Type mismatch\r\n\r\n// Solution: Add type converter\r\nbuilder.AddTransform<StringToIntConverter>("converter");\r\nbuilder.Connect("src", "converter");\r\nbuilder.Connect("converter", "trans"); // \u2705 Works\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0202-input-data-pipe-wrong-type",children:"NP0202: Input Data Pipe Wrong Type"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0202] Input data pipe is not of the expected type..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," An internal framework error where the input pipe type doesn't match expected type. This usually indicates a graph construction error."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Review your pipeline definition and ensure all node types and connections are correct."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0203-cannot-register-mappings-after-execution",children:"NP0203: Cannot Register Mappings After Execution"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0203] Cannot register type mappings after execution has begun..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Attempted to configure type mappings after the pipeline has started executing."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Configure all mappings before the pipeline starts executing or when building."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Configure all type mappings BEFORE pipeline execution\r\nvar builder = new PipelineBuilder();\r\n// Add your nodes and configure mappings here\r\nvar pipeline = builder.Build();\r\n\r\n// Then execute the pipeline\r\nawait pipeline.ExecuteAsync(source, context);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0204-record-type-has-no-public-constructor",children:"NP0204: Record Type Has No Public Constructor"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0204] Record type '{recordTypeName}' has no public constructors..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," You're trying to construct a record type that doesn't have any public constructors."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Either add a public constructor to the record or use a different conversion method."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// \u274c Bad: private constructor\r\npublic record Order(int Id)\r\n{\r\n    private Order() { }\r\n}\r\n\r\n// \u2705 Good: public constructor\r\npublic record Order(int Id);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0205-2008-member-access-and-setter-errors",children:"NP0205-2008: Member Access and Setter Errors"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Messages:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"[NP0205]"})," Invalid member access expression"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"[NP0206]"})," Member not writable"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"[NP0207]"})," Setter creation failed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"[NP0208]"})," ValueTuple constructor not found"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Issues with property/field mapping in type conversions. The member either doesn't exist, isn't writable, or has other issues."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Review your selector expressions and ensure they target valid, writable properties."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0210-cannot-concatenate-streams-type-mismatch",children:"NP0210: Cannot Concatenate Streams Type Mismatch"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0210] Cannot concatenate streams due to type mismatch..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," You're trying to merge multiple input streams with incompatible types."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Ensure all inputs to a merge point have the same type."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"np03xx---execution-errors",children:"NP03xx - Execution Errors"}),"\n",(0,s.jsx)(n.h3,{id:"np0301-node-kind-not-supported",children:"NP0301: Node Kind Not Supported"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0301] Node kind '{nodeKind}' is not supported..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," An internal framework error where a node type is not properly registered."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," This is usually an NPipeline bug. Please report it on GitHub."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0302-output-not-found-for-source-node",children:"NP0302: Output Not Found for Source Node"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0302] Could not find output for source node '{sourceNodeId}'..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," A downstream node is trying to consume output from a source node that hasn't executed or didn't produce output."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Ensure source nodes execute successfully before consuming their output."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0303-3004-pipeline-execution-failed",children:"NP0303-3004: Pipeline Execution Failed"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Messages:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"[NP0303]"})," Pipeline execution failed at node"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"[NP0304]"})," Pipeline execution failed"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," An exception occurred during pipeline execution."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Check the inner exception details and review the node's implementation. The error message will include details about what went wrong."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0305-item-failed-after-max-retries",children:"NP0305: Item Failed After Max Retries"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0305] An item failed to process after {attempts} attempts..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," An item failed to process and exceeded the configured retry limit."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Solution:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Increase retry limit if transient errors are expected"}),"\n",(0,s.jsx)(n.li,{children:"Fix the underlying issue causing the error"}),"\n",(0,s.jsx)(n.li,{children:"Implement better error handling"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"builder.WithRetryOptions(options =>\r\n    options with { MaxItemRetries = 5 } // Increase from default (typically 0)\r\n);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0306-error-handling-failed",children:"NP0306: Error Handling Failed"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0306] Error handling failed for node '{nodeId}'..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Your custom error handler threw an exception."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Review your error handler implementation and ensure it doesn't throw exceptions."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0307-lineage-cardinality-mismatch",children:"NP0307: Lineage Cardinality Mismatch"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0307] Lineage cardinality mismatch in node..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," The number of lineage mappings doesn't match the node's declared input/output cardinality."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Ensure your lineage configuration matches your node's actual cardinality (OneToOne, OneToMany, etc.)."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0310-circuit-breaker-tripped",children:"NP0310: Circuit Breaker Tripped"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0310] Circuit breaker tripped for node '{nodeId}'..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," A node exceeded the failure threshold and the circuit breaker activated."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Solution:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Fix the underlying issue causing failures"}),"\n",(0,s.jsx)(n.li,{children:"Increase the failure threshold if needed"}),"\n",(0,s.jsx)(n.li,{children:"Wait for the circuit breaker to reset (default: 1 minute)"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np0311-retry-limit-exhausted",children:"NP0311: Retry Limit Exhausted"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP0311] Retry limit exhausted for node '{nodeId}'..."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," A node failed repeatedly and exceeded both item-level and node-restart retry limits."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Solution:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Review error logs to understand why retries are failing"}),"\n",(0,s.jsx)(n.li,{children:"Increase retry limits if failures are transient"}),"\n",(0,s.jsx)(n.li,{children:"Fix the underlying issue"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np9302-sinknode-input-not-consumed",children:"NP9302: SinkNode Input Not Consumed"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP9302] SinkNode '{0}' overrides ExecuteAsync but doesn't consume input parameter. Sink nodes should process all items from input data pipe."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Category:"})," Node Execution Error"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Severity:"})," Error"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Your SinkNode implementation overrides ExecuteAsync but doesn't consume the input parameter. Sink nodes are designed to process all items from their input data pipe, but your implementation ignores the input."]}),"\n",(0,s.jsx)(n.p,{children:"This can cause:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Data loss when items in the input pipe are not processed"}),"\n",(0,s.jsx)(n.li,{children:"Incomplete pipeline execution"}),"\n",(0,s.jsx)(n.li,{children:"Unexpected behavior when downstream nodes depend on sink's side effects"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example of Problem Code:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// \u274c PROBLEM: SinkNode ignores input\r\npublic class MySinkNode : SinkNode<string>\r\n{\r\n    public override Task ExecuteAsync(IDataPipe<string> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Input parameter is never used\r\n        Console.WriteLine("Sink executed but ignoring input");\r\n        return Task.CompletedTask;\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Solution:"})}),"\n",(0,s.jsx)(n.p,{children:"Always consume input in SinkNode implementations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// \u2705 SOLUTION: Process all items from input\r\npublic class MySinkNode : SinkNode<string>\r\n{\r\n    public override async Task ExecuteAsync(IDataPipe<string> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Process all items from input\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            Console.WriteLine($"Processing: {item}");\r\n            // Save to database, write to file, etc.\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common Input Consumption Patterns:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Pattern"}),(0,s.jsx)(n.th,{children:"Example"}),(0,s.jsx)(n.th,{children:"Use Case"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Process all items"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"await foreach (var item in input.WithCancellation(cancellationToken)) { ... }"})}),(0,s.jsx)(n.td,{children:"Standard processing of each item"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Count items"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"var count = await input.CountAsync(cancellationToken);"})}),(0,s.jsx)(n.td,{children:"When you only need the count"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Collect to list"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"var items = await input.ToListAsync(cancellationToken);"})}),(0,s.jsx)(n.td,{children:"When you need all items in memory"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"First item only"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"var first = await input.FirstAsync(cancellationToken);"})}),(0,s.jsx)(n.td,{children:"When you only need the first item"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Any items check"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"var hasItems = await input.AnyAsync(cancellationToken);"})}),(0,s.jsx)(n.td,{children:"When you just need to check if input is non-empty"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Best Practices for SinkNode Implementation:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Always consume input"})," - Use ",(0,s.jsx)(n.code,{children:"await foreach"})," or other data pipe operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pass cancellation token"})," - Use ",(0,s.jsx)(n.code,{children:"WithCancellation(cancellationToken)"})," for proper cancellation support"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle empty input"})," - Your code should work correctly even if the input pipe is empty"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consider performance"})," - For large datasets, process items in a streaming fashion rather than collecting all items"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Don't silently ignore input"})," - Even if you don't need to process items, consume them to acknowledge receipt"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"np9303-unsafe-pipelinecontext-access",children:"NP9303: Unsafe PipelineContext Access"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP9303] Unsafe access pattern '{0}' detected on PipelineContext. This can lead to NullReferenceException at runtime. Use null-conditional operators (?.) or check for null before accessing these properties."}),"**"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Category:"})," Node Execution Error"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Severity:"})," Warning"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Your code is accessing PipelineContext properties or dictionaries in a way that can lead to NullReferenceException at runtime. The analyzer detects these unsafe patterns:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Direct access to nullable properties"})," without null checks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dictionary access without type checking"})," (Items, Parameters, Properties dictionaries)"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Unsafe casting from dictionary values"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Method calls on nullable properties"})," without null verification"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These unsafe patterns can cause:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Runtime NullReferenceException when properties are null"}),"\n",(0,s.jsx)(n.li,{children:"Pipeline failures that are difficult to debug"}),"\n",(0,s.jsx)(n.li,{children:"Inconsistent behavior in production environments"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example of Problem Code:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// \u274c PROBLEM: Unsafe access patterns\r\npublic async Task ProcessContext(PipelineContext context)\r\n{\r\n    // NP9303: Direct access to nullable property\r\n    var handler = context.PipelineErrorHandler;\r\n    \r\n    // NP9303: Dictionary access without null check\r\n    var configValue = context.Parameters["retryCount"];\r\n    \r\n    // NP9303: Method call on nullable property\r\n    var stateManager = context.StateManager;\r\n    stateManager.SaveState("key", data);\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Solution - Use Safe Access Patterns:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// \u2705 SOLUTION: Safe access patterns\r\npublic async Task ProcessContext(PipelineContext context)\r\n{\r\n    // Use null-conditional operator\r\n    await context.PipelineErrorHandler?.HandleNodeFailureAsync("nodeId", new Exception(), context, CancellationToken.None);\r\n    \r\n    // Use TryGetValue pattern for dictionary access\r\n    if (context.Parameters?.TryGetValue("retryCount", out var configValue) == true)\r\n    {\r\n        var retryCount = Convert.ToInt32(configValue);\r\n    }\r\n    \r\n    // Check for null before using\r\n    if (context.StateManager != null)\r\n    {\r\n        context.StateManager.SaveState("key", data);\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common Safe Access Patterns:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Pattern"}),(0,s.jsx)(n.th,{children:"Example"}),(0,s.jsx)(n.th,{children:"When to Use"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Null-conditional operator"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"context.PipelineErrorHandler?.HandleError()"})}),(0,s.jsx)(n.td,{children:"When you can safely continue if property is null"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Explicit null check"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"if (context.PipelineErrorHandler != null)"})}),(0,s.jsx)(n.td,{children:"When you need to handle null case explicitly"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"TryGetValue pattern"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'context.Parameters?.TryGetValue("key", out var value)'})}),(0,s.jsx)(n.td,{children:"For dictionary access with null safety"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Pattern matching"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"if (context.PipelineErrorHandler is { } handler)"})}),(0,s.jsx)(n.td,{children:"For type-safe access with null checking"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"np04xx---configuration-errors",children:"NP04xx - Configuration Errors"}),"\n",(0,s.jsx)(n.h3,{id:"np9001-incomplete-resilient-configuration",children:"NP9001: Incomplete Resilient Configuration"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP9001] Error handler can return PipelineErrorDecision.RestartNode but may not have all three mandatory prerequisites configured. Missing prerequisites will silently disable restart, causing the entire pipeline to fail instead of recovering the failed node."})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Category:"})," Configuration Error"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Severity:"})," Warning"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Your error handler can return ",(0,s.jsx)(n.code,{children:"PipelineErrorDecision.RestartNode"}),", but the configuration is incomplete. Restart functionality requires ",(0,s.jsx)(n.strong,{children:"all three"})," of the following mandatory prerequisites:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ResilientExecutionStrategy"})," must wrap the node"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MaxNodeRestartAttempts"})," must be > 0 in PipelineRetryOptions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MaxMaterializedItems"})," must be non-null (not unbounded)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Missing even one of these prerequisites will ",(0,s.jsx)(n.strong,{children:"silently disable restart"}),", causing the entire pipeline to fail instead of recovering gracefully."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example of Problem Code:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// \u274c PROBLEM: RestartNode is possible, but prerequisites are missing\r\n\r\nvar myErrorHandler = new MyErrorHandler();\r\n\r\nvar pipeline = builder\r\n    .AddTransform<MyTransform>("myNode")\r\n    // Missing: .WithExecutionStrategy(builder, new ResilientExecutionStrategy(...))\r\n    .Build();\r\n\r\n// If MyErrorHandler.HandleNodeFailureAsync() can return RestartNode,\r\n// but the node doesn\'t have ResilientExecutionStrategy, restart will fail silently!\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Solution - Complete Configuration Checklist:"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["For detailed step-by-step configuration instructions, see the ",(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/getting-started",children:"Getting Started with Resilience"})," guide."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// \u2705 SOLUTION: All three prerequisites configured\r\n\r\n// STEP 1: Apply ResilientExecutionStrategy\r\nvar nodeHandle = builder\r\n    .AddTransform<MyTransform, Input, Output>("myNode")\r\n    .WithExecutionStrategy(\r\n        builder,\r\n        new ResilientExecutionStrategy(new SequentialExecutionStrategy())\r\n    );\r\n\r\n// STEP 2: Configure retry options with MaxNodeRestartAttempts > 0\r\nvar retryOptions = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,           // \u2190 STEP 2: Set to > 0\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: 1000            // \u2190 STEP 3: Set to non-null value\r\n);\r\n\r\n// STEP 3: Create context with retry options\r\nvar context = PipelineContext.WithRetry(retryOptions);\r\nvar pipeline = builder.Build();\r\n\r\nawait pipeline.ExecuteAsync(source, context);\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Critical Warning:"})," Never set ",(0,s.jsx)(n.code,{children:"MaxMaterializedItems"})," to ",(0,s.jsx)(n.code,{children:"null"})," (unbounded). This silently disables restart functionality and can cause OutOfMemoryException. See the ",(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/getting-started",children:"Getting Started with Resilience"})," guide for detailed explanation of why unbounded buffers break resilience guarantees."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Read More:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/getting-started",children:"Getting Started with Resilience"})})," - Complete quick-start and step-by-step configuration guide"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/tooling/analyzers/resilience",children:"Build-Time Resilience Analyzer Guide"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling Guide"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/materialization",children:"Materialization & Buffering"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"np90xx-np94xx---analyzer-diagnostics",children:"NP90xx-NP94xx - Analyzer Diagnostics"}),"\n",(0,s.jsx)(n.h3,{id:"np9205-non-streaming-patterns-in-sourcenode",children:"NP9205: Non-Streaming Patterns in SourceNode"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP9205] Non-streaming patterns detected in SourceNode implementation. Consider using IAsyncEnumerable with yield return for better performance and memory efficiency."})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Category:"})," Performance"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Severity:"})," Warning"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Your SourceNode implementation contains patterns that can lead to memory issues and poor performance when processing large datasets. The analyzer detects these problematic patterns:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"List<T>"})," or ",(0,s.jsx)(n.code,{children:"Array"})," allocation and population"]})," in ExecuteAsync methods"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:".ToAsyncEnumerable()"})," calls on materialized collections"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Synchronous I/O operations"})," like File.ReadAllText, File.WriteAllBytes, etc."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:".ToList() and .ToArray()"})," calls that materialize collections in memory"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These patterns can cause:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"High memory usage when processing large datasets"}),"\n",(0,s.jsx)(n.li,{children:"Poor startup performance as all data must be loaded before processing begins"}),"\n",(0,s.jsx)(n.li,{children:"Increased GC pressure from large collections"}),"\n",(0,s.jsx)(n.li,{children:"Thread blocking from synchronous I/O operations"}),"\n",(0,s.jsx)(n.li,{children:"Reduced scalability as memory requirements grow with data size"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example of Problem Code:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// \u274c PROBLEM: Materializing all data in memory\r\npublic class BadSourceNode : SourceNode<string>\r\n{\r\n    protected override async Task ExecuteAsync(IDataPipe<string> output, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // NP9205: Allocating List<T> and populating it\r\n        var items = new List<string>();\r\n        \r\n        // Read all lines from file into memory\r\n        var lines = File.ReadAllLines("large-file.txt"); // NP9205: Synchronous I/O\r\n        \r\n        foreach (var line in lines)\r\n        {\r\n            items.Add(line);\r\n        }\r\n        \r\n        // NP9205: Materializing collection with ToList()\r\n        foreach (var item in items.ToList())\r\n        {\r\n            await output.ProduceAsync(item, cancellationToken);\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Solution - Use Streaming Patterns:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// \u2705 CORRECT: Using IAsyncEnumerable with yield return\r\npublic class GoodSourceNode : SourceNode<string>\r\n{\r\n    protected override async Task ExecuteAsync(IDataPipe<string> output, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Stream data line by line without materializing in memory\r\n        await foreach (var line in ReadLinesAsync("large-file.txt", cancellationToken))\r\n        {\r\n            await output.ProduceAsync(line, cancellationToken);\r\n        }\r\n    }\r\n    \r\n    // Helper method that yields lines one at a time\r\n    private async IAsyncEnumerable<string> ReadLinesAsync(string filePath, [EnumeratorCancellation] CancellationToken cancellationToken)\r\n    {\r\n        using var reader = new StreamReader(\r\n            new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 4096, useAsync: true));\r\n        \r\n        string? line;\r\n        while ((line = await reader.ReadLineAsync(cancellationToken)) != null)\r\n        {\r\n            yield return line; // Stream one line at a time\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common Streaming Patterns:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Pattern"}),(0,s.jsx)(n.th,{children:"Example"}),(0,s.jsx)(n.th,{children:"Use Case"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Process all items"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"await foreach (var item in GetItemsAsync(cancellationToken)) { ... }"})}),(0,s.jsx)(n.td,{children:"Standard processing of each item"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Generate data"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"for (int i = 0; i < count; i++) { yield return GenerateItem(i); }"})}),(0,s.jsx)(n.td,{children:"Data generation without materialization"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Stream from database"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"while (await reader.ReadAsync(cancellationToken)) { ... }"})}),(0,s.jsx)(n.td,{children:"Database cursor processing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Transform while streaming"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"await foreach (var item in GetSourceAsync()) { yield return Transform(item); }"})}),(0,s.jsx)(n.td,{children:"Transformation without buffering"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits of Streaming Patterns:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Efficiency"}),": Constant memory usage regardless of data size"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Better Performance"}),": Processing begins immediately without waiting for all data to load"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scalability"}),": Can handle arbitrarily large datasets without running out of memory"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Responsiveness"}),": Async I/O doesn't block threads, improving overall throughput"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Utilization"}),": Lower GC pressure and better cache locality"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Read More:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/tooling/analyzers/resilience",children:"Build-Time Resilience Analyzer Guide"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/nodes/source-nodes",children:"Source Node Best Practices"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Optimization Guide"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"np9401-missing-dependency-injection",children:"NP9401: Missing Dependency Injection"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message:"})," ",(0,s.jsx)(n.code,{children:"[NP9401] Avoid dependency injection anti-patterns in node implementations. Use constructor injection instead."})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Category:"})," Best Practice"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Severity:"})," Warning"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Your node implementation contains dependency injection anti-patterns that can lead to tightly coupled code that is difficult to test and maintain. The analyzer detects these problematic patterns:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Direct service instantiation"})," using ",(0,s.jsx)(n.code,{children:"new"})," keyword"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Static singleton field assignments"})," that create tightly coupled dependencies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service locator pattern usage"})," through GetService or GetRequiredService calls"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These anti-patterns violate the Dependency Inversion Principle and make code difficult to test, maintain, and configure."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example of Problem Code:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// \u274c PROBLEM: Dependency injection anti-patterns\r\n\r\npublic class BadTransformNode : TransformNode<string, string>\r\n{\r\n    private readonly BadService _badService = new BadService(); // NP9401: Direct instantiation\r\n\r\n    public override Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        return Task.FromResult(_badService.Process(item));\r\n    }\r\n}\r\n\r\npublic class BadSourceNode : SourceNode<int>\r\n{\r\n    private static BadService _service; // Static field\r\n\r\n    public BadSourceNode()\r\n    {\r\n        _service = new BadService(); // NP9401: Static singleton assignment\r\n    }\r\n}\r\n\r\npublic class BadSinkNode : SinkNode<string>\r\n{\r\n    private readonly IServiceProvider _serviceProvider;\r\n\r\n    public BadSinkNode(IServiceProvider serviceProvider)\r\n    {\r\n        _serviceProvider = serviceProvider;\r\n    }\r\n\r\n    public override Task ExecuteAsync(IDataPipe<string> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        var badService = _serviceProvider.GetService(typeof(BadService)) as BadService; // NP9401: Service locator\r\n        return Task.CompletedTask;\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Solution - Use Constructor Injection:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// \u2705 SOLUTION: Constructor injection\r\n\r\npublic class GoodTransformNode : TransformNode<string, string>\r\n{\r\n    private readonly BadService _badService;\r\n\r\n    public GoodTransformNode(BadService badService) // Constructor injection\r\n    {\r\n        _badService = badService;\r\n    }\r\n\r\n    public override Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        return Task.FromResult(_badService.Process(item));\r\n    }\r\n}\r\n\r\n// \u2705 SOLUTION: Multiple dependencies via constructor\r\n\r\npublic class GoodSinkNode : SinkNode<string>\r\n{\r\n    private readonly IEmailService _emailService;\r\n    private readonly ILoggingService _loggingService;\r\n    private readonly IDataRepository _repository;\r\n\r\n    public GoodSinkNode(\r\n        IEmailService emailService,\r\n        ILoggingService loggingService,\r\n        IDataRepository repository) // Multiple dependencies\r\n    {\r\n        _emailService = emailService;\r\n        _loggingService = loggingService;\r\n        _repository = repository;\r\n    }\r\n\r\n    public override async Task ExecuteAsync(IDataPipe<string> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            var processed = await _repository.SaveAsync(item);\r\n            await _emailService.SendNotificationAsync(processed);\r\n            _loggingService.Log(processed);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits of Constructor Injection:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testability"}),": Easy to mock dependencies for unit testing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flexibility"}),": Can swap implementations easily"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dependency Inversion"}),": Depends on abstractions rather than concretions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Explicit Dependencies"}),": All dependencies are visible in the constructor"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Better Configuration"}),": Works well with DI containers"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Read More:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/tooling/analyzers/resilience",children:"Build-Time Resilience Analyzer Guide"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/architecture/dependency-injection",children:"Dependency Injection Best Practices"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/extensions/testing",children:"Testing Pipeline Components"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var i=r(6540);const s={},t=i.createContext(s);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);