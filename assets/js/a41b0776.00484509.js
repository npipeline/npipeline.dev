"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[753],{4112:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>s,default:()=>g,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"core-concepts/pipeline-execution/dead-letter-queues","title":"Dead-Letter Queues","description":"Learn how to implement dead-letter queues in NPipeline using IDeadLetterSink to capture and analyze problematic items.","source":"@site/docs/core-concepts/pipeline-execution/dead-letter-queues.md","sourceDirName":"core-concepts/pipeline-execution","slug":"/core-concepts/pipeline-execution/dead-letter-queues","permalink":"/npipeline.dev/docs/core-concepts/pipeline-execution/dead-letter-queues","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"title":"Dead-Letter Queues","description":"Learn how to implement dead-letter queues in NPipeline using IDeadLetterSink to capture and analyze problematic items.","sidebar_position":9},"sidebar":"docsSidebar","previous":{"title":"Circuit Breaker Configuration","permalink":"/npipeline.dev/docs/core-concepts/pipeline-execution/circuit-breaker-configuration"},"next":{"title":"Pipeline Context (PipelineContext)","permalink":"/npipeline.dev/docs/core-concepts/pipeline-context"}}');var i=n(4848),a=n(8453);const o={title:"Dead-Letter Queues",description:"Learn how to implement dead-letter queues in NPipeline using IDeadLetterSink to capture and analyze problematic items.",sidebar_position:9},s="Dead-Letter Queues",d={},l=[{value:"Overview",id:"overview",level:2},{value:"IDeadLetterSink Interface",id:"ideadlettersink-interface",level:2},{value:"Implementing a Custom Dead Letter Sink",id:"implementing-a-custom-dead-letter-sink",level:2},{value:"File-based Dead Letter Sink",id:"file-based-dead-letter-sink",level:3},{value:"Database-based Dead Letter Sink",id:"database-based-dead-letter-sink",level:3},{value:"Message Queue-based Dead Letter Sink",id:"message-queue-based-dead-letter-sink",level:3},{value:"Registering a Dead Letter Sink",id:"registering-a-dead-letter-sink",level:2},{value:"Complete Pipeline Configuration Example",id:"complete-pipeline-configuration-example",level:2},{value:"Using Dead Letter Queues with Error Handlers",id:"using-dead-letter-queues-with-error-handlers",level:2},{value:"Basic Usage with Node Error Handler",id:"basic-usage-with-node-error-handler",level:3},{value:"Advanced Dead Letter Processing with Metadata",id:"advanced-dead-letter-processing-with-metadata",level:3},{value:"Reprocessing Dead Letter Items",id:"reprocessing-dead-letter-items",level:2},{value:"Simple Reprocessing Service",id:"simple-reprocessing-service",level:3},{value:"\u2705 Best Practices",id:"white_check_mark-best-practices",level:2},{value:"Production Example",id:"production-example",level:2},{value:"\u2139\ufe0f Configuration Guidance",id:"information_source-configuration-guidance",level:2},{value:"\u2139\ufe0f See Also",id:"information_source-see-also",level:2},{value:"\ud83d\udd17 Related Topics",id:"link-related-topics",level:2}];function c(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"dead-letter-queues",children:"Dead-Letter Queues"})}),"\n",(0,i.jsx)(r.p,{children:"Dead-letter queues in NPipeline provide a mechanism to capture and store items that repeatedly fail processing, allowing you to analyze and potentially reprocess problematic data outside the main pipeline flow."}),"\n",(0,i.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(r.p,{children:["When an ",(0,i.jsx)(r.code,{children:"INodeErrorHandler"})," returns ",(0,i.jsx)(r.code,{children:"NodeErrorDecision.DeadLetter"}),", the failed item is sent to an ",(0,i.jsx)(r.code,{children:"IDeadLetterSink"}),". This pattern allows your pipeline to continue processing other items while isolating problematic ones for later analysis and potential reprocessing."]}),"\n",(0,i.jsx)(r.h2,{id:"ideadlettersink-interface",children:"IDeadLetterSink Interface"}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"IDeadLetterSink"})," interface defines the contract for dead-letter queue implementations:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'public interface IDeadLetterSink\r\n{\r\n    /// <summary>\r\n    ///     Handles a failed item by persisting it for later analysis.\r\n    /// </summary>\r\n    /// <param name="nodeId">The ID of node where error occurred.</param>\r\n    /// <param name="item">The item that failed processing.</param>\r\n    /// <param name="error">The exception that was thrown.</param>\r\n    /// <param name="context">The current pipeline context.</param>\r\n    /// <param name="cancellationToken">A token to observe for cancellation requests.</param>\r\n    Task HandleAsync(string nodeId, object item, Exception error, PipelineContext context, CancellationToken cancellationToken);\r\n}\n'})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.code,{children:"nodeId"})}),": The ID of the node where the error occurred."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.code,{children:"item"})}),": The item that failed processing (non-generic object type)."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.code,{children:"error"})}),": The exception that was thrown."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.code,{children:"context"})}),": The current pipeline context."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.code,{children:"cancellationToken"})}),": A token to observe for cancellation requests."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.code,{children:"HandleAsync"})}),": Called when an item needs to be sent to dead-letter queue. Receives the node ID, failed item, exception, pipeline context, and a cancellation token."]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"implementing-a-custom-dead-letter-sink",children:"Implementing a Custom Dead Letter Sink"}),"\n",(0,i.jsx)(r.h3,{id:"file-based-dead-letter-sink",children:"File-based Dead Letter Sink"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'public class FileDeadLetterSink : IDeadLetterSink\r\n{\r\n    private readonly string _filePath;\r\n    private readonly ILogger _logger;\r\n\r\n    public FileDeadLetterSink(string filePath, ILogger logger)\r\n    {\r\n        _filePath = filePath;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task HandleAsync(string nodeId, object item, Exception error, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        var deadLetterEntry = new\r\n        {\r\n            Timestamp = DateTime.UtcNow,\r\n            NodeId = nodeId,\r\n            ItemType = item?.GetType().Name ?? "Unknown",\r\n            Item = item,\r\n            Error = error.Message,\r\n            StackTrace = error.StackTrace,\r\n            ErrorType = error.GetType().Name\r\n        };\r\n\r\n        var json = JsonSerializer.Serialize(deadLetterEntry, new JsonSerializerOptions { WriteIndented = true });\r\n\r\n        await File.AppendAllTextAsync(_filePath, json + Environment.NewLine, cancellationToken);\r\n        _logger.LogWarning("Item from node {NodeId} sent to dead-letter queue: {ItemType}", nodeId, item?.GetType().Name);\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.h3,{id:"database-based-dead-letter-sink",children:"Database-based Dead Letter Sink"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'public class DatabaseDeadLetterSink : IDeadLetterSink\r\n{\r\n    private readonly IDbConnection _connection;\r\n    private readonly ILogger _logger;\r\n    private readonly string _tableName;\r\n\r\n    public DatabaseDeadLetterSink(IDbConnection connection, string tableName, ILogger logger)\r\n    {\r\n        _connection = connection;\r\n        _tableName = tableName;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task HandleAsync(string nodeId, object item, Exception error, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        try\r\n        {\r\n            var command = _connection.CreateCommand();\r\n            command.CommandText = $@"\r\n                INSERT INTO {_tableName} (Timestamp, NodeId, ItemData, ErrorType, ErrorMessage, StackTrace, ItemType)\r\n                VALUES (@Timestamp, @NodeId, @ItemData, @ErrorType, @ErrorMessage, @StackTrace, @ItemType)";\r\n\r\n            command.Parameters.Add(new Parameter("@Timestamp", DateTime.UtcNow));\r\n            command.Parameters.Add(new Parameter("@NodeId", nodeId));\r\n            command.Parameters.Add(new Parameter("@ItemData", JsonSerializer.Serialize(item)));\r\n            command.Parameters.Add(new Parameter("@ErrorType", error.GetType().Name));\r\n            command.Parameters.Add(new Parameter("@ErrorMessage", error.Message));\r\n            command.Parameters.Add(new Parameter("@StackTrace", error.StackTrace));\r\n            command.Parameters.Add(new Parameter("@ItemType", item?.GetType().Name ?? "Unknown"));\r\n\r\n            await command.ExecuteNonQueryAsync(cancellationToken);\r\n            _logger.LogWarning("Item from node {NodeId} sent to dead-letter table: {ItemType}", nodeId, item?.GetType().Name);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Failed to send item to dead-letter queue");\r\n            throw;\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.h3,{id:"message-queue-based-dead-letter-sink",children:"Message Queue-based Dead Letter Sink"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'public class MessageQueueDeadLetterSink : IDeadLetterSink\r\n{\r\n    private readonly IMessageQueue _messageQueue;\r\n    private readonly string _queueName;\r\n    private readonly ILogger _logger;\r\n\r\n    public MessageQueueDeadLetterSink(IMessageQueue messageQueue, string queueName, ILogger logger)\r\n    {\r\n        _messageQueue = messageQueue;\r\n        _queueName = queueName;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task HandleAsync(string nodeId, object item, Exception error, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        var deadLetterMessage = new DeadLetterMessage\r\n        {\r\n            Id = Guid.NewGuid().ToString(),\r\n            Timestamp = DateTime.UtcNow,\r\n            NodeId = nodeId,\r\n            Item = item,\r\n            ErrorType = error.GetType().Name,\r\n            ErrorMessage = error.Message,\r\n            StackTrace = error.StackTrace,\r\n            ItemType = item?.GetType().Name ?? "Unknown",\r\n            RetryCount = 0 // Can be incremented if item is reprocessed\r\n        };\r\n\r\n        await _messageQueue.SendMessageAsync(_queueName, deadLetterMessage, cancellationToken);\r\n        _logger.LogWarning("Item {ItemId} from node {NodeId} sent to dead-letter queue", deadLetterMessage.Id, nodeId);\r\n    }\r\n\r\n    private class DeadLetterMessage\r\n    {\r\n        public string Id { get; set; }\r\n        public DateTime Timestamp { get; set; }\r\n        public string NodeId { get; set; }\r\n        public object Item { get; set; }\r\n        public string ErrorType { get; set; }\r\n        public string ErrorMessage { get; set; }\r\n        public string StackTrace { get; set; }\r\n        public string ItemType { get; set; }\r\n        public int RetryCount { get; set; }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"registering-a-dead-letter-sink",children:"Registering a Dead Letter Sink"}),"\n",(0,i.jsx)(r.p,{children:"You register a dead letter sink with your DI container:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'// File-based dead letter sink\r\nservices.AddSingleton<IDeadLetterSink>(provider =>\r\n    new FileDeadLetterSink("dead-letters.json", provider.GetRequiredService<ILogger<FileDeadLetterSink>>()));\r\n\r\n// Database-based dead letter sink\r\nservices.AddSingleton<IDeadLetterSink>(provider =>\r\n{\r\n    var connection = provider.GetRequiredService<IDbConnection>();\r\n    var logger = provider.GetRequiredService<ILogger<DatabaseDeadLetterSink>>();\r\n    return new DatabaseDeadLetterSink(connection, "DeadLetterItems", logger);\r\n});\r\n\r\n// Message queue-based dead letter sink\r\nservices.AddSingleton<IDeadLetterSink>(provider =>\r\n{\r\n    var messageQueue = provider.GetRequiredService<IMessageQueue>();\r\n    var logger = provider.GetRequiredService<ILogger<MessageQueueDeadLetterSink>>();\r\n    return new MessageQueueDeadLetterSink(messageQueue, "dead-letter-queue", logger);\r\n});\n'})}),"\n",(0,i.jsx)(r.h2,{id:"complete-pipeline-configuration-example",children:"Complete Pipeline Configuration Example"}),"\n",(0,i.jsx)(r.p,{children:"Here's a practical example showing how to configure a full pipeline with dead-letter queue support:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'using Microsoft.Extensions.DependencyInjection;\r\nusing Microsoft.Extensions.Logging;\r\nusing NPipeline;\r\nusing NPipeline.ErrorHandling;\r\n\r\npublic class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var services = new ServiceCollection();\r\n\r\n        // Configure logging\r\n        services.AddLogging(builder =>\r\n            builder.AddConsole()\r\n                .SetMinimumLevel(LogLevel.Information));\r\n\r\n        // Step 1: Register the dead-letter sink\r\n        services.AddSingleton<IDeadLetterSink>(provider =>\r\n            new FileDeadLetterSink(\r\n                "dead-letters.json",\r\n                provider.GetRequiredService<ILogger<FileDeadLetterSink>>()));\r\n\r\n        // Step 2: Register error handler that uses the dead-letter sink\r\n        services.AddSingleton<INodeErrorHandler<ITransformNode<string, string>, string>>(provider =>\r\n            new DeadLetterAwareErrorHandler(\r\n                provider.GetRequiredService<ILogger<DeadLetterAwareErrorHandler>>(),\r\n                provider.GetRequiredService<IDeadLetterSink>()));\r\n\r\n        var serviceProvider = services.BuildServiceProvider();\r\n\r\n        // Step 3: Build and execute the pipeline\r\n        var pipeline = new PipelineBuilder<string>()\r\n            .AddTransform("ValidationNode", async (item, context, ct) =>\r\n            {\r\n                // Simulate validation that might fail\r\n                if (item.Contains("INVALID"))\r\n                    throw new ValidationException("Item contains invalid content");\r\n                return item.ToUpper();\r\n            })\r\n            .AddTransform("ProcessingNode", async (item, context, ct) =>\r\n            {\r\n                // Simulate processing\r\n                return $"Processed: {item}";\r\n            })\r\n            .Build();\r\n\r\n        // Get the error handler from DI\r\n        var errorHandler = serviceProvider.GetRequiredService<INodeErrorHandler<ITransformNode<string, string>, string>>();\r\n\r\n        var context = PipelineContext.Default;\r\n        var items = new[] { "valid1", "INVALID_ITEM", "valid2", "INVALID_ITEM2" };\r\n\r\n        foreach (var item in items)\r\n        {\r\n            try\r\n            {\r\n                await pipeline.ExecuteAsync(item, context, CancellationToken.None);\r\n                Console.WriteLine($"\u2713 Successfully processed: {item}");\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine($"\u2717 Failed to process: {item}");\r\n                Console.WriteLine($"  Error: {ex.Message}");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npublic class DeadLetterAwareErrorHandler : INodeErrorHandler<ITransformNode<string, string>, string>\r\n{\r\n    private readonly ILogger _logger;\r\n    private readonly IDeadLetterSink _deadLetterSink;\r\n\r\n    public DeadLetterAwareErrorHandler(\r\n        ILogger logger,\r\n        IDeadLetterSink deadLetterSink)\r\n    {\r\n        _logger = logger;\r\n        _deadLetterSink = deadLetterSink;\r\n    }\r\n\r\n    public async Task<NodeErrorDecision> HandleAsync(\r\n        ITransformNode<string, string> node,\r\n        string failedItem,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        _logger.LogError(error, "Error processing item in node {NodeName}", node.Name);\r\n\r\n        // Send validation errors to dead-letter queue\r\n        if (error is ValidationException)\r\n        {\r\n            _logger.LogInformation("Validation error, redirecting to dead-letter queue");\r\n            await _deadLetterSink.HandleAsync(node.Id, failedItem, error, context, cancellationToken);\r\n            return NodeErrorDecision.DeadLetter;\r\n        }\r\n\r\n        // Log and skip other errors\r\n        _logger.LogWarning("Unexpected error, skipping item");\r\n        return NodeErrorDecision.Skip;\r\n    }\r\n}\r\n\r\npublic class FileDeadLetterSink : IDeadLetterSink\r\n{\r\n    private readonly string _filePath;\r\n    private readonly ILogger _logger;\r\n\r\n    public FileDeadLetterSink(string filePath, ILogger logger)\r\n    {\r\n        _filePath = filePath;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task HandleAsync(string nodeId, object item, Exception error, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        var deadLetterEntry = new\r\n        {\r\n            Timestamp = DateTime.UtcNow,\r\n            NodeId = nodeId,\r\n            ItemType = item?.GetType().Name ?? "Unknown",\r\n            Item = item,\r\n            Error = error.Message,\r\n            StackTrace = error.StackTrace,\r\n            ErrorType = error.GetType().Name\r\n        };\r\n\r\n        var json = JsonSerializer.Serialize(deadLetterEntry, new JsonSerializerOptions { WriteIndented = true });\r\n\r\n        await File.AppendAllTextAsync(_filePath, json + Environment.NewLine, cancellationToken);\r\n        _logger.LogWarning("Item from node {NodeId} sent to dead-letter queue: {Item}", nodeId, item);\r\n    }\r\n}\r\n\r\npublic class ValidationException : Exception\r\n{\r\n    public ValidationException(string message) : base(message) { }\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Key configuration steps:"})}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Register the sink"}),": Register your chosen ",(0,i.jsx)(r.code,{children:"IDeadLetterSink"})," implementation in the DI container."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Register the error handler"}),": Register an ",(0,i.jsx)(r.code,{children:"INodeErrorHandler"})," that uses the dead-letter sink to send failed items to the queue."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Build the pipeline"}),": Create your pipeline with the appropriate nodes."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Execute and handle errors"}),": When items fail, the error handler determines whether to redirect them to the dead-letter queue or skip them."]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"using-dead-letter-queues-with-error-handlers",children:"Using Dead Letter Queues with Error Handlers"}),"\n",(0,i.jsx)(r.h3,{id:"basic-usage-with-node-error-handler",children:"Basic Usage with Node Error Handler"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'public class DeadLetterAwareErrorHandler : INodeErrorHandler<ITransformNode<string, string>, string>\r\n{\r\n    private readonly ILogger _logger;\r\n    private readonly IDeadLetterSink _deadLetterSink;\r\n\r\n    public DeadLetterAwareErrorHandler(\r\n        ILogger logger,\r\n        IDeadLetterSink deadLetterSink)\r\n    {\r\n        _logger = logger;\r\n        _deadLetterSink = deadLetterSink;\r\n    }\r\n\r\n    public async Task<NodeErrorDecision> HandleAsync(\r\n        ITransformNode<string, string> node,\r\n        string failedItem,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        _logger.LogError(error, "Error processing item in node {NodeName}", node.Name);\r\n\r\n        if (error is ValidationException)\r\n        {\r\n            _logger.LogInformation("Validation error, redirecting to dead-letter queue");\r\n            await _deadLetterSink.HandleAsync(node.Id, failedItem, error, context, cancellationToken);\r\n            return NodeErrorDecision.DeadLetter;\r\n        }\r\n        else if (error is FormatException)\r\n        {\r\n            _logger.LogInformation("Format error, redirecting to dead-letter queue");\r\n            await _deadLetterSink.HandleAsync(node.Id, failedItem, error, context, cancellationToken);\r\n            return NodeErrorDecision.DeadLetter;\r\n        }\r\n        else\r\n        {\r\n            _logger.LogWarning("Unexpected error, skipping item");\r\n            return NodeErrorDecision.Skip;\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.h3,{id:"advanced-dead-letter-processing-with-metadata",children:"Advanced Dead Letter Processing with Metadata"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'public class EnhancedDeadLetterSink : IDeadLetterSink<object>\r\n{\r\n    private readonly string _filePath;\r\n    private readonly ILogger _logger;\r\n    private readonly IMetrics _metrics;\r\n\r\n    public EnhancedDeadLetterSink(string filePath, ILogger logger, IMetrics metrics)\r\n    {\r\n        _filePath = filePath;\r\n        _logger = logger;\r\n        _metrics = metrics;\r\n    }\r\n\r\n    public async Task SendAsync(object item, Exception error, CancellationToken cancellationToken)\r\n    {\r\n        var deadLetterEntry = new DeadLetterEntry\r\n        {\r\n            Id = Guid.NewGuid().ToString(),\r\n            Timestamp = DateTime.UtcNow,\r\n            Item = item,\r\n            ItemType = item.GetType().Name,\r\n            Error = new ErrorInfo\r\n            {\r\n                Type = error.GetType().Name,\r\n                Message = error.Message,\r\n                StackTrace = error.StackTrace,\r\n                Source = error.Source,\r\n                HResult = error.HResult\r\n            },\r\n            Metadata = new Dictionary<string, object>\r\n            {\r\n                ["Environment"] = Environment.GetEnvironmentVariable("ENVIRONMENT") ?? "Unknown",\r\n                ["MachineName"] = Environment.MachineName,\r\n                ["ProcessId"] = Environment.ProcessId\r\n            }\r\n        };\r\n\r\n        var json = JsonSerializer.Serialize(deadLetterEntry, new JsonSerializerOptions { WriteIndented = true });\r\n\r\n        await File.AppendAllTextAsync(_filePath, json + Environment.NewLine, cancellationToken);\r\n\r\n        _logger.LogWarning("Item {ItemId} sent to dead-letter queue: {ErrorType}",\r\n            deadLetterEntry.Id, error.GetType().Name);\r\n\r\n        _metrics.Increment("dead_letter_items", new[]\r\n        {\r\n            new KeyValuePair<string, object>("error_type", error.GetType().Name),\r\n            new KeyValuePair<string, object>("item_type", item.GetType().Name)\r\n        });\r\n    }\r\n\r\n    private class DeadLetterEntry\r\n    {\r\n        public string Id { get; set; }\r\n        public DateTime Timestamp { get; set; }\r\n        public object Item { get; set; }\r\n        public string ItemType { get; set; }\r\n        public ErrorInfo Error { get; set; }\r\n        public Dictionary<string, object> Metadata { get; set; }\r\n    }\r\n\r\n    private class ErrorInfo\r\n    {\r\n        public string Type { get; set; }\r\n        public string Message { get; set; }\r\n        public string StackTrace { get; set; }\r\n        public string Source { get; set; }\r\n        public int HResult { get; set; }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"reprocessing-dead-letter-items",children:"Reprocessing Dead Letter Items"}),"\n",(0,i.jsx)(r.h3,{id:"simple-reprocessing-service",children:"Simple Reprocessing Service"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'public class DeadLetterReprocessor\r\n{\r\n    private readonly IDeadLetterSink<object> _deadLetterSink;\r\n    private readonly ILogger<DeadLetterReprocessor> _logger;\r\n    private readonly ITransformNode<string, string> _targetNode;\r\n\r\n    public DeadLetterReprocessor(\r\n        IDeadLetterSink<object> deadLetterSink,\r\n        ILogger<DeadLetterReprocessor> logger,\r\n        ITransformNode<string, string> targetNode)\r\n    {\r\n        _deadLetterSink = deadLetterSink;\r\n        _logger = logger;\r\n        _targetNode = targetNode;\r\n    }\r\n\r\n    public async Task ReprocessItemsAsync(string filePath, CancellationToken cancellationToken = default)\r\n    {\r\n        var lines = await File.ReadAllLinesAsync(filePath, cancellationToken);\r\n        var reprocessedCount = 0;\r\n        var failedCount = 0;\r\n\r\n        foreach (var line in lines)\r\n        {\r\n            try\r\n            {\r\n                var deadLetterEntry = JsonSerializer.Deserialize<DeadLetterEntry>(line);\r\n\r\n                if (deadLetterEntry?.Item is string item)\r\n                {\r\n                    _logger.LogInformation("Reprocessing item: {ItemId}", deadLetterEntry.Id);\r\n\r\n                    // Attempt to reprocess the item\r\n                    var result = await _targetNode.ExecuteAsync(\r\n                        item,\r\n                        PipelineContext.Default,\r\n                        cancellationToken);\r\n\r\n                    reprocessedCount++;\r\n                    _logger.LogInformation("Successfully reprocessed item: {ItemId}", deadLetterEntry.Id);\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                failedCount++;\r\n                _logger.LogError(ex, "Failed to reprocess dead letter item");\r\n            }\r\n        }\r\n\r\n        _logger.LogInformation("Reprocessing complete. Success: {SuccessCount}, Failed: {FailedCount}",\r\n            reprocessedCount, failedCount);\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(r.h2,{id:"white_check_mark-best-practices",children:["\u2705"," Best Practices"]}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Include sufficient context"}),": Store not just the failed item but also error details, timestamps, and any relevant metadata."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Monitor dead-letter queues"}),": Set up monitoring and alerting for items being added to dead-letter queues."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Implement reprocessing workflows"}),": Create processes to analyze and potentially reprocess dead-letter items."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Consider retention policies"}),": Implement policies for how long dead-letter items should be retained."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Use appropriate storage"}),": Choose storage that matches your performance and durability requirements."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Implement proper error handling"}),": Ensure your dead-letter sink itself has robust error handling."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Track metrics"}),": Monitor the volume and types of items being sent to dead-letter queues to identify systemic issues."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"production-example",children:"Production Example"}),"\n",(0,i.jsx)(r.p,{children:"Here's a comprehensive example that combines multiple dead-letter queue concepts:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.ErrorHandling;\r\n\r\npublic class ProductionDeadLetterErrorHandler : INodeErrorHandler<ITransformNode<string, string>, string>\r\n{\r\n    private readonly ILogger _logger;\r\n    private readonly IMetrics _metrics;\r\n    private readonly IDeadLetterSink<string> _deadLetterSink;\r\n    private readonly ConcurrentDictionary<string, int> _itemRetryCounts = new();\r\n    private readonly int _maxRetriesBeforeDeadLetter = 3;\r\n\r\n    public ProductionDeadLetterErrorHandler(\r\n        ILogger logger,\r\n        IMetrics metrics,\r\n        IDeadLetterSink<string> deadLetterSink)\r\n    {\r\n        _logger = logger;\r\n        _metrics = metrics;\r\n        _deadLetterSink = deadLetterSink;\r\n    }\r\n\r\n    public async Task<NodeErrorDecision> HandleAsync(\r\n        ITransformNode<string, string> node,\r\n        string failedItem,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        var itemKey = $"{node.Id}:{failedItem.GetHashCode()}";\r\n        var retryCount = _itemRetryCounts.AddOrUpdate(itemKey, 1, (_, count) => count + 1);\r\n\r\n        // Record metrics\r\n        _metrics.Increment("node_error_handling_attempts", new[]\r\n        {\r\n            new KeyValuePair<string, object>("node_id", node.Id),\r\n            new KeyValuePair<string, object>("error_type", error.GetType().Name),\r\n            new KeyValuePair<string, object>("retry_count", retryCount)\r\n        });\r\n\r\n        _logger.LogError(error, "Error processing item in node {NodeName} (attempt {RetryCount})",\r\n            node.Name, retryCount);\r\n\r\n        if (IsTransientError(error) && retryCount <= _maxRetriesBeforeDeadLetter)\r\n        {\r\n            _logger.LogInformation("Retrying item (attempt {RetryCount}/{MaxRetries})", retryCount, _maxRetriesBeforeDeadLetter);\r\n            return NodeErrorDecision.Retry;\r\n        }\r\n\r\n        // Send to dead-letter queue\r\n        try\r\n        {\r\n            await _deadLetterSink.SendAsync(failedItem, error, cancellationToken);\r\n\r\n            _metrics.Increment("dead_letter_items_sent", new[]\r\n            {\r\n                new KeyValuePair<string, object>("node_id", node.Id),\r\n                new KeyValuePair<string, object>("error_type", error.GetType().Name),\r\n                new KeyValuePair<string, object>("retry_count", retryCount)\r\n            });\r\n\r\n            _logger.LogWarning("Item sent to dead-letter queue after {RetryCount} attempts", retryCount);\r\n            _itemRetryCounts.TryRemove(itemKey, out _);\r\n            return NodeErrorDecision.DeadLetter;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Failed to send item to dead-letter queue");\r\n            return NodeErrorDecision.Skip;\r\n        }\r\n    }\r\n\r\n    private static bool IsTransientError(Exception error)\r\n    {\r\n        return error is TimeoutException or HttpRequestException or OperationCanceledException;\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(r.h2,{id:"information_source-configuration-guidance",children:["\u2139\ufe0f"," Configuration Guidance"]}),"\n",(0,i.jsxs)(r.p,{children:["For comprehensive setup guidance that integrates dead-letter queues with other resilience features, see the ",(0,i.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/resilience/configuration-guide",children:"Configuration Guide"})," in the resilience section."]}),"\n",(0,i.jsxs)(r.h2,{id:"information_source-see-also",children:["\u2139\ufe0f"," See Also"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/resilience/",children:"Resilience Overview"})}),": Comprehensive guide to building fault-tolerant pipelines"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/resilience/configuration-guide",children:"Configuration Guide"})}),": Practical implementation guidance with code examples"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/resilience/dependency-chains",children:"Dependency Chains"})}),": Understanding critical prerequisite relationships for resilience features"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting"})}),": Diagnose and resolve common resilience issues"]}),"\n"]}),"\n",(0,i.jsxs)(r.h2,{id:"link-related-topics",children:["\ud83d\udd17"," Related Topics"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/node-error-handling",children:"Node-level Error Handling"})}),": Learn about handling errors for individual items."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/pipeline-error-handling",children:"Pipeline-level Error Handling"})}),": Learn about handling errors that affect entire node streams."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/retry-configuration",children:"Retry Configuration"})}),": Configure retry behavior for items and node restarts."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/error-handling",children:"Error Handling Overview"})}),": Return to the error handling overview."]}),"\n"]})]})}function g(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>s});var t=n(6540);const i={},a=t.createContext(i);function o(e){const r=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(a.Provider,{value:r},e.children)}}}]);