"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[5655],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var t=i(96540);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}},42387:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"extensions/composition/index","title":"Pipeline Composition Extension","description":"Overview","source":"@site/docs/extensions/composition/index.md","sourceDirName":"extensions/composition","slug":"/extensions/composition/","permalink":"/docs/extensions/composition/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Data Enrichment","permalink":"/docs/extensions/nodes/enrichment"},"next":{"title":"Context Inheritance","permalink":"/docs/extensions/composition/context-inheritance"}}');var s=i(74848),o=i(28453);const r={},l="Pipeline Composition Extension",d={},c=[{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Installation",id:"installation",level:2},{value:"Quick Start",id:"quick-start",level:2},{value:"Basic Composition",id:"basic-composition",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Composite Transform Node",id:"composite-transform-node",level:3},{value:"Sub-Pipeline Structure",id:"sub-pipeline-structure",level:3},{value:"Context Configuration",id:"context-configuration",level:3},{value:"Architecture",id:"architecture",level:2},{value:"Data Flow",id:"data-flow",level:3},{value:"Context Isolation",id:"context-isolation",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:3},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"Examples",id:"examples",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keep Sub-Pipelines Focused",id:"1-keep-sub-pipelines-focused",level:3},{value:"2. Use Meaningful Names",id:"2-use-meaningful-names",level:3},{value:"3. Minimize Context Inheritance",id:"3-minimize-context-inheritance",level:3},{value:"4. Test Sub-Pipelines Independently",id:"4-test-sub-pipelines-independently",level:3},{value:"5. Document Input/Output Contracts",id:"5-document-inputoutput-contracts",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"Extension Methods",id:"extension-methods",level:3},{value:"<code>AddComposite&lt;TIn, TOut, TDefinition&gt;</code>",id:"addcompositetin-tout-tdefinition",level:4},{value:"<code>AddComposite&lt;TIn, TOut, TDefinition&gt;</code> (with configuration action)",id:"addcompositetin-tout-tdefinition-with-configuration-action",level:4},{value:"Classes",id:"classes",level:3},{value:"<code>CompositeContextConfiguration</code>",id:"compositecontextconfiguration",level:4},{value:"<code>PipelineInputSource&lt;T&gt;</code>",id:"pipelineinputsourcet",level:4},{value:"<code>PipelineOutputSink&lt;T&gt;</code>",id:"pipelineoutputsinkt",level:4},{value:"<code>CompositeContextKeys</code>",id:"compositecontextkeys",level:4},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"&quot;Sub-pipeline did not produce an output item&quot;",id:"sub-pipeline-did-not-produce-an-output-item",level:4},{value:"&quot;No input item found in pipeline context&quot;",id:"no-input-item-found-in-pipeline-context",level:4},{value:"Type Mismatch Errors",id:"type-mismatch-errors",level:4},{value:"License",id:"license",level:2},{value:"Contributing",id:"contributing",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"pipeline-composition-extension",children:"Pipeline Composition Extension"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"The NPipeline.Extensions.Composition extension enables creating hierarchical, modular pipelines by treating entire pipelines as reusable transform nodes. This powerful capability allows you to build complex data processing workflows from simpler, well-tested building blocks."}),"\n",(0,s.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modular Design"}),": Break complex pipelines into smaller, reusable sub-pipelines"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Safety"}),": Full compile-time type checking across pipeline boundaries"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Context Control"}),": Fine-grained control over what data flows between parent and sub-pipelines"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Isolation"}),": Sub-pipelines execute in isolated contexts, preventing unintended side effects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Nested Composition"}),": Unlimited nesting depth for hierarchical pipeline structures"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High Performance"}),": Minimal overhead with shared runner and optimized context creation"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"dotnet add package NPipeline.Extensions.Composition\n"})}),"\n",(0,s.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,s.jsx)(n.h3,{id:"basic-composition",children:"Basic Composition"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.Extensions.Composition;\nusing NPipeline.Pipeline;\n\n// Define a sub-pipeline for validation\npublic class ValidationPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<Customer>, Customer>("input");\n        var validate = builder.AddTransform<ValidatorNode, Customer, ValidatedCustomer>("validate");\n        var output = builder.AddSink<PipelineOutputSink<ValidatedCustomer>, ValidatedCustomer>("output");\n        \n        builder.Connect(input, validate);\n        builder.Connect(validate, output);\n    }\n}\n\n// Use in parent pipeline\npublic class DataProcessingPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<CustomerSource, Customer>("customers");\n        \n        // Add validation as a composite node\n        var validate = builder.AddComposite<Customer, ValidatedCustomer, ValidationPipeline>("validate");\n        \n        var sink = builder.AddSink<DatabaseSink, ValidatedCustomer>("database");\n        \n        builder.Connect(source, validate);\n        builder.Connect(validate, sink);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"composite-transform-node",children:"Composite Transform Node"}),"\n",(0,s.jsx)(n.p,{children:"A composite node is a special transform node that executes an entire sub-pipeline for each input item. It:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Receives an input item from the parent pipeline"}),"\n",(0,s.jsx)(n.li,{children:"Creates an isolated sub-pipeline context"}),"\n",(0,s.jsx)(n.li,{children:"Passes the input to the sub-pipeline"}),"\n",(0,s.jsx)(n.li,{children:"Executes the sub-pipeline"}),"\n",(0,s.jsx)(n.li,{children:"Retrieves the output from the sub-pipeline"}),"\n",(0,s.jsx)(n.li,{children:"Returns the output to the parent pipeline"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"sub-pipeline-structure",children:"Sub-Pipeline Structure"}),"\n",(0,s.jsx)(n.p,{children:"Sub-pipelines must follow a specific structure:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Input"}),": Use ",(0,s.jsx)(n.code,{children:"PipelineInputSource<T>"})," to receive data from the parent"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Processing"}),": Use any standard NPipeline nodes (transforms, filters, etc.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": Use ",(0,s.jsx)(n.code,{children:"PipelineOutputSink<T>"})," to return data to the parent"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class MySubPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        // Input node - receives from parent\n        var input = builder.AddSource<PipelineInputSource<TInput>, TInput>("input");\n        \n        // Processing nodes\n        var transform = builder.AddTransform<MyTransform, TInput, TOutput>("process");\n        \n        // Output node - returns to parent\n        var output = builder.AddSink<PipelineOutputSink<TOutput>, TOutput>("output");\n        \n        builder.Connect(input, transform);\n        builder.Connect(transform, output);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"context-configuration",children:"Context Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Control what data the sub-pipeline inherits from the parent:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// No inheritance (default)\nbuilder.AddComposite<TIn, TOut, SubPipeline>(\n    contextConfiguration: CompositeContextConfiguration.Default);\n\n// Inherit everything\nbuilder.AddComposite<TIn, TOut, SubPipeline>(\n    contextConfiguration: CompositeContextConfiguration.InheritAll);\n\n// Custom inheritance\nbuilder.AddComposite<TIn, TOut, SubPipeline>(\n    contextConfiguration: new CompositeContextConfiguration\n    {\n        InheritParentParameters = true,\n        InheritParentItems = false,\n        InheritParentProperties = true\n    });\n\n// Using configuration action\nbuilder.AddComposite<TIn, TOut, SubPipeline>(\n    configureContext: config =>\n    {\n        config.InheritParentParameters = true;\n        config.InheritParentItems = true;\n    });\n"})}),"\n",(0,s.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"data-flow",children:"Data Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Parent Pipeline:\n  [Source] \u2192 [Composite Node] \u2192 [Sink]\n                    \u2193\n            Sub-Pipeline:\n              [PipelineInputSource] \u2192 [Transform] \u2192 [PipelineOutputSink]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"context-isolation",children:"Context Isolation"}),"\n",(0,s.jsx)(n.p,{children:"Sub-pipelines execute in isolated contexts:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Isolated by Default"}),": Changes to sub-pipeline context don't affect parent"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optional Inheritance"}),": Parent context data can be copied to sub-pipeline"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Thread-Safe"}),": Multiple composite nodes can execute concurrently"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Management"}),": Sub-pipeline resources are properly disposed"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single-Item Processing"}),": Each item is processed independently"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Minimal Overhead"}),": Shared pipeline runner for all composite nodes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Efficient"}),": Only input/output items in memory at once"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No Buffering"}),": Items flow directly through the pipeline hierarchy"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,s.jsx)(n.p,{children:"See the following guides for detailed information:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/extensions/composition/context-inheritance",children:"Context Inheritance"})," - Detailed guide on context configuration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/extensions/composition/nested-composition",children:"Nested Composition"})," - Building deep pipeline hierarchies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/extensions/composition/error-handling",children:"Error Handling"})," - Managing errors across pipeline boundaries"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/extensions/composition/performance",children:"Performance Optimization"})," - Best practices for high-performance scenarios"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/extensions/composition/testing",children:"Testing Strategies"})," - How to test composite pipelines effectively"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsxs)(n.p,{children:["Complete examples are available in the ",(0,s.jsx)(n.a,{href:"../../../samples/Sample_Composition/",children:"samples directory"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Basic composition with simple sub-pipelines"}),"\n",(0,s.jsx)(n.li,{children:"Context inheritance patterns"}),"\n",(0,s.jsx)(n.li,{children:"Nested composition scenarios"}),"\n",(0,s.jsx)(n.li,{children:"Error handling across boundaries"}),"\n",(0,s.jsx)(n.li,{children:"Complex multi-stage processing"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-keep-sub-pipelines-focused",children:"1. Keep Sub-Pipelines Focused"}),"\n",(0,s.jsx)(n.p,{children:"Each sub-pipeline should have a single, well-defined responsibility:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"\u2705 Good: ValidationPipeline, EnrichmentPipeline, TransformationPipeline\n\u274c Bad: DoEverythingPipeline\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-use-meaningful-names",children:"2. Use Meaningful Names"}),"\n",(0,s.jsx)(n.p,{children:"Name composite nodes and sub-pipelines descriptively:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'\u2705 Good:\nbuilder.AddComposite<Customer, ValidatedCustomer, ValidationPipeline>("validate-customer");\n\n\u274c Bad:\nbuilder.AddComposite<Customer, ValidatedCustomer, ValidationPipeline>("node1");\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-minimize-context-inheritance",children:"3. Minimize Context Inheritance"}),"\n",(0,s.jsx)(n.p,{children:"Only inherit what you need:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"\u2705 Good:\nnew CompositeContextConfiguration\n{\n    InheritParentParameters = true  // Only parameters needed\n}\n\n\u274c Bad:\nCompositeContextConfiguration.InheritAll  // Unless you really need everything\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-test-sub-pipelines-independently",children:"4. Test Sub-Pipelines Independently"}),"\n",(0,s.jsx)(n.p,{children:"Test each sub-pipeline in isolation before composing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"[Fact]\npublic async Task ValidationPipeline_WithInvalidData_ShouldProduceErrors()\n{\n    var runner = PipelineRunner.Create();\n    var context = new PipelineContext();\n    \n    // Test the sub-pipeline directly\n    await runner.RunAsync<ValidationPipeline>(context);\n    \n    // Assert expected behavior\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-document-inputoutput-contracts",children:"5. Document Input/Output Contracts"}),"\n",(0,s.jsx)(n.p,{children:"Clearly document what each sub-pipeline expects and produces:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"/// <summary>\n/// Validates customer data and returns validation results.\n/// </summary>\n/// <remarks>\n/// Input: Customer with Id, Name, Email\n/// Output: ValidatedCustomer with IsValid flag and error list\n/// </remarks>\npublic class ValidationPipeline : IPipelineDefinition\n{\n    // ...\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,s.jsx)(n.h3,{id:"extension-methods",children:"Extension Methods"}),"\n",(0,s.jsx)(n.h4,{id:"addcompositetin-tout-tdefinition",children:(0,s.jsx)(n.code,{children:"AddComposite<TIn, TOut, TDefinition>"})}),"\n",(0,s.jsx)(n.p,{children:"Adds a composite node to the pipeline."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public static TransformNodeHandle<TIn, TOut> AddComposite<TIn, TOut, TDefinition>(\n    this PipelineBuilder builder,\n    string? name = null,\n    CompositeContextConfiguration? contextConfiguration = null)\n    where TDefinition : IPipelineDefinition, new()\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"builder"}),": The pipeline builder"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),": Optional node name (defaults to type name)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"contextConfiguration"}),": Optional context configuration"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," Handle to the composite node"]}),"\n",(0,s.jsxs)(n.h4,{id:"addcompositetin-tout-tdefinition-with-configuration-action",children:[(0,s.jsx)(n.code,{children:"AddComposite<TIn, TOut, TDefinition>"})," (with configuration action)"]}),"\n",(0,s.jsx)(n.p,{children:"Adds a composite node with a configuration action."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public static TransformNodeHandle<TIn, TOut> AddComposite<TIn, TOut, TDefinition>(\n    this PipelineBuilder builder,\n    Action<CompositeContextConfiguration> configureContext,\n    string? name = null)\n    where TDefinition : IPipelineDefinition, new()\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"builder"}),": The pipeline builder"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"configureContext"}),": Action to configure context inheritance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),": Optional node name"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," Handle to the composite node"]}),"\n",(0,s.jsx)(n.h3,{id:"classes",children:"Classes"}),"\n",(0,s.jsx)(n.h4,{id:"compositecontextconfiguration",children:(0,s.jsx)(n.code,{children:"CompositeContextConfiguration"})}),"\n",(0,s.jsx)(n.p,{children:"Configuration for sub-pipeline context inheritance."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Properties:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"InheritParentParameters"}),": Copy parent Parameters dictionary"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"InheritParentItems"}),": Copy parent Items dictionary"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"InheritParentProperties"}),": Copy parent Properties dictionary"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Static Properties:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Default"}),": No inheritance (all flags false)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"InheritAll"}),": Full inheritance (all flags true)"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"pipelineinputsourcet",children:(0,s.jsx)(n.code,{children:"PipelineInputSource<T>"})}),"\n",(0,s.jsx)(n.p,{children:"Source node that retrieves input from parent context."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"T"}),": Type of input item"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"pipelineoutputsinkt",children:(0,s.jsx)(n.code,{children:"PipelineOutputSink<T>"})}),"\n",(0,s.jsx)(n.p,{children:"Sink node that stores output in parent context."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"T"}),": Type of output item"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"compositecontextkeys",children:(0,s.jsx)(n.code,{children:"CompositeContextKeys"})}),"\n",(0,s.jsx)(n.p,{children:"Well-known context keys for composite nodes."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Constants:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"InputItem"}),": Key for input item storage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OutputItem"}),": Key for output item storage"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,s.jsx)(n.h4,{id:"sub-pipeline-did-not-produce-an-output-item",children:'"Sub-pipeline did not produce an output item"'}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Sub-pipeline is missing ",(0,s.jsx)(n.code,{children:"PipelineOutputSink"})," or it received no data."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Ensure your sub-pipeline has:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"PipelineOutputSink<T>"})," as the final node"]}),"\n",(0,s.jsx)(n.li,{children:"Data flowing through the pipeline to the sink"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// \u2705 Correct\npublic void Define(PipelineBuilder builder, PipelineContext context)\n{\n    var input = builder.AddSource<PipelineInputSource<T>, T>("input");\n    var output = builder.AddSink<PipelineOutputSink<T>, T>("output");\n    builder.Connect(input, output);\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"no-input-item-found-in-pipeline-context",children:'"No input item found in pipeline context"'}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Sub-pipeline is missing ",(0,s.jsx)(n.code,{children:"PipelineInputSource"})," or accessing context incorrectly."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Always use ",(0,s.jsx)(n.code,{children:"PipelineInputSource<T>"})," as the first node in sub-pipelines."]}),"\n",(0,s.jsx)(n.h4,{id:"type-mismatch-errors",children:"Type Mismatch Errors"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Sub-pipeline output type doesn't match composite node's TOut type parameter."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Ensure type consistency:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// \u2705 Correct - types match\nbuilder.AddComposite<Customer, ValidatedCustomer, ValidationPipeline>(...);\n\n// In ValidationPipeline:\nvar output = builder.AddSink<PipelineOutputSink<ValidatedCustomer>, ValidatedCustomer>("output");\n'})}),"\n",(0,s.jsx)(n.h2,{id:"license",children:"License"}),"\n",(0,s.jsx)(n.p,{children:"This extension is part of NPipeline and is licensed under the MIT License."}),"\n",(0,s.jsx)(n.h2,{id:"contributing",children:"Contributing"}),"\n",(0,s.jsxs)(n.p,{children:["Contributions are welcome! Please see the ",(0,s.jsx)(n.a,{href:"pathname:///CONTRIBUTING.md",children:"contribution guidelines"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);