"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[1465],{4745:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"architecture/data-flow","title":"Data Flow Details","description":"How data pipes work and lazy evaluation in NPipeline.","source":"@site/docs/architecture/data-flow.md","sourceDirName":"architecture","slug":"/architecture/data-flow","permalink":"/docs/architecture/data-flow","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Data Flow Details","description":"How data pipes work and lazy evaluation in NPipeline.","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Execution Flow","permalink":"/docs/architecture/execution-flow"},"next":{"title":"Dependency Injection Integration","permalink":"/docs/architecture/dependency-injection"}}');var i=a(4848),t=a(8453);const s={title:"Data Flow Details",description:"How data pipes work and lazy evaluation in NPipeline.",sidebar_position:4},o="Data Flow Details",c={},l=[{value:"How Data Pipes Work",id:"how-data-pipes-work",level:2},{value:"Lazy Evaluation",id:"lazy-evaluation",level:2},{value:"How Lazy Evaluation Works",id:"how-lazy-evaluation-works",level:3},{value:"Benefits of Lazy Evaluation",id:"benefits-of-lazy-evaluation",level:3},{value:"Composability of Data Pipes",id:"composability-of-data-pipes",level:2},{value:"Memory Patterns",id:"memory-patterns",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"data-flow-details",children:"Data Flow Details"})}),"\n",(0,i.jsx)(n.p,{children:"Understanding how data flows through NPipeline and the lazy evaluation principles that make it efficient is key to building high-performance pipelines."}),"\n",(0,i.jsx)(n.h2,{id:"how-data-pipes-work",children:"How Data Pipes Work"}),"\n",(0,i.jsx)(n.p,{children:"Data pipes are the channels through which data flows from nodes to the next stage in the pipeline."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Data Pipe Interface:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public interface IDataPipe<T> : IAsyncEnumerable<T>\r\n{\r\n    // IDataPipe<T> implements IAsyncEnumerable<T> directly\r\n    // Iterate using: await foreach (var item in dataPipe)\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Basic Data Flow:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// 1. Source produces a pipe\r\nvar sourcePipe = await sourceNode.Execute(context, cancellationToken);\r\n\r\n// 2. Transform consumes and wraps it\r\nvar transformedPipe = new TransformPipe(sourcePipe, transformNode);\r\n\r\n// 3. Sink consumes the pipe\r\nawait foreach (var item in transformedPipe.WithCancellation(cancellationToken))\r\n{\r\n    // Each item flows through here\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"lazy-evaluation",children:"Lazy Evaluation"}),"\n",(0,i.jsxs)(n.p,{children:["The key to NPipeline's efficiency is ",(0,i.jsx)(n.strong,{children:"lazy evaluation"}),": data is only processed when explicitly consumed."]}),"\n",(0,i.jsx)(n.h3,{id:"how-lazy-evaluation-works",children:"How Lazy Evaluation Works"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Step 1: Source creates pipe\r\n        \u2193\r\n        Pipe exists, but no data is read yet\r\n        \r\nStep 2: Transform wraps pipe\r\n        \u2193\r\n        Transform is ready, but no processing happens yet\r\n        \r\nStep 3: Sink iterates through pipe\r\n        \u2193\r\n        NOW data flows:\r\n        - Source reads item\r\n        - Transform processes item\r\n        - Sink consumes item\r\n        - REPEAT for next item\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Code Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Step 1: Source creates pipe (but doesn't read data yet)\r\nvar pipe = await source.Execute(context, cancellationToken);\r\n\r\n// Step 2: Transform wraps pipe (but doesn't process yet)\r\nvar wrappedPipe = new TransformPipe(pipe, transform);\r\n\r\n// Step 3: Sink actually triggers execution\r\nawait foreach (var item in wrappedPipe.WithCancellation(cancellationToken))\r\n{\r\n    // NOW data is read, transformed, consumed\r\n    await sink.ProcessAsync(item);\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"benefits-of-lazy-evaluation",children:"Benefits of Lazy Evaluation"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Early Termination:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// If pipeline is cancelled before consuming all items,\r\n// source never reads remaining data\r\nawait foreach (var item in pipe.WithCancellation(cancellationToken))\r\n{\r\n    if (shouldStop)\r\n    {\r\n        cancellationToken.Cancel();\r\n        break; // Source stops reading\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Memory Efficiency:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Reading 1 million items from a file:\r\n// - Lazy: Only ~1 item in memory at a time\r\n// - Eager (.ToList()): ~100 MB or more in memory\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Streaming Responsiveness:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Results are available immediately\r\n// Don't wait for entire dataset to load\r\nawait foreach (var result in pipeline.WithCancellation(cancellationToken))\r\n{\r\n    // Process each result as it's available\r\n    await WriteToUIAsync(result);\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"composability-of-data-pipes",children:"Composability of Data Pipes"}),"\n",(0,i.jsx)(n.p,{children:"Each transform creates a new data pipe, allowing for clean composition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"var source = await sourceNode.Execute(context, ct);      // IDataPipe<Order>\r\nvar validated = new TransformPipe(source, validator);          // IDataPipe<ValidatedOrder>\r\nvar enriched = new TransformPipe(validated, enricher);         // IDataPipe<EnrichedOrder>\r\nvar processed = new TransformPipe(enriched, processor);        // IDataPipe<ProcessedOrder>\r\n\r\n// Only when iterated does the entire chain execute\r\nawait foreach (var result in processed.WithCancellation(ct))\r\n{\r\n    // All transforms happen here for each item\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"memory-patterns",children:"Memory Patterns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Good: Streaming Processing"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Only one item in memory at a time\r\nawait foreach (var item in pipe.WithCancellation(ct))\r\n{\r\n    var result = await ProcessAsync(item);\r\n    await WriteAsync(result);\r\n    // Item is eligible for GC after this iteration\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Bad: Materializing Entire Stream"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Loads everything into memory!\r\nvar allItems = await pipe.ToListAsync(ct); // \u274c Bad for large datasets\r\nforeach (var item in allItems)\r\n{\r\n    // Process...\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/architecture/dependency-injection",children:"Dependency Injection Integration"})})," - Learn how DI works with NPipeline"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/architecture/performance-characteristics",children:"Performance Characteristics"})})," - Understand memory and throughput implications"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>o});var r=a(6540);const i={},t=r.createContext(i);function s(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);