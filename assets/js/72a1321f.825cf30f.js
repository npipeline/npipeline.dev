"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3056],{8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>o});var i=r(6540);const t={},s=i.createContext(t);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(s.Provider,{value:n},e.children)}},8962:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-concepts/resilience/node-restart-quickstart","title":"Node Restart - Quick Start Checklist","description":"Three-step mandatory checklist for configuring node restarts. Read this before you enable RestartNode error handling.","source":"@site/docs/core-concepts/resilience/node-restart-quickstart.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/node-restart-quickstart","permalink":"/docs/core-concepts/resilience/node-restart-quickstart","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Node Restart - Quick Start Checklist","description":"Three-step mandatory checklist for configuring node restarts. Read this before you enable RestartNode error handling.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Execution with Resilience","permalink":"/docs/core-concepts/resilience/execution-with-resilience"},"next":{"title":"Circuit Breaker Advanced Configuration","permalink":"/docs/core-concepts/resilience/circuit-breaker-advanced-configuration"}}');var t=r(4848),s=r(8453);const l={title:"Node Restart - Quick Start Checklist",description:"Three-step mandatory checklist for configuring node restarts. Read this before you enable RestartNode error handling.",sidebar_position:2},o=void 0,a={},c=[{value:"Node Restart - Quick Start Checklist",id:"node-restart---quick-start-checklist",level:2},{value:"The Three-Step Mandatory Checklist",id:"the-three-step-mandatory-checklist",level:2},{value:"\u2705 STEP 1: Apply ResilientExecutionStrategy",id:"-step-1-apply-resilientexecutionstrategy",level:3},{value:"\u2705 STEP 2: Configure Maximum Restart Attempts",id:"-step-2-configure-maximum-restart-attempts",level:3},{value:"\u2705 STEP 3: Enable Input Materialization (\u26a0\ufe0f CRITICAL)",id:"-step-3-enable-input-materialization-\ufe0f-critical",level:3},{value:"Conservative Starting Point",id:"conservative-starting-point",level:3},{value:"\u26a0\ufe0f CRITICAL WARNING: Unbounded Materialization",id:"\ufe0f-critical-warning-unbounded-materialization",level:2},{value:"Why Unbounded Memory Buffers Break Resilience Guarantees",id:"why-unbounded-memory-buffers-break-resilience-guarantees",level:3},{value:"Complete Configuration Example",id:"complete-configuration-example",level:2},{value:"Verification Checklist",id:"verification-checklist",level:2},{value:"What Happens If One Is Missing",id:"what-happens-if-one-is-missing",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"node-restart---quick-start-checklist",children:"Node Restart - Quick Start Checklist"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["\u26a0\ufe0f BEFORE YOU USE ",(0,t.jsx)(n.code,{children:"PipelineErrorDecision.RestartNode"}),", READ THIS."]})}),"\n",(0,t.jsxs)(n.p,{children:["Node restart is a powerful resilience feature, but it requires ",(0,t.jsx)(n.strong,{children:"three mandatory prerequisites"}),". Missing even one silently disables the feature."]}),"\n",(0,t.jsx)(n.p,{children:"If you've experienced mysterious pipeline failures where restart seemed enabled but didn't work, one of these requirements was missing."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\ud83d\udca1 Tip:"})," The NPipeline build-time analyzer automatically detects incomplete restart configurations at compile time. Enable ",(0,t.jsx)(n.a,{href:"/docs/reference/error-codes#npl9002-incomplete-resilient-configuration",children:"NP9002"})," to catch these issues before deployment."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"the-three-step-mandatory-checklist",children:"The Three-Step Mandatory Checklist"}),"\n",(0,t.jsx)(n.h3,{id:"-step-1-apply-resilientexecutionstrategy",children:"\u2705 STEP 1: Apply ResilientExecutionStrategy"}),"\n",(0,t.jsxs)(n.p,{children:["Your node must be wrapped with ",(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"}),". This enables the restart capability at the node level."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"What it does:"})," Allows the pipeline to restart the node when an error occurs."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Without it:"})," Restart decisions are ignored; the node cannot recover."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How to configure:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'var nodeHandle = builder\r\n    .AddTransform<MyTransform, Input, Output>("myNode")\r\n    .WithExecutionStrategy(\r\n        builder,\r\n        new ResilientExecutionStrategy(new SequentialExecutionStrategy())\r\n    );\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Learn more:"})," ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/execution-with-resilience",children:"Resilient Execution Strategy"})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-step-2-configure-maximum-restart-attempts",children:"\u2705 STEP 2: Configure Maximum Restart Attempts"}),"\n",(0,t.jsxs)(n.p,{children:["Set ",(0,t.jsx)(n.code,{children:"MaxNodeRestartAttempts > 0"})," in ",(0,t.jsx)(n.code,{children:"PipelineRetryOptions"}),". This tells the pipeline how many times to attempt restarting a failed node."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"What it does:"})," Limits how many restart attempts the pipeline will make before giving up."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Without it:"})," No restarts will be attempted."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How to configure:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,  // \u2190 At least 1\r\n    MaxMaterializedItems: 1000   // (see Step 3!)\r\n);\r\n\r\nvar context = PipelineContext.WithRetry(options);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Recommended starting values:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transient failures (network, temporary service issues):"})," 2-3 attempts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistent issues (resource exhaustion):"})," 3-5 attempts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Critical nodes:"})," 5+ attempts"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Learn more:"})," ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/configuration-guide",children:"Configuration Guide"})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-step-3-enable-input-materialization-\ufe0f-critical",children:"\u2705 STEP 3: Enable Input Materialization (\u26a0\ufe0f CRITICAL)"}),"\n",(0,t.jsxs)(n.p,{children:["Set ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," to a ",(0,t.jsx)(n.strong,{children:"non-null, positive number"})," on the input to the node you want to be restartable. This is the replay buffer."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"What it does:"})," Buffers items from the input source so the node can be replayed from a known state if it fails."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u26a0\ufe0f CRITICAL ISSUE:"})," If ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," is ",(0,t.jsx)(n.code,{children:"null"})," (unbounded), the system silently falls back to ",(0,t.jsx)(n.code,{children:"FailPipeline"}),", even if you've configured restart logic. Your entire pipeline crashes instead of just restarting the node."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How to configure:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxMaterializedItems: 1000  // \u2190 Must be set! Not null!\r\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Choosing a value:"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Scenario"}),(0,t.jsx)(n.th,{children:"Recommended Value"}),(0,t.jsx)(n.th,{children:"Rationale"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Small objects (< 100 bytes)"}),(0,t.jsx)(n.td,{children:"5,000-10,000"}),(0,t.jsx)(n.td,{children:"Minimal memory overhead"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Medium objects (100-1KB)"}),(0,t.jsx)(n.td,{children:"1,000-5,000"}),(0,t.jsx)(n.td,{children:"Balanced buffer size"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Large objects (1KB+)"}),(0,t.jsx)(n.td,{children:"500-1,000"}),(0,t.jsx)(n.td,{children:"Respect memory constraints"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Critical/high-priority node"}),(0,t.jsx)(n.td,{children:"2,000-5,000"}),(0,t.jsx)(n.td,{children:"More replay buffer = higher restart success rate"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"conservative-starting-point",children:"Conservative Starting Point"}),"\n",(0,t.jsx)(n.p,{children:"Here's a good default configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxMaterializedItems: 1000  // \u2190 Good default: buffers ~1000 items\r\n);\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Learn more:"})," ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/materialization-and-buffering",children:"Materialization and Buffering"})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"\ufe0f-critical-warning-unbounded-materialization",children:"\u26a0\ufe0f CRITICAL WARNING: Unbounded Materialization"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Never set ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," to ",(0,t.jsx)(n.code,{children:"null"}),":"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// \u274c WRONG - This disables restart silently!\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxMaterializedItems: null  // \u2190 DANGER!\r\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"If you do:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Your pipeline will NOT restart on failures"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.strong,{children:["The system silently falls back to ",(0,t.jsx)(n.code,{children:"FailPipeline"})]})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Your entire pipeline will crash"})," (not just the failing node)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Risk of Out-of-Memory exceptions"})," with unbounded data streams"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Symptom:"})," You've configured restart logic, but when an error occurs, the pipeline fails completely instead of restarting the node."]}),"\n",(0,t.jsx)(n.h3,{id:"why-unbounded-memory-buffers-break-resilience-guarantees",children:"Why Unbounded Memory Buffers Break Resilience Guarantees"}),"\n",(0,t.jsxs)(n.p,{children:["Unbounded materialization (",(0,t.jsx)(n.code,{children:"MaxMaterializedItems: null"}),") creates a fundamental contradiction in the resilience model:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Memory Safety vs. Recovery Trade-off"}),": Unbounded buffers can consume all available memory, causing OutOfMemoryException that cannot be recovered from. This defeats the purpose of resilience."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Silent Failure Mode"}),": When the system detects unbounded materialization with a RestartNode decision, it cannot safely buffer items for replay. Instead of risking memory exhaustion, it silently falls back to ",(0,t.jsx)(n.code,{children:"FailPipeline"})," to protect the system."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Unpredictable Behavior"}),": In production, unbounded buffers lead to unpredictable memory usage patterns that can cause cascading failures across the entire system."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Resource Contention"}),": Unbounded buffers compete with other processes for memory, potentially causing system-wide instability."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The Design Philosophy"}),": NPipeline prioritizes system stability over incomplete recovery. An unbounded buffer represents an undefined recovery boundary, making safe restart impossible. By requiring explicit buffer limits, NPipeline ensures that restart operations have predictable memory footprints and can be safely executed."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Choosing Not to Set a Memory Cap = Choosing Complete Pipeline Failure"})}),"\n",(0,t.jsxs)(n.p,{children:["When you set ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems: null"}),", you are making an explicit choice to sacrifice restart capability in favor of unlimited buffering. This means:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"You accept that RestartNode will not work"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"You accept that your pipeline will fail completely on node errors"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"You accept the risk of OutOfMemoryException"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If you need node restart functionality, you ",(0,t.jsx)(n.strong,{children:"must"})," set a memory cap. The system cannot provide resilience guarantees without defined resource boundaries."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"complete-configuration-example",children:"Complete Configuration Example"}),"\n",(0,t.jsx)(n.p,{children:"Here's a complete example with all three requirements:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Step 1: Create retry options with ALL three settings\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,           // \u2190 Step 2: Restart attempts\r\n    MaxMaterializedItems: 1000            // \u2190 Step 3: Replay buffer\r\n);\r\n\r\nvar context = PipelineContext.WithRetry(options);\r\n\r\n// Step 2: Build pipeline with resilient nodes\r\nvar definition = new MyPipelineDefinition();\r\ndefinition.Define(builder, context);\r\n\r\n// In MyPipelineDefinition.Define():\r\n// \r\n//   Step 1: Wrap node with ResilientExecutionStrategy\r\n//   var nodeHandle = builder\r\n//       .AddTransform<MyTransform, Input, Output>("risky")\r\n//       .WithExecutionStrategy(\r\n//           builder,\r\n//           new ResilientExecutionStrategy(\r\n//               new SequentialExecutionStrategy()\r\n//           )\r\n//       );\r\n//\r\n//   Add error handler that returns RestartNode\r\n//   builder.AddPipelineErrorHandler<MyErrorHandler>();\r\n//\r\n// In MyErrorHandler.HandleNodeFailureAsync():\r\n//\r\n//   return error switch\r\n//   {\r\n//       TimeoutException => Task.FromResult(\r\n//           PipelineErrorDecision.RestartNode  // \u2190 RestartNode requires all 3!\r\n//       ),\r\n//       _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\r\n//   };\r\n\r\nvar runner = PipelineRunner.Create();\r\nawait runner.RunAsync<MyPipelineDefinition>(context);\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"verification-checklist",children:"Verification Checklist"}),"\n",(0,t.jsx)(n.p,{children:"Before you assume restarts are working, verify all three:"}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.strong,{children:"Strategy:"})," Node is wrapped with ",(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"})]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.strong,{children:"Attempts:"})," ",(0,t.jsx)(n.code,{children:"MaxNodeRestartAttempts > 0"})," in ",(0,t.jsx)(n.code,{children:"PipelineRetryOptions"})]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.strong,{children:"Materialization:"})," ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," is set to a positive number (not null)"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.strong,{children:"Error Handler:"})," Handler returns ",(0,t.jsx)(n.code,{children:"PipelineErrorDecision.RestartNode"})," for your error type"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If any are missing, restarts won't work."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"what-happens-if-one-is-missing",children:"What Happens If One Is Missing"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Missing Component"}),(0,t.jsx)(n.th,{children:"Symptom"}),(0,t.jsx)(n.th,{children:"What Happens"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"ResilientExecutionStrategy"})}),(0,t.jsx)(n.td,{children:"Node not wrapped"}),(0,t.jsx)(n.td,{children:"Error handler decisions are ignored; pipeline always fails"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"MaxNodeRestartAttempts"})}),(0,t.jsx)(n.td,{children:"Not configured or = 0"}),(0,t.jsx)(n.td,{children:"No restarts are attempted; pipeline fails immediately"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"MaxMaterializedItems"})}),(0,t.jsx)(n.td,{children:"Not set (null)"}),(0,t.jsxs)(n.td,{children:["RestartNode falls back to ",(0,t.jsx)(n.code,{children:"FailPipeline"}),"; ",(0,t.jsx)(n.strong,{children:"entire pipeline crashes"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Error Handler"})}),(0,t.jsxs)(n.td,{children:["Returns ",(0,t.jsx)(n.code,{children:"FailPipeline"})," for all errors"]}),(0,t.jsx)(n.td,{children:"Restarts never triggered; all errors kill the pipeline"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.a,{href:"/docs/analyzers/resilience",children:"Build-Time Resilience Analyzer"}),":"]})," Catch incomplete configurations at compile time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/execution-with-resilience",children:"Resilient Execution Strategy"}),":"]})," Deep dive into how ResilientExecutionStrategy works"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/materialization-and-buffering",children:"Materialization and Buffering"}),":"]})," Understand the replay buffer and memory implications"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling-guide",children:"Error Handling"}),":"]})," Learn how to write error handlers that return RestartNode"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting"}),":"]})," Diagnose restart issues in your pipeline"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);