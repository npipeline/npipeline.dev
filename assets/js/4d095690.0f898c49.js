"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[7152],{6076:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"core-concepts/node-definition","title":"Node Definition Structure","description":"Understanding the nested configuration structure of NodeDefinition in NPipeline.","source":"@site/docs/core-concepts/node-definition.md","sourceDirName":"core-concepts","slug":"/core-concepts/node-definition","permalink":"/docs/core-concepts/node-definition","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Node Definition Structure","description":"Understanding the nested configuration structure of NodeDefinition in NPipeline.","sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"PipelineBuilder","permalink":"/docs/core-concepts/pipelinebuilder"},"next":{"title":"Pipeline Execution","permalink":"/docs/core-concepts/pipeline-execution"}}');var t=i(4848),o=i(8453);const a={title:"Node Definition Structure",description:"Understanding the nested configuration structure of NodeDefinition in NPipeline.",sidebar_position:6},s="Node Definition Structure",d={},c=[{value:"Overview",id:"overview",level:2},{value:"Nested Configuration Records",id:"nested-configuration-records",level:2},{value:"NodeIdentity",id:"nodeidentity",level:3},{value:"NodeTypeSystem",id:"nodetypesystem",level:3},{value:"NodeExecutionConfig",id:"nodeexecutionconfig",level:3},{value:"NodeMergeConfig",id:"nodemergeconfig",level:3},{value:"NodeLineageConfig",id:"nodelineageconfig",level:3},{value:"Benefits of Nested Structure",id:"benefits-of-nested-structure",level:2},{value:"Accessing Properties",id:"accessing-properties",level:2},{value:"Creating NodeDefinition Instances",id:"creating-nodedefinition-instances",level:2},{value:"Using Individual Parameters (Backward Compatible)",id:"using-individual-parameters-backward-compatible",level:3},{value:"Using Nested Configuration Records (Recommended)",id:"using-nested-configuration-records-recommended",level:3},{value:"Updating NodeDefinition",id:"updating-nodedefinition",level:2},{value:"Migrated Delegate Types",id:"migrated-delegate-types",level:2},{value:"See Also",id:"see-also",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"node-definition-structure",children:"Node Definition Structure"})}),"\n",(0,t.jsxs)(n.p,{children:["NPipeline uses a ",(0,t.jsx)(n.code,{children:"NodeDefinition"})," record to represent nodes in the pipeline graph. This record has been refactored to use a nested configuration structure that organizes node properties logically and makes the API more maintainable."]}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"NodeDefinition"})," record is composed of several nested configuration records, each responsible for a specific aspect of node configuration:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"NodeIdentity"}),": Contains identification information (ID and name)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"NodeTypeSystem"}),": Contains type system information (node type, kind, input/output types)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"NodeExecutionConfig"}),": Contains execution-related configuration (strategy, error handler, cardinality)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"NodeMergeConfig"}),": Contains merge-related configuration (strategy, custom merge logic)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"NodeLineageConfig"}),": Contains lineage-related configuration (adapters, mappers, unwrappers)"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"nested-configuration-records",children:"Nested Configuration Records"}),"\n",(0,t.jsx)(n.h3,{id:"nodeidentity",children:"NodeIdentity"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'/// <summary>\n/// Represents the identity information of a node.\n/// </summary>\n/// <param name="Id">The unique identifier for the node.</param>\n/// <param name="Name">A descriptive name for the node.</param>\npublic sealed record NodeIdentity(\n    string Id,\n    string Name);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"nodetypesystem",children:"NodeTypeSystem"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'/// <summary>\n/// Represents the type system information of a node.\n/// </summary>\n/// <param name="NodeType">The type of the pipeline node, which must implement INode.</param>\n/// <param name="Kind">The kind of node (Source, Transform, Sink, Join, or Aggregate).</param>\n/// <param name="InputType">The type of input data for the node.</param>\n/// <param name="OutputType">The type of output data for the node.</param>\npublic sealed record NodeTypeSystem(\n    Type NodeType,\n    NodeKind Kind,\n    Type? InputType = null,\n    Type? OutputType = null);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"nodeexecutionconfig",children:"NodeExecutionConfig"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'/// <summary>\n/// Represents the execution configuration of a node.\n/// </summary>\n/// <param name="ExecutionStrategy">The execution strategy for the node.</param>\n/// <param name="ErrorHandlerType">The type of the error handler for the node.</param>\n/// <param name="DeclaredCardinality">The declared cardinality transformation of the node.</param>\npublic sealed record NodeExecutionConfig(\n    IExecutionStrategy? ExecutionStrategy = null,\n    Type? ErrorHandlerType = null,\n    TransformCardinality? DeclaredCardinality = null);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"nodemergeconfig",children:"NodeMergeConfig"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'/// <summary>\n/// Represents the merge configuration of a node.\n/// </summary>\n/// <param name="MergeStrategy">The merge strategy for nodes that combine multiple inputs.</param>\n/// <param name="HasCustomMerge">Whether this node has custom merge logic.</param>\n/// <param name="IsJoin">Whether this node is a join node.</param>\n/// <param name="CustomMerge">Optional custom merge delegate for merging multiple input streams.</param>\npublic sealed record NodeMergeConfig(\n    MergeType? MergeStrategy = null,\n    bool HasCustomMerge = false,\n    bool IsJoin = false,\n    CustomMergeDelegate? CustomMerge = null);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"nodelineageconfig",children:"NodeLineageConfig"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'/// <summary>\n/// Represents the lineage configuration of a node.\n/// </summary>\n/// <param name="LineageAdapter">Optional delegate for transforming lineage data.</param>\n/// <param name="LineageMapperType">The type of the lineage mapper for non-1:1 transformations.</param>\n/// <param name="SinkLineageUnwrap">Optional delegate for unwrapping lineage in sink nodes.</param>\npublic sealed record NodeLineageConfig(\n    LineageAdapterDelegate? LineageAdapter = null,\n    Type? LineageMapperType = null,\n    SinkLineageUnwrapDelegate? SinkLineageUnwrap = null);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"benefits-of-nested-structure",children:"Benefits of Nested Structure"}),"\n",(0,t.jsx)(n.p,{children:"The nested configuration structure provides several benefits:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Logical Organization"}),": Related properties are grouped together, making the API more intuitive"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type Safety"}),": Each configuration record has a focused set of related properties"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Immutability"}),": Records provide built-in immutability and value-based equality"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Maintainability"}),": Changes to specific aspects of node configuration are isolated"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extensibility"}),": New configuration aspects can be added without affecting existing code"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"accessing-properties",children:"Accessing Properties"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"NodeDefinition"})," record provides convenience properties that delegate to the nested configuration records:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Accessing execution strategy through the nested structure\nvar strategy = nodeDefinition.ExecutionConfig.ExecutionStrategy;\n\n// Accessing merge configuration\nvar mergeStrategy = nodeDefinition.MergeConfig.MergeStrategy;\nvar hasCustomMerge = nodeDefinition.MergeConfig.HasCustomMerge;\n\n// Accessing lineage configuration\nvar lineageAdapter = nodeDefinition.LineageConfig.LineageAdapter;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"creating-nodedefinition-instances",children:"Creating NodeDefinition Instances"}),"\n",(0,t.jsx)(n.p,{children:"When creating NodeDefinition instances, you can use either the constructor with individual parameters or the nested structure approach:"}),"\n",(0,t.jsx)(n.h3,{id:"using-individual-parameters-backward-compatible",children:"Using Individual Parameters (Backward Compatible)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'var nodeDefinition = new NodeDefinition(\n    "myNodeId",\n    "My Node",\n    typeof(MyNode),\n    NodeKind.Transform,\n    executionStrategy: new MyExecutionStrategy(),\n    errorHandlerType: typeof(MyErrorHandler),\n    inputType: typeof(string),\n    outputType: typeof(int),\n    mergeStrategy: MergeType.Concat,\n    hasCustomMerge: false,\n    declaredCardinality: TransformCardinality.OneToOne,\n    lineageAdapter: null,\n    lineageMapperType: null,\n    isJoin: false,\n    customMerge: null,\n    sinkLineageUnwrap: null\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"using-nested-configuration-records-recommended",children:"Using Nested Configuration Records (Recommended)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'var nodeDefinition = new NodeDefinition(\n    new NodeIdentity("myNodeId", "My Node"),\n    new NodeTypeSystem(typeof(MyNode), NodeKind.Transform, typeof(string), typeof(int)),\n    new NodeExecutionConfig(new MyExecutionStrategy(), typeof(MyErrorHandler), TransformCardinality.OneToOne),\n    new NodeMergeConfig(MergeType.Concat, false, false, null),\n    new NodeLineageConfig(null, null, null)\n);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"updating-nodedefinition",children:"Updating NodeDefinition"}),"\n",(0,t.jsxs)(n.p,{children:["The nested structure makes it easier to update specific aspects of node configuration using the ",(0,t.jsx)(n.code,{children:"with"})," expression:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Update execution strategy\nvar updatedNode = nodeDefinition with { \n    ExecutionConfig = nodeDefinition.ExecutionConfig with { \n        ExecutionStrategy = newExecutionStrategy \n    } \n};\n\n// Update merge configuration\nvar withCustomMerge = nodeDefinition with { \n    MergeConfig = nodeDefinition.MergeConfig with { \n        CustomMerge = myCustomMergeDelegate,\n        HasCustomMerge = true\n    } \n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"migrated-delegate-types",children:"Migrated Delegate Types"}),"\n",(0,t.jsxs)(n.p,{children:["The following delegate types have been moved to the ",(0,t.jsx)(n.code,{children:"NPipeline.Graph.PipelineDelegates"})," namespace:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"CustomMergeDelegate"}),": For custom merge logic in join nodes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SinkLineageUnwrapDelegate"}),": For unwrapping lineage in sink nodes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"LineageAdapterDelegate"}),": For transforming lineage data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"JoinKeySelectorDelegate"}),": For extracting join keys"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"When using these delegates, ensure you import the correct namespace:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"using NPipeline.Graph.PipelineDelegates;\n\n// Now you can use the delegates\nCustomMergeDelegate? myCustomMerge = (node, dataPipes, cancellationToken) => {\n    // Custom merge implementation\n    return mergedDataPipe;\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/pipeline-definition",children:"Pipeline Definition"})," - Learn how to define pipelines"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/pipelinebuilder",children:"PipelineBuilder"})," - How to use the builder API"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/nodes/",children:"Node Types"})," - Overview of different node types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/execution-strategies",children:"Execution Strategies"})," - Configure node execution"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>s});var r=i(6540);const t={},o=r.createContext(t);function a(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);