"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[7037],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>c});var t=i(96540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},61122:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"architecture/architectural-foundations","title":"Architectural Foundations","description":"Fundamental architectural concepts in NPipeline - graphs, nodes, and streaming data.","source":"@site/docs/architecture/architectural-foundations.md","sourceDirName":"architecture","slug":"/architecture/architectural-foundations","permalink":"/docs/architecture/architectural-foundations","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Architectural Foundations","description":"Fundamental architectural concepts in NPipeline - graphs, nodes, and streaming data.","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Architecture Overview","permalink":"/docs/architecture/"},"next":{"title":"Component Architecture","permalink":"/docs/architecture/component-architecture"}}');var s=i(74848),r=i(28453);const a={title:"Architectural Foundations",description:"Fundamental architectural concepts in NPipeline - graphs, nodes, and streaming data.",sidebar_position:1},c="Architectural Foundations",o={},l=[{value:"Graph-Based Architecture",id:"graph-based-architecture",level:2},{value:"Node Architecture",id:"node-architecture",level:2},{value:"Interface Hierarchy",id:"interface-hierarchy",level:3},{value:"Streaming Data Model",id:"streaming-data-model",level:2},{value:"Key Characteristics",id:"key-characteristics",level:3},{value:"Example: How Streaming Works",id:"example-how-streaming-works",level:3},{value:"Benefits of This Design",id:"benefits-of-this-design",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"architectural-foundations",children:"Architectural Foundations"})}),"\n",(0,s.jsx)(n.p,{children:"NPipeline's architecture is built on three fundamental concepts: graph-based data representation, distinct node types, and a streaming data model."}),"\n",(0,s.jsx)(n.h2,{id:"graph-based-architecture",children:"Graph-Based Architecture"}),"\n",(0,s.jsxs)(n.p,{children:["NPipeline represents pipelines as ",(0,s.jsx)(n.strong,{children:"directed acyclic graphs (DAGs)"})," where:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Nodes"})," are processing units (sources, transforms, sinks)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Edges"})," are connections between nodes representing data flow"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data flows"})," through the graph from sources to sinks"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"Source Node\n    \u2193\nTransform Node 1\n    \u2193\nTransform Node 2\n    \u2193\nSink Node\n"})}),"\n",(0,s.jsx)(n.p,{children:"This approach provides several advantages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clarity"}),": Visual representation of data flow"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flexibility"}),": Easy to add, remove, or reroute nodes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Safety"}),": Compile-time validation of connections"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Composability"}),": Nodes can be tested and reused independently"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"node-architecture",children:"Node Architecture"}),"\n",(0,s.jsx)(n.p,{children:"From an architectural perspective, nodes are the fundamental processing units that form the vertices of the pipeline graph. NPipeline defines three primary node types:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Source Nodes"}),": Initiate data flow by producing data streams"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transform Nodes"}),": Process and transform data as it flows through the pipeline"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sink Nodes"}),": Consume data at the terminal point of the pipeline"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"interface-hierarchy",children:"Interface Hierarchy"}),"\n",(0,s.jsxs)(n.p,{children:["All nodes implement the ",(0,s.jsx)(n.code,{children:"INode"})," interface, with specialized interfaces for each node type:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Base interface\npublic interface INode\n{\n    string Name { get; }\n}\n\n// Source nodes produce output streams\npublic interface ISourceNode<out TOutput> : INode\n{\n    IDataPipe<TOutput> Initialize(PipelineContext context, CancellationToken cancellationToken);\n}\n\n// Transform nodes process individual items\npublic interface ITransformNode<in TInput, out TOutput> : INode\n{\n    Task<TOutput> ExecuteAsync(TInput item, PipelineContext context, CancellationToken cancellationToken);\n}\n\n// Sink nodes consume entire streams\npublic interface ISinkNode<in TInput> : INode\n{\n    Task ExecuteAsync(IDataPipe<TInput> input, PipelineContext context, CancellationToken cancellationToken);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Safety Through Generics:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Input types (",(0,s.jsx)(n.code,{children:"TInput"}),") and output types (",(0,s.jsx)(n.code,{children:"TOutput"}),") are enforced at compile time"]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"PipelineBuilder"})," validates that connected nodes have compatible types"]}),"\n",(0,s.jsx)(n.li,{children:"Attempting to connect incompatible nodes results in a build error"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Data Flow Model:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Source nodes return ",(0,s.jsx)(n.code,{children:"IDataPipe<TOutput>"}),", which implements ",(0,s.jsx)(n.code,{children:"IAsyncEnumerable<TOutput>"})]}),"\n",(0,s.jsxs)(n.li,{children:["Transform nodes process items one at a time via ",(0,s.jsx)(n.code,{children:"ExecuteAsync"})]}),"\n",(0,s.jsxs)(n.li,{children:["Sink nodes consume the entire input stream using ",(0,s.jsx)(n.code,{children:"await foreach"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The architectural design emphasizes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Separation of Concerns"}),": Each node type has a distinct responsibility"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Safety"}),": Compile-time validation of node connections"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Composability"}),": Nodes can be combined in various configurations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testability"}),": Each node can be tested in isolation"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For detailed information about node implementations, interfaces, and examples, see the ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/nodes/",children:"Nodes documentation"})}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"streaming-data-model",children:"Streaming Data Model"}),"\n",(0,s.jsxs)(n.p,{children:["NPipeline uses ",(0,s.jsx)(n.code,{children:"IAsyncEnumerable<T>"})," for ",(0,s.jsx)(n.strong,{children:"lazy, streaming data flow"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public interface IDataPipe<T> : IAsyncEnumerable<T>\n{\n    // IDataPipe<T> implements IAsyncEnumerable<T> directly\n    // Iterate using: await foreach (var item in dataPipe)\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"key-characteristics",children:"Key Characteristics"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Lazy Evaluation"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Data is only produced when consumed"}),"\n",(0,s.jsx)(n.li,{children:"If pipeline is cancelled, source never reads unused data"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Memory Efficient"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Only active items are in memory at any time"}),"\n",(0,s.jsx)(n.li,{children:"No need to load entire datasets upfront"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Responsive"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Processing begins immediately upon pipeline start"}),"\n",(0,s.jsx)(n.li,{children:"Results are available as soon as items flow through"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Composable"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Each transform creates a new data pipe"}),"\n",(0,s.jsx)(n.li,{children:"Pipes can be layered and composed"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-how-streaming-works",children:"Example: How Streaming Works"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Step 1: Source creates pipe (but doesn't read yet)\nvar sourcePipe = await sourceNode.Initialize(context, cancellationToken);\n\n// Step 2: Transform wraps pipe (but doesn't process yet)\nvar transformPipe = new TransformPipe(sourcePipe, transformNode);\n\n// Step 3: Sink actually triggers execution\nawait foreach (var item in transformPipe.WithCancellation(cancellationToken))\n{\n    // Data is produced, transformed, and consumed\n    // Only ONE item is in memory at a time\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"benefits-of-this-design",children:"Benefits of This Design"}),"\n",(0,s.jsxs)(n.p,{children:["\u2713 ",(0,s.jsx)(n.strong,{children:"Memory Efficient"})," - Only active items in memory\n\u2713 ",(0,s.jsx)(n.strong,{children:"Responsive"})," - Processing starts immediately\n\u2713 ",(0,s.jsx)(n.strong,{children:"Cancellable"})," - Can stop at any time\n\u2713 ",(0,s.jsx)(n.strong,{children:"Type Safe"})," - Compile-time validation of node connections\n\u2713 ",(0,s.jsx)(n.strong,{children:"Testable"})," - Each node can be tested in isolation"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/architecture/component-architecture",children:"Component Architecture"})})," - Learn about the major system components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/architecture/execution-flow",children:"Execution Flow"})})," - Understand how data flows through pipelines"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/nodes/",children:"Nodes"})})," - Explore detailed node implementations and examples"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);