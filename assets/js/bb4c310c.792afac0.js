"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3616],{1648:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"extensions/dependency-injection","title":"Dependency Injection","description":"Integrate NPipeline with .NET\'s dependency injection framework to manage dependencies in your nodes and pipelines.","source":"@site/docs/extensions/dependency-injection.md","sourceDirName":"extensions","slug":"/extensions/dependency-injection","permalink":"/docs/extensions/dependency-injection","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Dependency Injection","description":"Integrate NPipeline with .NET\'s dependency injection framework to manage dependencies in your nodes and pipelines.","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"NPipeline Extensions","permalink":"/docs/extensions"},"next":{"title":"Parallelism","permalink":"/docs/extensions/parallelism"}}');var s=i(4848),t=i(8453);const l={title:"Dependency Injection",description:"Integrate NPipeline with .NET's dependency injection framework to manage dependencies in your nodes and pipelines.",sidebar_position:1},c="Dependency Injection",o={},a=[{value:"Installation",id:"installation",level:2},{value:"Registering NPipeline Services",id:"registering-npipeline-services",level:2},{value:"Assembly Scanning (Automatic Discovery)",id:"assembly-scanning-automatic-discovery",level:3},{value:"Fluent Configuration (Manual Registration)",id:"fluent-configuration-manual-registration",level:3},{value:"Mixed Approach (Manual + Assembly Scanning)",id:"mixed-approach-manual--assembly-scanning",level:3},{value:"NPipelineServiceBuilder API",id:"npipelineservicebuilder-api",level:3},{value:"Automatic Registration",id:"automatic-registration",level:3},{value:"Core Services Registered",id:"core-services-registered",level:3},{value:"Overriding Default Registrations",id:"overriding-default-registrations",level:3},{value:"Running Pipelines with DI",id:"running-pipelines-with-di",level:2},{value:"Simple Pipeline Execution",id:"simple-pipeline-execution",level:3},{value:"Pipeline Execution with Parameters",id:"pipeline-execution-with-parameters",level:3},{value:"Registering Pipelines and Nodes with Dependencies",id:"registering-pipelines-and-nodes-with-dependencies",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Resolving Services within Nodes",id:"resolving-services-within-nodes",level:2},{value:"DI-Specific Node Factory Behavior",id:"di-specific-node-factory-behavior",level:2},{value:"Service Lifetimes in Pipelines",id:"service-lifetimes-in-pipelines",level:3},{value:"Benefits of Using Dependency Injection",id:"benefits-of-using-dependency-injection",level:2},{value:"\ud83d\udd17 Related Topics",id:"link-related-topics",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"dependency-injection",children:"Dependency Injection"})}),"\n",(0,s.jsxs)(n.p,{children:["Managing dependencies in complex data pipelines can be challenging. The ",(0,s.jsx)(n.code,{children:"NPipeline.Extensions.DependencyInjection"})," package provides seamless integration with the standard ",(0,s.jsx)(n.code,{children:"Microsoft.Extensions.DependencyInjection"})," framework, allowing you to register your pipelines and nodes with a service container and have their dependencies automatically resolved."]}),"\n",(0,s.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsx)(n.p,{children:"First, add the NuGet package to your project:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"dotnet add package NPipeline.Extensions.DependencyInjection\n"})}),"\n",(0,s.jsx)(n.h2,{id:"registering-npipeline-services",children:"Registering NPipeline Services"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"AddNPipeline"})," extension method on ",(0,s.jsx)(n.code,{children:"IServiceCollection"})," registers all necessary NPipeline services, including ",(0,s.jsx)(n.code,{children:"IPipelineRunner"}),", node factories, and optionally any ",(0,s.jsx)(n.code,{children:"IPipelineDefinition"})," or ",(0,s.jsx)(n.code,{children:"INode"})," implementations found in specified assemblies."]}),"\n",(0,s.jsx)(n.p,{children:"NPipeline supports two registration approaches:"}),"\n",(0,s.jsx)(n.h3,{id:"assembly-scanning-automatic-discovery",children:"Assembly Scanning (Automatic Discovery)"}),"\n",(0,s.jsx)(n.p,{children:"Use this approach when you want automatic discovery of pipeline components in your assemblies. This leverages reflection to find and register all implementations."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using Microsoft.Extensions.DependencyInjection;\r\nusing NPipeline.DataFlow;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Observability.Tracing;\r\n\r\npublic class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var services = new ServiceCollection();\r\n\r\n        // Register NPipeline services from the current assembly\r\n        // This will discover and register:\r\n        // - IPipelineRunner\r\n        // - Any IPipelineDefinition implementations\r\n        // - Any INode implementations\r\n        // - Any INodeErrorHandler implementations\r\n        // - Any IPipelineErrorHandler implementations\r\n        // - Any IDeadLetterSink implementations\r\n        // - Any ILineageSink implementations\r\n        // - Any IPipelineLineageSink implementations\r\n        // - Any IPipelineLineageSinkProvider implementations\r\n        services.AddNPipeline(Assembly.GetExecutingAssembly());\r\n\r\n        // You can also add other services as needed\r\n        // services.AddSingleton<IMyCustomService, MyCustomService>();\r\n\r\n        var serviceProvider = services.BuildServiceProvider();\r\n\r\n        // Resolve the pipeline runner\r\n        var runner = serviceProvider.GetRequiredService<IPipelineRunner>();\r\n\r\n        // Now you can run your pipeline\r\n        await runner.RunAsync<MyPipelineDefinition>();\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits of Assembly Scanning:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Automatic discovery - no need to manually register each component"}),"\n",(0,s.jsx)(n.li,{children:"Convenient for larger projects with many components"}),"\n",(0,s.jsx)(n.li,{children:"Works with components in multiple assemblies"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"fluent-configuration-manual-registration",children:"Fluent Configuration (Manual Registration)"}),"\n",(0,s.jsx)(n.p,{children:"Use this approach for explicit, fine-grained control over service registration. This is ideal when:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You want to avoid reflection overhead"}),"\n",(0,s.jsx)(n.li,{children:"You have a specific set of components to register"}),"\n",(0,s.jsxs)(n.li,{children:["You need custom ",(0,s.jsx)(n.code,{children:"ServiceLifetime"})," control for certain components"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using Microsoft.Extensions.DependencyInjection;\r\nusing NPipeline.Extensions.DependencyInjection;\r\nusing NPipeline.DataFlow;\r\nusing NPipeline.Nodes;\r\n\r\npublic class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var services = new ServiceCollection();\r\n\r\n        // Register NPipeline services using fluent configuration\r\n        services.AddNPipeline(builder => builder\r\n            // Register nodes with default transient lifetime\r\n            .AddNode<MySourceNode>()\r\n            .AddNode<MyTransformNode>()\r\n            .AddNode<MySinkNode>()\r\n            \r\n            // Register pipeline definition\r\n            .AddPipeline<MyPipelineDefinition>()\r\n            \r\n            // Register error handlers\r\n            .AddErrorHandler<MyErrorHandler>()\r\n            \r\n            // Register lineage sinks\r\n            .AddLineageSink<MyLineageSink>()\r\n        );\r\n\r\n        // You can also add other services as needed\r\n        services.AddSingleton<IMyCustomService, MyCustomService>();\r\n\r\n        var serviceProvider = services.BuildServiceProvider();\r\n\r\n        var runner = serviceProvider.GetRequiredService<IPipelineRunner>();\r\n        await runner.RunAsync<MyPipelineDefinition>();\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits of Fluent Configuration:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"No reflection overhead - explicit component registration"}),"\n",(0,s.jsx)(n.li,{children:"Clear, discoverable API via IntelliSense"}),"\n",(0,s.jsx)(n.li,{children:"Type-safe registration with compile-time verification"}),"\n",(0,s.jsxs)(n.li,{children:["Flexible ",(0,s.jsx)(n.code,{children:"ServiceLifetime"})," control per component"]}),"\n",(0,s.jsx)(n.li,{children:"Better for small/medium projects or performance-critical scenarios"}),"\n",(0,s.jsx)(n.li,{children:"Can mix manual registration with selective assembly scanning"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"mixed-approach-manual--assembly-scanning",children:"Mixed Approach (Manual + Assembly Scanning)"}),"\n",(0,s.jsx)(n.p,{children:"You can combine both approaches by registering some components manually and scanning for others:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"services.AddNPipeline(builder => builder\r\n    // Register high-performance or singleton components manually\r\n    .AddNode<SpecialCachedNode>(ServiceLifetime.Singleton)\r\n    .AddPipeline<MyPipeline>()\r\n    \r\n    // Then scan remaining components from assemblies\r\n    .ScanAssemblies(\r\n        Assembly.GetExecutingAssembly(),\r\n        typeof(PluginProvider).Assembly\r\n    )\r\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"npipelineservicebuilder-api",children:"NPipelineServiceBuilder API"}),"\n",(0,s.jsx)(n.p,{children:"The fluent builder provides the following methods:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Register nodes (default: Transient)\r\nAddNode<TNode>()\r\nAddNode<TNode>(ServiceLifetime lifetime)\r\n\r\n// Register pipelines (default: Transient)\r\nAddPipeline<TPipeline>()\r\nAddPipeline<TPipeline>(ServiceLifetime lifetime)\r\n\r\n// Register error handlers (default: Transient)\r\nAddErrorHandler<THandler>()\r\nAddErrorHandler<THandler>(ServiceLifetime lifetime)\r\n\r\n// Register pipeline error handlers (default: Transient)\r\nAddPipelineErrorHandler<THandler>()\r\nAddPipelineErrorHandler<THandler>(ServiceLifetime lifetime)\r\n\r\n// Register sinks (default: Transient)\r\nAddDeadLetterSink<TSink>()\r\nAddDeadLetterSink<TSink>(ServiceLifetime lifetime)\r\n\r\nAddLineageSink<TSink>()\r\nAddLineageSink<TSink>(ServiceLifetime lifetime)\r\n\r\nAddPipelineLineageSink<TSink>()\r\nAddPipelineLineageSink<TSink>(ServiceLifetime lifetime)\r\n\r\n// Register providers (default: Transient)\r\nAddLineageSinkProvider<TProvider>()\r\nAddLineageSinkProvider<TProvider>(ServiceLifetime lifetime)\r\n\r\n// Scan assemblies for implementations\r\nScanAssemblies(params Assembly[] assemblies)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"automatic-registration",children:"Automatic Registration"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"AddNPipeline"})," automatically scans the provided assemblies for:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"IPipelineDefinition"})}),": Your pipeline definitions are registered as transient services, meaning a new instance is created for each pipeline run."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"INode"})}),": Your custom node implementations (sources, transforms, sinks, join nodes, aggregation nodes) are registered as transient services by default. This ensures node isolation between pipeline runs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"INodeErrorHandler"})," / ",(0,s.jsx)(n.code,{children:"IPipelineErrorHandler"})]}),": Custom error handlers are also registered."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"IDeadLetterSink"})}),": Dead letter sink implementations for handling failed items."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"ILineageSink"})," / ",(0,s.jsx)(n.code,{children:"IPipelineLineageSink"})]}),": Lineage tracking sink implementations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"IPipelineLineageSinkProvider"})}),": Providers for creating lineage sinks dynamically."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"core-services-registered",children:"Core Services Registered"}),"\n",(0,s.jsxs)(n.p,{children:["In addition to scanning for your implementations, ",(0,s.jsx)(n.code,{children:"AddNPipeline"})," registers these core NPipeline services:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"IPipelineFactory"})}),": Factory for creating pipeline instances"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"IPipelineRunner"})}),": Main pipeline execution service"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"INodeFactory"})}),": DI-aware node factory (replaces default factory)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"IErrorHandlerFactory"})}),": Factory for creating error handlers and dead-letter sinks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"ILineageFactory"})}),": Factory for creating lineage sinks and resolving lineage collectors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"IObservabilityFactory"})}),": Factory for resolving observability collectors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Execution services"}),": CountingService, MergeStrategySelector, PipeMergeService, etc."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Observability services"}),": LineageService, BranchService, NodeExecutor, etc."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error handling"}),": ErrorHandlingService"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Persistence"}),": PersistenceService"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"overriding-default-registrations",children:"Overriding Default Registrations"}),"\n",(0,s.jsx)(n.p,{children:"You can override or customize default registrations if needed. For example, if you want a singleton instance of a particular node:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"services.AddNPipeline(Assembly.GetExecutingAssembly());\r\nservices.AddSingleton<MySingletonNode>(); // Overrides the default transient registration\n"})}),"\n",(0,s.jsx)(n.h2,{id:"running-pipelines-with-di",children:"Running Pipelines with DI"}),"\n",(0,s.jsx)(n.p,{children:"The dependency injection extension provides convenient extension methods for running pipelines directly from the service provider."}),"\n",(0,s.jsx)(n.h3,{id:"simple-pipeline-execution",children:"Simple Pipeline Execution"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Run pipeline without parameters\r\nawait serviceProvider.RunPipelineAsync<MyPipelineDefinition>();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"pipeline-execution-with-parameters",children:"Pipeline Execution with Parameters"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// Run pipeline with parameters\r\nvar parameters = new Dictionary<string, object>\r\n{\r\n    ["InputPath"] = "/data/input.csv",\r\n    ["OutputPath"] = "/data/output.csv",\r\n    ["BatchSize"] = 1000\r\n};\r\n\r\nawait serviceProvider.RunPipelineAsync<MyPipelineDefinition>(parameters);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"registering-pipelines-and-nodes-with-dependencies",children:"Registering Pipelines and Nodes with Dependencies"}),"\n",(0,s.jsxs)(n.p,{children:["The extension provides a set of ",(0,s.jsx)(n.code,{children:"IServiceCollection"})," extension methods to register your pipeline components. The primary method is ",(0,s.jsx)(n.code,{children:"AddNPipeline()"}),", which sets up the core services required to run pipelines."]}),"\n",(0,s.jsx)(n.p,{children:"You can then register your pipeline definitions and the nodes they depend on."}),"\n",(0,s.jsxs)(n.p,{children:["Let's consider a pipeline where a transform node relies on an external service, ",(0,s.jsx)(n.code,{children:"IEmailService"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. Define your services and nodes:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.DataFlow;\r\nusing NPipeline.DataFlow.DataPipes;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Observability.Tracing;\r\nusing NPipeline.Pipeline;\r\n\r\n// A service your node depends on\r\npublic interface IEmailService\r\n{\r\n    Task SendEmailAsync(string to, string subject, string body);\r\n}\r\n\r\npublic class EmailService : IEmailService\r\n{\r\n    public Task SendEmailAsync(string to, string subject, string body)\r\n    {\r\n        Console.WriteLine($"Sending email to {to}: {subject}");\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n\r\n// A transform that uses the service\r\npublic sealed class NotificationTransform : TransformNode<string, string>\r\n{\r\n    private readonly IEmailService _emailService;\r\n\r\n    public NotificationTransform(IEmailService emailService)\r\n    {\r\n        _emailService = emailService;\r\n    }\r\n\r\n    public override Task<string> ExecuteAsync(\r\n        string item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken = default)\r\n    {\r\n        _emailService.SendEmailAsync(\r\n            "admin@example.com",\r\n            "Processing Item",\r\n            $"Item \'{item}\' was processed.");\r\n        return Task.FromResult($"Notified for {item}");\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Define your pipeline:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.DataFlow;\r\nusing NPipeline.DataFlow.DataPipes;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Obersability.Tracing;\r\nusing NPipeline.Pipeline;\r\n\r\npublic sealed class TestStringSource : SourceNode<string>\r\n{\r\n    public IDataPipe<string> ExecuteAsync(\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken = default)\r\n    {\r\n        static IAsyncEnumerable<string> Stream()\r\n        {\r\n            return Generate();\r\n\r\n            async IAsyncEnumerable<string> Generate()\r\n            {\r\n                var data = new[] { "A", "B", "C" };\r\n                foreach (var item in data)\r\n                {\r\n                    yield return item;\r\n                }\r\n            }\r\n        }\r\n\r\n        return new StreamingDataPipe<string>(Stream());\r\n    }\r\n}\r\n\r\npublic sealed class TestStringSink : SinkNode<string>\r\n{\r\n    public async Task ExecuteAsync(\r\n        IDataPipe<string> input,\r\n        PipelineContext context,\r\n        IPipelineActivity parentActivity,\r\n        CancellationToken cancellationToken = default)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            Console.WriteLine($"Result: {item}");\r\n        }\r\n    }\r\n}\r\n\r\npublic class MyPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<TestStringSource, string>();\r\n        var transformHandle = builder.AddTransform<NotificationTransform, string, string>();\r\n        var sinkHandle = builder.AddSink<TestStringSink, string>();\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. Register everything with the DI container:"})}),"\n",(0,s.jsxs)(n.p,{children:["In your ",(0,s.jsx)(n.code,{children:"Program.cs"})," or ",(0,s.jsx)(n.code,{children:"Startup.cs"}),", use the ",(0,s.jsx)(n.code,{children:"AddNPipeline"})," extension method."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using NPipeline.DataFlow;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\npublic class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var services = new ServiceCollection();\r\n\r\n        // 1. Add required NPipeline services, scanning this assembly for pipeline components\r\n        services.AddNPipeline(Assembly.GetExecutingAssembly());\r\n\r\n        // 2. Register your application's services\r\n        services.AddSingleton<IEmailService, EmailService>();\r\n\r\n        var serviceProvider = services.BuildServiceProvider();\r\n\r\n        // 3. Run the pipeline using the service provider\r\n        await serviceProvider.RunPipelineAsync<MyPipelineDefinition>();\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AddNPipeline(Assembly.GetExecutingAssembly())"}),": Registers core NPipeline services and automatically scans the provided assembly for pipeline definitions and nodes."]}),"\n",(0,s.jsxs)(n.li,{children:["When nodes are instantiated (like ",(0,s.jsx)(n.code,{children:"NotificationTransform"}),"), the service provider automatically resolves their dependencies."]}),"\n",(0,s.jsxs)(n.li,{children:["This ensures that ",(0,s.jsx)(n.code,{children:"NotificationTransform"})," receives its ",(0,s.jsx)(n.code,{children:"IEmailService"})," dependency from the container."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"DiContainerNodeFactory"})," is used instead of the default ",(0,s.jsx)(n.code,{children:"DefaultNodeFactory"}),", enabling constructor injection for nodes."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"resolving-services-within-nodes",children:"Resolving Services within Nodes"}),"\n",(0,s.jsx)(n.p,{children:"Nodes can receive dependencies through constructor injection, just like any other service in your DI container."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.DataFlow;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\npublic interface IDataService\r\n{\r\n    Task<string> FetchDataAsync(int id);\r\n}\r\n\r\npublic class MyDataService : IDataService\r\n{\r\n    public Task<string> FetchDataAsync(int id) => Task.FromResult($"Data for {id}");\r\n}\r\n\r\npublic class MyDependentTransform(IDataService dataService) : TransformNode<int, string>\r\n{\r\n    public override Task<string> ExecuteAsync(int item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        var data = dataService.FetchDataAsync(item).Result;\r\n        return Task.FromResult($"Transformed: {data}");\r\n    }\r\n}\r\n\r\n// Register services and node\r\n// services.AddSingleton<IDataService, MyDataService>();\r\n// services.AddNPipeline(Assembly.GetExecutingAssembly());\n'})}),"\n",(0,s.jsx)(n.h2,{id:"di-specific-node-factory-behavior",children:"DI-Specific Node Factory Behavior"}),"\n",(0,s.jsxs)(n.p,{children:["When using dependency injection, the ",(0,s.jsx)(n.code,{children:"DiContainerNodeFactory"})," is registered instead of the default ",(0,s.jsx)(n.code,{children:"DefaultNodeFactory"}),". This provides several benefits:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Constructor Injection"}),": Nodes can receive dependencies through their constructors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service Lifetime Management"}),": Nodes respect the service lifetimes configured in the DI container"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scoped Services"}),": Nodes can receive scoped services that are shared within a pipeline execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic Disposal"}),": The DI container manages disposal of nodes and their dependencies"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"service-lifetimes-in-pipelines",children:"Service Lifetimes in Pipelines"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transient"}),": New instance created for each node (default for nodes)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Singleton"}),": Single instance shared across all pipeline runs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scoped"}),": Instance shared within a single pipeline execution"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"benefits-of-using-dependency-injection",children:"Benefits of Using Dependency Injection"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Decoupling"}),": Your nodes no longer need to create their own dependencies. They simply declare what they need in their constructors."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lifecycle Management"}),": The DI container manages the lifetime of your services (singleton, scoped, transient)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testability"}),": It becomes much easier to test your nodes by providing mock implementations of their dependencies."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configuration"}),": You can easily inject configuration objects (",(0,s.jsx)(n.code,{children:"IOptions<T>"}),") into your nodes to change their behavior without modifying code."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service Discovery"}),": The DI container automatically discovers and registers your pipeline components."]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"link-related-topics",children:["\ud83d\udd17"," Related Topics"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/extensions/parallelism",children:"Parallelism"})}),": Learn how to execute parts of your pipeline in parallel to improve performance."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/extensions/testing",children:"Testing Extensions"})}),": Discover utilities for testing your pipelines and nodes effectively."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/",children:"NPipeline Extensions Index"})}),": Return to the extensions overview."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>c});var r=i(6540);const s={},t=r.createContext(s);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);