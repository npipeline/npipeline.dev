"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[5784],{4466:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"extensions/testing/fluent-assertions","title":"FluentAssertions","description":"Use the popular FluentAssertions library to write strongly-typed, descriptive, and readable tests for your NPipelines.","source":"@site/docs/extensions/testing/fluent-assertions.md","sourceDirName":"extensions/testing","slug":"/extensions/testing/fluent-assertions","permalink":"/npipeline.dev/docs/extensions/testing/fluent-assertions","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"FluentAssertions","description":"Use the popular FluentAssertions library to write strongly-typed, descriptive, and readable tests for your NPipelines.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"AwesomeAssertions","permalink":"/npipeline.dev/docs/extensions/testing/awesome-assertions"},"next":{"title":"Connectors Overview","permalink":"/npipeline.dev/docs/connectors"}}');var t=s(4848),i=s(8453);const o={title:"FluentAssertions",description:"Use the popular FluentAssertions library to write strongly-typed, descriptive, and readable tests for your NPipelines.",sidebar_position:3},l="FluentAssertions Integration",a={},d=[{value:"Installation",id:"installation",level:2},{value:"Pipeline Execution Result Assertions",id:"pipeline-execution-result-assertions",level:2},{value:"Pipeline Result Assertions",id:"pipeline-result-assertions",level:3},{value:"Sink Node Assertions",id:"sink-node-assertions",level:2},{value:"Complete Example: Testing with Error Handling",id:"complete-example-testing-with-error-handling",level:2},{value:"Why Use FluentAssertions?",id:"why-use-fluentassertions",level:2},{value:"\u27a1\ufe0f Next Steps",id:"arrow_right-next-steps",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"fluentassertions-integration",children:"FluentAssertions Integration"})}),"\n",(0,t.jsxs)(n.p,{children:["For developers who prefer the widely-used ",(0,t.jsx)(n.a,{href:"https://fluentassertions.com/",children:"FluentAssertions"})," library, ",(0,t.jsx)(n.code,{children:"NPipeline.Extensions.Testing.FluentAssertions"})," provides a seamless integration. This extension allows you to use the rich, fluent, and highly readable assertion syntax of FluentAssertions to validate your pipeline's output and execution results."]}),"\n",(0,t.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,t.jsxs)(n.p,{children:["To use this integration, add both the ",(0,t.jsx)(n.code,{children:"FluentAssertions"})," and the NPipeline extension package to your test project:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"dotnet add package FluentAssertions\r\ndotnet add package NPipeline.Extensions.Testing.FluentAssertions\n"})}),"\n",(0,t.jsx)(n.h2,{id:"pipeline-execution-result-assertions",children:"Pipeline Execution Result Assertions"}),"\n",(0,t.jsxs)(n.p,{children:["With ",(0,t.jsx)(n.code,{children:"NPipeline.Extensions.Testing"}),", you can use ",(0,t.jsx)(n.code,{children:"PipelineTestHarness<T>"})," to test your pipelines with fluent assertions on the execution results:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.Extensions.Testing;\r\nusing NPipeline.Extensions.Testing.FluentAssertions;\r\nusing Xunit;\r\nusing FluentAssertions;\r\n\r\npublic class MyPipelineTests\r\n{\r\n    [Fact]\r\n    public async Task Pipeline_ShouldCompleteSuccessfully()\r\n    {\r\n        // Arrange & Act\r\n        var result = await new PipelineTestHarness<MyPipeline>()\r\n            .WithParameter("input", testData)\r\n            .RunAsync();\r\n\r\n        // Assert - fluent API with FluentAssertions\r\n        result\r\n            .ShouldBeSuccessful()\r\n            .ShouldHaveNoErrors()\r\n            .ShouldCompleteWithin(TimeSpan.FromSeconds(5));\r\n    }\r\n\r\n    [Fact]\r\n    public async Task Pipeline_ShouldCaptureErrorsGracefully()\r\n    {\r\n        // Arrange & Act\r\n        var result = await new PipelineTestHarness<MyPipeline>()\r\n            .WithParameter("input", invalidData)\r\n            .CaptureErrors()\r\n            .RunAsync();\r\n\r\n        // Assert\r\n        result\r\n            .ShouldFail()\r\n            .ShouldHaveErrorOfType<InvalidOperationException>()\r\n            .ShouldHaveErrorCount(1);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"pipeline-result-assertions",children:"Pipeline Result Assertions"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"FluentAssertions"})," integration provides these assertion extension methods:"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Method"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ShouldBeSuccessful()"})}),(0,t.jsx)(n.td,{children:"Assert pipeline executed successfully (no uncaught exceptions)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ShouldFail()"})}),(0,t.jsx)(n.td,{children:"Assert pipeline execution failed"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ShouldHaveNoErrors()"})}),(0,t.jsx)(n.td,{children:"Assert no errors were captured"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ShouldHaveErrorCount(int)"})}),(0,t.jsx)(n.td,{children:"Assert specific number of errors were captured"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ShouldHaveErrorOfType<TException>()"})}),(0,t.jsx)(n.td,{children:"Assert at least one error of a specific type"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ShouldCompleteWithin(TimeSpan)"})}),(0,t.jsx)(n.td,{children:"Assert execution completed within duration"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"All methods return the result for fluent chaining."}),"\n",(0,t.jsx)(n.h2,{id:"sink-node-assertions",children:"Sink Node Assertions"}),"\n",(0,t.jsx)(n.p,{children:"For asserting on individual sink nodes, the existing sink extensions still apply:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.Extensions.Testing.FluentAssertions;\r\nusing FluentAssertions;\r\n\r\n[Fact]\r\npublic async Task Sink_Should_Receive_Data()\r\n{\r\n    // Arrange\r\n    var sink = new InMemorySinkNode<string>();\r\n    var context = new PipelineContext();\r\n    var data = new ListDataPipe<string>(new[] { "a", "b", "c" });\r\n\r\n    // Act\r\n    await sink.ExecuteAsync(data, context, CancellationToken.None);\r\n\r\n    // Assert\r\n    sink.ShouldHaveReceived(3);\r\n    sink.ShouldContain("a");\r\n    sink.ShouldContain(x => x.Length == 1);\r\n    sink.ShouldOnlyContain(x => !string.IsNullOrEmpty(x));\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"complete-example-testing-with-error-handling",children:"Complete Example: Testing with Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.Extensions.Testing;\r\nusing NPipeline.Extensions.Testing.FluentAssertions;\r\nusing Xunit;\r\nusing FluentAssertions;\r\n\r\npublic class PipelineWithErrorHandlingTests\r\n{\r\n    [Fact]\r\n    public async Task Pipeline_With_Error_Capturing_Should_Report_Errors()\r\n    {\r\n        // Arrange\r\n        var result = await new PipelineTestHarness<PipelineThatCanFail>()\r\n            .WithParameter("input", problemData)\r\n            .CaptureErrors(PipelineErrorDecision.ContinueWithoutNode)\r\n            .RunAsync();\r\n\r\n        // Assert - fluent assertions make this very readable\r\n        result\r\n            .ShouldHaveErrorCount(2)\r\n            .ShouldHaveErrorOfType<ValidationException>()\r\n            .ShouldCompleteWithin(TimeSpan.FromSeconds(10));\r\n        \r\n        // Can also access the sink\r\n        var sink = result.GetSink<InMemorySinkNode<ProcessedData>>();\r\n        sink.ShouldHaveReceived(expectedSuccessfulCount);\r\n    }\r\n\r\n    [Fact]\r\n    public async Task Pipeline_Should_Preserve_Custom_Error_Handlers()\r\n    {\r\n        // Arrange - create a context with custom error handler\r\n        var errorLog = new List<string>();\r\n        var customHandler = new LoggingErrorHandler(errorLog);\r\n        \r\n        var context = new PipelineContext();\r\n        context.PipelineErrorHandler = customHandler;\r\n\r\n        // Act - test harness will chain custom handler with capturing handler\r\n        var result = await new PipelineTestHarness<MyPipeline>(context)\r\n            .WithParameter("input", testData)\r\n            .CaptureErrors()\r\n            .RunAsync();\r\n\r\n        // Assert - both error capturing AND custom logging happened\r\n        errorLog.Should().NotBeEmpty("custom handler should have logged");\r\n        result.Errors.Should().NotBeEmpty("errors should be captured");\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"why-use-fluentassertions",children:"Why Use FluentAssertions?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Strongly-Typed and Discoverable:"})," The fluent API guides you to the right assertions, with excellent IntelliSense support."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rich Collection Support:"})," FluentAssertions has an extensive set of assertions for collections, allowing you to check for order, equivalency, subsets, and more."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Clear Failure Messages:"})," When a test fails, FluentAssertions provides exceptionally clear and detailed error messages that pinpoint the exact cause of the failure, making debugging much faster."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Chainable Assertions:"})," Pipeline result assertions chain together, allowing elegant multi-assertion test patterns."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This integration allows you to leverage the full power of FluentAssertions to write robust and maintainable tests for your NPipelines."}),"\n",(0,t.jsxs)(n.h2,{id:"arrow_right-next-steps",children:["\u27a1\ufe0f"," Next Steps"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/npipeline.dev/docs/extensions/testing/awesome-assertions",children:"AwesomeAssertions"})}),": If you prefer AwesomeAssertions, NPipeline also provides a similar integration for that library."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/npipeline.dev/docs/extensions/testing",children:"Testing Extensions"})}),": Return to the main testing documentation for more testing patterns and utilities."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/npipeline.dev/docs/connectors",children:"Connectors"})}),": Explore the available connectors for reading from and writing to external systems like CSV files."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var r=s(6540);const t={},i=r.createContext(t);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);