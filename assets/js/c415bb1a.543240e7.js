"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[8674],{28453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>r});var i=a(96540);const t={},l=i.createContext(t);function o(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(l.Provider,{value:n},e.children)}},61443:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"extensions/lineage/use-cases","title":"Lineage Use Cases","description":"Common use cases and practical examples for NPipeline Lineage extension.","source":"@site/docs/extensions/lineage/use-cases.md","sourceDirName":"extensions/lineage","slug":"/extensions/lineage/use-cases","permalink":"/docs/extensions/lineage/use-cases","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Lineage Use Cases","description":"Common use cases and practical examples for NPipeline Lineage extension."},"sidebar":"docsSidebar","previous":{"title":"Lineage Performance","permalink":"/docs/extensions/lineage/performance"},"next":{"title":"NPipeline Lineage Extension","permalink":"/docs/extensions/lineage"}}');var t=a(74848),l=a(28453);const o={title:"Lineage Use Cases",description:"Common use cases and practical examples for NPipeline Lineage extension."},r="Lineage Use Cases",s={},c=[{value:"Data Governance",id:"data-governance",level:2},{value:"Compliance Tracking",id:"compliance-tracking",level:3},{value:"Audit Report Generation",id:"audit-report-generation",level:3},{value:"Sensitive Data Handling",id:"sensitive-data-handling",level:3},{value:"Debugging",id:"debugging",level:2},{value:"Root Cause Analysis",id:"root-cause-analysis",level:3},{value:"Identify Problematic Nodes",id:"identify-problematic-nodes",level:3},{value:"Debug Specific Data Items",id:"debug-specific-data-items",level:3},{value:"Impact Analysis",id:"impact-analysis",level:2},{value:"Find Affected Downstream Processes",id:"find-affected-downstream-processes",level:3},{value:"Before Change Analysis",id:"before-change-analysis",level:3},{value:"Dependency Mapping",id:"dependency-mapping",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:2},{value:"Find Slow Transformations",id:"find-slow-transformations",level:3},{value:"Throughput Analysis",id:"throughput-analysis",level:3},{value:"Cardinality Analysis",id:"cardinality-analysis",level:3},{value:"Data Science and Analytics",id:"data-science-and-analytics",level:2},{value:"Dataset Provenance",id:"dataset-provenance",level:3},{value:"Model Training Lineage",id:"model-training-lineage",level:3},{value:"Data Cataloging",id:"data-cataloging",level:3},{value:"Complete Examples",id:"complete-examples",level:2},{value:"Example 1: ETL Pipeline with Lineage",id:"example-1-etl-pipeline-with-lineage",level:3},{value:"Example 2: Debugging with Lineage",id:"example-2-debugging-with-lineage",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Appropriate Sampling",id:"1-use-appropriate-sampling",level:3},{value:"2. Enable Redaction for Sensitive Data",id:"2-enable-redaction-for-sensitive-data",level:3},{value:"3. Use Deterministic Sampling for Reproducibility",id:"3-use-deterministic-sampling-for-reproducibility",level:3},{value:"4. Implement Custom Sinks for Production",id:"4-implement-custom-sinks-for-production",level:3},{value:"5. Analyze Lineage Regularly",id:"5-analyze-lineage-regularly",level:3},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"lineage-use-cases",children:"Lineage Use Cases"})}),"\n",(0,t.jsx)(n.p,{children:"This guide covers common use cases and practical examples for NPipeline Lineage extension."}),"\n",(0,t.jsx)(n.h2,{id:"data-governance",children:"Data Governance"}),"\n",(0,t.jsx)(n.p,{children:"Maintain complete audit trails for regulatory compliance:"}),"\n",(0,t.jsx)(n.h3,{id:"compliance-tracking",children:"Compliance Tracking"}),"\n",(0,t.jsx)(n.p,{children:"Track all data transformations for GDPR, HIPAA, SOX compliance:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"services.AddNPipelineLineage<DatabaseLineageSink>();\n\n// In pipeline\nbuilder.EnableItemLevelLineage(options =>\n{\n    options.SampleEvery = 1;  // 100% for compliance\n    options.DeterministicSampling = true;  // Consistent tracking\n    options.RedactData = false;  // Keep data for audit\n    options.MaterializationCap = int.MaxValue;  // Complete records\n    options.OverflowPolicy = LineageOverflowPolicy.Materialize;\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why This Works:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Complete audit trail of all data movements"}),"\n",(0,t.jsx)(n.li,{children:"Immutable records for legal requirements"}),"\n",(0,t.jsx)(n.li,{children:"Timestamped transformations for accountability"}),"\n",(0,t.jsx)(n.li,{children:"Queryable lineage for audits"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"audit-report-generation",children:"Audit Report Generation"}),"\n",(0,t.jsx)(n.p,{children:"Generate compliance reports from lineage data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public sealed class ComplianceReportGenerator\n{\n    private readonly ILineageCollector _collector;\n\n    public ComplianceReportGenerator(ILineageCollector collector)\n    {\n        _collector = collector;\n    }\n\n    public ComplianceReport GenerateReport(DateTime startDate, DateTime endDate)\n    {\n        var allLineage = _collector.GetAllLineageInfo();\n        \n        var report = new ComplianceReport\n        {\n            PeriodStart = startDate,\n            PeriodEnd = endDate,\n            TotalItemsProcessed = allLineage.Count,\n            TransformationsApplied = allLineage\n                .SelectMany(li => li.LineageHops)\n                .Count(),\n            UniqueNodesInvolved = allLineage\n                .SelectMany(li => li.TraversalPath)\n                .Distinct()\n                .Count()\n        };\n        \n        return report;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"sensitive-data-handling",children:"Sensitive Data Handling"}),"\n",(0,t.jsx)(n.p,{children:"Track sensitive data without storing actual values:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"builder.EnableItemLevelLineage(options =>\n{\n    options.RedactData = true;  // Don't store PII\n    options.SampleEvery = 1;  // Track all items\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Compliance with data protection regulations"}),"\n",(0,t.jsx)(n.li,{children:"Audit trail without exposing sensitive data"}),"\n",(0,t.jsx)(n.li,{children:"Reduced memory footprint"}),"\n",(0,t.jsx)(n.li,{children:"Maintains transformation history"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"debugging",children:"Debugging"}),"\n",(0,t.jsx)(n.p,{children:"Quickly identify which node introduced issues:"}),"\n",(0,t.jsx)(n.h3,{id:"root-cause-analysis",children:"Root Cause Analysis"}),"\n",(0,t.jsx)(n.p,{children:"Trace problems back to their source:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public sealed class LineageDebugger\n{\n    private readonly ILineageCollector _collector;\n    private readonly ILogger _logger;\n\n    public LineageDebugger(ILineageCollector collector, ILogger<LineageDebugger> logger)\n    {\n        _collector = collector;\n        _logger = logger;\n    }\n\n    public void DebugItem(Guid lineageId)\n    {\n        var lineageInfo = _collector.GetLineageInfo(lineageId);\n        \n        if (lineageInfo == null)\n        {\n            _logger.LogWarning("Lineage {LineageId} not found", lineageId);\n            return;\n        }\n\n        _logger.LogInformation("=== Lineage Debug Report ===");\n        _logger.LogInformation("Lineage ID: {LineageId}", lineageInfo.LineageId);\n        _logger.LogInformation("Traversal Path: {Path}", \n            string.Join(" \u2192 ", lineageInfo.TraversalPath));\n        \n        foreach (var hop in lineageInfo.LineageHops)\n        {\n            _logger.LogInformation("Hop {Index}: {NodeId}", \n                lineageInfo.LineageHops.IndexOf(hop), hop.NodeId);\n            _logger.LogInformation("  Outcome: {Outcome}", hop.Outcome);\n            _logger.LogInformation("  Cardinality: {Cardinality}", hop.Cardinality);\n            _logger.LogInformation("  Input Count: {InputCount}", hop.InputCount);\n            _logger.LogInformation("  Output Count: {OutputCount}", hop.OutputCount);\n            \n            if (hop.Outcome != "Success")\n            {\n                _logger.LogError("  \u26a0\ufe0f  Issue detected at this hop!");\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"identify-problematic-nodes",children:"Identify Problematic Nodes"}),"\n",(0,t.jsx)(n.p,{children:"Find nodes with high failure rates:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public sealed class NodeHealthAnalyzer\n{\n    private readonly ILineageCollector _collector;\n\n    public NodeHealthAnalyzer(ILineageCollector collector)\n    {\n        _collector = collector;\n    }\n\n    public Dictionary<string, NodeHealth> AnalyzeNodeHealth()\n    {\n        var allLineage = _collector.GetAllLineageInfo();\n        var nodeHealth = new Dictionary<string, NodeHealth>();\n        \n        foreach (var lineage in allLineage)\n        {\n            foreach (var hop in lineage.LineageHops)\n            {\n                if (!nodeHealth.ContainsKey(hop.NodeId))\n                {\n                    nodeHealth[hop.NodeId] = new NodeHealth\n                    {\n                        NodeId = hop.NodeId,\n                        TotalHops = 0,\n                        SuccessCount = 0,\n                        FailureCount = 0\n                    };\n                }\n                \n                var health = nodeHealth[hop.NodeId];\n                health.TotalHops++;\n                \n                if (hop.Outcome == "Success")\n                    health.SuccessCount++;\n                else\n                    health.FailureCount++;\n            }\n        }\n        \n        // Calculate success rates\n        foreach (var health in nodeHealth.Values)\n        {\n            health.SuccessRate = (double)health.SuccessCount / health.TotalHops;\n        }\n        \n        return nodeHealth;\n    }\n}\n\npublic sealed record NodeHealth(\n    string NodeId,\n    int TotalHops,\n    int SuccessCount,\n    int FailureCount,\n    double SuccessRate\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"debug-specific-data-items",children:"Debug Specific Data Items"}),"\n",(0,t.jsx)(n.p,{children:"Trace exact journey of a problematic item:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// After pipeline execution\nvar collector = serviceProvider.GetRequiredService<ILineageCollector>();\n\n// Find lineage for a specific item\nvar problematicItemId = Guid.Parse("your-item-id-here");\nvar lineageInfo = collector.GetLineageInfo(problematicItemId);\n\nif (lineageInfo != null)\n{\n    Console.WriteLine($"Item entered at: {lineageInfo.LineageHops[0].NodeId}");\n    \n    foreach (var hop in lineageInfo.LineageHops)\n    {\n        Console.WriteLine($"  \u2192 {hop.NodeId}");\n        Console.WriteLine($"    Outcome: {hop.Outcome}");\n        Console.WriteLine($"    Cardinality: {hop.Cardinality}");\n        Console.WriteLine($"    Input: {hop.InputCount}, Output: {hop.OutputCount}");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"impact-analysis",children:"Impact Analysis"}),"\n",(0,t.jsx)(n.p,{children:"Understand dependencies before making changes:"}),"\n",(0,t.jsx)(n.h3,{id:"find-affected-downstream-processes",children:"Find Affected Downstream Processes"}),"\n",(0,t.jsx)(n.p,{children:"Identify all items that passed through a specific node:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public sealed class ImpactAnalyzer\n{\n    private readonly ILineageCollector _collector;\n\n    public ImpactAnalyzer(ILineageCollector collector)\n    {\n        _collector = collector;\n    }\n\n    public ImpactReport AnalyzeImpact(string nodeId)\n    {\n        var allLineage = _collector.GetAllLineageInfo();\n        \n        var affectedItems = allLineage\n            .Where(li => li.TraversalPath.Contains(nodeId))\n            .ToList();\n        \n        var report = new ImpactReport\n        {\n            NodeId = nodeId,\n            AffectedItemCount = affectedItems.Count,\n            AffectedLineageIds = affectedItems.Select(li => li.LineageId).ToList(),\n            DownstreamNodes = GetDownstreamNodes(nodeId, allLineage)\n        };\n        \n        return report;\n    }\n    \n    private List<string> GetDownstreamNodes(string nodeId, IReadOnlyList<ILineageInfo> allLineage)\n    {\n        var downstream = new HashSet<string>();\n        \n        foreach (var lineage in allLineage)\n        {\n            var nodeIndex = lineage.TraversalPath.IndexOf(nodeId);\n            if (nodeIndex >= 0 && nodeIndex < lineage.TraversalPath.Count - 1)\n            {\n                downstream.Add(lineage.TraversalPath[nodeIndex + 1]);\n            }\n        }\n        \n        return downstream.ToList();\n    }\n}\n\npublic sealed record ImpactReport(\n    string NodeId,\n    int AffectedItemCount,\n    List<Guid> AffectedLineageIds,\n    List<string> DownstreamNodes\n);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"before-change-analysis",children:"Before Change Analysis"}),"\n",(0,t.jsx)(n.p,{children:"Assess impact before modifying a node:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class Program\n{\n    public static async Task Main(string[] args)\n    {\n        // Run pipeline with lineage\n        await RunPipelineWithLineage();\n        \n        // Analyze impact of changing "ValidationNode"\n        var analyzer = serviceProvider.GetRequiredService<ImpactAnalyzer>();\n        var impact = analyzer.AnalyzeImpact("ValidationNode");\n        \n        Console.WriteLine($"Impact Analysis for {impact.NodeId}:");\n        Console.WriteLine($"  Affected Items: {impact.AffectedItemCount}");\n        Console.WriteLine($"  Downstream Nodes: {string.Join(", ", impact.DownstreamNodes)}");\n        \n        if (impact.AffectedItemCount > 10000)\n        {\n            Console.WriteLine("  \u26a0\ufe0f  High impact - consider careful testing");\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"dependency-mapping",children:"Dependency Mapping"}),"\n",(0,t.jsx)(n.p,{children:"Build a complete dependency graph:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public sealed class DependencyMapper\n{\n    private readonly ILineageCollector _collector;\n\n    public DependencyMapper(ILineageCollector collector)\n    {\n        _collector = collector;\n    }\n\n    public DependencyGraph BuildDependencyGraph()\n    {\n        var allLineage = _collector.GetAllLineageInfo();\n        var graph = new DependencyGraph();\n        \n        foreach (var lineage in allLineage)\n        {\n            for (int i = 0; i < lineage.TraversalPath.Count - 1; i++)\n            {\n                var source = lineage.TraversalPath[i];\n                var target = lineage.TraversalPath[i + 1];\n                \n                graph.AddEdge(source, target);\n            }\n        }\n        \n        return graph;\n    }\n}\n\npublic sealed class DependencyGraph\n{\n    private readonly Dictionary<string, HashSet<string>> _edges = new();\n    \n    public void AddEdge(string source, string target)\n    {\n        if (!_edges.ContainsKey(source))\n            _edges[source] = new HashSet<string>();\n        \n        _edges[source].Add(target);\n    }\n    \n    public HashSet<string> GetDownstream(string node)\n    {\n        return _edges.GetValueOrDefault(node, new HashSet<string>());\n    }\n    \n    public HashSet<string> GetUpstream(string node)\n    {\n        var upstream = new HashSet<string>();\n        \n        foreach (var kvp in _edges)\n        {\n            if (kvp.Value.Contains(node))\n                upstream.Add(kvp.Key);\n        }\n        \n        return upstream;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,t.jsx)(n.p,{children:"Identify bottlenecks in complex pipelines:"}),"\n",(0,t.jsx)(n.h3,{id:"find-slow-transformations",children:"Find Slow Transformations"}),"\n",(0,t.jsx)(n.p,{children:"Analyze hop durations to find performance issues:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public sealed class PerformanceAnalyzer\n{\n    private readonly ILineageCollector _collector;\n\n    public PerformanceAnalyzer(ILineageCollector collector)\n    {\n        _collector = collector;\n    }\n\n    public List<NodePerformance> AnalyzePerformance()\n    {\n        var allLineage = _collector.GetAllLineageInfo();\n        var nodePerformance = new Dictionary<string, NodePerformance>();\n        \n        foreach (var lineage in allLineage)\n        {\n            foreach (var hop in lineage.LineageHops)\n            {\n                if (!nodePerformance.ContainsKey(hop.NodeId))\n                {\n                    nodePerformance[hop.NodeId] = new NodePerformance\n                    {\n                        NodeId = hop.NodeId,\n                        TotalHops = 0,\n                        TotalDurationMs = 0\n                    };\n                }\n                \n                var perf = nodePerformance[hop.NodeId];\n                perf.TotalHops++;\n                \n                // Note: Duration would need to be tracked in LineageHop\n                // This is a placeholder for the concept\n                perf.TotalDurationMs += 0;  // Would be hop.DurationMs\n            }\n        }\n        \n        return nodePerformance.Values.OrderByDescending(p => p.TotalDurationMs).ToList();\n    }\n}\n\npublic sealed record NodePerformance(\n    string NodeId,\n    int TotalHops,\n    double TotalDurationMs,\n    double AverageDurationMs => TotalDurationMs / TotalHops\n);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"throughput-analysis",children:"Throughput Analysis"}),"\n",(0,t.jsx)(n.p,{children:"Measure processing rates across nodes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public sealed class ThroughputAnalyzer\n{\n    private readonly ILineageCollector _collector;\n\n    public ThroughputAnalyzer(ILineageCollector collector)\n    {\n        _collector = collector;\n    }\n\n    public List<NodeThroughput> AnalyzeThroughput()\n    {\n        var allLineage = _collector.GetAllLineageInfo();\n        var nodeThroughput = new Dictionary<string, NodeThroughput>();\n        \n        foreach (var lineage in allLineage)\n        {\n            foreach (var hop in lineage.LineageHops)\n            {\n                if (!nodeThroughput.ContainsKey(hop.NodeId))\n                {\n                    nodeThroughput[hop.NodeId] = new NodeThroughput\n                    {\n                        NodeId = hop.NodeId,\n                        TotalInputCount = 0,\n                        TotalOutputCount = 0\n                    };\n                }\n                \n                var throughput = nodeThroughput[hop.NodeId];\n                throughput.TotalInputCount += hop.InputCount;\n                throughput.TotalOutputCount += hop.OutputCount;\n            }\n        }\n        \n        return nodeThroughput.Values.ToList();\n    }\n}\n\npublic sealed record NodeThroughput(\n    string NodeId,\n    long TotalInputCount,\n    long TotalOutputCount,\n    double FilterRatio => TotalInputCount > 0 ? (double)TotalOutputCount / TotalInputCount : 0\n);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"cardinality-analysis",children:"Cardinality Analysis"}),"\n",(0,t.jsx)(n.p,{children:"Understand data transformation patterns:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public sealed class CardinalityAnalyzer\n{\n    private readonly ILineageCollector _collector;\n\n    public CardinalityAnalyzer(ILineageCollector collector)\n    {\n        _collector = collector;\n    }\n\n    public Dictionary<string, CardinalityStats> AnalyzeCardinality()\n    {\n        var allLineage = _collector.GetAllLineageInfo();\n        var stats = new Dictionary<string, CardinalityStats>();\n        \n        foreach (var lineage in allLineage)\n        {\n            foreach (var hop in lineage.LineageHops)\n            {\n                if (!stats.ContainsKey(hop.NodeId))\n                {\n                    stats[hop.NodeId] = new CardinalityStats\n                    {\n                        NodeId = hop.NodeId,\n                        TotalHops = 0,\n                        CardinalityCounts = new Dictionary<Cardinality, int>()\n                    };\n                }\n                \n                var nodeStats = stats[hop.NodeId];\n                nodeStats.TotalHops++;\n                \n                if (!nodeStats.CardinalityCounts.ContainsKey(hop.Cardinality))\n                    nodeStats.CardinalityCounts[hop.Cardinality] = 0;\n                \n                nodeStats.CardinalityCounts[hop.Cardinality]++;\n            }\n        }\n        \n        return stats;\n    }\n}\n\npublic sealed record CardinalityStats(\n    string NodeId,\n    int TotalHops,\n    Dictionary<Cardinality, int> CardinalityCounts\n);\n\npublic enum Cardinality\n{\n    OneToOne,      // 1 input \u2192 1 output\n    OneToMany,      // 1 input \u2192 N outputs\n    ManyToOne,      // N inputs \u2192 1 output\n    ManyToMany       // N inputs \u2192 N outputs\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"data-science-and-analytics",children:"Data Science and Analytics"}),"\n",(0,t.jsx)(n.p,{children:"Support reproducibility and data cataloging:"}),"\n",(0,t.jsx)(n.h3,{id:"dataset-provenance",children:"Dataset Provenance"}),"\n",(0,t.jsx)(n.p,{children:"Document exactly how datasets were created:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public sealed class DatasetProvenanceTracker\n{\n    private readonly ILineageCollector _collector;\n\n    public DatasetProvenanceTracker(ILineageCollector collector)\n    {\n        _collector = collector;\n    }\n\n    public DatasetProvenance GetProvenance(string datasetName)\n    {\n        var allLineage = _collector.GetAllLineageInfo();\n        \n        var provenance = new DatasetProvenance\n        {\n            DatasetName = datasetName,\n            CreationTimestamp = DateTime.UtcNow,\n            SourceNodes = allLineage\n                .SelectMany(li => li.LineageHops)\n                .Where(h => h.Outcome == "Source")\n                .Select(h => h.NodeId)\n                .Distinct()\n                .ToList(),\n            TransformationsApplied = allLineage\n                .SelectMany(li => li.LineageHops)\n                .Where(h => h.Outcome == "Success")\n                .GroupBy(h => h.NodeId)\n                .Select(g => new TransformationSummary\n                {\n                    NodeId = g.Key,\n                    ApplicationCount = g.Count()\n                })\n                .ToList(),\n            TotalItemsProcessed = allLineage.Count\n        };\n        \n        return provenance;\n    }\n}\n\npublic sealed record DatasetProvenance(\n    string DatasetName,\n    DateTime CreationTimestamp,\n    List<string> SourceNodes,\n    List<TransformationSummary> TransformationsApplied,\n    int TotalItemsProcessed\n);\n\npublic sealed record TransformationSummary(\n    string NodeId,\n    int ApplicationCount\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"model-training-lineage",children:"Model Training Lineage"}),"\n",(0,t.jsx)(n.p,{children:"Understand the provenance of training data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public sealed class ModelTrainingLineage\n{\n    private readonly ILineageCollector _collector;\n\n    public ModelTrainingLineage(ILineageCollector collector)\n    {\n        _collector = collector;\n    }\n\n    public ModelTrainingReport GenerateReport(string modelName)\n    {\n        var allLineage = _collector.GetAllLineageInfo();\n        \n        var report = new ModelTrainingReport\n        {\n            ModelName = modelName,\n            TrainingDataSources = allLineage\n                .SelectMany(li => li.LineageHops)\n                .Where(h => h.Outcome == "Source")\n                .Select(h => h.NodeId)\n                .Distinct()\n                .ToList(),\n            DataTransformations = allLineage\n                .SelectMany(li => li.LineageHops)\n                .GroupBy(h => h.NodeId)\n                .Select(g => new\n                {\n                    NodeId = g.Key,\n                    TransformCount = g.Count(),\n                    SuccessRate = g.Count(h => h.Outcome == "Success") / (double)g.Count()\n                })\n                .ToList(),\n            SampleSize = allLineage.Count,\n            DataQualityMetrics = CalculateQualityMetrics(allLineage)\n        };\n        \n        return report;\n    }\n    \n    private DataQualityMetrics CalculateQualityMetrics(IReadOnlyList<ILineageInfo> lineage)\n    {\n        // Calculate quality metrics based on lineage\n        // This is a placeholder for the concept\n        return new DataQualityMetrics\n        {\n            SuccessRate = lineage.Count(li => li.LineageHops.All(h => h.Outcome == "Success")) / (double)lineage.Count,\n            AverageHopCount = lineage.Average(li => li.LineageHops.Count)\n        };\n    }\n}\n\npublic sealed record ModelTrainingReport(\n    string ModelName,\n    List<string> TrainingDataSources,\n    List<object> DataTransformations,\n    int SampleSize,\n    DataQualityMetrics DataQualityMetrics\n);\n\npublic sealed record DataQualityMetrics(\n    double SuccessRate,\n    double AverageHopCount\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"data-cataloging",children:"Data Cataloging"}),"\n",(0,t.jsx)(n.p,{children:"Build a comprehensive catalog of data sources and transformations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public sealed class DataCatalogBuilder\n{\n    private readonly ILineageCollector _collector;\n\n    public DataCatalogBuilder(ILineageCollector collector)\n    {\n        _collector = collector;\n    }\n\n    public DataCatalog BuildCatalog()\n    {\n        var allLineage = _collector.GetAllLineageInfo();\n        \n        var catalog = new DataCatalog\n        {\n            DataSources = ExtractDataSources(allLineage),\n            Transformations = ExtractTransformations(allLineage),\n            DataFlows = ExtractDataFlows(allLineage)\n        };\n        \n        return catalog;\n    }\n    \n    private List<DataSource> ExtractDataSources(IReadOnlyList<ILineageInfo> lineage)\n    {\n        return lineage\n            .SelectMany(li => li.LineageHops)\n            .Where(h => h.Outcome == "Source")\n            .GroupBy(h => h.NodeId)\n            .Select(g => new DataSource\n            {\n                NodeId = g.Key,\n                UsageCount = g.Count()\n            })\n            .ToList();\n    }\n    \n    private List<DataTransformation> ExtractTransformations(IReadOnlyList<ILineageInfo> lineage)\n    {\n        return lineage\n            .SelectMany(li => li.LineageHops)\n            .Where(h => h.Outcome == "Success")\n            .GroupBy(h => h.NodeId)\n            .Select(g => new DataTransformation\n            {\n                NodeId = g.Key,\n                ApplicationCount = g.Count(),\n                CardinalityDistribution = g.GroupBy(h => h.Cardinality)\n                    .Select(cg => new { Cardinality = cg.Key, Count = cg.Count() })\n                    .ToList()\n            })\n            .ToList();\n    }\n    \n    private List<DataFlow> ExtractDataFlows(IReadOnlyList<ILineageInfo> lineage)\n    {\n        return lineage\n            .Select(li => new DataFlow\n            {\n                LineageId = li.LineageId,\n                FlowPath = li.TraversalPath,\n                HopCount = li.LineageHops.Count\n            })\n            .ToList();\n    }\n}\n\npublic sealed record DataCatalog(\n    List<DataSource> DataSources,\n    List<DataTransformation> Transformations,\n    List<DataFlow> DataFlows\n);\n\npublic sealed record DataSource(\n    string NodeId,\n    int UsageCount\n);\n\npublic sealed record DataTransformation(\n    string NodeId,\n    int ApplicationCount,\n    List<object> CardinalityDistribution\n);\n\npublic sealed record DataFlow(\n    Guid LineageId,\n    IReadOnlyList<string> FlowPath,\n    int HopCount\n);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"complete-examples",children:"Complete Examples"}),"\n",(0,t.jsx)(n.h3,{id:"example-1-etl-pipeline-with-lineage",children:"Example 1: ETL Pipeline with Lineage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Microsoft.Extensions.DependencyInjection;\nusing NPipeline.Lineage;\nusing NPipeline.Lineage.DependencyInjection;\n\npublic class EtlPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<DatabaseSource, RawData>("source");\n        var validate = builder.AddTransform<ValidationTransform, RawData, ValidatedData>("validate");\n        var transform = builder.AddTransform<DataTransform, ValidatedData, ProcessedData>("transform");\n        var sink = builder.AddSink<DataWarehouseSink, ProcessedData>("sink");\n\n        builder.Connect(source, validate);\n        builder.Connect(validate, transform);\n        builder.Connect(transform, sink);\n    }\n}\n\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var services = new ServiceCollection();\n        \n        // Add lineage with database sink for compliance\n        services.AddNPipelineLineage<DatabaseLineageSink>();\n        services.AddNPipeline(typeof(Program).Assembly);\n        \n        var serviceProvider = services.BuildServiceProvider();\n        \n        var builder = new PipelineBuilder("EtlPipeline");\n        \n        // Enable lineage for compliance\n        builder.EnableItemLevelLineage(options =>\n        {\n            options.SampleEvery = 1;  // 100% for compliance\n            options.DeterministicSampling = true;\n            options.RedactData = false;  // Keep data for audit\n        });\n        \n        var pipeline = new EtlPipeline();\n        pipeline.Define(builder, new PipelineContext());\n        \n        await serviceProvider.RunPipelineAsync(builder.Build());\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"example-2-debugging-with-lineage",children:"Example 2: Debugging with Lineage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var services = new ServiceCollection();\n        \n        services.AddNPipelineLineage();  // Use logging sink\n        services.AddNPipeline(typeof(Program).Assembly);\n        \n        var serviceProvider = services.BuildServiceProvider();\n        \n        var builder = new PipelineBuilder("DebugPipeline");\n        \n        // Enable lineage for debugging\n        builder.EnableItemLevelLineage(options =>\n        {\n            options.SampleEvery = 1;  // Track everything\n            options.RedactData = false;  // Keep data for inspection\n        });\n        \n        var pipeline = new DebugPipeline();\n        pipeline.Define(builder, new PipelineContext());\n        \n        // Run pipeline\n        await serviceProvider.RunPipelineAsync(builder.Build());\n        \n        // Analyze lineage for debugging\n        var collector = serviceProvider.GetRequiredService<ILineageCollector>();\n        var debugger = new LineageDebugger(collector, logger);\n        \n        // Debug a specific problematic item\n        var problematicItemId = Guid.Parse("your-item-id");\n        debugger.DebugItem(problematicItemId);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-use-appropriate-sampling",children:"1. Use Appropriate Sampling"}),"\n",(0,t.jsx)(n.p,{children:"Choose sampling rate based on use case:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Use Case"}),(0,t.jsx)(n.th,{children:"Sampling Rate"}),(0,t.jsx)(n.th,{children:"Reasoning"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Compliance"}),(0,t.jsx)(n.td,{children:"100%"}),(0,t.jsx)(n.td,{children:"Complete audit trail required"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Debugging"}),(0,t.jsx)(n.td,{children:"100%"}),(0,t.jsx)(n.td,{children:"Need complete visibility"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Monitoring"}),(0,t.jsx)(n.td,{children:"1-10%"}),(0,t.jsx)(n.td,{children:"Representative samples sufficient"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Analytics"}),(0,t.jsx)(n.td,{children:"0.1-1%"}),(0,t.jsx)(n.td,{children:"Minimal overhead needed"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"2-enable-redaction-for-sensitive-data",children:"2. Enable Redaction for Sensitive Data"}),"\n",(0,t.jsx)(n.p,{children:"Always redact PII, financial data, or health records:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"options.RedactData = true;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-use-deterministic-sampling-for-reproducibility",children:"3. Use Deterministic Sampling for Reproducibility"}),"\n",(0,t.jsx)(n.p,{children:"When you need consistent behavior:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"options.DeterministicSampling = true;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-implement-custom-sinks-for-production",children:"4. Implement Custom Sinks for Production"}),"\n",(0,t.jsx)(n.p,{children:"Use database or external system sinks:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"services.AddNPipelineLineage<DatabaseLineageSink>();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"5-analyze-lineage-regularly",children:"5. Analyze Lineage Regularly"}),"\n",(0,t.jsx)(n.p,{children:"Build tools to analyze lineage data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'var analyzer = new ImpactAnalyzer(collector);\nvar impact = analyzer.AnalyzeImpact("ValidationNode");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/extensions/lineage/getting-started",children:"Getting Started"})})," - Installation and basic setup"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/extensions/lineage/configuration",children:"Configuration"})})," - Configuration options and settings"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/extensions/lineage/architecture",children:"Architecture"})})," - Internal architecture and design decisions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/extensions/lineage/performance",children:"Performance"})})," - Performance characteristics and optimization"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);