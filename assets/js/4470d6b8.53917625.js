"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[914],{5358:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"core-concepts/resilience/execution-with-resilience","title":"Execution with Resilience","description":"Learn how ResilientExecutionStrategy wraps other execution strategies to provide fault tolerance and recovery capabilities.","source":"@site/docs/core-concepts/resilience/execution-with-resilience.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/execution-with-resilience","permalink":"/docs/core-concepts/resilience/execution-with-resilience","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Execution with Resilience","description":"Learn how ResilientExecutionStrategy wraps other execution strategies to provide fault tolerance and recovery capabilities.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Error Handling in NPipeline","permalink":"/docs/core-concepts/resilience/error-handling-guide"},"next":{"title":"Node Restart - Quick Start Checklist","permalink":"/docs/core-concepts/resilience/node-restart-quickstart"}}');var t=i(4848),a=i(8453);const l={title:"Execution with Resilience",description:"Learn how ResilientExecutionStrategy wraps other execution strategies to provide fault tolerance and recovery capabilities.",sidebar_position:2},s="Execution with Resilience",o={},c=[{value:"How It Works",id:"how-it-works",level:2},{value:"Key Responsibilities",id:"key-responsibilities",level:2},{value:"Wrapper Pattern",id:"wrapper-pattern",level:2},{value:"Materialization Behavior",id:"materialization-behavior",level:2},{value:"Configuration Examples",id:"configuration-examples",level:2},{value:"Basic Resilient Sequential Execution",id:"basic-resilient-sequential-execution",level:3},{value:"Resilient Parallel Execution",id:"resilient-parallel-execution",level:3},{value:"Per-Node Retry Options",id:"per-node-retry-options",level:3},{value:"Prerequisite Relationship",id:"prerequisite-relationship",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Memory Usage",id:"memory-usage",level:3},{value:"Latency Impact",id:"latency-impact",level:3},{value:"Throughput Considerations",id:"throughput-considerations",level:3},{value:"Integration with Error Handling",id:"integration-with-error-handling",level:2},{value:"Common Configuration Patterns",id:"common-configuration-patterns",level:2},{value:"E-commerce Order Processing",id:"e-commerce-order-processing",level:3},{value:"High-Volume Data Analytics",id:"high-volume-data-analytics",level:3},{value:"Microservice Integration",id:"microservice-integration",level:3},{value:"Configuration Decision Matrix",id:"configuration-decision-matrix",level:3},{value:"Common Configuration Mistakes to Avoid",id:"common-configuration-mistakes-to-avoid",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"execution-with-resilience",children:"Execution with Resilience"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["\u2139\ufe0f"," ",(0,t.jsx)(n.strong,{children:"Documentation Scope"}),"\nThis guide covers ",(0,t.jsx)(n.strong,{children:"resilience capabilities"})," - the wrapper strategy that adds error handling, retries, and node restart functionality. For information about ",(0,t.jsx)(n.strong,{children:"all execution strategies"})," (sequential, parallel, and how they work), see ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/execution-strategies",children:"Execution Strategies"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"../../../src/NPipeline/Execution/Strategies/ResilientExecutionStrategy.cs",children:(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"})})," is a wrapper strategy that enables resilience capabilities for your pipeline nodes. It doesn't execute nodes directly but instead wraps another execution strategy (like ",(0,t.jsx)(n.code,{children:"SequentialExecutionStrategy"})," or ",(0,t.jsx)(n.code,{children:"ParallelExecutionStrategy"}),") to add error handling, retry logic, and recovery mechanisms."]}),"\n",(0,t.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"})," acts as a middleware layer between the pipeline executor and the actual execution strategy:"]}),"\n",(0,t.jsx)(n.mermaid,{value:'graph TD\n    A[Pipeline Executor] --\x3e B[ResilientExecutionStrategy]\n    B --\x3e C["Inner Strategy\n(Sequential/Parallel)"]\n    C --\x3e D[Node Processing]\n    D --\x3e E{Success?}\n    E --\x3e|Yes| F[Output Stream]\n    E --\x3e|No| G[Error Handler]\n    G --\x3e H{PipelineErrorDecision}\n    H --\x3e|RestartNode| I[Restart Stream]\n    H --\x3e|ContinueWithoutNode| J[Bypass Node]\n    H --\x3e|FailPipeline| K[Pipeline Failure]\n    I --\x3e C\n\n    style B fill:#e1f5fe\n    style G fill:#fff3e0\n    style H fill:#ffecb3'}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Figure: ResilientExecutionStrategy wraps inner strategies to add resilience capabilities."})}),"\n",(0,t.jsx)(n.h2,{id:"key-responsibilities",children:"Key Responsibilities"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"})," handles several critical responsibilities:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stream Materialization"}),": Automatically materializes streaming inputs to enable replay during restarts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Interception"}),": Catches exceptions from node execution and routes them to the error handler"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Decision Execution"}),": Implements the ",(0,t.jsx)(n.code,{children:"PipelineErrorDecision"})," returned by the error handler"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Circuit Breaking"}),": Prevents cascading failures when consecutive failures exceed thresholds"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Retry Limit Enforcement"}),": Respects configured retry limits for both items and node restarts"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"wrapper-pattern",children:"Wrapper Pattern"}),"\n",(0,t.jsx)(n.p,{children:"The strategy follows a wrapper pattern where it enhances any inner strategy with resilience capabilities:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Wrap a sequential strategy\nvar resilientSequential = new ResilientExecutionStrategy(\n    new SequentialExecutionStrategy()\n);\n\n// Wrap a parallel strategy\nvar resilientParallel = new ResilientExecutionStrategy(\n    new ParallelExecutionStrategy(maxDegreeOfParallelism: 4)\n);\n\n// Apply to a node\nvar nodeHandle = builder\n    .AddTransform<MyTransform, Input, Output>("myNode")\n    .WithExecutionStrategy(builder, resilientParallel);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"materialization-behavior",children:"Materialization Behavior"}),"\n",(0,t.jsxs)(n.p,{children:["When the ",(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"})," detects a streaming input, it automatically materializes the stream to enable replay functionality:"]}),"\n",(0,t.jsx)(n.mermaid,{value:"graph TD\n    A[Streaming Input] --\x3e B{ResilientExecutionStrategy Applied?}\n    B --\x3e|No| C[Direct Processing]\n    B --\x3e|Yes| D[Materialize via CappedReplayableDataPipe]\n    D --\x3e E[Buffer Items]\n    E --\x3e F[Process Items]\n    F --\x3e G{Failure?}\n    G --\x3e|No| H[Continue]\n    G --\x3e|Yes| I[Replay from Buffer]\n    I --\x3e F\n\n    style B fill:#e1f5fe\n    style D fill:#f3e5f5\n    style E fill:#e8f5e9\n    style I fill:#fff3e0"}),"\n",(0,t.jsxs)(n.p,{children:["The materialization process is controlled by the ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," parameter in ",(0,t.jsx)(n.code,{children:"PipelineRetryOptions"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["When ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," is null"]})," (default): Unbounded materialization - all items are buffered"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["When ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," has a value"]}),": Limited materialization - only the specified number of items are buffered"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u26a0\ufe0f Critical Warning"}),": Setting ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," to ",(0,t.jsx)(n.code,{children:"null"})," (unbounded) silently disables node restart functionality. For detailed explanation of why unbounded buffers break resilience guarantees, see the ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/node-restart-quickstart#why-unbounded-memory-buffers-break-resilience-guarantees",children:"Node Restart Quick Start Checklist"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,t.jsx)(n.h3,{id:"basic-resilient-sequential-execution",children:"Basic Resilient Sequential Execution"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\nusing NPipeline.Execution.Strategies;\nusing NPipeline.ErrorHandling;\n\n// Create a resilient sequential strategy\nvar resilientStrategy = new ResilientExecutionStrategy(\n    new SequentialExecutionStrategy()\n);\n\n// Apply to a transform node\nvar resilientStrategy = new ResilientExecutionStrategy(\n    new SequentialExecutionStrategy()\n);\n\nvar builder = new PipelineBuilder();\nvar sourceHandle = builder.AddSource<DataSource, object>("source");\nvar transformHandle = builder\n    .AddTransform<DataTransform, object, object>("transform")\n    .WithExecutionStrategy(builder, resilientStrategy);\nvar sinkHandle = builder.AddSink<DataSink, object>("sink");\n\nbuilder.Connect(sourceHandle, transformHandle);\nbuilder.Connect(transformHandle, sinkHandle);\nbuilder.WithRetryOptions(new PipelineRetryOptions(\n    MaxItemRetries: 3,\n    MaxNodeRestartAttempts: 2,\n    MaxSequentialNodeAttempts: 5\n));\n\nvar pipeline = builder.Build();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"resilient-parallel-execution",children:"Resilient Parallel Execution"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.Extensions.Parallelism;\n\n// Wrap a parallel strategy with resilience\nvar resilientParallel = new ResilientExecutionStrategy(\n    new ParallelExecutionStrategy(maxDegreeOfParallelism: 4)\n);\n\n// Configure with parallel options and resilience\nvar builder = new PipelineBuilder();\nvar sourceHandle = builder.AddSource<DataSource, object>("source");\nvar transformHandle = builder\n    .AddTransform<DataTransform, object, object>("transform")\n    .WithExecutionStrategy(builder, resilientParallel);\nvar sinkHandle = builder.AddSink<DataSink, object>("sink");\n\nbuilder.Connect(sourceHandle, transformHandle);\nbuilder.Connect(transformHandle, sinkHandle);\nbuilder.SetNodeExecutionOption(transformHandle.Id, new ParallelOptions\n{\n    MaxDegreeOfParallelism = 4,\n    MaxQueueLength = 10,\n    QueuePolicy = BoundedQueuePolicy.Block,\n    PreserveOrdering = true\n});\n\nbuilder.WithRetryOptions(new PipelineRetryOptions(\n    MaxItemRetries: 3,\n    MaxNodeRestartAttempts: 2,\n    MaxSequentialNodeAttempts: 5\n));\n\nvar pipeline = builder.Build();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"per-node-retry-options",children:"Per-Node Retry Options"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'var builder = new PipelineBuilder();\nvar sourceHandle = builder.AddSource<DataSource, object>("source");\nvar criticalHandle = builder\n    .AddTransform<CriticalTransform, object, object>("criticalNode")\n    .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\n        new SequentialExecutionStrategy()\n    ));\nvar regularHandle = builder\n    .AddTransform<RegularTransform, object, object>("regularNode")\n    .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\n        new SequentialExecutionStrategy()\n    ));\nvar sinkHandle = builder.AddSink<DataSink, object>("sink");\n\nbuilder.Connect(sourceHandle, criticalHandle);\nbuilder.Connect(criticalHandle, regularHandle);\nbuilder.Connect(regularHandle, sinkHandle);\n\n// Configure different retry options for each node\nbuilder.WithRetryOptions(criticalHandle, new PipelineRetryOptions(\n    MaxItemRetries: 5,\n    MaxNodeRestartAttempts: 5,\n    MaxSequentialNodeAttempts: 10\n));\nbuilder.WithRetryOptions(regularHandle, new PipelineRetryOptions(\n    MaxItemRetries: 2,\n    MaxNodeRestartAttempts: 1,\n    MaxSequentialNodeAttempts: 3\n));\n\nvar pipeline = builder.Build();\n'})}),"\n",(0,t.jsx)(n.h2,{id:"prerequisite-relationship",children:"Prerequisite Relationship"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"})," is the ",(0,t.jsx)(n.strong,{children:"mandatory starting point"})," for all resilience features in NPipeline. Without this strategy:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PipelineErrorDecision.RestartNode"})," will not work"]}),"\n",(0,t.jsx)(n.li,{children:"Materialization will not be automatically applied"}),"\n",(0,t.jsx)(n.li,{children:"Circuit breaker functionality will not be available"}),"\n",(0,t.jsx)(n.li,{children:"Node restart capabilities will be disabled"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Always apply ",(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"})," to nodes that require any form of resilience."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["For complete configuration requirements for node restart functionality, see the ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/node-restart-quickstart",children:"Node Restart Quick Start Checklist"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsx)(n.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,t.jsx)(n.p,{children:"Materialization for resilience comes with memory trade-offs:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// High memory usage - unlimited buffering\nvar unlimitedBuffering = new PipelineRetryOptions(\n    MaxItemRetries: 3,\n    MaxNodeRestartAttempts: 2,\n    MaxSequentialNodeAttempts: 5,\n    MaxMaterializedItems: null // No limit\n);\n\n// Controlled memory usage - limited buffering\nvar limitedBuffering = new PipelineRetryOptions(\n    MaxItemRetries: 3,\n    MaxNodeRestartAttempts: 2,\n    MaxSequentialNodeAttempts: 5,\n    MaxMaterializedItems: 1000 // Limit to 1000 items\n);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"latency-impact",children:"Latency Impact"}),"\n",(0,t.jsx)(n.p,{children:"The resilience wrapper adds minimal latency to successful operations:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error-free execution"}),": ~1-2% overhead for wrapper logic"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"During failures"}),": Additional latency for error handling and restarts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory pressure"}),": Potential GC impact from buffered items"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"throughput-considerations",children:"Throughput Considerations"}),"\n",(0,t.jsxs)(n.p,{children:["When using ",(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"})," with ",(0,t.jsx)(n.code,{children:"ParallelExecutionStrategy"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Optimal configuration for high throughput\nvar highThroughputConfig = new ParallelOptions\n{\n    MaxDegreeOfParallelism = Environment.ProcessorCount,\n    MaxQueueLength = 100,\n    QueuePolicy = BoundedQueuePolicy.Block,\n    PreserveOrdering = false // Disable ordering for maximum throughput\n};\n\nvar resilientHighThroughput = new ResilientExecutionStrategy(\n    new ParallelExecutionStrategy()\n);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"integration-with-error-handling",children:"Integration with Error Handling"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"})," works in tandem with NPipeline's error handling system:"]}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant PE as Pipeline Executor\n    participant RES as ResilientExecutionStrategy\n    participant ES as Inner Execution Strategy\n    participant N as Node\n    participant EH as Error Handler\n\n    PE->>RES: Execute node\n    RES->>ES: Execute with resilience\n    ES->>N: Process item\n    N--\x3e>ES: Exception\n    ES--\x3e>RES: Exception\n    RES->>EH: Handle error\n    EH--\x3e>RES: PipelineErrorDecision\n    RES->>RES: Execute decision\n\n    alt RestartNode\n        RES->>ES: Restart execution\n    else ContinueWithoutNode\n        RES->>PE: Skip node\n    else FailPipeline\n        RES->>PE: Fail pipeline\n    end"}),"\n",(0,t.jsx)(n.h2,{id:"common-configuration-patterns",children:"Common Configuration Patterns"}),"\n",(0,t.jsx)(n.p,{children:"Real-world resilience configurations depend on your specific use case. Here are practical patterns for common scenarios:"}),"\n",(0,t.jsx)(n.h3,{id:"e-commerce-order-processing",children:"E-commerce Order Processing"}),"\n",(0,t.jsx)(n.p,{children:"For critical financial operations where order reliability is paramount:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class EcommercePipelineDefinition : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var orderSourceHandle = builder.AddSource<OrderSource, Order>("orderSource");\n        var validatorHandle = builder\n            .AddTransform<OrderValidator, Order, ValidatedOrder>("validator")\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\n                new SequentialExecutionStrategy()\n            ));\n        var paymentHandle = builder\n            .AddTransform<PaymentProcessor, ValidatedOrder, PaidOrder>("paymentProcessor")\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\n                new SequentialExecutionStrategy()\n            ));\n        var inventoryHandle = builder\n            .AddTransform<InventoryUpdater, PaidOrder, UpdatedOrder>("inventoryUpdater")\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\n                new ParallelExecutionStrategy()\n            ));\n        var shippingHandle = builder\n            .AddTransform<ShippingScheduler, UpdatedOrder, ScheduledOrder>("shippingScheduler")\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\n                new SequentialExecutionStrategy()\n            ));\n        var sinkHandle = builder.AddSink<OrderSink, ScheduledOrder>("orderSink");\n\n        builder.Connect(orderSourceHandle, validatorHandle);\n        builder.Connect(validatorHandle, paymentHandle);\n        builder.Connect(paymentHandle, inventoryHandle);\n        builder.Connect(inventoryHandle, shippingHandle);\n        builder.Connect(shippingHandle, sinkHandle);\n    }\n}\n\npublic static class EcommercePipeline\n{\n    public static async Task RunAsync()\n    {\n        var retryOptions = new PipelineRetryOptions(\n            MaxItemRetries: 3,\n            MaxNodeRestartAttempts: 2,\n            MaxSequentialNodeAttempts: 5\n        );\n\n        var config = new PipelineContextConfiguration(\n            RetryOptions: retryOptions,\n            PipelineErrorHandler: new EcommerceErrorHandler()\n        );\n        var context = new PipelineContext(config);\n\n        var runner = PipelineRunner.Create();\n        await runner.RunAsync<EcommercePipelineDefinition>(context);\n    }\n}\n\npublic class EcommerceErrorHandler : IPipelineErrorHandler\n{\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n        string nodeId,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        return nodeId switch\n        {\n            "paymentProcessor" when error is PaymentException =>\n                Task.FromResult(PipelineErrorDecision.RestartNode),\n            "inventoryUpdater" when error is DatabaseException =>\n                Task.FromResult(PipelineErrorDecision.RestartNode),\n            "validator" when error is ValidationException =>\n                Task.FromResult(PipelineErrorDecision.ContinueWithoutNode),\n            _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\n        };\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"high-volume-data-analytics",children:"High-Volume Data Analytics"}),"\n",(0,t.jsx)(n.p,{children:"For high-throughput scenarios where some data loss is acceptable:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class AnalyticsPipelineDefinition : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var sourceHandle = builder.AddSource<EventStreamSource, EventData>("eventSource");\n        var parserHandle = builder\n            .AddTransform<EventParser, EventData, ParsedEvent>("parser")\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\n                new ParallelExecutionStrategy()\n            ));\n        var aggregatorHandle = builder\n            .AddTransform<Aggregator, ParsedEvent, AggregatedData>("aggregator")\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\n                new ParallelExecutionStrategy()\n            ));\n        var calculatorHandle = builder\n            .AddTransform<MetricsCalculator, AggregatedData, Metrics>("calculator")\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\n                new SequentialExecutionStrategy()\n            ));\n        var sinkHandle = builder.AddSink<MetricsSink, Metrics>("metricsSink");\n\n        builder.Connect(sourceHandle, parserHandle);\n        builder.Connect(parserHandle, aggregatorHandle);\n        builder.Connect(aggregatorHandle, calculatorHandle);\n        builder.Connect(calculatorHandle, sinkHandle);\n\n        // Configure execution options for parallel nodes\n        builder.SetNodeExecutionOption(parserHandle.Id, new ParallelOptions\n        {\n            MaxDegreeOfParallelism = 8,\n            MaxQueueLength = 100,\n            QueuePolicy = BoundedQueuePolicy.Block,\n            PreserveOrdering = false // Disable ordering for maximum throughput\n        });\n        builder.SetNodeExecutionOption(aggregatorHandle.Id, new ParallelOptions\n        {\n            MaxDegreeOfParallelism = 4,\n            MaxQueueLength = 50,\n            QueuePolicy = BoundedQueuePolicy.Block,\n            PreserveOrdering = false\n        });\n    }\n}\n\npublic static class AnalyticsPipeline\n{\n    public static async Task RunAsync()\n    {\n        var retryOptions = new PipelineRetryOptions(\n            MaxItemRetries: 1,\n            MaxNodeRestartAttempts: 2,\n            MaxSequentialNodeAttempts: 4,\n            MaxMaterializedItems: 10000 // Large buffer for high volume\n        );\n\n        var context = PipelineContext.WithRetry(retryOptions);\n        context.AddPipelineErrorHandler<AnalyticsErrorHandler>();\n\n        var runner = PipelineRunner.Create();\n        await runner.RunAsync<AnalyticsPipelineDefinition>(context);\n    }\n}\n\npublic class AnalyticsErrorHandler : IPipelineErrorHandler\n{\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n        string nodeId,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        return error switch\n        {\n            TimeoutException => Task.FromResult(PipelineErrorDecision.RestartNode),\n            IOException => Task.FromResult(PipelineErrorDecision.RestartNode),\n            _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\n        };\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"microservice-integration",children:"Microservice Integration"}),"\n",(0,t.jsx)(n.p,{children:"For distributed systems calling external services:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class MicroservicePipelineDefinition : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var sourceHandle = builder.AddSource<MessageQueueSource, ServiceRequest>("messageSource");\n        var requestBuilderHandle = builder\n            .AddTransform<RequestBuilder, ServiceRequest, HttpRequestMessage>("requestBuilder")\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\n                new SequentialExecutionStrategy()\n            ));\n        var serviceCallerHandle = builder\n            .AddTransform<ExternalServiceCaller, HttpRequestMessage, HttpResponseMessage>("serviceCaller")\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\n                new ParallelExecutionStrategy()\n            ));\n        var responseProcessorHandle = builder\n            .AddTransform<ResponseProcessor, HttpResponseMessage, ServiceResponse>("responseProcessor")\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\n                new SequentialExecutionStrategy()\n            ));\n        var sinkHandle = builder.AddSink<ResultPublisher, ServiceResponse>("resultPublisher");\n\n        builder.Connect(sourceHandle, requestBuilderHandle);\n        builder.Connect(requestBuilderHandle, serviceCallerHandle);\n        builder.Connect(serviceCallerHandle, responseProcessorHandle);\n        builder.Connect(responseProcessorHandle, sinkHandle);\n\n        // Configure high parallelism for external service calls\n        builder.SetNodeExecutionOption(serviceCallerHandle.Id, new ParallelOptions\n        {\n            MaxDegreeOfParallelism = 10, // High parallelism for external calls\n            MaxQueueLength = 200,\n            QueuePolicy = BoundedQueuePolicy.Block,\n            PreserveOrdering = false\n        });\n    }\n}\n\npublic static class MicroservicePipeline\n{\n    public static async Task RunAsync()\n    {\n        var retryOptions = new PipelineRetryOptions(\n            MaxItemRetries: 5, // High retry count for external services\n            MaxNodeRestartAttempts: 3,\n            MaxSequentialNodeAttempts: 8,\n            MaxMaterializedItems: 2000\n        );\n\n        var context = PipelineContext.WithRetry(retryOptions);\n\n        context.AddPipelineErrorHandler<MicroserviceErrorHandler>();\n\n        var runner = PipelineRunner.Create();\n        await runner.RunAsync<MicroservicePipelineDefinition>(context);\n    }\n}\n\npublic class MicroserviceErrorHandler : IPipelineErrorHandler\n{\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n        string nodeId,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        return nodeId switch\n        {\n            "serviceCaller" when IsTransientHttpError(error) =>\n                Task.FromResult(PipelineErrorDecision.RestartNode),\n            "serviceCaller" when IsPermanentHttpError(error) =>\n                Task.FromResult(PipelineErrorDecision.ContinueWithoutNode),\n            _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\n        };\n    }\n\n    private bool IsTransientHttpError(Exception ex)\n    {\n        return ex is HttpRequestException httpEx &&\n               (httpEx.StatusCode is HttpStatusCode.ServiceUnavailable or\n                HttpStatusCode.RequestTimeout or\n                HttpStatusCode.TooManyRequests);\n    }\n\n    private bool IsPermanentHttpError(Exception ex)\n    {\n        return ex is HttpRequestException httpEx &&\n               (httpEx.StatusCode is HttpStatusCode.NotFound or\n                HttpStatusCode.Unauthorized or\n                HttpStatusCode.Forbidden);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"configuration-decision-matrix",children:"Configuration Decision Matrix"}),"\n",(0,t.jsx)(n.p,{children:"When choosing retry configuration, consider this matrix:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Scenario"}),(0,t.jsx)(n.th,{children:"MaxItemRetries"}),(0,t.jsx)(n.th,{children:"MaxNodeRestartAttempts"}),(0,t.jsx)(n.th,{children:"MaxSequentialNodeAttempts"}),(0,t.jsx)(n.th,{children:"MaxMaterializedItems"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Stable internal services"})}),(0,t.jsx)(n.td,{children:"1-2"}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"3"}),(0,t.jsx)(n.td,{children:"500-1000"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Unstable external APIs"})}),(0,t.jsx)(n.td,{children:"3-5"}),(0,t.jsx)(n.td,{children:"3-5"}),(0,t.jsx)(n.td,{children:"8-10"}),(0,t.jsx)(n.td,{children:"1000-2000"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"High-volume streaming"})}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"2"}),(0,t.jsx)(n.td,{children:"4"}),(0,t.jsx)(n.td,{children:"5000-10000"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Critical business logic"})}),(0,t.jsx)(n.td,{children:"3-5"}),(0,t.jsx)(n.td,{children:"5"}),(0,t.jsx)(n.td,{children:"10"}),(0,t.jsx)(n.td,{children:"2000-5000"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Memory-constrained"})}),(0,t.jsx)(n.td,{children:"1-2"}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"3"}),(0,t.jsx)(n.td,{children:"100-500"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"common-configuration-mistakes-to-avoid",children:"Common Configuration Mistakes to Avoid"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Mistake 1: Forgetting ResilientExecutionStrategy"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'var nodeHandle = builder.AddTransform<MyTransform, Input, Output>("node");\n\n// \u274c WRONG: Missing resilience wrapper\nvar nodeHandle = builder\n    .AddTransform<MyTransform, Input, Output>("node")\n    .WithExecutionStrategy(builder, new ParallelExecutionStrategy());\n\n// \u2713 CORRECT: With resilience wrapper\nvar nodeHandle = builder\n    .AddTransform<MyTransform, Input, Output>("node")\n    .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\n        new ParallelExecutionStrategy()\n    ));\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Mistake 2: No Materialization for Streaming Inputs"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// \u274c WRONG: No materialization\nvar options = new PipelineRetryOptions(\n    MaxMaterializedItems: null // No buffering\n);\n\n// \u2713 CORRECT: Enable materialization\nvar options = new PipelineRetryOptions(\n    MaxMaterializedItems: 1000 // Buffer items for replay\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Mistake 3: Always Restarting on All Errors"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// \u274c WRONG: Restarts forever on all errors\npublic class BadErrorHandler : IPipelineErrorHandler\n{\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(...)\n    {\n        return Task.FromResult(PipelineErrorDecision.RestartNode); // Always!\n    }\n}\n\n// \u2713 CORRECT: Distinguish transient from permanent failures\npublic class GoodErrorHandler : IPipelineErrorHandler\n{\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n        string nodeId, Exception error, ...)\n    {\n        return error switch\n        {\n            TimeoutException => Task.FromResult(PipelineErrorDecision.RestartNode),\n            ValidationException => Task.FromResult(PipelineErrorDecision.ContinueWithoutNode),\n            _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\n        };\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/node-restart-quickstart",children:"Node Restart Quick Start Checklist"})}),": Complete step-by-step configuration guide for node restart functionality"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/configuration-guide",children:"Configuration Guide"})}),": Get step-by-step configuration guidance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/materialization-and-buffering",children:"Materialization and Buffering"})}),": Learn how buffering enables replay functionality"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/dependency-chains",children:"Dependency Chains"})}),": Understand the critical prerequisite relationships"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>s});var r=i(6540);const t={},a=r.createContext(t);function l(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);