"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[517],{3634:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"core-concepts/resilience/dependency-chains","title":"Dependency Chains","description":"Understand the critical prerequisite relationships between resilience components and why configuration sequence matters.","source":"@site/docs/core-concepts/resilience/dependency-chains.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/dependency-chains","permalink":"/docs/core-concepts/resilience/dependency-chains","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Dependency Chains","description":"Understand the critical prerequisite relationships between resilience components and why configuration sequence matters.","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Materialization and Buffering","permalink":"/docs/core-concepts/resilience/materialization-and-buffering"},"next":{"title":"Configuration Guide","permalink":"/docs/core-concepts/resilience/configuration-guide"}}');var t=i(4848),s=i(8453);const a={title:"Dependency Chains",description:"Understand the critical prerequisite relationships between resilience components and why configuration sequence matters.",sidebar_position:4},l="Dependency Chains",o={},c=[{value:"The Critical Dependency Chain",id:"the-critical-dependency-chain",level:2},{value:"Critical Dependency Rules",id:"critical-dependency-rules",level:2},{value:"1. ResilientExecutionStrategy is Mandatory",id:"1-resilientexecutionstrategy-is-mandatory",level:3},{value:"\u26a0\ufe0f Critical Prerequisite",id:"warning-critical-prerequisite",level:4},{value:"2. Materialization is Required for RestartNode",id:"2-materialization-is-required-for-restartnode",level:3},{value:"\u26a0\ufe0f Critical Prerequisite",id:"warning-critical-prerequisite-1",level:4},{value:"3. Error Handler Must Return Correct Decision",id:"3-error-handler-must-return-correct-decision",level:3},{value:"\u26a0\ufe0f Critical Prerequisite",id:"warning-critical-prerequisite-2",level:4},{value:"Configuration Sequence Dependencies",id:"configuration-sequence-dependencies",level:2},{value:"Correct Configuration Sequence",id:"correct-configuration-sequence",level:3},{value:"Incorrect Configuration Sequence",id:"incorrect-configuration-sequence",level:3},{value:"Common Dependency Breakages",id:"common-dependency-breakages",level:2},{value:"Breakage 1: Missing ResilientExecutionStrategy",id:"breakage-1-missing-resilientexecutionstrategy",level:3},{value:"Breakage 2: Missing Materialization for Streaming Inputs",id:"breakage-2-missing-materialization-for-streaming-inputs",level:3},{value:"Breakage 3: Error Handler Not Returning RestartNode",id:"breakage-3-error-handler-not-returning-restartnode",level:3},{value:"Dependency Validation Checklist",id:"dependency-validation-checklist",level:2},{value:"\u2705 ResilientExecutionStrategy Applied",id:"-resilientexecutionstrategy-applied",level:3},{value:"\u2705 Materialization Configured",id:"-materialization-configured",level:3},{value:"\u2705 Error Handler Configured",id:"-error-handler-configured",level:3},{value:"\u2705 Retry Options Configured",id:"-retry-options-configured",level:3},{value:"Visual Dependency Flow",id:"visual-dependency-flow",level:2},{value:"Testing Dependency Chains",id:"testing-dependency-chains",level:2},{value:"Unit Test for Dependency Validation",id:"unit-test-for-dependency-validation",level:3},{value:"Integration Test for End-to-End Validation",id:"integration-test-for-end-to-end-validation",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",input:"input",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"dependency-chains",children:"Dependency Chains"})}),"\n",(0,t.jsx)(n.p,{children:"Resilience in NPipeline relies on a strict chain of dependencies between components. Understanding these relationships is crucial because missing or misconfigured dependencies will cause resilience features to fail silently or fall back to undesirable default behaviors."}),"\n",(0,t.jsx)(n.h2,{id:"the-critical-dependency-chain",children:"The Critical Dependency Chain"}),"\n",(0,t.jsx)(n.mermaid,{value:"graph TD\r\n    A[ResilientExecutionStrategy] --\x3e B[Materialization via MaxMaterializedItems]\r\n    B --\x3e C[PipelineErrorDecision.RestartNode]\r\n    C --\x3e D[Node Restart Functionality]\r\n\r\n    E[IPipelineErrorHandler] --\x3e F[Error Decision Logic]\r\n    F --\x3e C\r\n\r\n    G[PipelineRetryOptions] --\x3e H[Retry Limits]\r\n    G --\x3e I[Materialization Caps]\r\n    H --\x3e C\r\n    I --\x3e B\r\n\r\n    J[Streaming Input] --\x3e K{Materialization Required?}\r\n    K --\x3e|Yes| B\r\n    K --\x3e|No| L[Direct Processing]\r\n\r\n    style A fill:#e1f5fe\r\n    style B fill:#f3e5f5\r\n    style C fill:#ffecb3\r\n    style D fill:#e8f5e9\r\n    style E fill:#e1f5fe\r\n    style F fill:#f3e5f5\r\n    style G fill:#e1f5fe\r\n    style H fill:#f3e5f5\r\n    style I fill:#f3e5f5\r\n    style J fill:#e8f5e9\r\n    style K fill:#ffecb3\r\n    style L fill:#e8f5e9"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Figure: The complete dependency chain showing how resilience components must be configured in the correct sequence."})}),"\n",(0,t.jsx)(n.h2,{id:"critical-dependency-rules",children:"Critical Dependency Rules"}),"\n",(0,t.jsx)(n.h3,{id:"1-resilientexecutionstrategy-is-mandatory",children:"1. ResilientExecutionStrategy is Mandatory"}),"\n",(0,t.jsxs)(n.h4,{id:"warning-critical-prerequisite",children:["\u26a0\ufe0f"," Critical Prerequisite"]}),"\n",(0,t.jsxs)(n.p,{children:["All resilience features require ",(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"})," to be applied to a node. Without this strategy:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PipelineErrorDecision.RestartNode"})," will not work"]}),"\n",(0,t.jsx)(n.li,{children:"Materialization will not be automatically applied"}),"\n",(0,t.jsx)(n.li,{children:"Circuit breaker functionality will not be available"}),"\n",(0,t.jsx)(n.li,{children:"Node restart capabilities will be disabled"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"What breaks without it:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Error handlers return ",(0,t.jsx)(n.code,{children:"RestartNode"})," decision, but node cannot restart"]}),"\n",(0,t.jsx)(n.li,{children:"Materialization is not applied to streaming inputs"}),"\n",(0,t.jsx)(n.li,{children:"Circuit breaker logic is bypassed"}),"\n",(0,t.jsx)(n.li,{children:"Retry limits are not enforced"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Fix:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// WRONG: Missing resilience wrapper\r\nvar nodeHandle = builder\r\n    .AddTransform<MyTransform, Input, Output>("node")\r\n    .WithExecutionStrategy(builder, new SequentialExecutionStrategy());\r\n\r\n// CORRECT: With resilience wrapper\r\nvar nodeHandle = builder\r\n    .AddTransform<MyTransform, Input, Output>("node")\r\n    .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n        new SequentialExecutionStrategy()\r\n    ));\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-materialization-is-required-for-restartnode",children:"2. Materialization is Required for RestartNode"}),"\n",(0,t.jsxs)(n.h4,{id:"warning-critical-prerequisite-1",children:["\u26a0\ufe0f"," Critical Prerequisite"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"PipelineErrorDecision.RestartNode"})," only works if the input stream is materialized via ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," (for streaming inputs)."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"What breaks without it:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"RestartNode"})," decision falls back to ",(0,t.jsx)(n.code,{children:"FailPipeline"})," behavior"]}),"\n",(0,t.jsx)(n.li,{children:"Streaming inputs cannot be replayed after failure"}),"\n",(0,t.jsx)(n.li,{children:'Node restart fails with "Cannot restart streaming node without materialization"'}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Fix:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// WRONG: No materialization for streaming input\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: null // No materialization\r\n);\r\n\r\n// CORRECT: With materialization\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: 1000 // Enable materialization\r\n);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-error-handler-must-return-correct-decision",children:"3. Error Handler Must Return Correct Decision"}),"\n",(0,t.jsxs)(n.h4,{id:"warning-critical-prerequisite-2",children:["\u26a0\ufe0f"," Critical Prerequisite"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"IPipelineErrorHandler"})," must return ",(0,t.jsx)(n.code,{children:"PipelineErrorDecision.RestartNode"})," to trigger restart functionality."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"What breaks without it:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Error handler returns ",(0,t.jsx)(n.code,{children:"FailPipeline"})," or ",(0,t.jsx)(n.code,{children:"ContinueWithoutNode"})]}),"\n",(0,t.jsx)(n.li,{children:"Node restart is never attempted"}),"\n",(0,t.jsx)(n.li,{children:"Resilience configuration is ineffective"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Fix:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// WRONG: Always fails pipeline\r\npublic class WrongErrorHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId, Exception error, PipelineContext context, CancellationToken ct)\r\n    {\r\n        return Task.FromResult(PipelineErrorDecision.FailPipeline);\r\n    }\r\n}\r\n\r\n// CORRECT: Returns RestartNode when appropriate\r\npublic class CorrectErrorHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId, Exception error, PipelineContext context, CancellationToken ct)\r\n    {\r\n        return error switch\r\n        {\r\n            TimeoutException => Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            InvalidOperationException => Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\r\n        };\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"configuration-sequence-dependencies",children:"Configuration Sequence Dependencies"}),"\n",(0,t.jsx)(n.p,{children:"The order in which you configure resilience components matters:"}),"\n",(0,t.jsx)(n.h3,{id:"correct-configuration-sequence",children:"Correct Configuration Sequence"}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\n    participant C as Configuration\r\n    participant PB as PipelineBuilder\r\n    participant RES as ResilientExecutionStrategy\r\n    participant EH as ErrorHandler\r\n    participant RO as RetryOptions\r\n\r\n    C->>PB: Create pipeline\r\n    C->>PB: Add nodes\r\n    C->>PB: WithExecutionStrategy(ResilientExecutionStrategy)\r\n    C->>PB: WithRetryOptions(MaxMaterializedItems)\r\n    C->>PB: WithErrorHandling(ErrorHandler)\r\n    C->>PB: Build pipeline\r\n\r\n    Note over C,PB: Dependencies satisfied in correct order"}),"\n",(0,t.jsx)(n.h3,{id:"incorrect-configuration-sequence",children:"Incorrect Configuration Sequence"}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\n    participant C as Configuration\r\n    participant PB as PipelineBuilder\r\n    participant RES as ResilientExecutionStrategy\r\n    participant EH as ErrorHandler\r\n    participant RO as RetryOptions\r\n\r\n    C->>PB: Create pipeline\r\n    C->>PB: Add nodes\r\n    C->>PB: WithErrorHandling(ErrorHandler)\r\n    C->>PB: WithExecutionStrategy(SequentialExecutionStrategy)\r\n    C->>PB: WithRetryOptions(MaxMaterializedItems)\r\n    C->>PB: Build pipeline\r\n\r\n    Note over C,PB: ResilientExecutionStrategy missing!\r\n    Note over C,PB: RestartNode will not work"}),"\n",(0,t.jsx)(n.h2,{id:"common-dependency-breakages",children:"Common Dependency Breakages"}),"\n",(0,t.jsx)(n.h3,{id:"breakage-1-missing-resilientexecutionstrategy",children:"Breakage 1: Missing ResilientExecutionStrategy"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Symptoms:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Error handler returns ",(0,t.jsx)(n.code,{children:"RestartNode"})," but node doesn't restart"]}),"\n",(0,t.jsx)(n.li,{children:"Pipeline fails despite restart decision"}),"\n",(0,t.jsx)(n.li,{children:"No materialization occurs for streaming inputs"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Diagnosis:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Check if ResilientExecutionStrategy is applied\r\nvar nodeDefinition = pipeline.GetNodeDefinition("myNode");\r\nvar hasResilientStrategy = nodeDefinition.ExecutionStrategy is ResilientExecutionStrategy;\r\n\r\nif (!hasResilientStrategy)\r\n{\r\n    Console.WriteLine("ERROR: ResilientExecutionStrategy not applied to node");\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Fix:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Apply ResilientExecutionStrategy to all nodes that need resilience\r\nvar nodeHandle = builder\r\n    .AddTransform<MyTransform, Input, Output>("myNode")\r\n    .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n        new SequentialExecutionStrategy()\r\n    ));\n'})}),"\n",(0,t.jsx)(n.h3,{id:"breakage-2-missing-materialization-for-streaming-inputs",children:"Breakage 2: Missing Materialization for Streaming Inputs"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Symptoms:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"InvalidOperationException: Cannot restart streaming node without materialization"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"RestartNode"})," decision falls back to ",(0,t.jsx)(n.code,{children:"FailPipeline"})]}),"\n",(0,t.jsx)(n.li,{children:"Buffer overflow exceptions when processing large streams"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Diagnosis:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Check if materialization is configured\r\nvar retryOptions = context.RetryOptions;\r\nif (retryOptions.MaxMaterializedItems == null)\r\n{\r\n    Console.WriteLine("WARNING: No materialization limit set - streaming inputs cannot be restarted");\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Fix:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Configure materialization for streaming inputs\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: 1000 // Enable materialization\r\n);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"breakage-3-error-handler-not-returning-restartnode",children:"Breakage 3: Error Handler Not Returning RestartNode"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Symptoms:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Node never restarts despite failures"}),"\n",(0,t.jsx)(n.li,{children:"Pipeline always fails on first error"}),"\n",(0,t.jsx)(n.li,{children:"Resilience configuration appears ineffective"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Diagnosis:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Add logging to error handler\r\npublic class DebuggingErrorHandler : IPipelineErrorHandler\r\n{\r\n    public async Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId, Exception error, PipelineContext context, CancellationToken ct)\r\n    {\r\n        Console.WriteLine($"Error handler called for node {nodeId}");\r\n        Console.WriteLine($"Exception type: {error.GetType().Name}");\r\n\r\n        var decision = await HandleError(nodeId, error, context, ct);\r\n        Console.WriteLine($"Decision: {decision}");\r\n\r\n        return decision;\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Fix:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Ensure error handler returns RestartNode for appropriate errors\r\npublic class FixedErrorHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId, Exception error, PipelineContext context, CancellationToken ct)\r\n    {\r\n        return error switch\r\n        {\r\n            TimeoutException => Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            HttpRequestException => Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            InvalidOperationException => Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\r\n        };\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"dependency-validation-checklist",children:"Dependency Validation Checklist"}),"\n",(0,t.jsx)(n.p,{children:"Use this checklist to validate your resilience configuration:"}),"\n",(0,t.jsx)(n.h3,{id:"-resilientexecutionstrategy-applied",children:"\u2705 ResilientExecutionStrategy Applied"}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All nodes requiring resilience have ",(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"})," applied"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Inner strategy is correctly configured (Sequential, Parallel, etc.)"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Strategy is applied before error handling configuration"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"-materialization-configured",children:"\u2705 Materialization Configured"}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," is set to a non-null value for streaming inputs"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Buffer size is appropriate for expected data volume"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Memory constraints are considered"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"-error-handler-configured",children:"\u2705 Error Handler Configured"}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.code,{children:"IPipelineErrorHandler"})," is registered"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Handler returns ",(0,t.jsx)(n.code,{children:"RestartNode"})," for appropriate error types"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Handler is configured with the pipeline"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"-retry-options-configured",children:"\u2705 Retry Options Configured"}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.code,{children:"MaxNodeRestartAttempts"})," is set to enable restarts"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.code,{children:"MaxItemRetries"})," is configured for item-level retries"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.code,{children:"MaxSequentialNodeAttempts"})," is set appropriately"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"visual-dependency-flow",children:"Visual Dependency Flow"}),"\n",(0,t.jsx)(n.mermaid,{value:"flowchart TD\r\n    Start[Node Configuration] --\x3e RES{ResilientExecutionStrategy?}\r\n    RES --\x3e|No| Fail[\u274c No Resilience]\r\n    RES --\x3e|Yes| MAT{MaxMaterializedItems > 0?}\r\n\r\n    MAT --\x3e|No| NoRestart[\u274c RestartNode Disabled]\r\n    MAT --\x3e|Yes| EH{IPipelineErrorHandler?}\r\n\r\n    EH --\x3e|No| NoDecision[\u274c No Error Handling]\r\n    EH --\x3e|Yes| DEC{Returns RestartNode?}\r\n\r\n    DEC --\x3e|No| NoRestartDecision[\u274c No Restart Decision]\r\n    DEC --\x3e|Yes| RETRY{MaxNodeRestartAttempts > 0?}\r\n\r\n    RETRY --\x3e|No| NoRetryLimit[\u274c No Retry Attempts]\r\n    RETRY --\x3e|Yes| Success[\u2705 Full Resilience]\r\n\r\n    style Success fill:#e8f5e9\r\n    style Fail fill:#ffebee\r\n    style NoRestart fill:#ffebee\r\n    style NoDecision fill:#ffebee\r\n    style NoRestartDecision fill:#ffebee\r\n    style NoRetryLimit fill:#ffebee"}),"\n",(0,t.jsx)(n.h2,{id:"testing-dependency-chains",children:"Testing Dependency Chains"}),"\n",(0,t.jsx)(n.h3,{id:"unit-test-for-dependency-validation",children:"Unit Test for Dependency Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'[Test]\r\npublic void ResilienceDependencies_ShouldBeCorrectlyConfigured()\r\n{\r\n    // Arrange\r\n    var pipeline = CreateTestPipeline();\r\n    var nodeDefinition = pipeline.GetNodeDefinition("testNode");\r\n\r\n    // Assert ResilientExecutionStrategy is applied\r\n    Assert.IsInstanceOf<ResilientExecutionStrategy>(nodeDefinition.ExecutionStrategy);\r\n\r\n    // Assert materialization is configured\r\n    var retryOptions = pipeline.RetryOptions;\r\n    Assert.IsNotNull(retryOptions.MaxMaterializedItems);\r\n    Assert.Greater(retryOptions.MaxMaterializedItems.Value, 0);\r\n\r\n    // Assert error handler is configured\r\n    Assert.IsNotNull(pipeline.ErrorHandler);\r\n}\r\n\r\n[Test]\r\npublic async Task RestartNode_ShouldWork_WhenDependenciesMet()\r\n{\r\n    // Arrange\r\n    var pipeline = CreateResilientPipeline();\r\n    var context = PipelineContext.WithRetry(new PipelineRetryOptions(\r\n        MaxItemRetries: 3,\r\n        MaxNodeRestartAttempts: 2,\r\n        MaxSequentialNodeAttempts: 5,\r\n        MaxMaterializedItems: 1000\r\n    ));\r\n\r\n    // Act - Simulate failure that should trigger restart\r\n    var result = await pipeline.RunWithFailure(context);\r\n\r\n    // Assert - Node should have restarted\r\n    Assert.Greater(context.GetRestartCount("testNode"), 0);\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"integration-test-for-end-to-end-validation",children:"Integration Test for End-to-End Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'[Test]\r\npublic async Task FullResilienceChain_ShouldWork_IntegrationTest()\r\n{\r\n    // Arrange\r\n    var flakySource = new FlakyDataSource(failureRate: 0.3);\r\n    \r\n    var retryOptions = new PipelineRetryOptions(\r\n        MaxItemRetries: 3,\r\n        MaxNodeRestartAttempts: 2,\r\n        MaxSequentialNodeAttempts: 5,\r\n        MaxMaterializedItems: 1000\r\n    );\r\n    \r\n    var context = PipelineContext.WithRetry(retryOptions);\r\n    context.AddPipelineErrorHandler<TestErrorHandler>();\r\n\r\n    // Act\r\n    var runner = new PipelineRunner();\r\n    var result = await runner.RunAsync<FullResiliencePipeline>(context);\r\n\r\n    // Assert - should complete successfully with resilience applied\r\n    Assert.NotNull(result);\r\n}\r\n\r\npublic class FullResiliencePipeline : IPipelineDefinition\r\n{\r\n    private readonly FlakyDataSource _flakySource;\r\n\r\n    public FullResiliencePipeline(FlakyDataSource flakySource)\r\n    {\r\n        _flakySource = flakySource;\r\n    }\r\n\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<FlakyDataSource, Data>("source");\r\n        var transformHandle = builder\r\n            .AddTransform<DataTransform, Data, TransformedData>("transform")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new SequentialExecutionStrategy()\r\n            ));\r\n        var sinkHandle = builder.AddSink<DataSink, TransformedData>("sink");\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"// Assert\r\nAssert.IsTrue(result.IsSuccess);\r\nAssert.Greater(flakySource.ProcessedItems, 0);\r\n}"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\r\n## :arrow_right: Next Steps\r\n\r\n- **[Configuration Guide](configuration-guide.md)**: Get practical implementation guidance with complete examples\r\n- **[Troubleshooting](troubleshooting.md)**: Learn to diagnose and resolve dependency issues\r\n\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var r=i(6540);const t={},s=r.createContext(t);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);