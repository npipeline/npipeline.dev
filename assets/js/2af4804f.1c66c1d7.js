"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[7376],{7037:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>s,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"core-concepts/pipeline-execution/pipeline-error-handling","title":"Pipeline-level Error Handling","description":"Learn how to implement pipeline-level error handling in NPipeline using IPipelineErrorHandler to manage errors that affect entire node streams.","source":"@site/docs/core-concepts/pipeline-execution/pipeline-error-handling.md","sourceDirName":"core-concepts/pipeline-execution","slug":"/core-concepts/pipeline-execution/pipeline-error-handling","permalink":"/docs/core-concepts/pipeline-execution/pipeline-error-handling","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Pipeline-level Error Handling","description":"Learn how to implement pipeline-level error handling in NPipeline using IPipelineErrorHandler to manage errors that affect entire node streams.","sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Node-level Error Handling","permalink":"/docs/core-concepts/pipeline-execution/node-error-handling"},"next":{"title":"Retry Configuration","permalink":"/docs/core-concepts/pipeline-execution/retry-configuration"}}');var o=n(4848),t=n(8453);const l={title:"Pipeline-level Error Handling",description:"Learn how to implement pipeline-level error handling in NPipeline using IPipelineErrorHandler to manage errors that affect entire node streams.",sidebar_position:6},a="Pipeline-level Error Handling",s={},d=[{value:"Overview",id:"overview",level:2},{value:"IPipelineErrorHandler Interface",id:"ipipelineerrorhandler-interface",level:2},{value:"PipelineErrorDecision",id:"pipelineerrordecision",level:2},{value:"Implementing a Custom Pipeline Error Handler",id:"implementing-a-custom-pipeline-error-handler",level:2},{value:"Registering a Pipeline Error Handler",id:"registering-a-pipeline-error-handler",level:2},{value:"Common Pipeline Error Handling Scenarios",id:"common-pipeline-error-handling-scenarios",level:2},{value:"Scenario 1: Resource Exhaustion Handling",id:"scenario-1-resource-exhaustion-handling",level:3},{value:"Scenario 2: External Service Dependency Handling",id:"scenario-2-external-service-dependency-handling",level:3},{value:"Scenario 3: Circuit Breaker Pattern Implementation",id:"scenario-3-circuit-breaker-pattern-implementation",level:3},{value:"Production-Ready Pipeline Error Handler",id:"production-ready-pipeline-error-handler",level:2},{value:"\u2705 Best Practices",id:"white_check_mark-best-practices",level:2},{value:"\ud83d\udd17 Related Topics",id:"link-related-topics",level:2}];function c(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"pipeline-level-error-handling",children:"Pipeline-level Error Handling"})}),"\n",(0,o.jsx)(r.p,{children:"Pipeline-level error handling in NPipeline is designed to manage errors that affect an entire node's stream rather than individual items. These are typically more severe errors that might impact the entire pipeline execution flow, such as infrastructure failures or external service outages."}),"\n",(0,o.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsxs)(r.p,{children:["When an error occurs that affects an entire node's stream (e.g., an external service going down), NPipeline's ",(0,o.jsx)(r.code,{children:"ResilientExecutionStrategy"})," consults the configured ",(0,o.jsx)(r.code,{children:"IPipelineErrorHandler"})," to determine how to react to such failures. This allows you to implement strategies like restarting a failing node, continuing without it, or failing the entire pipeline."]}),"\n",(0,o.jsx)(r.h2,{id:"ipipelineerrorhandler-interface",children:"IPipelineErrorHandler Interface"}),"\n",(0,o.jsxs)(r.p,{children:["For errors that affect an entire node's stream, you implement ",(0,o.jsx)(r.a,{href:"../../../src/NPipeline/Abstractions/ErrorHandling/IPipelineErrorHandler.cs",children:(0,o.jsx)(r.code,{children:"IPipelineErrorHandler"})})," interface."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"public interface IPipelineErrorHandler\r\n{\r\n    Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,o.jsx)(r.h2,{id:"pipelineerrordecision",children:"PipelineErrorDecision"}),"\n",(0,o.jsx)(r.p,{children:"This enum defines the decision when a node stream fails:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"RestartNode"})}),": The node's entire input stream will be re-processed from the beginning (requires the input stream to be replayable, e.g., if materialized by ",(0,o.jsx)(r.code,{children:"ResilientExecutionStrategy"}),")."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"ContinueWithoutNode"})}),": The failing node is effectively removed from the pipeline, and its output stream will be empty. The pipeline continues without it."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"FailPipeline"})}),": The entire pipeline execution terminates."]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"implementing-a-custom-pipeline-error-handler",children:"Implementing a Custom Pipeline Error Handler"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.ErrorHandling;\r\nusing NPipeline.Pipeline;\r\n\r\npublic sealed class MyPipelineErrorHandler : IPipelineErrorHandler\r\n{\r\n    private readonly ILogger _logger;\r\n    private readonly Dictionary<string, int> _nodeRestartAttempts = new();\r\n\r\n    public MyPipelineErrorHandler(ILogger logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        _nodeRestartAttempts.TryGetValue(nodeId, out var attempts);\r\n        attempts++;\r\n        _nodeRestartAttempts[nodeId] = attempts;\r\n\r\n        _logger.LogError(error, \"Pipeline-level error in node '{NodeId}': {ErrorMessage}\",\r\n            nodeId, error.Message);\r\n\r\n        // Example logic:\r\n        // - Allow a few restarts for transient node failures.\r\n        // - If persistent, fail the pipeline.\r\n        if (attempts < 3)\r\n        {\r\n            _logger.LogInformation(\"Attempting to restart node '{NodeId}'. Attempt: {Attempt}\",\r\n                nodeId, attempts);\r\n            return Task.FromResult(PipelineErrorDecision.RestartNode);\r\n        }\r\n        else\r\n        {\r\n            _logger.LogError(\"Node '{NodeId}' failed too many times, failing pipeline.\", nodeId);\r\n            return Task.FromResult(PipelineErrorDecision.FailPipeline);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(r.h2,{id:"registering-a-pipeline-error-handler",children:"Registering a Pipeline Error Handler"}),"\n",(0,o.jsxs)(r.p,{children:["You register a pipeline error handler using the ",(0,o.jsx)(r.code,{children:"AddPipelineErrorHandler"})," method on ",(0,o.jsx)(r.code,{children:"PipelineBuilder"}),":"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.ErrorHandling;\r\nusing NPipeline.Pipeline;\r\n\r\npublic sealed class ErrorHandlingPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<DataSource, string>();\r\n        var transformHandle = builder.AddTransform<DataTransform, string, string>();\r\n        var sinkHandle = builder.AddSink<DataSink, string>();\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n\r\n        // Configure retry options\r\n        builder.WithRetryOptions(new PipelineRetryOptions(\r\n            MaxItemRetries: 3,\r\n            MaxNodeRestartAttempts: 2,\r\n            MaxSequentialNodeAttempts: 5\r\n        ));\r\n\r\n        // Register the pipeline error handler\r\n        builder.AddPipelineErrorHandler<MyPipelineErrorHandler>();\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var runner = new PipelineRunner();\r\n\r\n        // Configure retry options at context level\r\n        var retryOptions = new PipelineRetryOptions(\r\n            MaxItemRetries: 3,\r\n            MaxNodeRestartAttempts: 2,\r\n            MaxSequentialNodeAttempts: 5\r\n        );\r\n\r\n        var context = new PipelineContextBuilder()\r\n            .WithRetryOptions(retryOptions)\r\n            .Build();\r\n\r\n        var pipeline = PipelineBuilder.Create<ErrorHandlingPipelineDefinition>();\r\n\r\n        await runner.RunAsync<ErrorHandlingPipelineDefinition>(context);\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(r.p,{children:"You also need to register your custom error handler with your DI container:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"services.AddSingleton<IPipelineErrorHandler, MyPipelineErrorHandler>();\n"})}),"\n",(0,o.jsx)(r.h2,{id:"common-pipeline-error-handling-scenarios",children:"Common Pipeline Error Handling Scenarios"}),"\n",(0,o.jsx)(r.h3,{id:"scenario-1-resource-exhaustion-handling",children:"Scenario 1: Resource Exhaustion Handling"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"public class ResourceExhaustionHandler : IPipelineErrorHandler\r\n{\r\n    private readonly ILogger _logger;\r\n    private readonly Dictionary<string, int> _nodeFailureCounts = new();\r\n\r\n    public ResourceExhaustionHandler(ILogger logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        _nodeFailureCounts.TryGetValue(nodeId, out var count);\r\n        _nodeFailureCounts[nodeId] = count + 1;\r\n\r\n        if (error is OutOfMemoryException or InsufficientMemoryException)\r\n        {\r\n            _logger.LogCritical(\"Resource exhaustion in node '{NodeId}': {Error}\", nodeId, error.Message);\r\n            return Task.FromResult(PipelineErrorDecision.FailPipeline);\r\n        }\r\n\r\n        // For other errors, allow up to 3 restarts per node\r\n        if (_nodeFailureCounts[nodeId] <= 3)\r\n        {\r\n            _logger.LogWarning(\"Restarting node '{NodeId}' (attempt {Attempt})\", nodeId, _nodeFailureCounts[nodeId]);\r\n            return Task.FromResult(PipelineErrorDecision.RestartNode);\r\n        }\r\n\r\n        _logger.LogError(\"Node '{NodeId}' failed too many times, continuing without it\", nodeId);\r\n        return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(r.h3,{id:"scenario-2-external-service-dependency-handling",children:"Scenario 2: External Service Dependency Handling"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"public class ExternalServiceErrorHandler : IPipelineErrorHandler\r\n{\r\n    private readonly ILogger _logger;\r\n    private readonly Dictionary<string, DateTime> _lastFailureTime = new();\r\n    private readonly Dictionary<string, int> _failureCounts = new();\r\n\r\n    public ExternalServiceErrorHandler(ILogger logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        _failureCounts.TryGetValue(nodeId, out var count);\r\n        _failureCounts[nodeId] = count + 1;\r\n\r\n        var now = DateTime.UtcNow;\r\n        _lastFailureTime.TryGetValue(nodeId, out var lastFailure);\r\n\r\n        // If the same node failed recently, it might be a persistent issue\r\n        if (lastFailure != null && (now - lastFailure).TotalMinutes < 5)\r\n        {\r\n            _logger.LogWarning(\"Node '{NodeId}' failed again recently ({Minutes} minutes ago). Total failures: {Count}\",\r\n                nodeId, (now - lastFailure).TotalMinutes, _failureCounts[nodeId]);\r\n\r\n            // After multiple recent failures, continue without the node\r\n            if (_failureCounts[nodeId] >= 3)\r\n            {\r\n                _logger.LogError(\"Node '{NodeId}' has failed multiple times recently, continuing without it\", nodeId);\r\n                return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\r\n            }\r\n        }\r\n\r\n        _lastFailureTime[nodeId] = now;\r\n\r\n        // For external service errors, try restarting the node\r\n        if (error is HttpRequestException or TimeoutException)\r\n        {\r\n            _logger.LogWarning(\"External service error in node '{NodeId}': {Error}. Restarting node.\", nodeId, error.Message);\r\n            return Task.FromResult(PipelineErrorDecision.RestartNode);\r\n        }\r\n\r\n        // For other types of errors, fail the pipeline\r\n        _logger.LogError(\"Unexpected error in node '{NodeId}': {Error}. Failing pipeline.\", nodeId, error.Message);\r\n        return Task.FromResult(PipelineErrorDecision.FailPipeline);\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(r.h3,{id:"scenario-3-circuit-breaker-pattern-implementation",children:"Scenario 3: Circuit Breaker Pattern Implementation"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"public class CircuitBreakerErrorHandler : IPipelineErrorHandler\r\n{\r\n    private readonly ILogger _logger;\r\n    private readonly Dictionary<string, CircuitBreakerState> _circuitBreakers = new();\r\n    private readonly TimeSpan _openDuration = TimeSpan.FromMinutes(5);\r\n    private readonly int _failureThreshold = 5;\r\n\r\n    private class CircuitBreakerState\r\n    {\r\n        public int FailureCount { get; set; }\r\n        public DateTime? LastFailureTime { get; set; }\r\n        public bool IsOpen { get; set; }\r\n    }\r\n\r\n    public CircuitBreakerErrorHandler(ILogger logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        if (!_circuitBreakers.TryGetValue(nodeId, out var state))\r\n        {\r\n            state = new CircuitBreakerState();\r\n            _circuitBreakers[nodeId] = state;\r\n        }\r\n\r\n        state.FailureCount++;\r\n        state.LastFailureTime = DateTime.UtcNow;\r\n\r\n        // If circuit is open, check if it should be half-open\r\n        if (state.IsOpen)\r\n        {\r\n            var timeSinceOpen = DateTime.UtcNow - state.LastFailureTime.Value;\r\n            if (timeSinceOpen > _openDuration)\r\n            {\r\n                state.IsOpen = false;\r\n                state.FailureCount = 0;\r\n                _logger.LogInformation(\"Circuit breaker for node '{NodeId}' is now half-open\", nodeId);\r\n            }\r\n            else\r\n            {\r\n                _logger.LogWarning(\"Circuit breaker for node '{NodeId}' is open. Failing pipeline.\", nodeId);\r\n                return Task.FromResult(PipelineErrorDecision.FailPipeline);\r\n            }\r\n        }\r\n\r\n        // Check if failure threshold is reached\r\n        if (state.FailureCount >= _failureThreshold)\r\n        {\r\n            state.IsOpen = true;\r\n            _logger.LogError(\"Circuit breaker for node '{NodeId}' opened after {FailureCount} failures\", nodeId, state.FailureCount);\r\n            return Task.FromResult(PipelineErrorDecision.FailPipeline);\r\n        }\r\n\r\n        // For normal failures, restart the node\r\n        _logger.LogWarning(\"Node '{NodeId}' failed (attempt {FailureCount}/{Threshold}). Restarting node.\",\r\n            nodeId, state.FailureCount, _failureThreshold);\r\n        return Task.FromResult(PipelineErrorDecision.RestartNode);\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(r.h2,{id:"production-ready-pipeline-error-handler",children:"Production-Ready Pipeline Error Handler"}),"\n",(0,o.jsx)(r.p,{children:"Here's a comprehensive example that combines multiple strategies:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.ErrorHandling;\r\nusing NPipeline.Pipeline;\r\n\r\npublic class ProductionPipelineErrorHandler : IPipelineErrorHandler\r\n{\r\n    private readonly ILogger _logger;\r\n    private readonly IMetrics _metrics;\r\n    private readonly Dictionary<string, FailureInfo> _nodeFailures = new();\r\n    private readonly TimeSpan _failureWindow = TimeSpan.FromMinutes(10);\r\n    private readonly int _maxFailuresPerWindow = 5;\r\n    private readonly int _maxTotalFailures = 20;\r\n\r\n    private class FailureInfo\r\n    {\r\n        public int TotalFailures { get; set; }\r\n        public List<DateTime> RecentFailures { get; set; } = new();\r\n        public DateTime? LastFailureTime { get; set; }\r\n    }\r\n\r\n    public ProductionPipelineErrorHandler(ILogger logger, IMetrics metrics)\r\n    {\r\n        _logger = logger;\r\n        _metrics = metrics;\r\n    }\r\n\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        if (!_nodeFailures.TryGetValue(nodeId, out var failureInfo))\r\n        {\r\n            failureInfo = new FailureInfo();\r\n            _nodeFailures[nodeId] = failureInfo;\r\n        }\r\n\r\n        failureInfo.TotalFailures++;\r\n        failureInfo.LastFailureTime = DateTime.UtcNow;\r\n\r\n        // Clean up old failures outside the window\r\n        var now = DateTime.UtcNow;\r\n        failureInfo.RecentFailures.RemoveAll(time => now - time > _failureWindow);\r\n        failureInfo.RecentFailures.Add(now);\r\n\r\n        // Record metrics\r\n        _metrics.Increment("pipeline_node_failures", new[]\r\n        {\r\n            new KeyValuePair<string, object>("node_id", nodeId),\r\n            new KeyValuePair<string, object>("error_type", error.GetType().Name)\r\n        });\r\n\r\n        _logger.LogError(error, "Node {NodeId} failed (total: {TotalFailures}, recent: {RecentFailures})",\r\n            nodeId, failureInfo.TotalFailures, failureInfo.RecentFailures.Count);\r\n\r\n        // Check for critical errors that should fail the pipeline immediately\r\n        if (IsCriticalError(error))\r\n        {\r\n            _logger.LogCritical("Critical error in node \'{NodeId}\': {ErrorType}. Failing pipeline.",\r\n                nodeId, error.GetType().Name);\r\n            return Task.FromResult(PipelineErrorDecision.FailPipeline);\r\n        }\r\n\r\n        // Check if we\'ve exceeded the total failure limit\r\n        if (failureInfo.TotalFailures >= _maxTotalFailures)\r\n        {\r\n            _logger.LogError("Node \'{NodeId}\' has exceeded maximum total failures ({MaxFailures}). Continuing without node.",\r\n                nodeId, _maxTotalFailures);\r\n            return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\r\n        }\r\n\r\n        // Check if we\'ve exceeded the failure window limit\r\n        if (failureInfo.RecentFailures.Count >= _maxFailuresPerWindow)\r\n        {\r\n            _logger.LogError("Node \'{NodeId}\' has exceeded failure rate ({RecentFailures} in {Window} minutes). Continuing without node.",\r\n                nodeId, failureInfo.RecentFailures.Count, _failureWindow.TotalMinutes);\r\n            return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\r\n        }\r\n\r\n        // For transient errors, restart the node\r\n        if (IsTransientError(error))\r\n        {\r\n            _logger.LogWarning("Transient error in node \'{NodeId}\': {ErrorType}. Restarting node.",\r\n                nodeId, error.GetType().Name);\r\n            return Task.FromResult(PipelineErrorDecision.RestartNode);\r\n        }\r\n\r\n        // For other errors, continue without the node\r\n        _logger.LogWarning("Non-transient error in node \'{NodeId}\': {ErrorType}. Continuing without node.",\r\n            nodeId, error.GetType().Name);\r\n        return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\r\n    }\r\n\r\n    private static bool IsCriticalError(Exception error)\r\n    {\r\n        return error is OutOfMemoryException or StackOverflowException or AccessViolationException;\r\n    }\r\n\r\n    private static bool IsTransientError(Exception error)\r\n    {\r\n        return error is TimeoutException or HttpRequestException or OperationCanceledException;\r\n    }\r\n}\n'})}),"\n",(0,o.jsxs)(r.h2,{id:"white_check_mark-best-practices",children:["\u2705"," Best Practices"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Track failure patterns"}),": Keep track of when and how often nodes fail to detect persistent issues."]}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Implement circuit breaker patterns"}),": Prevent cascading failures by temporarily stopping attempts to failing nodes."]}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Differentiate between error types"}),": Critical errors should fail the pipeline immediately, while transient errors might be worth retrying."]}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Set reasonable limits"}),": Prevent infinite restarts by setting limits on the number of restart attempts."]}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Monitor and alert"}),": Implement proper monitoring and alerting for pipeline failures."]}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Consider graceful degradation"}),": Design your pipeline to continue functioning even when some nodes fail."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(r.h2,{id:"link-related-topics",children:["\ud83d\udd17"," Related Topics"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.a,{href:"/docs/core-concepts/pipeline-execution/node-error-handling",children:"Node-level Error Handling"})}),": Learn about handling errors for individual items."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.a,{href:"/docs/core-concepts/pipeline-execution/retry-configuration",children:"Retry Configuration"})}),": Configure retry behavior for node restarts."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.a,{href:"/docs/core-concepts/pipeline-execution/circuit-breaker-configuration",children:"Circuit Breaker Configuration"})}),": Configure circuit breaker patterns."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.a,{href:"/docs/core-concepts/pipeline-execution/dead-letter-queues",children:"Dead-Letter Queues"})}),": Implement dead-letter queues for problematic items."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.a,{href:"/docs/core-concepts/pipeline-execution/error-handling",children:"Error Handling Overview"})}),": Return to the error handling overview."]}),"\n"]})]})}function p(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>a});var i=n(6540);const o={},t=i.createContext(o);function l(e){const r=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),i.createElement(t.Provider,{value:r},e.children)}}}]);