"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[2402],{8179:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"extensions/composition/testing","title":"Testing Composite Pipelines","description":"Overview","source":"@site/docs/extensions/composition/testing.md","sourceDirName":"extensions/composition","slug":"/extensions/composition/testing","permalink":"/docs/extensions/composition/testing","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Performance Optimization","permalink":"/docs/extensions/composition/performance"},"next":{"title":"NPipeline Observability Extension","permalink":"/docs/extensions/observability/"}}');var s=t(74848),r=t(28453);const a={},l="Testing Composite Pipelines",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Testing Strategies",id:"testing-strategies",level:2},{value:"1. Test Sub-Pipelines Independently",id:"1-test-sub-pipelines-independently",level:3},{value:"2. Test Parent Pipeline with Mock Sub-Pipelines",id:"2-test-parent-pipeline-with-mock-sub-pipelines",level:3},{value:"3. Integration Testing",id:"3-integration-testing",level:3},{value:"4. Test Context Inheritance",id:"4-test-context-inheritance",level:3},{value:"Test Helpers",id:"test-helpers",level:2},{value:"Helper: CollectorSink",id:"helper-collectorsink",level:3},{value:"Helper: StubSource",id:"helper-stubsource",level:3},{value:"Helper: SpyTransform",id:"helper-spytransform",level:3},{value:"Test Patterns",id:"test-patterns",level:2},{value:"Pattern 1: Arrange-Act-Assert",id:"pattern-1-arrange-act-assert",level:3},{value:"Pattern 2: Theory-Based Testing",id:"pattern-2-theory-based-testing",level:3},{value:"Pattern 3: Builder Pattern for Test Data",id:"pattern-3-builder-pattern-for-test-data",level:3},{value:"Pattern 4: Fixture-Based Testing",id:"pattern-4-fixture-based-testing",level:3},{value:"Testing Error Scenarios",id:"testing-error-scenarios",level:2},{value:"Test Exception Handling",id:"test-exception-handling",level:3},{value:"Test Error Propagation",id:"test-error-propagation",level:3},{value:"Testing Async Behavior",id:"testing-async-behavior",level:2},{value:"Test Cancellation",id:"test-cancellation",level:3},{value:"Test Async Transforms",id:"test-async-transforms",level:3},{value:"Test-Driven Development",id:"test-driven-development",level:2},{value:"TDD Workflow for Composite Pipelines",id:"tdd-workflow-for-composite-pipelines",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Test Pyramid",id:"1-test-pyramid",level:3},{value:"2. Isolate External Dependencies",id:"2-isolate-external-dependencies",level:3},{value:"3. Use Descriptive Test Names",id:"3-use-descriptive-test-names",level:3},{value:"4. Test One Thing Per Test",id:"4-test-one-thing-per-test",level:3},{value:"5. Clean Up After Tests",id:"5-clean-up-after-tests",level:3},{value:"Summary",id:"summary",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"testing-composite-pipelines",children:"Testing Composite Pipelines"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Testing composite pipelines requires different strategies than testing flat pipelines. This guide covers unit testing, integration testing, and test-driven development approaches for composite pipelines."}),"\n",(0,s.jsx)(n.h2,{id:"testing-strategies",children:"Testing Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"1-test-sub-pipelines-independently",children:"1. Test Sub-Pipelines Independently"}),"\n",(0,s.jsxs)(n.p,{children:["The most important principle: ",(0,s.jsx)(n.strong,{children:"test each sub-pipeline in isolation"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'[Fact]\npublic async Task ValidationPipeline_WithValidData_ShouldPass()\n{\n    // Arrange\n    var runner = PipelineRunner.Create();\n    var context = new PipelineContext();\n    var validCustomer = new Customer(1, "John", "john@example.com");\n    context.Parameters[CompositeContextKeys.InputItem] = validCustomer;\n    \n    // Act\n    await runner.RunAsync<ValidationPipeline>(context);\n    \n    // Assert\n    var output = context.Parameters[CompositeContextKeys.OutputItem];\n    output.Should().BeOfType<ValidatedCustomer>();\n    var validated = (ValidatedCustomer)output;\n    validated.IsValid.Should().BeTrue();\n}\n\n[Fact]\npublic async Task ValidationPipeline_WithInvalidData_ShouldFail()\n{\n    // Arrange\n    var runner = PipelineRunner.Create();\n    var context = new PipelineContext();\n    var invalidCustomer = new Customer(1, "", ""); // Missing name and email\n    context.Parameters[CompositeContextKeys.InputItem] = invalidCustomer;\n    \n    // Act\n    await runner.RunAsync<ValidationPipeline>(context);\n    \n    // Assert\n    var output = context.Parameters[CompositeContextKeys.OutputItem];\n    var validated = (ValidatedCustomer)output;\n    validated.IsValid.Should().BeFalse();\n    validated.ValidationErrors.Should().Contain("Name is required");\n    validated.ValidationErrors.Should().Contain("Email is required");\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-test-parent-pipeline-with-mock-sub-pipelines",children:"2. Test Parent Pipeline with Mock Sub-Pipelines"}),"\n",(0,s.jsx)(n.p,{children:"Test the parent pipeline structure without executing real sub-pipelines:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// Mock sub-pipeline for testing\npublic class MockValidationPipeline : IPipelineDefinition\n{\n    public static int CallCount { get; set; }\n    \n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<Customer>, Customer>("input");\n        var mock = builder.AddTransform<MockValidator, Customer, ValidatedCustomer>("mock");\n        var output = builder.AddSink<PipelineOutputSink<ValidatedCustomer>, ValidatedCustomer>("output");\n        \n        builder.Connect(input, mock);\n        builder.Connect(mock, output);\n    }\n}\n\npublic class MockValidator : TransformNode<Customer, ValidatedCustomer>\n{\n    public override Task<ValidatedCustomer> ExecuteAsync(Customer input, PipelineContext context, CancellationToken ct)\n    {\n        MockValidationPipeline.CallCount++;\n        return Task.FromResult(new ValidatedCustomer(input, true, new List<string>()));\n    }\n}\n\n[Fact]\npublic async Task ParentPipeline_ShouldCallValidationPipeline()\n{\n    // Arrange\n    MockValidationPipeline.CallCount = 0;\n    var runner = PipelineRunner.Create();\n    var context = new PipelineContext();\n    \n    // Act\n    await runner.RunAsync<ParentPipelineWithMocks>(context);\n    \n    // Assert\n    MockValidationPipeline.CallCount.Should().BeGreaterThan(0);\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-integration-testing",children:"3. Integration Testing"}),"\n",(0,s.jsx)(n.p,{children:"Test the complete pipeline hierarchy:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"[Fact]\npublic async Task CompleteWorkflow_WithRealData_ShouldProcessCorrectly()\n{\n    // Arrange\n    var runner = PipelineRunner.Create();\n    var context = new PipelineContext();\n    var collector = new CollectorSink<EnrichedCustomer>();\n    \n    // Act\n    await runner.RunAsync<CompleteProcessingPipeline>(context);\n    \n    // Assert\n    var results = collector.CollectedItems;\n    results.Should().HaveCount(ExpectedCount);\n    results.All(r => r.ValidatedCustomer.IsValid).Should().BeTrue();\n    results.All(r => r.LoyaltyTier != null).Should().BeTrue();\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-test-context-inheritance",children:"4. Test Context Inheritance"}),"\n",(0,s.jsx)(n.p,{children:"Verify context data flows correctly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'[Fact]\npublic async Task SubPipeline_WithInheritance_ShouldReceiveParentContext()\n{\n    // Arrange\n    var runner = PipelineRunner.Create();\n    var context = new PipelineContext();\n    context.Parameters["ApiKey"] = "test-key";\n    context.Parameters["Environment"] = "Test";\n    \n    ContextCheckTransform.CapturedApiKey = null;\n    ContextCheckTransform.CapturedEnvironment = null;\n    \n    // Act\n    await runner.RunAsync<ParentWithInheritance>(context);\n    \n    // Assert\n    ContextCheckTransform.CapturedApiKey.Should().Be("test-key");\n    ContextCheckTransform.CapturedEnvironment.Should().Be("Test");\n}\n\n[Fact]\npublic async Task SubPipeline_WithoutInheritance_ShouldNotReceiveParentContext()\n{\n    // Arrange\n    var runner = PipelineRunner.Create();\n    var context = new PipelineContext();\n    context.Parameters["ApiKey"] = "test-key";\n    \n    ContextCheckTransform.CapturedApiKey = null;\n    \n    // Act\n    await runner.RunAsync<ParentWithoutInheritance>(context);\n    \n    // Assert\n    ContextCheckTransform.CapturedApiKey.Should().BeNull();\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"test-helpers",children:"Test Helpers"}),"\n",(0,s.jsx)(n.h3,{id:"helper-collectorsink",children:"Helper: CollectorSink"}),"\n",(0,s.jsx)(n.p,{children:"Collects items for assertion:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class CollectorSink<T> : ISinkNode<T>\n{\n    public List<T> CollectedItems { get; } = new();\n    \n    public async Task ExecuteAsync(IDataPipe<T> input, PipelineContext context, CancellationToken ct)\n    {\n        CollectedItems.Clear();\n        await foreach (var item in input.WithCancellation(ct))\n        {\n            CollectedItems.Add(item);\n        }\n    }\n    \n    public ValueTask DisposeAsync()\n    {\n        GC.SuppressFinalize(this);\n        return ValueTask.CompletedTask;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"helper-stubsource",children:"Helper: StubSource"}),"\n",(0,s.jsx)(n.p,{children:"Provides test data:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class StubSource<T> : ISourceNode<T>\n{\n    private readonly IEnumerable<T> _items;\n    \n    public StubSource(IEnumerable<T> items)\n    {\n        _items = items;\n    }\n    \n    public IDataPipe<T> Initialize(PipelineContext context, CancellationToken ct)\n    {\n        return new InMemoryDataPipe<T>(_items, "StubSource");\n    }\n    \n    public ValueTask DisposeAsync()\n    {\n        GC.SuppressFinalize(this);\n        return ValueTask.CompletedTask;\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"helper-spytransform",children:"Helper: SpyTransform"}),"\n",(0,s.jsx)(n.p,{children:"Tracks calls and data:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class SpyTransform<T> : TransformNode<T, T>\n{\n    public List<T> ProcessedItems { get; } = new();\n    public int CallCount { get; private set; }\n    \n    public override Task<T> ExecuteAsync(T input, PipelineContext context, CancellationToken ct)\n    {\n        CallCount++;\n        ProcessedItems.Add(input);\n        return Task.FromResult(input);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"test-patterns",children:"Test Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"pattern-1-arrange-act-assert",children:"Pattern 1: Arrange-Act-Assert"}),"\n",(0,s.jsx)(n.p,{children:"Standard test structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"[Fact]\npublic async Task SubPipeline_ValidInput_ProducesExpectedOutput()\n{\n    // Arrange: Set up test data and context\n    var runner = PipelineRunner.Create();\n    var context = new PipelineContext();\n    var testInput = CreateTestInput();\n    context.Parameters[CompositeContextKeys.InputItem] = testInput;\n    \n    // Act: Execute the pipeline\n    await runner.RunAsync<SubPipeline>(context);\n    \n    // Assert: Verify the output\n    var output = context.Parameters[CompositeContextKeys.OutputItem];\n    output.Should().NotBeNull();\n    VerifyOutput(output);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"pattern-2-theory-based-testing",children:"Pattern 2: Theory-Based Testing"}),"\n",(0,s.jsx)(n.p,{children:"Test multiple scenarios:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'[Theory]\n[InlineData(1, "Bronze")]\n[InlineData(50, "Gold")]\n[InlineData(200, "Silver")]\n[InlineData(1000, "Bronze")]\npublic async Task EnrichmentPipeline_VariousIds_AssignsCorrectTier(int customerId, string expectedTier)\n{\n    // Arrange\n    var runner = PipelineRunner.Create();\n    var context = new PipelineContext();\n    var customer = new Customer(customerId, "Test", "test@example.com");\n    context.Parameters[CompositeContextKeys.InputItem] = customer;\n    \n    // Act\n    await runner.RunAsync<EnrichmentPipeline>(context);\n    \n    // Assert\n    var output = (EnrichedCustomer)context.Parameters[CompositeContextKeys.OutputItem];\n    output.LoyaltyTier.Should().Be(expectedTier);\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"pattern-3-builder-pattern-for-test-data",children:"Pattern 3: Builder Pattern for Test Data"}),"\n",(0,s.jsx)(n.p,{children:"Create complex test data easily:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class CustomerBuilder\n{\n    private int _id = 1;\n    private string _name = "Test Customer";\n    private string _email = "test@example.com";\n    private string? _phone = null;\n    \n    public CustomerBuilder WithId(int id) { _id = id; return this; }\n    public CustomerBuilder WithName(string name) { _name = name; return this; }\n    public CustomerBuilder WithEmail(string email) { _email = email; return this; }\n    public CustomerBuilder WithPhone(string phone) { _phone = phone; return this; }\n    \n    public Customer Build() => new Customer(_id, _name, _email, _phone);\n    \n    public static CustomerBuilder Default() => new();\n}\n\n// Usage\n[Fact]\npublic async Task ValidationPipeline_CustomerWithoutEmail_ShouldFail()\n{\n    var customer = CustomerBuilder.Default()\n        .WithEmail("")  // Invalid\n        .Build();\n        \n    var context = new PipelineContext();\n    context.Parameters[CompositeContextKeys.InputItem] = customer;\n    \n    await runner.RunAsync<ValidationPipeline>(context);\n    \n    var output = (ValidatedCustomer)context.Parameters[CompositeContextKeys.OutputItem];\n    output.IsValid.Should().BeFalse();\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"pattern-4-fixture-based-testing",children:"Pattern 4: Fixture-Based Testing"}),"\n",(0,s.jsx)(n.p,{children:"Share setup across tests:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class CompositionTestFixture\n{\n    public PipelineRunner Runner { get; }\n    public List<Customer> TestCustomers { get; }\n    \n    public CompositionTestFixture()\n    {\n        Runner = PipelineRunner.Create();\n        TestCustomers = new List<Customer>\n        {\n            new Customer(1, "Alice", "alice@example.com"),\n            new Customer(2, "Bob", "bob@example.com"),\n            new Customer(3, "Charlie", "charlie@example.com")\n        };\n    }\n}\n\npublic class CompositionTests : IClassFixture<CompositionTestFixture>\n{\n    private readonly CompositionTestFixture _fixture;\n    \n    public CompositionTests(CompositionTestFixture fixture)\n    {\n        _fixture = fixture;\n    }\n    \n    [Fact]\n    public async Task Test1()\n    {\n        var context = new PipelineContext();\n        context.Parameters[CompositeContextKeys.InputItem] = _fixture.TestCustomers[0];\n        await _fixture.Runner.RunAsync<ValidationPipeline>(context);\n        // Assert\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-error-scenarios",children:"Testing Error Scenarios"}),"\n",(0,s.jsx)(n.h3,{id:"test-exception-handling",children:"Test Exception Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'[Fact]\npublic async Task SubPipeline_WithInvalidData_ShouldThrowValidationException()\n{\n    // Arrange\n    var runner = PipelineRunner.Create();\n    var context = new PipelineContext();\n    var invalidData = CreateInvalidData();\n    context.Parameters[CompositeContextKeys.InputItem] = invalidData;\n    \n    // Act & Assert\n    await Assert.ThrowsAsync<ValidationException>(() =>\n        runner.RunAsync<ValidationPipeline>(context));\n}\n\n[Fact]\npublic async Task SubPipeline_ThrowsException_MessageContainsDetails()\n{\n    // Arrange\n    var runner = PipelineRunner.Create();\n    var context = new PipelineContext();\n    var invalidData = CreateInvalidData();\n    context.Parameters[CompositeContextKeys.InputItem] = invalidData;\n    \n    // Act\n    var exception = await Assert.ThrowsAsync<ValidationException>(() =>\n        runner.RunAsync<ValidationPipeline>(context));\n    \n    // Assert\n    exception.Message.Should().Contain("validation");\n    exception.Message.Should().Contain(invalidData.Id.ToString());\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"test-error-propagation",children:"Test Error Propagation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"[Fact]\npublic async Task ParentPipeline_SubPipelineThrows_ErrorPropagates()\n{\n    // Arrange\n    var runner = PipelineRunner.Create();\n    var context = new PipelineContext();\n    \n    // Act & Assert\n    var exception = await Assert.ThrowsAsync<ProcessingException>(() =>\n        runner.RunAsync<ParentPipeline>(context));\n    \n    exception.InnerException.Should().NotBeNull();\n    exception.InnerException.Should().BeOfType<ValidationException>();\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"testing-async-behavior",children:"Testing Async Behavior"}),"\n",(0,s.jsx)(n.h3,{id:"test-cancellation",children:"Test Cancellation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"[Fact]\npublic async Task SubPipeline_WhenCancelled_ShouldThrowOperationCanceledException()\n{\n    // Arrange\n    var runner = PipelineRunner.Create();\n    var cts = new CancellationTokenSource();\n    var context = new PipelineContext(\n        PipelineContextConfiguration.WithCancellation(cts.Token));\n    \n    // Cancel immediately\n    cts.Cancel();\n    \n    // Act & Assert\n    await Assert.ThrowsAnyAsync<OperationCanceledException>(() =>\n        runner.RunAsync<SlowPipeline>(context));\n}\n\n[Fact]\npublic async Task SubPipeline_CancelledDuringExecution_ShouldStop()\n{\n    // Arrange\n    var runner = PipelineRunner.Create();\n    var cts = new CancellationTokenSource();\n    var context = new PipelineContext(\n        PipelineContextConfiguration.WithCancellation(cts.Token));\n    \n    SpyTransform<int>.ProcessedCount = 0;\n    \n    // Act\n    var task = runner.RunAsync<LongRunningPipeline>(context);\n    \n    // Cancel after some processing\n    await Task.Delay(100);\n    cts.Cancel();\n    \n    // Assert\n    await Assert.ThrowsAnyAsync<OperationCanceledException>(() => task);\n    SpyTransform<int>.ProcessedCount.Should().BeLessThan(ExpectedTotalCount);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"test-async-transforms",children:"Test Async Transforms"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"[Fact]\npublic async Task SubPipeline_WithAsyncTransform_ShouldCompleteSuccessfully()\n{\n    // Arrange\n    var runner = PipelineRunner.Create();\n    var context = new PipelineContext();\n    var input = CreateTestData();\n    context.Parameters[CompositeContextKeys.InputItem] = input;\n    \n    // Act\n    var sw = Stopwatch.StartNew();\n    await runner.RunAsync<AsyncTransformPipeline>(context);\n    sw.Stop();\n    \n    // Assert\n    sw.Elapsed.Should().BeGreaterThan(TimeSpan.FromMilliseconds(100)); // Async delay occurred\n    var output = context.Parameters[CompositeContextKeys.OutputItem];\n    output.Should().NotBeNull();\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"test-driven-development",children:"Test-Driven Development"}),"\n",(0,s.jsx)(n.h3,{id:"tdd-workflow-for-composite-pipelines",children:"TDD Workflow for Composite Pipelines"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Write failing test for sub-pipeline"}),":"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'[Fact]\npublic async Task ValidationPipeline_WithEmail_ShouldValidate()\n{\n    // This test will fail initially\n    var context = new PipelineContext();\n    context.Parameters[CompositeContextKeys.InputItem] = \n        new Customer(1, "Test", "test@example.com");\n    \n    await runner.RunAsync<ValidationPipeline>(context);\n    \n    var output = (ValidatedCustomer)context.Parameters[CompositeContextKeys.OutputItem];\n    output.IsValid.Should().BeTrue();\n}\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement sub-pipeline to pass test"}),":"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class ValidationPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<Customer>, Customer>("input");\n        var validate = builder.AddTransform<EmailValidator, Customer, ValidatedCustomer>("validate");\n        var output = builder.AddSink<PipelineOutputSink<ValidatedCustomer>, ValidatedCustomer>("output");\n        \n        builder.Connect(input, validate);\n        builder.Connect(validate, output);\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Write failing test for parent pipeline"}),":"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"[Fact]\npublic async Task ProcessingPipeline_WithValidData_ShouldProcess()\n{\n    var context = new PipelineContext();\n    await runner.RunAsync<ProcessingPipeline>(context);\n    \n    // Add assertions\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement parent pipeline"}),":"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class ProcessingPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<DataSource, Customer>("source");\n        var validate = builder.AddComposite<Customer, ValidatedCustomer, ValidationPipeline>("validate");\n        var sink = builder.AddSink<DataSink, ValidatedCustomer>("sink");\n        \n        builder.Connect(source, validate);\n        builder.Connect(validate, sink);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-test-pyramid",children:"1. Test Pyramid"}),"\n",(0,s.jsx)(n.p,{children:"Structure your tests following the test pyramid:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"     /\\      Integration Tests (few)\n    /  \\     - Test complete pipeline hierarchy\n   /    \\    - Test context propagation\n  /      \\   - End-to-end workflows\n /________\\  \n Unit Tests (many)\n - Test each sub-pipeline independently\n - Test individual transforms\n - Test error conditions\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-isolate-external-dependencies",children:"2. Isolate External Dependencies"}),"\n",(0,s.jsx)(n.p,{children:"Mock external dependencies in tests:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class MockApiClient : IApiClient\n{\n    public Task<ApiResponse> CallAsync(string endpoint) =>\n        Task.FromResult(new ApiResponse { Data = "mock data" });\n}\n\n[Fact]\npublic async Task SubPipeline_WithMockApi_ShouldProcess()\n{\n    var context = new PipelineContext();\n    context.Items["ApiClient"] = new MockApiClient();\n    \n    await runner.RunAsync<ApiCallPipeline>(context);\n    \n    // Assert\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-use-descriptive-test-names",children:"3. Use Descriptive Test Names"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"\u2705 Good test names:\nValidationPipeline_CustomerWithoutEmail_ShouldReturnInvalidResult\nEnrichmentPipeline_GoldCustomer_ShouldHaveHighLoyaltyPoints\nProcessingPipeline_WithCancellation_ShouldStopGracefully\n\n\u274c Bad test names:\nTest1\nTestValidation\nTestPipeline\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-test-one-thing-per-test",children:"4. Test One Thing Per Test"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'\u2705 Good: Tests one specific behavior\n[Fact]\npublic async Task ValidationPipeline_EmptyEmail_ShouldHaveEmailError()\n{\n    var customer = new Customer(1, "Test", "");\n    var context = new PipelineContext();\n    context.Parameters[CompositeContextKeys.InputItem] = customer;\n    \n    await runner.RunAsync<ValidationPipeline>(context);\n    \n    var output = (ValidatedCustomer)context.Parameters[CompositeContextKeys.OutputItem];\n    output.ValidationErrors.Should().Contain("Email is required");\n}\n\n\u274c Bad: Tests multiple things\n[Fact]\npublic async Task ValidationPipeline_VariousScenarios_ShouldWork()\n{\n    // Test 1: Empty email\n    // Test 2: Empty name\n    // Test 3: Invalid phone\n    // Too much in one test!\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"5-clean-up-after-tests",children:"5. Clean Up After Tests"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class MyTests : IDisposable\n{\n    private readonly PipelineRunner _runner;\n    \n    public MyTests()\n    {\n        _runner = PipelineRunner.Create();\n    }\n    \n    public void Dispose()\n    {\n        // Clean up resources\n        SpyTransform<int>.Reset();\n        MockValidationPipeline.Reset();\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Test Type"}),(0,s.jsx)(n.th,{children:"Purpose"}),(0,s.jsx)(n.th,{children:"Frequency"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Unit Tests"})}),(0,s.jsx)(n.td,{children:"Test sub-pipelines independently"}),(0,s.jsx)(n.td,{children:"High (many tests)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Integration Tests"})}),(0,s.jsx)(n.td,{children:"Test pipeline hierarchy"}),(0,s.jsx)(n.td,{children:"Medium (some tests)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Mock Tests"})}),(0,s.jsx)(n.td,{children:"Test structure without execution"}),(0,s.jsx)(n.td,{children:"Medium (as needed)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Error Tests"})}),(0,s.jsx)(n.td,{children:"Test error handling"}),(0,s.jsx)(n.td,{children:"High (important)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Context Tests"})}),(0,s.jsx)(n.td,{children:"Test context inheritance"}),(0,s.jsx)(n.td,{children:"Medium (per config)"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Principles:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Test sub-pipelines independently first"}),"\n",(0,s.jsx)(n.li,{children:"Use test helpers (CollectorSink, StubSource, SpyTransform)"}),"\n",(0,s.jsx)(n.li,{children:"Follow the test pyramid"}),"\n",(0,s.jsx)(n.li,{children:"Isolate external dependencies"}),"\n",(0,s.jsx)(n.li,{children:"Test error scenarios thoroughly"}),"\n",(0,s.jsx)(n.li,{children:"Use descriptive test names"}),"\n",(0,s.jsx)(n.li,{children:"Keep tests focused and clean"}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);