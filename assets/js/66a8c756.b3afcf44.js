"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[1879],{26880:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"core-concepts/resilience/pipeline-error-handling","title":"Pipeline-Level Error Handling","description":"Handle errors that affect entire node streams using IPipelineErrorHandler","source":"@site/docs/core-concepts/resilience/pipeline-error-handling.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/pipeline-error-handling","permalink":"/docs/core-concepts/resilience/pipeline-error-handling","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Pipeline-Level Error Handling","description":"Handle errors that affect entire node streams using IPipelineErrorHandler","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Materialization and Buffering","permalink":"/docs/core-concepts/resilience/materialization"},"next":{"title":"Troubleshooting","permalink":"/docs/core-concepts/resilience/troubleshooting"}}');var t=r(74848),o=r(28453);const l={title:"Pipeline-Level Error Handling",description:"Handle errors that affect entire node streams using IPipelineErrorHandler",sidebar_position:3},a="Pipeline-Level Error Handling",s={},d=[{value:"IPipelineErrorHandler Interface",id:"ipipelineerrorhandler-interface",level:2},{value:"PipelineErrorDecision Enum",id:"pipelineerrordecision-enum",level:2},{value:"Implementing a Custom Pipeline Error Handler",id:"implementing-a-custom-pipeline-error-handler",level:2},{value:"Registering a Pipeline Error Handler",id:"registering-a-pipeline-error-handler",level:2},{value:"Common Scenarios",id:"common-scenarios",level:2},{value:"Scenario 1: Resource Exhaustion Handling",id:"scenario-1-resource-exhaustion-handling",level:3},{value:"Scenario 2: External Service Dependency Handling",id:"scenario-2-external-service-dependency-handling",level:3},{value:"Scenario 3: Production-Ready Pipeline Error Handler with Metrics",id:"scenario-3-production-ready-pipeline-error-handler-with-metrics",level:3},{value:"Error Decision Patterns",id:"error-decision-patterns",level:2},{value:"Pattern 1: Fail-Fast for Critical Errors",id:"pattern-1-fail-fast-for-critical-errors",level:3},{value:"Pattern 2: Graceful Degradation",id:"pattern-2-graceful-degradation",level:3},{value:"Pattern 3: Circuit Breaker Pattern",id:"pattern-3-circuit-breaker-pattern",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Prerequisites \u26a0\ufe0f",id:"prerequisites-\ufe0f",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"pipeline-level-error-handling",children:"Pipeline-Level Error Handling"})}),"\n",(0,t.jsx)(n.p,{children:"Pipeline-level error handling manages errors that affect an entire node's stream rather than individual items. These are typically more severe errors that might impact the pipeline execution flow, such as infrastructure failures or external service outages."}),"\n",(0,t.jsxs)(n.p,{children:["When an error occurs that affects an entire node's stream (e.g., an external service going down), NPipeline's ",(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"})," consults your configured ",(0,t.jsx)(n.code,{children:"IPipelineErrorHandler"})," to determine how to react."]}),"\n",(0,t.jsx)(n.h2,{id:"ipipelineerrorhandler-interface",children:"IPipelineErrorHandler Interface"}),"\n",(0,t.jsxs)(n.p,{children:["For errors affecting an entire node's stream, implement ",(0,t.jsx)(n.a,{href:"../../../src/NPipeline/Abstractions/ErrorHandling/IPipelineErrorHandler.cs",children:(0,t.jsx)(n.code,{children:"IPipelineErrorHandler"})}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public interface IPipelineErrorHandler\n{\n    Task<PipelineErrorDecision> HandleNodeFailureAsync(\n        string nodeId,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken);\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"pipelineerrordecision-enum",children:"PipelineErrorDecision Enum"}),"\n",(0,t.jsx)(n.p,{children:"This enum defines the decision when a node stream fails:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"RestartNode"})}),": The node's entire input stream will be re-processed from the beginning (requires the input stream to be replayable, e.g., materialized by ",(0,t.jsx)(n.code,{children:"ResilientExecutionStrategy"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ContinueWithoutNode"})}),": The failing node is effectively removed from the pipeline, and its output stream will be empty. The pipeline continues without it."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"FailPipeline"})}),": The entire pipeline execution terminates."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementing-a-custom-pipeline-error-handler",children:"Implementing a Custom Pipeline Error Handler"}),"\n",(0,t.jsx)(n.p,{children:"Here's a basic example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\n/// <summary>\n/// Pipeline-level error handler for managing node failures.\n/// Demonstrates circuit breaker pattern and restart logic.\n/// </summary>\npublic sealed class MyPipelineErrorHandler : IPipelineErrorHandler\n{\n    private readonly ILogger _logger;\n    private readonly Dictionary<string, int> _nodeRestartAttempts = new();\n\n    public MyPipelineErrorHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles node-level failures that affect entire stream processing.\n    /// Implements circuit breaker pattern to prevent infinite restart loops.\n    /// </summary>\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n        string nodeId,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Track restart attempts for each node\n        _nodeRestartAttempts.TryGetValue(nodeId, out var attempts);\n        attempts++;\n        _nodeRestartAttempts[nodeId] = attempts;\n\n        // Log failure with context for monitoring\n        _logger.LogError(error, \"Pipeline-level error in node '{NodeId}': {ErrorMessage}\",\n            nodeId, error.Message);\n\n        // Implement circuit breaker pattern - limit restart attempts\n        if (attempts < 3)\n        {\n            _logger.LogInformation(\"Attempting to restart node '{NodeId}'. Attempt: {Attempt}\",\n                nodeId, attempts);\n            return Task.FromResult(PipelineErrorDecision.RestartNode);\n        }\n        else\n        {\n            _logger.LogError(\"Node '{NodeId}' failed too many times, failing pipeline.\", nodeId);\n            return Task.FromResult(PipelineErrorDecision.FailPipeline);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"registering-a-pipeline-error-handler",children:"Registering a Pipeline Error Handler"}),"\n",(0,t.jsxs)(n.p,{children:["Register using the ",(0,t.jsx)(n.code,{children:"AddPipelineErrorHandler"})," method on ",(0,t.jsx)(n.code,{children:"PipelineBuilder"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\npublic sealed class ErrorHandlingPipelineDefinition : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var sourceHandle = builder.AddSource<DataSource, string>();\n        var transformHandle = builder.AddTransform<DataTransform, string, string>();\n        var sinkHandle = builder.AddSink<DataSink, string>();\n\n        builder.Connect(sourceHandle, transformHandle);\n        builder.Connect(transformHandle, sinkHandle);\n\n        // Configure retry options\n        builder.WithRetryOptions(new PipelineRetryOptions(\n            MaxItemRetries: 3,\n            MaxNodeRestartAttempts: 2,\n            MaxSequentialNodeAttempts: 5\n        ));\n\n        // Register the pipeline error handler\n        builder.AddPipelineErrorHandler<MyPipelineErrorHandler>();\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Also register with your DI container:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"services.AddSingleton<IPipelineErrorHandler, MyPipelineErrorHandler>();\n"})}),"\n",(0,t.jsx)(n.h2,{id:"common-scenarios",children:"Common Scenarios"}),"\n",(0,t.jsx)(n.h3,{id:"scenario-1-resource-exhaustion-handling",children:"Scenario 1: Resource Exhaustion Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\n/// <summary>\n/// Pipeline error handler for resource exhaustion scenarios.\n/// Demonstrates critical error handling for system resource issues.\n/// </summary>\npublic class ResourceExhaustionHandler : IPipelineErrorHandler\n{\n    private readonly ILogger _logger;\n    private readonly Dictionary<string, int> _nodeFailureCounts = new();\n\n    public ResourceExhaustionHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles resource exhaustion by failing fast to prevent system damage.\n    /// Critical resource errors should immediately terminate processing.\n    /// </summary>\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n        string nodeId,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Track failure count for each node\n        _nodeFailureCounts.TryGetValue(nodeId, out var count);\n        _nodeFailureCounts[nodeId] = count + 1;\n\n        // Handle critical resource errors immediately\n        if (error is OutOfMemoryException or InsufficientMemoryException)\n        {\n            _logger.LogCritical(\"Resource exhaustion in node '{NodeId}': {Error}\", nodeId, error.Message);\n            return Task.FromResult(PipelineErrorDecision.FailPipeline);\n        }\n\n        // For other errors, allow limited restarts\n        if (_nodeFailureCounts[nodeId] <= 3)\n        {\n            _logger.LogWarning(\"Restarting node '{NodeId}' (attempt {Attempt})\", \n                nodeId, _nodeFailureCounts[nodeId]);\n            return Task.FromResult(PipelineErrorDecision.RestartNode);\n        }\n\n        // Too many failures - continue without the problematic node\n        _logger.LogError(\"Node '{NodeId}' failed too many times, continuing without it\", nodeId);\n        return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"scenario-2-external-service-dependency-handling",children:"Scenario 2: External Service Dependency Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\n/// <summary>\n/// Pipeline error handler for external service dependencies.\n/// Demonstrates graceful degradation when external services fail.\n/// </summary>\npublic class ExternalServiceErrorHandler : IPipelineErrorHandler\n{\n    private readonly ILogger _logger;\n    private readonly Dictionary<string, DateTime> _lastFailureTime = new();\n    private readonly TimeSpan _circuitBreakerWindow = TimeSpan.FromSeconds(60);\n\n    public ExternalServiceErrorHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles external service failures with circuit breaker pattern.\n    /// Fails fast if a node has failed multiple times recently.\n    /// </summary>\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n        string nodeId,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Check if node has failed recently (circuit breaker open)\n        _lastFailureTime.TryGetValue(nodeId, out var lastFailure);\n        if (DateTime.UtcNow - lastFailure < _circuitBreakerWindow)\n        {\n            _logger.LogWarning(\"Circuit breaker open for node '{NodeId}', continuing without it\", nodeId);\n            return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\n        }\n\n        // Record failure time\n        _lastFailureTime[nodeId] = DateTime.UtcNow;\n\n        _logger.LogError(error, \"External service error in node '{NodeId}': {Message}\", \n            nodeId, error.Message);\n\n        // For transient network errors, retry the node\n        if (error is HttpRequestException or TimeoutException)\n        {\n            return Task.FromResult(PipelineErrorDecision.RestartNode);\n        }\n\n        // For persistent failures, continue without the node\n        return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"scenario-3-production-ready-pipeline-error-handler-with-metrics",children:"Scenario 3: Production-Ready Pipeline Error Handler with Metrics"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\n/// <summary>\n/// Production-ready pipeline error handler with circuit breaker pattern.\n/// Demonstrates sophisticated error handling for production environments.\n/// </summary>\npublic class ProductionPipelineErrorHandler : IPipelineErrorHandler\n{\n    private readonly ILogger _logger;\n    private readonly IMetrics _metrics;\n    private readonly Dictionary<string, int> _failureCounts = new();\n\n    public ProductionPipelineErrorHandler(ILogger logger, IMetrics metrics)\n    {\n        _logger = logger;\n        _metrics = metrics;\n    }\n\n    /// <summary>\n    /// Handles node failures with circuit breaker pattern and metrics.\n    /// Prevents cascading failures by limiting restart attempts.\n    /// </summary>\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n        string nodeId,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Track failure count for circuit breaker logic\n        _failureCounts.TryGetValue(nodeId, out var count);\n        _failureCounts[nodeId] = count + 1;\n\n        // Record metrics for monitoring\n        _metrics.Increment("pipeline_node_failures", new[] { \n            new KeyValuePair<string, object>("node_id", nodeId),\n            new KeyValuePair<string, object>("error_type", error.GetType().Name)\n        });\n\n        // Log failure for monitoring\n        _logger.LogError(error, "Node {NodeId} failed (attempt {Attempt})", \n            nodeId, _failureCounts[nodeId]);\n\n        // Implement circuit breaker based on error type and count\n        return error switch\n        {\n            // Critical resource errors - fail immediately\n            OutOfMemoryException => Task.FromResult(PipelineErrorDecision.FailPipeline),\n            \n            // Transient errors - allow limited restarts\n            _ when _failureCounts[nodeId] < 3 => Task.FromResult(PipelineErrorDecision.RestartNode),\n            \n            // Persistent failures - continue without node\n            _ => Task.FromResult(PipelineErrorDecision.ContinueWithoutNode)\n        };\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"error-decision-patterns",children:"Error Decision Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"pattern-1-fail-fast-for-critical-errors",children:"Pattern 1: Fail-Fast for Critical Errors"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n    string nodeId,\n    Exception error,\n    PipelineContext context,\n    CancellationToken cancellationToken)\n{\n    // Critical errors should fail immediately\n    if (error is OutOfMemoryException or StackOverflowException)\n    {\n        _logger.LogCritical("Critical error in node {NodeId}", nodeId);\n        return Task.FromResult(PipelineErrorDecision.FailPipeline);\n    }\n\n    // Other errors can be retried\n    return Task.FromResult(PipelineErrorDecision.RestartNode);\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"pattern-2-graceful-degradation",children:"Pattern 2: Graceful Degradation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n    string nodeId,\n    Exception error,\n    PipelineContext context,\n    CancellationToken cancellationToken)\n{\n    _logger.LogError(error, "Node {NodeId} failed", nodeId);\n    \n    // Try to restart once, then continue without the node\n    if (!_attemptedRestart.Contains(nodeId))\n    {\n        _attemptedRestart.Add(nodeId);\n        return Task.FromResult(PipelineErrorDecision.RestartNode);\n    }\n\n    // Node failed again, continue without it\n    return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"pattern-3-circuit-breaker-pattern",children:"Pattern 3: Circuit Breaker Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n    string nodeId,\n    Exception error,\n    PipelineContext context,\n    CancellationToken cancellationToken)\n{\n    _failureCount.TryGetValue(nodeId, out var count);\n    _failureCount[nodeId] = count + 1;\n\n    // Open circuit after N failures\n    if (_failureCount[nodeId] >= 3)\n    {\n        _logger.LogWarning("Circuit breaker open for node {NodeId}", nodeId);\n        return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\n    }\n\n    return Task.FromResult(PipelineErrorDecision.RestartNode);\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Track failure patterns"}),": Keep track of when and how often nodes fail to detect persistent issues."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Implement circuit breaker patterns"}),": Prevent cascading failures by temporarily stopping attempts to failing nodes."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Differentiate between error types"}),": Critical errors should fail the pipeline immediately, while transient errors might be worth retrying."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Set reasonable limits"}),": Prevent infinite restarts by setting limits on the number of restart attempts."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Monitor and alert"}),": Implement proper monitoring and alerting for pipeline failures."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Consider graceful degradation"}),": Design your pipeline to continue functioning even when some nodes fail."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Log with context"}),": Include node IDs, error types, and failure counts in your logs for troubleshooting."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"prerequisites-\ufe0f",children:"Prerequisites \u26a0\ufe0f"}),"\n",(0,t.jsxs)(n.p,{children:["For resilience features like ",(0,t.jsx)(n.code,{children:"PipelineErrorDecision.RestartNode"})," to work properly, you must understand the dependency chain between components. See ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/getting-started",children:"Getting Started with Resilience"})," for detailed prerequisites."]}),"\n",(0,t.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling-overview",children:"Error Handling Overview"})," - Understand both levels of error handling"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/node-error-handling",children:"Node-Level Error Handling"})," - Handle individual item failures"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/getting-started",children:"Getting Started with Resilience"})," - Quick guide and prerequisites"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/retries",children:"Retries"})," - Configure retry policies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/circuit-breakers",children:"Circuit Breakers"})," - Circuit breaker patterns and configuration"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var i=r(96540);const t={},o=i.createContext(t);function l(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);