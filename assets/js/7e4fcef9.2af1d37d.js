"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3042],{7022:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"core-concepts/nodes/time-windowed-join","title":"Time-Windowed Joins","description":"Learn how to perform joins on streams within specific time windows, a key technique for real-time and event-driven data processing.","source":"@site/docs/core-concepts/nodes/time-windowed-join.md","sourceDirName":"core-concepts/nodes","slug":"/core-concepts/nodes/time-windowed-join","permalink":"/docs/core-concepts/nodes/time-windowed-join","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"Time-Windowed Joins","description":"Learn how to perform joins on streams within specific time windows, a key technique for real-time and event-driven data processing.","sidebar_position":8},"sidebar":"docsSidebar","previous":{"title":"Aggregation Nodes","permalink":"/docs/core-concepts/nodes/aggregation"},"next":{"title":"Resilience Overview","permalink":"/docs/core-concepts/resilience/"}}');var r=i(4848),s=i(8453);const o={title:"Time-Windowed Joins",description:"Learn how to perform joins on streams within specific time windows, a key technique for real-time and event-driven data processing.",sidebar_position:8},a="Time-Windowed Joins",d={},c=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"Windows",id:"windows",level:3},{value:"Timestamps",id:"timestamps",level:3},{value:"Watermarks",id:"watermarks",level:3},{value:"<code>TimeWindowedJoinNode&lt;TKey, TIn1, TIn2, TOut&gt;</code>",id:"timewindowedjoinnodetkey-tin1-tin2-tout",level:2},{value:"Constructor",id:"constructor",level:3},{value:"Timestamp Extraction Patterns",id:"timestamp-extraction-patterns",level:3},{value:"Example: Joining Click and Impression Streams",id:"example-joining-click-and-impression-streams",level:3},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"time-windowed-joins",children:"Time-Windowed Joins"})}),"\n",(0,r.jsxs)(n.p,{children:["In many real-time applications, you need to join streams of data that are aligned by time. For example, you might want to correlate user clicks with ad impressions that occurred within the same 5-minute window. NPipeline supports this through the ",(0,r.jsx)(n.code,{children:"TimeWindowedJoinNode<TKey, TIn1, TIn2, TOut>"})," abstract base class."]}),"\n",(0,r.jsxs)(n.p,{children:["This node extends ",(0,r.jsx)(n.code,{children:"BaseJoinNode<TKey, TIn1, TIn2, TOut>"})," by adding the concepts of ",(0,r.jsx)(n.strong,{children:"windows"}),", ",(0,r.jsx)(n.strong,{children:"timestamps"}),", and ",(0,r.jsx)(n.strong,{children:"watermarks"})," to manage stateful joins over time."]}),"\n",(0,r.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"windows",children:"Windows"}),"\n",(0,r.jsx)(n.p,{children:"A window is a finite slice of time over which a join operation is performed. NPipeline supports different windowing strategies, such as:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tumbling Windows"}),": Fixed-size, non-overlapping time intervals (e.g., every 1 minute)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sliding Windows"}),": Fixed-size, overlapping time intervals (e.g., a 5-minute window that slides every 10 seconds)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Session Windows"}),": Dynamically sized windows based on periods of activity followed by a gap of inactivity."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["You configure this using a ",(0,r.jsx)(n.code,{children:"WindowAssigner"})," when creating the node."]}),"\n",(0,r.jsx)(n.h3,{id:"timestamps",children:"Timestamps"}),"\n",(0,r.jsxs)(n.p,{children:["Each incoming item must have a timestamp associated with it so the node knows which window(s) it belongs to. You can provide a ",(0,r.jsx)(n.code,{children:"TimestampExtractor"})," to tell the node how to get this timestamp from your data model. If not provided, the node will use the system time of arrival."]}),"\n",(0,r.jsx)(n.h3,{id:"watermarks",children:"Watermarks"}),"\n",(0,r.jsxs)(n.p,{children:["Watermarks are a crucial mechanism in stream processing that represent the progress of event time. A watermark with a timestamp ",(0,r.jsx)(n.code,{children:"T"})," signals to the node that no more items with a timestamp earlier than ",(0,r.jsx)(n.code,{children:"T"})," are expected to arrive. This allows the node to safely close windows, process the joined results, and clean up its internal state (like unmatched items), preventing memory leaks in long-running pipelines."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"TimeWindowedJoinNode"})," automatically handles watermark generation based on the incoming data stream."]}),"\n",(0,r.jsx)(n.h2,{id:"timewindowedjoinnodetkey-tin1-tin2-tout",children:(0,r.jsx)(n.code,{children:"TimeWindowedJoinNode<TKey, TIn1, TIn2, TOut>"})}),"\n",(0,r.jsx)(n.p,{children:"This class manages the complexity of storing items from each stream, matching them based on their key and window, and handling out-of-order data."}),"\n",(0,r.jsx)(n.h3,{id:"constructor",children:"Constructor"}),"\n",(0,r.jsx)(n.p,{children:"To create a time-windowed join, you need to provide:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"windowAssigner"})," (",(0,r.jsx)(n.code,{children:"WindowAssigner"}),"): The window assigner strategy to use for defining time windows (required)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"timestampExtractor1"})," (",(0,r.jsx)(n.code,{children:"TimestampExtractor<TIn1>?"}),", optional): A function to extract timestamps from the first input type. If not provided, system time of arrival will be used."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"timestampExtractor2"})," (",(0,r.jsx)(n.code,{children:"TimestampExtractor<TIn2>?"}),", optional): A function to extract timestamps from the second input type. If not provided, system time of arrival will be used."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"maxOutOfOrderness"})," (",(0,r.jsx)(n.code,{children:"TimeSpan?"}),", optional): The maximum allowed lateness for out-of-order events. Events arriving later than this relative to the current watermark may be treated as late. Defaults to 5 minutes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"watermarkInterval"})," (",(0,r.jsx)(n.code,{children:"TimeSpan?"}),", optional): The frequency at which watermarks are emitted to advance event time and trigger window cleanup. Defaults to 30 seconds."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Example constructor usage\r\npublic class MyTimeWindowedJoinNode : TimeWindowedJoinNode<string, EventA, EventB, Result>\r\n{\r\n    public MyTimeWindowedJoinNode() : base(\r\n        windowAssigner: new TumblingWindowAssigner(TimeSpan.FromMinutes(5)),\r\n        timestampExtractor1: evt => evt.Timestamp,\r\n        timestampExtractor2: evt => evt.Timestamp,\r\n        maxOutOfOrderness: TimeSpan.FromSeconds(30),\r\n        watermarkInterval: TimeSpan.FromSeconds(10))\r\n    {\r\n        JoinType = JoinType.Inner;\r\n    }\r\n    \r\n    // Required method implementations...\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"timestamp-extraction-patterns",children:"Timestamp Extraction Patterns"}),"\n",(0,r.jsx)(n.p,{children:"Timestamp extraction is crucial for time-windowed joins. You can provide custom timestamp extractors in several ways:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// 1. Simple property access\r\ntimestampExtractor1: evt => evt.EventTime\r\n\r\n// 2. Complex timestamp calculation\r\ntimestampExtractor2: evt => \r\n{\r\n    // Calculate timestamp from multiple fields or business logic\r\n    var baseTime = evt.BaseDate;\r\n    var timeOfDay = TimeSpan.Parse(evt.TimeString);\r\n    return baseTime.Date + timeOfDay;\r\n}\r\n\r\n// 3. Using external timestamp sources\r\ntimestampExtractor1: evt => \r\n{\r\n    // Look up timestamp from external system\r\n    return _timestampService.GetTimestamp(evt.EventId);\r\n}\r\n\r\n// 4. Default behavior (no extractor provided)\r\n// If no extractor is provided, the system time of arrival is used\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When providing timestamp extractors, ensure they return consistent, comparable ",(0,r.jsx)(n.code,{children:"DateTime"})," or ",(0,r.jsx)(n.code,{children:"DateTimeOffset"})," values that represent the actual event time, not the processing time."]}),"\n",(0,r.jsx)(n.h3,{id:"example-joining-click-and-impression-streams",children:"Example: Joining Click and Impression Streams"}),"\n",(0,r.jsxs)(n.p,{children:["Let's imagine a conceptual example where we want to join a stream of ",(0,r.jsx)(n.code,{children:"AdClickEvent"}),"s with a stream of ",(0,r.jsx)(n.code,{children:"AdImpressionEvent"}),"s. We want to match them if they occur within the same 1-minute tumbling window."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.DataFlow.Windowing;\r\nusing NPipeline.Nodes;\r\n\r\n// Data models with timestamps\r\npublic sealed record AdClickEvent(string AdId, DateTime Timestamp, string UserId);\r\npublic sealed record AdImpressionEvent(string AdId, DateTime Timestamp, string CampaignId);\r\npublic sealed record CorrelatedAdEvent(string AdId, string UserId, string CampaignId);\r\n\r\n// Timestamp extractors\r\npublic static class Extractors\r\n{\r\n    public static DateTime GetClickTimestamp(AdClickEvent evt) => evt.Timestamp;\r\n    public static DateTime GetImpressionTimestamp(AdImpressionEvent evt) => evt.Timestamp;\r\n}\r\n\r\n// Join Node\r\n[KeySelector(typeof(AdClickEvent), nameof(AdClickEvent.AdId))]\r\n[KeySelector(typeof(AdImpressionEvent), nameof(AdImpressionEvent.AdId))]\r\npublic class AdCorrelationNode : TimeWindowedJoinNode<string, AdClickEvent, AdImpressionEvent, CorrelatedAdEvent>\r\n{\r\n    public AdCorrelationNode() : base(\r\n        windowAssigner: new TumblingWindowAssigner(TimeSpan.FromMinutes(1)),\r\n        timestampExtractor1: new TimestampExtractor<AdClickEvent>(Extractors.GetClickTimestamp),\r\n        timestampExtractor2: new TimestampExtractor<AdImpressionEvent>(Extractors.GetImpressionTimestamp),\r\n        maxOutOfOrderness: TimeSpan.FromSeconds(30))\r\n    {\r\n        JoinType = JoinType.Inner;\r\n    }\r\n\r\n    public override CorrelatedAdEvent CreateOutput(AdClickEvent item1, AdImpressionEvent item2)\r\n    {\r\n        return new CorrelatedAdEvent(item1.AdId, item1.UserId, item2.CampaignId);\r\n    }\r\n}\r\n\r\n// Pipeline Setup\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var context = PipelineContext.Default;\r\n        var runner = new PipelineRunner();\r\n        await runner.RunAsync<AdCorrelationPipelineDefinition>(context);\r\n    }\r\n}\r\n\r\npublic sealed class AdCorrelationPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var clickSourceHandle = builder.AddSource<ClickStreamSource, AdClickEvent>("clicks");\r\n        var impressionSourceHandle = builder.AddSource<ImpressionStreamSource, AdImpressionEvent>("impressions");\r\n        var joinHandle = builder.AddJoin<AdCorrelationNode, AdClickEvent, AdImpressionEvent, CorrelatedAdEvent>("correlator");\r\n        var sinkHandle = builder.AddSink<ConsoleSink<CorrelatedAdEvent>, CorrelatedAdEvent>("sink");\r\n\r\n        builder.Connect(clickSourceHandle, joinHandle);\r\n        builder.Connect(impressionSourceHandle, joinHandle);\r\n        builder.Connect(joinHandle, sinkHandle);\r\n    }\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In this setup, the ",(0,r.jsx)(n.code,{children:"AdCorrelationNode"})," will:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Receive clicks and impressions."}),"\n",(0,r.jsx)(n.li,{children:"Use the provided extractors to get their event timestamps."}),"\n",(0,r.jsx)(n.li,{children:"Assign each item to a 1-minute tumbling window."}),"\n",(0,r.jsxs)(n.li,{children:["Store items in memory, waiting for a match on ",(0,r.jsx)(n.code,{children:"AdId"})," within the same window."]}),"\n",(0,r.jsxs)(n.li,{children:["When a match is found, call ",(0,r.jsx)(n.code,{children:"CreateOutput"})," and emit the ",(0,r.jsx)(n.code,{children:"CorrelatedAdEvent"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"As watermarks advance past the end of a window, it will clean up any state for that window."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-concepts/nodes/",children:"Node Types Index"})}),": Return to the node types overview."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution",children:"Pipeline Execution"})}),": Learn about how pipelines are executed and managed."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(6540);const r={},s=t.createContext(r);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);