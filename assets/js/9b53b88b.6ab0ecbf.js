"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[6562],{28453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>s});var t=i(96540);const r={},a=t.createContext(r);function o(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),t.createElement(a.Provider,{value:e},n.children)}},88484:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"core-concepts/nodes/sink-nodes","title":"Sink Nodes","description":"Learn how to implement sink nodes that consume and finalize data at the end of your pipeline.","source":"@site/docs/core-concepts/nodes/sink-nodes.md","sourceDirName":"core-concepts/nodes","slug":"/core-concepts/nodes/sink-nodes","permalink":"/docs/core-concepts/nodes/sink-nodes","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Sink Nodes","description":"Learn how to implement sink nodes that consume and finalize data at the end of your pipeline.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Join Nodes","permalink":"/docs/core-concepts/nodes/join"},"next":{"title":"Lookup Nodes","permalink":"/docs/core-concepts/nodes/lookup"}}');var r=i(74848),a=i(28453);const o={title:"Sink Nodes",description:"Learn how to implement sink nodes that consume and finalize data at the end of your pipeline.",sidebar_position:3},s="Sink Nodes (ISinkNode<TIn>)",c={},l=[{value:"Interface Definition",id:"interface-definition",level:2},{value:"Implementation Example",id:"implementation-example",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Data Pipe Consumption",id:"data-pipe-consumption",level:3},{value:"Streaming Iteration",id:"streaming-iteration",level:3},{value:"Activity Tracking",id:"activity-tracking",level:3},{value:"Graceful Shutdown",id:"graceful-shutdown",level:3},{value:"Common Sink Patterns",id:"common-sink-patterns",level:2},{value:"Database Write Sink",id:"database-write-sink",level:3},{value:"File Write Sink",id:"file-write-sink",level:3},{value:"HTTP Request Sink",id:"http-request-sink",level:3},{value:"Aggregating Sink (Collect Results)",id:"aggregating-sink-collect-results",level:3},{value:"Metric Collection Sink",id:"metric-collection-sink",level:3},{value:"Lineage Support in Sink Nodes",id:"lineage-support-in-sink-nodes",level:2},{value:"Implementation Example",id:"implementation-example-1",level:2},{value:"Next Steps",id:"next-steps",level:2}];function p(n){const e={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsxs)(e.h1,{id:"sink-nodes-isinknodetin",children:["Sink Nodes (",(0,r.jsx)(e.code,{children:"ISinkNode<TIn>"}),")"]})}),"\n",(0,r.jsxs)(e.p,{children:["Sink nodes are the terminal points of a pipeline. They consume the final processed data stream (",(0,r.jsx)(e.code,{children:"TInput"}),") and typically perform an action such as writing to a database, sending a notification, or displaying results. Sink nodes do not produce any output."]}),"\n",(0,r.jsx)(e.h2,{id:"interface-definition",children:"Interface Definition"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:"public interface ISinkNode<TIn> : INode\r\n{\r\n    Task ExecuteAsync(IDataPipe<TIn> input, PipelineContext context, CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"implementation-example",children:"Implementation Example"}),"\n",(0,r.jsx)(e.p,{children:"A sink that prints each incoming number to the console:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.DataFlow;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Observability.Tracing;\r\nusing NPipeline.Pipeline;\r\n\r\npublic sealed class ConsoleSink<T> : ISinkNode<T>\r\n{\r\n    public async Task ExecuteAsync(IDataPipe<T> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            Console.WriteLine($"Sink received: {item}");\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsx)(e.h3,{id:"data-pipe-consumption",children:"Data Pipe Consumption"}),"\n",(0,r.jsxs)(e.p,{children:["The ",(0,r.jsx)(e.code,{children:"ExecuteAsync"})," method receives an ",(0,r.jsx)(e.code,{children:"IDataPipe<TIn>"})," which represents the final stream of items produced by the previous node in the pipeline. Sink nodes iterate through this stream and perform appropriate operations."]}),"\n",(0,r.jsx)(e.h3,{id:"streaming-iteration",children:"Streaming Iteration"}),"\n",(0,r.jsxs)(e.p,{children:["Use ",(0,r.jsx)(e.code,{children:"await foreach"})," to asynchronously iterate through the data pipe. This pattern allows efficient memory usage\u2014items are processed as they arrive rather than being buffered in memory."]}),"\n",(0,r.jsx)(e.h3,{id:"activity-tracking",children:"Activity Tracking"}),"\n",(0,r.jsxs)(e.p,{children:["To access tracing and observability information, use the ",(0,r.jsx)(e.code,{children:"PipelineContext"})," parameter. The current activity can be accessed through ",(0,r.jsx)(e.code,{children:"context.Tracer.CurrentActivity"}),", which returns the active tracing span if one exists, or ",(0,r.jsx)(e.code,{children:"null"})," if tracing is disabled."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'public async Task ExecuteAsync(IDataPipe<T> input, PipelineContext context, CancellationToken cancellationToken)\r\n{\r\n    var activity = context.Tracer.CurrentActivity;\r\n    if (activity != null)\r\n    {\r\n        // Access tracing metadata, emit logs, track metrics\r\n        await activity.EmitEventAsync("Processing started", cancellationToken);\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"graceful-shutdown",children:"Graceful Shutdown"}),"\n",(0,r.jsxs)(e.p,{children:["Always respect the ",(0,r.jsx)(e.code,{children:"cancellationToken"})," parameter to allow graceful shutdown of your pipeline. This is especially important for long-running sinks or those that interact with external systems."]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"\u26a0\ufe0f Important"})}),"\n",(0,r.jsxs)(e.p,{children:["Always check the cancellation token in your sink's ",(0,r.jsx)(e.code,{children:"ExecuteAsync"})," method. Failure to do so can cause hangs during pipeline shutdown or when users request cancellation."]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"common-sink-patterns",children:"Common Sink Patterns"}),"\n",(0,r.jsx)(e.h3,{id:"database-write-sink",children:"Database Write Sink"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'public sealed class DatabaseWriteSink : ISinkNode<CustomerRecord>\r\n{\r\n    private readonly string _connectionString;\r\n\r\n    public DatabaseWriteSink(string connectionString)\r\n    {\r\n        _connectionString = connectionString;\r\n    }\r\n\r\n    public async Task ExecuteAsync(IDataPipe<CustomerRecord> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        using (var connection = new SqlConnection(_connectionString))\r\n        {\r\n            await connection.OpenAsync(cancellationToken);\r\n\r\n            await foreach (var record in input.WithCancellation(cancellationToken))\r\n            {\r\n                using (var command = new SqlCommand("INSERT INTO Customers (Id, Name, Email) VALUES (@id, @name, @email)", connection))\r\n                {\r\n                    command.Parameters.AddWithValue("@id", record.Id);\r\n                    command.Parameters.AddWithValue("@name", record.Name);\r\n                    command.Parameters.AddWithValue("@email", record.Email);\r\n\r\n                    await command.ExecuteNonQueryAsync(cancellationToken);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"file-write-sink",children:"File Write Sink"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:"public sealed class FileWriteSink : ISinkNode<string>\r\n{\r\n    private readonly string _filePath;\r\n\r\n    public FileWriteSink(string filePath)\r\n    {\r\n        _filePath = filePath;\r\n    }\r\n\r\n    public async Task ExecuteAsync(IDataPipe<string> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        using (var writer = new StreamWriter(_filePath, append: false))\r\n        {\r\n            await foreach (var line in input.WithCancellation(cancellationToken))\r\n            {\r\n                await writer.WriteLineAsync(line);\r\n            }\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"http-request-sink",children:"HTTP Request Sink"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'public sealed class HttpPostSink : ISinkNode<DataRecord>\r\n{\r\n    private readonly string _endpoint;\r\n    private readonly HttpClient _httpClient;\r\n\r\n    public HttpPostSink(string endpoint)\r\n    {\r\n        _endpoint = endpoint;\r\n        _httpClient = new HttpClient();\r\n    }\r\n\r\n    public async Task ExecuteAsync(IDataPipe<DataRecord> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        await foreach (var record in input.WithCancellation(cancellationToken))\r\n        {\r\n            var json = JsonSerializer.Serialize(record);\r\n            var content = new StringContent(json, Encoding.UTF8, "application/json");\r\n\r\n            var response = await _httpClient.PostAsync(_endpoint, content, cancellationToken);\r\n            response.EnsureSuccessStatusCode();\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"aggregating-sink-collect-results",children:"Aggregating Sink (Collect Results)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:"public sealed class CollectingSink : ISinkNode<int>\r\n{\r\n    public List<int> Results { get; } = new();\r\n\r\n    public async Task ExecuteAsync(IDataPipe<int> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            Results.Add(item);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"metric-collection-sink",children:"Metric Collection Sink"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:"public sealed class MetricsSink : ISinkNode<ProcessedEvent>\r\n{\r\n    private int _totalProcessed = 0;\r\n    private int _totalErrors = 0;\r\n\r\n    public int TotalProcessed => _totalProcessed;\r\n    public int TotalErrors => _totalErrors;\r\n\r\n    public async Task ExecuteAsync(IDataPipe<ProcessedEvent> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        await foreach (var @event in input.WithCancellation(cancellationToken))\r\n        {\r\n            if (@event.IsError)\r\n            {\r\n                Interlocked.Increment(ref _totalErrors);\r\n            }\r\n            else\r\n            {\r\n                Interlocked.Increment(ref _totalProcessed);\r\n            }\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"lineage-support-in-sink-nodes",children:"Lineage Support in Sink Nodes"}),"\n",(0,r.jsxs)(e.p,{children:["For sink nodes that need to work with lineage data, the ",(0,r.jsx)(e.code,{children:"SinkLineageUnwrapDelegate"})," is available in the ",(0,r.jsx)(e.code,{children:"NPipeline.Graph.PipelineDelegates"})," namespace:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:"using NPipeline.Graph.PipelineDelegates;\r\n\r\n// Example sink with lineage support\r\npublic class LineageAwareSink : ISinkNode<Output>\r\n{\r\n    private readonly SinkLineageUnwrapDelegate? _lineageUnwrap;\r\n    \r\n    public LineageAwareSink(SinkLineageUnwrapDelegate? lineageUnwrap = null)\r\n    {\r\n        _lineageUnwrap = lineageUnwrap;\r\n    }\r\n    \r\n    public async Task ExecuteAsync(\r\n        IDataPipe<Output> input, \r\n        PipelineContext context, \r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Use lineage unwrap delegate if provided\r\n        if (_lineageUnwrap != null)\r\n        {\r\n            var unwrappedInput = _lineageUnwrap(\r\n                input,\r\n                context.LineageSink,\r\n                context.CurrentNodeId,\r\n                context.LineageOptions,\r\n                cancellationToken);\r\n                \r\n            // Process with unwrapped input\r\n            await ProcessItemsAsync(unwrappedInput, cancellationToken);\r\n        }\r\n        else\r\n        {\r\n            // Standard processing without lineage\r\n            await ProcessItemsAsync(input, cancellationToken);\r\n        }\r\n    }\r\n    \r\n    private async Task ProcessItemsAsync(IDataPipe<Output> items, CancellationToken cancellationToken)\r\n    {\r\n        // Your sink processing logic here\r\n        await foreach (var item in items.WithCancellation(cancellationToken))\r\n        {\r\n            // Process each item\r\n            await ProcessItemAsync(item, cancellationToken);\r\n        }\r\n    }\r\n    \r\n    private async Task ProcessItemAsync(Output item, CancellationToken cancellationToken)\r\n    {\r\n        // Your actual item processing logic\r\n        await SaveToDestinationAsync(item, cancellationToken);\r\n    }\r\n    \r\n    private async Task SaveToDestinationAsync(Output item, CancellationToken cancellationToken)\r\n    {\r\n        // Your save logic here\r\n        // For example: save to database, file, API, etc.\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"implementation-example-1",children:"Implementation Example"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\nusing NPipeline.Graph.PipelineDelegates;\r\n\r\n/// <summary>\r\n/// Sink node that outputs messages to console.\r\n/// Demonstrates terminal node pattern for pipeline output.\r\n/// </summary>\r\npublic sealed class ConsoleSink : ISinkNode<string>\r\n{\r\n    public async Task ExecuteAsync(IDataPipe<string> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Process each message as it arrives from upstream\r\n        await foreach (var message in input.WithCancellation(cancellationToken))\r\n        {\r\n            Console.WriteLine(message);\r\n        }\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// Sink node with lineage support that outputs messages to console.\r\n/// Demonstrates how to work with lineage data in sink nodes.\r\n/// </summary>\r\npublic sealed class LineageConsoleSink : ISinkNode<string>\r\n{\r\n    private readonly SinkLineageUnwrapDelegate? _lineageUnwrap;\r\n    \r\n    public LineageConsoleSink(SinkLineageUnwrapDelegate? lineageUnwrap = null)\r\n    {\r\n        _lineageUnwrap = lineageUnwrap;\r\n    }\r\n    \r\n    public async Task ExecuteAsync(IDataPipe<string> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Use lineage unwrap delegate if provided\r\n        if (_lineageUnwrap != null)\r\n        {\r\n            var unwrappedInput = _lineageUnwrap(\r\n                input,\r\n                context.LineageSink,\r\n                context.CurrentNodeId,\r\n                context.LineageOptions,\r\n                cancellationToken);\r\n                \r\n            // Process with unwrapped input\r\n            await foreach (var message in unwrappedInput.WithCancellation(cancellationToken))\r\n            {\r\n                Console.WriteLine(message);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            // Standard processing without lineage\r\n            await foreach (var message in input.WithCancellation(cancellationToken))\r\n            {\r\n                Console.WriteLine(message);\r\n            }\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.a,{href:"/docs/core-concepts/nodes/",children:"Node Types"})}),": Explore sophisticated patterns like aggregation and batching"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.a,{href:"/docs/core-concepts/pipeline-execution",children:"Pipeline Execution"})}),": Learn how pipelines execute and handle errors"]}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(p,{...n})}):p(n)}}}]);