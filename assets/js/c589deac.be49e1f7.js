"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[9983],{7986:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"extensions/testing/awesome-assertions","title":"AwesomeAssertions","description":"Write expressive, readable assertions for your pipeline tests with the AwesomeAssertions integration.","source":"@site/docs/extensions/testing/awesome-assertions.md","sourceDirName":"extensions/testing","slug":"/extensions/testing/awesome-assertions","permalink":"/docs/extensions/testing/awesome-assertions","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"AwesomeAssertions","description":"Write expressive, readable assertions for your pipeline tests with the AwesomeAssertions integration.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Testing Extensions","permalink":"/docs/extensions/testing"},"next":{"title":"FluentAssertions","permalink":"/docs/extensions/testing/fluent-assertions"}}');var i=s(4848),t=s(8453);const o={title:"AwesomeAssertions",description:"Write expressive, readable assertions for your pipeline tests with the AwesomeAssertions integration.",sidebar_position:2},a="AwesomeAssertions Integration",l={},d=[{value:"Installation",id:"installation",level:2},{value:"Pipeline Execution Result Assertions",id:"pipeline-execution-result-assertions",level:2},{value:"Pipeline Result Assertions",id:"pipeline-result-assertions",level:3},{value:"Sink Node Assertions",id:"sink-node-assertions",level:2},{value:"Available Extension Methods",id:"available-extension-methods",level:2},{value:"Count Assertions",id:"count-assertions",level:3},{value:"Content Assertions",id:"content-assertions",level:3},{value:"Complete Example: Pipeline with Error Handling",id:"complete-example-pipeline-with-error-handling",level:2},{value:"Benefits of AwesomeAssertions",id:"benefits-of-awesomeassertions",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"awesomeassertions-integration",children:"AwesomeAssertions Integration"})}),"\n",(0,i.jsxs)(n.p,{children:["While standard ",(0,i.jsx)(n.code,{children:"Assert"})," statements work perfectly well, assertion libraries can make tests more readable and expressive. ",(0,i.jsx)(n.code,{children:"NPipeline.Extensions.Testing.AwesomeAssertions"})," is a small extension that integrates with the ",(0,i.jsx)(n.a,{href:"https://github.com/Awesome-Assertions/Awesome-Assertions",children:"AwesomeAssertions"})," library, providing a fluent, human-readable syntax for validating the output of your pipelines."]}),"\n",(0,i.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsxs)(n.p,{children:["To use this integration, you need to add both the ",(0,i.jsx)(n.code,{children:"AwesomeAssertions"})," and the NPipeline extension package to your test project:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"dotnet add package AwesomeAssertions\r\ndotnet add package NPipeline.Extensions.Testing.AwesomeAssertions\n"})}),"\n",(0,i.jsx)(n.h2,{id:"pipeline-execution-result-assertions",children:"Pipeline Execution Result Assertions"}),"\n",(0,i.jsxs)(n.p,{children:["With ",(0,i.jsx)(n.code,{children:"NPipeline.Extensions.Testing"}),", you can use ",(0,i.jsx)(n.code,{children:"PipelineTestHarness<T>"})," to test your pipelines with fluent assertions on the execution results:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.Extensions.Testing;\r\nusing NPipeline.Extensions.Testing.AwesomeAssertions;\r\nusing AwesomeAssertions;\r\nusing Xunit;\r\n\r\npublic class MyPipelineTests\r\n{\r\n    [Fact]\r\n    public async Task Pipeline_ShouldCompleteSuccessfully()\r\n    {\r\n        // Arrange & Act\r\n        var result = await new PipelineTestHarness<MyPipeline>()\r\n            .WithParameter("input", testData)\r\n            .RunAsync();\r\n\r\n        // Assert - fluent API with AwesomeAssertions\r\n        result\r\n            .ShouldBeSuccessful()\r\n            .ShouldHaveNoErrors()\r\n            .ShouldCompleteWithin(TimeSpan.FromSeconds(5));\r\n    }\r\n\r\n    [Fact]\r\n    public async Task Pipeline_ShouldCaptureErrorsGracefully()\r\n    {\r\n        // Arrange & Act\r\n        var result = await new PipelineTestHarness<MyPipeline>()\r\n            .WithParameter("input", invalidData)\r\n            .CaptureErrors()\r\n            .RunAsync();\r\n\r\n        // Assert\r\n        result\r\n            .ShouldFail()\r\n            .ShouldHaveErrorOfType<InvalidOperationException>()\r\n            .ShouldHaveErrorCount(1);\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"pipeline-result-assertions",children:"Pipeline Result Assertions"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"AwesomeAssertions"})," integration provides these assertion extension methods:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Method"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ShouldBeSuccessful()"})}),(0,i.jsx)(n.td,{children:"Assert pipeline executed successfully (no uncaught exceptions)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ShouldFail()"})}),(0,i.jsx)(n.td,{children:"Assert pipeline execution failed"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ShouldHaveNoErrors()"})}),(0,i.jsx)(n.td,{children:"Assert no errors were captured"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ShouldHaveErrorCount(int)"})}),(0,i.jsx)(n.td,{children:"Assert specific number of errors were captured"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ShouldHaveErrorOfType<TException>()"})}),(0,i.jsx)(n.td,{children:"Assert at least one error of a specific type"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ShouldCompleteWithin(TimeSpan)"})}),(0,i.jsx)(n.td,{children:"Assert execution completed within duration"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"All methods return the result for fluent chaining."}),"\n",(0,i.jsx)(n.h2,{id:"sink-node-assertions",children:"Sink Node Assertions"}),"\n",(0,i.jsx)(n.p,{children:"For asserting on individual sink nodes, use the existing sink extensions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.Extensions.Testing;\r\nusing NPipeline.Extensions.Testing.AwesomeAssertions;\r\nusing AwesomeAssertions;\r\n\r\npublic class InMemorySinkTests\r\n{\r\n    [Fact]\r\n    public async Task Sink_Should_Receive_Data()\r\n    {\r\n        // Arrange\r\n        var inputData = new[] { "a", "b" };\r\n        var context = new PipelineContext();\r\n        context.SetSourceData(inputData);\r\n\r\n        var sink = new InMemorySinkNode<string>();\r\n        var builder = new PipelineBuilder();\r\n        var source = builder.AddInMemorySource<string>();\r\n        var transform = builder.AddTransform<ToUpperTransform, string, string>();\r\n\r\n        builder.Connect(source, transform);\r\n        builder.Connect(transform, sink);\r\n\r\n        var pipeline = builder.Build();\r\n\r\n        // Act\r\n        await PipelineRunner.Create().RunAsync(pipeline, context);\r\n\r\n        // Assert\r\n        sink.ShouldContain("A");\r\n        sink.ShouldContain("B");\r\n        sink.ShouldHaveReceived(2);\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"available-extension-methods",children:"Available Extension Methods"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"../../../src/NPipeline.Extensions.Testing.AwesomeAssertions/InMemorySinkExtensions.cs",children:(0,i.jsx)(n.code,{children:"InMemorySinkExtensions"})})," class provides these assertion methods for sink nodes:"]}),"\n",(0,i.jsx)(n.h3,{id:"count-assertions",children:"Count Assertions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Assert that sink has received a specific number of items\r\nsink.ShouldHaveReceived(expectedCount);\r\n\r\n// Equivalent to:\r\nsink.Items.Count.Should().Be(expectedCount);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"content-assertions",children:"Content Assertions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// Assert that sink contains a specific item\r\nsink.ShouldContain(expectedItem);\r\n\r\n// Assert that sink contains an item matching a predicate\r\nsink.ShouldContain(item => item.StartsWith("A"));\r\n\r\n// Assert that sink does not contain a specific item\r\nsink.ShouldNotContain(unexpectedItem);\r\n\r\n// Assert that all items in sink satisfy a predicate\r\nsink.ShouldOnlyContain(item => item.Length > 0);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"complete-example-pipeline-with-error-handling",children:"Complete Example: Pipeline with Error Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.Extensions.Testing;\r\nusing NPipeline.Extensions.Testing.AwesomeAssertions;\r\nusing AwesomeAssertions;\r\nusing Xunit;\r\n\r\npublic class PipelineWithErrorHandlingTests\r\n{\r\n    [Fact]\r\n    public async Task Pipeline_Should_Filter_And_Transform_Data()\r\n    {\r\n        // Arrange\r\n        var inputData = new[] { "apple", "banana", "cherry", "date" };\r\n        var context = new PipelineContext();\r\n        context.SetSourceData(inputData);\r\n\r\n        var builder = new PipelineBuilder();\r\n        var source = builder.AddInMemorySource<string>();\r\n        var filter = builder.AddTransform<FruitFilter, string, string>();\r\n        var transform = builder.AddTransform<ToUpperTransform, string, string>();\r\n        var sink = builder.AddInMemorySink<string>(context);\r\n\r\n        builder.Connect(source, filter);\r\n        builder.Connect(filter, transform);\r\n        builder.Connect(transform, sink);\r\n\r\n        var pipeline = builder.Build();\r\n\r\n        // Act\r\n        await PipelineRunner.Create().RunAsync(pipeline, context);\r\n\r\n        // Assert\r\n        sink.ShouldHaveReceived(2); // Only "apple" and "banana" should pass filter\r\n        sink.ShouldContain("APPLE");\r\n        sink.ShouldContain("BANANA");\r\n        sink.ShouldNotContain("CHERRY"); // "cherry" and "date" should be filtered out\r\n        sink.ShouldOnlyContain(item => item.Length >= 5); // All results should be 5+ characters\r\n    }\r\n\r\n    [Fact]\r\n    public async Task Pipeline_With_Error_Capturing_Should_Report_Errors()\r\n    {\r\n        // Arrange & Act\r\n        var result = await new PipelineTestHarness<PipelineThatCanFail>()\r\n            .WithParameter("input", problemData)\r\n            .CaptureErrors(PipelineErrorDecision.ContinueWithoutNode)\r\n            .RunAsync();\r\n\r\n        // Assert - fluent assertions make this very readable\r\n        result\r\n            .ShouldHaveErrorCount(2)\r\n            .ShouldHaveErrorOfType<ValidationException>()\r\n            .ShouldCompleteWithin(TimeSpan.FromSeconds(10));\r\n        \r\n        // Can also access the sink\r\n        var sink = result.GetSink<InMemorySinkNode<ProcessedData>>();\r\n        sink.ShouldHaveReceived(expectedSuccessfulCount);\r\n    }\r\n\r\n    [Fact]\r\n    public async Task Pipeline_Should_Preserve_Custom_Error_Handlers()\r\n    {\r\n        // Arrange - create a context with custom error handler\r\n        var errorLog = new List<string>();\r\n        var customHandler = new LoggingErrorHandler(errorLog);\r\n        \r\n        var context = new PipelineContext();\r\n        context.PipelineErrorHandler = customHandler;\r\n\r\n        // Act - test harness will chain custom handler with capturing handler\r\n        var result = await new PipelineTestHarness<MyPipeline>(context)\r\n            .WithParameter("input", testData)\r\n            .CaptureErrors()\r\n            .RunAsync();\r\n\r\n        // Assert - both error capturing AND custom logging happened\r\n        errorLog.Should().NotBeEmpty("custom handler should have logged");\r\n        result.Errors.Should().NotBeEmpty("errors should be captured");\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"benefits-of-awesomeassertions",children:"Benefits of AwesomeAssertions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Readability:"})," ",(0,i.jsx)(n.code,{children:"sink.ShouldHaveReceived(5)"})," reads more like a natural sentence than ",(0,i.jsx)(n.code,{children:"Assert.Equal(5, sink.Items.Count)"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Expressiveness:"})," AwesomeAssertions provides a rich set of assertions for collections, objects, exceptions, and more. For example, you can assert that a collection contains a specific item, that all items match a predicate, or that the output is in a specific order."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Detailed Error Messages:"})," When an assertion fails, AwesomeAssertions provides detailed output highlighting exactly what was different between the actual and expected values, which can significantly speed up debugging."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fluent Chaining:"})," You can chain multiple assertions together for complex validation scenarios."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/extensions/testing/fluent-assertions",children:"FluentAssertions"})}),": If you prefer FluentAssertions, NPipeline also provides a similar integration for that library."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/extensions/testing",children:"Testing Extensions"})}),": Return to the main testing documentation for more testing patterns and utilities."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var r=s(6540);const i={},t=r.createContext(i);function o(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);