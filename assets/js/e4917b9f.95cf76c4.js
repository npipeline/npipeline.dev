"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[8356],{7180:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>y,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"core-concepts/resilience/retry-delay-advanced","title":"Advanced Retry Delay Strategies","description":"Learn advanced patterns and scenarios for using retry delay strategies in NPipeline, including dynamic configuration, adaptive strategies, testing approaches, and performance optimization.","source":"@site/docs/core-concepts/resilience/retry-delay-advanced.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/retry-delay-advanced","permalink":"/docs/core-concepts/resilience/retry-delay-advanced","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"Advanced Retry Delay Strategies","description":"Learn advanced patterns and scenarios for using retry delay strategies in NPipeline, including dynamic configuration, adaptive strategies, testing approaches, and performance optimization.","sidebar_position":8},"sidebar":"docsSidebar","previous":{"title":"Retry Configuration","permalink":"/docs/core-concepts/resilience/retries"},"next":{"title":"Retry Delay Quickstart","permalink":"/docs/core-concepts/resilience/retry-delay-quickstart"}}');var r=n(4848),i=n(8453);const s={title:"Advanced Retry Delay Strategies",description:"Learn advanced patterns and scenarios for using retry delay strategies in NPipeline, including dynamic configuration, adaptive strategies, testing approaches, and performance optimization.",sidebar_position:8},l="Advanced Retry Delay Strategies",o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Dynamic Configuration",id:"dynamic-configuration",level:2},{value:"Runtime Strategy Adjustment",id:"runtime-strategy-adjustment",level:3},{value:"Per-Node Configuration",id:"per-node-configuration",level:3},{value:"Adaptive Retry Strategies",id:"adaptive-retry-strategies",level:2},{value:"Decorrelated Jitter for Adapting Load",id:"decorrelated-jitter-for-adapting-load",level:3},{value:"Fallback Strategy Pattern",id:"fallback-strategy-pattern",level:3},{value:"Testing Retry Behavior",id:"testing-retry-behavior",level:2},{value:"Testing with Controlled Randomness",id:"testing-with-controlled-randomness",level:3},{value:"Chaos Testing",id:"chaos-testing",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Batch Processing with Retry",id:"batch-processing-with-retry",level:3},{value:"Monitoring and Observability",id:"monitoring-and-observability",level:2},{value:"Measuring Retry Metrics",id:"measuring-retry-metrics",level:3},{value:"Custom Logging",id:"custom-logging",level:3},{value:"Complex Scenarios",id:"complex-scenarios",level:2},{value:"Exponential Backoff with Deadletter",id:"exponential-backoff-with-deadletter",level:3},{value:"Multi-Strategy Composition",id:"multi-strategy-composition",level:3},{value:"Custom Jitter Strategy",id:"custom-jitter-strategy",level:3},{value:"Custom Backoff Strategy",id:"custom-backoff-strategy",level:3},{value:"Advanced Configuration Patterns",id:"advanced-configuration-patterns",level:3},{value:"Conditional Strategy Selection",id:"conditional-strategy-selection",level:4},{value:"Composite Strategy with Multiple Delegates",id:"composite-strategy-with-multiple-delegates",level:4},{value:"Testing with Delegate Strategies",id:"testing-with-delegate-strategies",level:3},{value:"Unit Testing Custom Delegates",id:"unit-testing-custom-delegates",level:4},{value:"Testing Jitter Combinations",id:"testing-jitter-combinations",level:4},{value:"Performance Optimization with Delegates",id:"performance-optimization-with-delegates",level:3},{value:"Caching Delegates",id:"caching-delegates",level:4},{value:"Memory-Efficient Strategy Composition",id:"memory-efficient-strategy-composition",level:4},{value:"Advanced Monitoring with Delegates",id:"advanced-monitoring-with-delegates",level:3},{value:"Strategy Performance Metrics",id:"strategy-performance-metrics",level:4},{value:"Strategy Comparison Framework",id:"strategy-comparison-framework",level:4},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"See Also",id:"see-also",level:2},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"advanced-retry-delay-strategies",children:"Advanced Retry Delay Strategies"})}),"\n",(0,r.jsx)(t.p,{children:"This guide covers advanced patterns and scenarios for using retry delay strategies in NPipeline."}),"\n",(0,r.jsx)(t.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#dynamic-configuration",children:"Dynamic Configuration"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#adaptive-retry-strategies",children:"Adaptive Retry Strategies"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#testing-retry-behavior",children:"Testing Retry Behavior"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#monitoring-and-observability",children:"Monitoring and Observability"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#complex-scenarios",children:"Complex Scenarios"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"dynamic-configuration",children:"Dynamic Configuration"}),"\n",(0,r.jsx)(t.h3,{id:"runtime-strategy-adjustment",children:"Runtime Strategy Adjustment"}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["\u2139\ufe0f"," ",(0,r.jsx)(t.strong,{children:"Dynamic Configuration"})," allows you to modify retry strategies at runtime based on system conditions, providing adaptive behavior for changing environments."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"NPipeline allows you to modify retry strategies at runtime based on conditions:"}),"\n",(0,r.jsx)(t.mermaid,{value:"flowchart TD\n    A[Pipeline Initialization] --\x3e B[System Load Check]\n    B --\x3e C{Load Level?}\n    C --\x3e|High Load| D[Aggressive Backoff<br>baseDelay: 2s<br>multiplier: 3.0<br>maxDelay: 5m]\n    C --\x3e|Low Latency| E[Fast Backoff<br>baseDelay: 100ms<br>increment: 50ms<br>maxDelay: 5s]\n    C --\x3e|Normal| F[Standard Backoff<br>baseDelay: 1s<br>multiplier: 2.0<br>maxDelay: 1m]\n    \n    D --\x3e G[Continue with Aggressive Strategy]\n    E --\x3e H[Continue with Fast Strategy]\n    F --\x3e I[Continue with Standard Strategy]\n    \n    style A fill:#e1f5fe\n    style B fill:#fff3e0\n    style C fill:#ffecb3\n    style D fill:#ffe6e6\n    style E fill:#e8f5e9\n    style F fill:#e3f2fd\n    style G fill:#e8f5e9\n    style H fill:#e8f5e9\n    style I fill:#e3f2fd"}),"\n",(0,r.jsx)(t.h3,{id:"per-node-configuration",children:"Per-Node Configuration"}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["\ud83d\udca1"," ",(0,r.jsx)(t.strong,{children:"Pro Tip"}),": Different nodes can have different retry strategies based on their specific requirements and failure patterns."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Different nodes can have different retry strategies:"}),"\n",(0,r.jsx)(t.mermaid,{value:"graph TD\n    A[Pipeline Definition] --\x3e B{Node Type?}\n    B --\x3e|In-Memory Operations| C[Fast Retry Strategy<br>Fixed: 50ms<br>Max Retries: 1]\n    B --\x3e|I/O Operations| D[Standard Retry Strategy<br>Linear: 1s + 200ms<br>Max Retries: 3]\n    B --\x3e|External API| E[Conservative Retry Strategy<br>Exponential: 1s \xd7 2.0<br>Max Retries: 5]\n    \n    C --\x3e F[Memory Transform Node]\n    D --\x3e G[I/O Transform Node]\n    E --\x3e H[API Transform Node]\n    \n    F --\x3e I[Connect to Pipeline]\n    G --\x3e I\n    H --\x3e I\n    \n    style A fill:#e1f5fe\n    style B fill:#ffecb3\n    style C fill:#e8f5e9\n    style D fill:#e3f2fd\n    style E fill:#ffe6e6\n    style F fill:#e8f5e9\n    style G fill:#e3f2fd\n    style H fill:#e3f2fd\n    style I fill:#e8f5e9"}),"\n",(0,r.jsx)(t.h2,{id:"adaptive-retry-strategies",children:"Adaptive Retry Strategies"}),"\n",(0,r.jsx)(t.h3,{id:"decorrelated-jitter-for-adapting-load",children:"Decorrelated Jitter for Adapting Load"}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["\u2139\ufe0f"," ",(0,r.jsx)(t.strong,{children:"Decorrelated Jitter"})," is particularly useful when you want the system to adapt to changing conditions, as it considers previous delays when calculating the next delay."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Decorrelated jitter is particularly useful when you want the system to adapt to changing conditions:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"// Configuration that adapts based on previous retry timing\nvar context = CreatePipelineContext();\ncontext.UseExponentialBackoffDelay(\n    baseDelay: TimeSpan.FromMilliseconds(100),\n    multiplier: 2.0,\n    maxDelay: TimeSpan.FromSeconds(30));\n\n// Add decorrelated jitter to adapt to load\nvar decorrelatedConfig = new DecorrelatedJitterConfiguration\n{\n    MaxDelay = TimeSpan.FromSeconds(30),\n    Multiplier = 3.0\n};\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Benefits:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Automatically adapts to system load"}),"\n",(0,r.jsx)(t.li,{children:"Reduces retry thundering in variable conditions"}),"\n",(0,r.jsx)(t.li,{children:"Better utilization of system resources"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"fallback-strategy-pattern",children:"Fallback Strategy Pattern"}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["\u26a0\ufe0f"," ",(0,r.jsx)(t.strong,{children:"Important"}),": Implement a fallback strategy when primary strategy exhausts retries to prevent infinite retry loops and ensure graceful degradation."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Implement a fallback strategy when primary strategy exhausts retries:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class FallbackRetryStrategy\n{\n    private readonly IRetryDelayStrategy _primaryStrategy;\n    private readonly IRetryDelayStrategy _fallbackStrategy;\n    private readonly int _maxPrimaryAttempts;\n\n    public FallbackRetryStrategy(\n        IRetryDelayStrategy primary,\n        IRetryDelayStrategy fallback,\n        int maxPrimaryAttempts = 3)\n    {\n        _primaryStrategy = primary;\n        _fallbackStrategy = fallback;\n        _maxPrimaryAttempts = maxPrimaryAttempts;\n    }\n\n    public async ValueTask<TimeSpan> GetDelayAsync(\n        int attemptNumber,\n        CancellationToken cancellationToken = default)\n    {\n        var strategy = attemptNumber < _maxPrimaryAttempts\n            ? _primaryStrategy\n            : _fallbackStrategy;\n\n        return await strategy.GetDelayAsync(attemptNumber, cancellationToken);\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"testing-retry-behavior",children:"Testing Retry Behavior"}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["\ud83d\udca1"," ",(0,r.jsx)(t.strong,{children:"Pro Tip"}),": When testing retry behavior, use fixed delays with no jitter for predictable results, and use seeded random numbers for testing jitter behavior."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"When testing, use fixed delays with no jitter for predictable behavior:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"[Fact]\npublic async Task TestRetryBehavior()\n{\n    // Use fixed delay for deterministic testing\n    var context = CreateTestContext();\n    context.UseFixedDelay(TimeSpan.FromMilliseconds(10));\n\n    var stopwatch = Stopwatch.StartNew();\n\n    // Perform operation that will retry\n    var result = await ExecuteWithRetries(context, 3);\n\n    stopwatch.Stop();\n\n    // Verify expected delays: 10ms + 10ms = 20ms minimum\n    Assert.True(stopwatch.ElapsedMilliseconds >= 20);\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"testing-with-controlled-randomness",children:"Testing with Controlled Randomness"}),"\n",(0,r.jsx)(t.p,{children:"For testing jitter behavior, use a seeded Random:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"[Fact]\npublic async Task TestJitterDistribution()\n{\n    var config = new ExponentialBackoffConfiguration(\n        baseDelay: TimeSpan.FromSeconds(1),\n        multiplier: 2.0,\n        maxDelay: TimeSpan.FromMinutes(1));\n\n    var jitter = JitterStrategies.FullJitter();\n    var random = new Random(42); // Fixed seed for reproducibility\n\n    var factory = new DefaultRetryDelayStrategyFactory();\n    var strategy = factory.CreateExponentialBackoff(config, jitter);\n\n    // Test multiple attempts with same seed\n    var delays = new List<TimeSpan>();\n    for (int i = 0; i < 5; i++)\n    {\n        delays.Add(await strategy.GetDelayAsync(i));\n    }\n\n    // Verify delays are within expected range\n    foreach (var delay in delays)\n    {\n        Assert.True(delay >= TimeSpan.Zero);\n        Assert.True(delay <= TimeSpan.FromMinutes(1));\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"chaos-testing",children:"Chaos Testing"}),"\n",(0,r.jsx)(t.p,{children:"Simulate various failure scenarios:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class ChaosRetryTest\n{\n    [Theory]\n    [InlineData(1)] // Single retry\n    [InlineData(3)] // Multiple retries\n    [InlineData(5)] // Many retries\n    public async Task TestExhaustiveRetries(int maxRetries)\n    {\n        var context = CreatePipelineContext();\n        context.UseExponentialBackoffDelay(\n            TimeSpan.FromMilliseconds(5),\n            2.0,\n            TimeSpan.FromSeconds(1));\n\n        var failingNode = new AlwaysFailingNode();\n        var strategy = new ResilientExecutionStrategy(\n            new SequentialExecutionStrategy());\n\n        var ex = await Assert.ThrowsAsync<Exception>(\n            async () =>\n            {\n                var result = await strategy.ExecuteAsync(\n                    CreateInput(), failingNode, context,\n                    CancellationToken.None);\n                \n                await foreach (var item in result)\n                {\n                    // Consume results\n                }\n            });\n\n        Assert.NotNull(ex);\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["\u2714\ufe0f"," ",(0,r.jsx)(t.strong,{children:"Recommended"}),": The PipelineContext automatically caches retry strategies to avoid recreation overhead. Always retrieve the strategy from context rather than creating new instances."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"The PipelineContext automatically caches retry strategies:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"// First call creates the strategy\nvar strategy1 = context.GetRetryDelayStrategy();\n\n// Subsequent calls return the same instance\nvar strategy2 = context.GetRetryDelayStrategy();\n\nAssert.Same(strategy1, strategy2); // True - same instance\n"})}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["\u26a0\ufe0f"," ",(0,r.jsx)(t.strong,{children:"Performance Consideration"}),": Minimize allocations in hot paths by using ValueTask for synchronous operations and avoiding unnecessary async overhead."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Use async patterns efficiently:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"// ValueTask avoids allocation when result is synchronous\npublic async ValueTask<TimeSpan> GetDelayAsync(int attempt)\n{\n    // For synchronous paths, ValueTask doesn't allocate\n    if (attempt < 0)\n        return TimeSpan.Zero; // No allocation for successful path\n\n    // Only allocates for async paths\n    return await CalculateDelayAsync(attempt);\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"batch-processing-with-retry",children:"Batch Processing with Retry"}),"\n",(0,r.jsx)(t.p,{children:"When processing large batches, consider retry strategy efficiency:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class BatchRetryProcessor\n{\n    public async Task ProcessBatchAsync(\n        IEnumerable<Item> items,\n        PipelineContext context)\n    {\n        var strategy = context.GetRetryDelayStrategy(); // Cached\n        var maxRetries = 3;\n\n        foreach (var item in items)\n        {\n            for (int attempt = 0; attempt <= maxRetries; attempt++)\n            {\n                try\n                {\n                    await ProcessItemAsync(item);\n                    break;\n                }\n                catch when (attempt < maxRetries)\n                {\n                    // Get delay and wait - strategy is cached\n                    var delay = await strategy.GetDelayAsync(attempt);\n                    await Task.Delay(delay);\n                }\n            }\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"monitoring-and-observability",children:"Monitoring and Observability"}),"\n",(0,r.jsx)(t.h3,{id:"measuring-retry-metrics",children:"Measuring Retry Metrics"}),"\n",(0,r.jsx)(t.p,{children:"Track retry behavior for insights:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public class RetryMetricsCollector\n{\n    private readonly List<RetryMetric> _metrics = new();\n\n    public async Task TrackRetryAsync(\n        string nodeId,\n        int attemptNumber,\n        PipelineContext context)\n    {\n        var strategy = context.GetRetryDelayStrategy();\n        var delay = await strategy.GetDelayAsync(attemptNumber);\n\n        _metrics.Add(new RetryMetric\n        {\n            NodeId = nodeId,\n            Attempt = attemptNumber,\n            Delay = delay,\n            Timestamp = DateTime.UtcNow\n        });\n    }\n\n    public void LogMetrics()\n    {\n        var grouped = _metrics.GroupBy(m => m.NodeId);\n\n        foreach (var group in grouped)\n        {\n            var avgDelay = group.Average(m => m.Delay.TotalMilliseconds);\n            var maxDelay = group.Max(m => m.Delay.TotalMilliseconds);\n            var retryCount = group.Count();\n\n            Console.WriteLine(\n                $"Node {group.Key}: {retryCount} retries, " +\n                $"avg delay {avgDelay:F2}ms, max {maxDelay:F2}ms");\n        }\n    }\n}\n\npublic class RetryMetric\n{\n    public string NodeId { get; set; }\n    public int Attempt { get; set; }\n    public TimeSpan Delay { get; set; }\n    public DateTime Timestamp { get; set; }\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"custom-logging",children:"Custom Logging"}),"\n",(0,r.jsx)(t.p,{children:"Log retry patterns for debugging:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public class RetryLogger\n{\n    private readonly ILogger _logger;\n\n    public async Task LogRetryAsync(\n        string nodeId,\n        int attempt,\n        Exception error,\n        PipelineContext context)\n    {\n        var strategy = context.GetRetryDelayStrategy();\n        var delay = await strategy.GetDelayAsync(attempt);\n\n        _logger.LogWarning(\n            "Node {NodeId} retry {Attempt}: " +\n            "Error={ErrorType}, Delay={DelayMs}ms, " +\n            "StrategyType={StrategyType}",\n            nodeId,\n            attempt,\n            error.GetType().Name,\n            delay.TotalMilliseconds,\n            strategy.GetType().Name);\n    }\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"complex-scenarios",children:"Complex Scenarios"}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["\u2139\ufe0f"," ",(0,r.jsx)(t.strong,{children:"Circuit Breaker Pattern"}),": Combining retry delays with circuit breaker patterns provides enhanced resilience for distributed systems, allowing fast failure when services are consistently unavailable."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Combine retry delays with circuit breaker:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class CircuitBreakerRetryStrategy : IRetryDelayStrategy\n{\n    private readonly IRetryDelayStrategy _innerStrategy;\n    private readonly CircuitBreaker _circuitBreaker;\n\n    public async ValueTask<TimeSpan> GetDelayAsync(\n        int attemptNumber,\n        CancellationToken cancellationToken = default)\n    {\n        if (_circuitBreaker.IsOpen)\n        {\n            // Increase delay when circuit is open\n            return TimeSpan.FromSeconds(30);\n        }\n\n        return await _innerStrategy.GetDelayAsync(\n            attemptNumber, cancellationToken);\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"exponential-backoff-with-deadletter",children:"Exponential Backoff with Deadletter"}),"\n",(0,r.jsx)(t.p,{children:"Implement deadletter handling after max retries:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class DeadletterRetryStrategy\n{\n    private readonly IRetryDelayStrategy _strategy;\n    private readonly int _maxRetries;\n    private readonly IDeadletterQueue _deadletter;\n\n    public async Task RetryWithDeadletterAsync<T>(\n        T item,\n        Func<T, Task> operation,\n        int attempt = 0)\n    {\n        try\n        {\n            await operation(item);\n        }\n        catch (Exception ex) when (attempt < _maxRetries)\n        {\n            var delay = await _strategy.GetDelayAsync(attempt);\n            await Task.Delay(delay);\n            await RetryWithDeadletterAsync(item, operation, attempt + 1);\n        }\n        catch (Exception ex)\n        {\n            // Send to deadletter after exhausting retries\n            await _deadletter.SendAsync(item, ex);\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"multi-strategy-composition",children:"Multi-Strategy Composition"}),"\n",(0,r.jsx)(t.p,{children:"Combine multiple strategies with custom logic:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class ComposedRetryStrategy : IRetryDelayStrategy\n{\n    private readonly IRetryDelayStrategy[] _strategies;\n    private readonly Func<int, int> _strategySelector;\n\n    public async ValueTask<TimeSpan> GetDelayAsync(\n        int attemptNumber,\n        CancellationToken cancellationToken = default)\n    {\n        var strategyIndex = _strategySelector(attemptNumber);\n        var strategy = _strategies[\n            Math.Min(strategyIndex, _strategies.Length - 1)];\n\n        return await strategy.GetDelayAsync(\n            attemptNumber, cancellationToken);\n    }\n}\n\n// Usage: Switch between strategies based on attempt count\nvar composed = new ComposedRetryStrategy(\n    new[]\n    {\n        exponentialBackoff,    // Attempts 0-2\n        linearBackoff,         // Attempts 3-5\n        fixedDelay             // Attempts 6+\n    },\n    attempt => attempt / 3);   // Switch strategy every 3 attempts\n"})}),"\n",(0,r.jsx)(t.h3,{id:"custom-jitter-strategy",children:"Custom Jitter Strategy"}),"\n",(0,r.jsx)(t.p,{children:"Create custom jitter strategies using the delegate pattern:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"// Custom jitter implementation\nJitterStrategy customJitter = (baseDelay, random) =>\n{\n    // Your custom jitter calculation logic\n    var jitterMs = random.NextDouble() * baseDelay.TotalMilliseconds * 0.1;\n    return TimeSpan.FromMilliseconds(jitterMs);\n};\n\n// Use with existing backoff strategy delegate\nvar backoff = BackoffStrategies.ExponentialBackoff(\n    TimeSpan.FromSeconds(1), \n    2.0, \n    TimeSpan.FromMinutes(1));\nvar composite = new CompositeRetryDelayStrategy(backoff, customJitter);\n"})}),"\n",(0,r.jsx)(t.h3,{id:"custom-backoff-strategy",children:"Custom Backoff Strategy"}),"\n",(0,r.jsx)(t.p,{children:"Create custom backoff strategies using the delegate pattern:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"// Custom backoff implementation\nBackoffStrategy customBackoff = (attemptNumber) =>\n{\n    // Your custom backoff calculation logic\n    if (attemptNumber < 0)\n        return TimeSpan.Zero;\n    \n    // Example: Fibonacci backoff\n    if (attemptNumber == 0) return TimeSpan.FromSeconds(1);\n    if (attemptNumber == 1) return TimeSpan.FromSeconds(1);\n    \n    var fib = CalculateFibonacci(attemptNumber + 2);\n    return TimeSpan.FromSeconds(Math.Min(fib, 60)); // Cap at 60 seconds\n};\n\n// Use with existing jitter strategy\nvar jitter = JitterStrategies.FullJitter();\nvar composite = new CompositeRetryDelayStrategy(customBackoff, jitter);\n"})}),"\n",(0,r.jsx)(t.h3,{id:"advanced-configuration-patterns",children:"Advanced Configuration Patterns"}),"\n",(0,r.jsx)(t.h4,{id:"conditional-strategy-selection",children:"Conditional Strategy Selection"}),"\n",(0,r.jsx)(t.p,{children:"Select strategies based on runtime conditions:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public class AdaptiveRetryStrategySelector\n{\n    private readonly Dictionary<string, BackoffStrategy> _strategies;\n    \n    public AdaptiveRetryStrategySelector()\n    {\n        _strategies = new Dictionary<string, BackoffStrategy>\n        {\n            ["fast"] = BackoffStrategies.LinearBackoff(\n                TimeSpan.FromMilliseconds(50), \n                TimeSpan.FromMilliseconds(25), \n                TimeSpan.FromSeconds(1)),\n            ["normal"] = BackoffStrategies.ExponentialBackoff(\n                TimeSpan.FromSeconds(1), \n                2.0, \n                TimeSpan.FromMinutes(1)),\n            ["slow"] = BackoffStrategies.ExponentialBackoff(\n                TimeSpan.FromSeconds(5), \n                3.0, \n                TimeSpan.FromMinutes(5))\n        };\n    }\n    \n    public BackoffStrategy SelectStrategy(string mode)\n    {\n        return _strategies.TryGetValue(mode, out var strategy) \n            ? strategy \n            : _strategies["normal"];\n    }\n}\n'})}),"\n",(0,r.jsx)(t.h4,{id:"composite-strategy-with-multiple-delegates",children:"Composite Strategy with Multiple Delegates"}),"\n",(0,r.jsx)(t.p,{children:"Combine multiple backoff strategies with custom logic:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class HybridBackoffStrategy\n{\n    private readonly BackoffStrategy _primary;\n    private readonly BackoffStrategy _secondary;\n    private readonly int _switchThreshold;\n    \n    public HybridBackoffStrategy(\n        BackoffStrategy primary,\n        BackoffStrategy secondary,\n        int switchThreshold = 3)\n    {\n        _primary = primary;\n        _secondary = secondary;\n        _switchThreshold = switchThreshold;\n    }\n    \n    public TimeSpan CalculateDelay(int attemptNumber)\n    {\n        return attemptNumber < _switchThreshold\n            ? _primary(attemptNumber)\n            : _secondary(attemptNumber);\n    }\n}\n\n// Usage: Start with exponential, switch to linear after 3 attempts\nvar hybrid = new HybridBackoffStrategy(\n    BackoffStrategies.ExponentialBackoff(TimeSpan.FromSeconds(1), 2.0, TimeSpan.FromMinutes(1)),\n    BackoffStrategies.LinearBackoff(TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5), TimeSpan.FromMinutes(2)),\n    3);\n"})}),"\n",(0,r.jsx)(t.h3,{id:"testing-with-delegate-strategies",children:"Testing with Delegate Strategies"}),"\n",(0,r.jsx)(t.h4,{id:"unit-testing-custom-delegates",children:"Unit Testing Custom Delegates"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"[Fact]\npublic void CustomBackoffStrategy_ReturnsExpectedDelays()\n{\n    // Arrange\n    var customBackoff = BackoffStrategies.ExponentialBackoff(\n        TimeSpan.FromSeconds(1), \n        2.0, \n        TimeSpan.FromSeconds(10));\n    \n    // Act & Assert\n    Assert.Equal(TimeSpan.FromSeconds(1), customBackoff(0));\n    Assert.Equal(TimeSpan.FromSeconds(2), customBackoff(1));\n    Assert.Equal(TimeSpan.FromSeconds(4), customBackoff(2));\n    Assert.Equal(TimeSpan.FromSeconds(8), customBackoff(3));\n    Assert.Equal(TimeSpan.FromSeconds(10), customBackoff(4)); // Capped\n}\n"})}),"\n",(0,r.jsx)(t.h4,{id:"testing-jitter-combinations",children:"Testing Jitter Combinations"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"[Fact]\npublic async Task BackoffWithJitter_WithinExpectedRange()\n{\n    // Arrange\n    var backoff = BackoffStrategies.ExponentialBackoff(\n        TimeSpan.FromSeconds(1), \n        2.0, \n        TimeSpan.FromMinutes(1));\n    var jitter = JitterStrategies.FullJitter();\n    var composite = new CompositeRetryDelayStrategy(backoff, jitter);\n    \n    // Act\n    var delays = new List<TimeSpan>();\n    for (int i = 0; i < 5; i++)\n    {\n        delays.Add(await composite.GetDelayAsync(i));\n    }\n    \n    // Assert\n    foreach (var delay in delays)\n    {\n        Assert.True(delay >= TimeSpan.Zero);\n        Assert.True(delay <= TimeSpan.FromMinutes(1));\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"performance-optimization-with-delegates",children:"Performance Optimization with Delegates"}),"\n",(0,r.jsx)(t.h4,{id:"caching-delegates",children:"Caching Delegates"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public class OptimizedRetryManager\n{\n    private readonly ConcurrentDictionary<string, BackoffStrategy> _backoffCache = new();\n    private readonly ConcurrentDictionary<string, JitterStrategy> _jitterCache = new();\n    \n    public BackoffStrategy GetBackoffStrategy(string type, TimeSpan baseDelay)\n    {\n        var key = $"{type}_{baseDelay.TotalMilliseconds}";\n        return _backoffCache.GetOrAdd(key, _ => type switch\n        {\n            "exponential" => BackoffStrategies.ExponentialBackoff(baseDelay),\n            "linear" => BackoffStrategies.LinearBackoff(baseDelay),\n            "fixed" => BackoffStrategies.FixedDelay(baseDelay),\n            _ => BackoffStrategies.ExponentialBackoff(baseDelay)\n        });\n    }\n    \n    public JitterStrategy GetJitterStrategy(string type)\n    {\n        return _jitterCache.GetOrAdd(type, _ => type switch\n        {\n            "full" => JitterStrategies.FullJitter(),\n            "equal" => JitterStrategies.EqualJitter(),\n            "decorrelated" => JitterStrategies.DecorrelatedJitter(),\n            _ => JitterStrategies.NoJitter()\n        });\n    }\n}\n'})}),"\n",(0,r.jsx)(t.h4,{id:"memory-efficient-strategy-composition",children:"Memory-Efficient Strategy Composition"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class LightweightRetryStrategy : IRetryDelayStrategy\n{\n    private readonly BackoffStrategy _backoff;\n    private readonly JitterStrategy _jitter;\n    private readonly Random _random = new();\n    \n    public LightweightRetryStrategy(BackoffStrategy backoff, JitterStrategy jitter = null)\n    {\n        _backoff = backoff;\n        _jitter = jitter;\n    }\n    \n    public ValueTask<TimeSpan> GetDelayAsync(int attemptNumber, CancellationToken cancellationToken = default)\n    {\n        var baseDelay = _backoff(attemptNumber);\n        \n        if (_jitter != null)\n            return new ValueTask<TimeSpan>(_jitter(baseDelay, _random));\n        \n        return new ValueTask<TimeSpan>(baseDelay);\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"advanced-monitoring-with-delegates",children:"Advanced Monitoring with Delegates"}),"\n",(0,r.jsx)(t.h4,{id:"strategy-performance-metrics",children:"Strategy Performance Metrics"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public class BackoffMetricsCollector\n{\n    private readonly Dictionary<string, List<TimeSpan>> _metrics = new();\n    \n    public BackoffStrategy WithMetrics(string name, BackoffStrategy strategy)\n    {\n        return attemptNumber =>\n        {\n            var delay = strategy(attemptNumber);\n            \n            if (!_metrics.ContainsKey(name))\n                _metrics[name] = new List<TimeSpan>();\n            \n            _metrics[name].Add(delay);\n            return delay;\n        };\n    }\n    \n    public void ReportMetrics()\n    {\n        foreach (var (name, delays) in _metrics)\n        {\n            var avg = delays.Average(d => d.TotalMilliseconds);\n            var max = delays.Max(d => d.TotalMilliseconds);\n            var min = delays.Min(d => d.TotalMilliseconds);\n            \n            Console.WriteLine($"{name}: Avg={avg:F2}ms, Min={min:F2}ms, Max={max:F2}ms, Count={delays.Count}");\n        }\n    }\n}\n\n// Usage\nvar metrics = new BackoffMetricsCollector();\nvar backoffWithMetrics = metrics.WithMetrics("exponential", \n    BackoffStrategies.ExponentialBackoff(TimeSpan.FromSeconds(1), 2.0, TimeSpan.FromMinutes(1)));\n'})}),"\n",(0,r.jsx)(t.h4,{id:"strategy-comparison-framework",children:"Strategy Comparison Framework"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public class StrategyComparer\n{\n    public async Task CompareStrategiesAsync(\n        IEnumerable<BackoffStrategy> strategies,\n        int maxAttempts = 10)\n    {\n        var results = new List<StrategyResult>();\n        \n        foreach (var strategy in strategies)\n        {\n            var delays = new List<TimeSpan>();\n            var stopwatch = Stopwatch.StartNew();\n            \n            for (int attempt = 0; attempt < maxAttempts; attempt++)\n            {\n                delays.Add(strategy(attempt));\n            }\n            \n            stopwatch.Stop();\n            \n            results.Add(new StrategyResult\n            {\n                StrategyName = strategy.GetType().Name,\n                TotalTime = stopwatch.Elapsed,\n                Delays = delays,\n                AverageDelay = delays.Average(d => d.TotalMilliseconds),\n                MaxDelay = delays.Max(d => d.TotalMilliseconds),\n                MinDelay = delays.Min(d => d.TotalMilliseconds)\n            });\n        }\n        \n        // Print comparison\n        foreach (var result in results.OrderBy(r => r.AverageDelay))\n        {\n            Console.WriteLine($"{result.StrategyName}: Avg={result.AverageDelay:F2}ms, " +\n                             $"Min={result.MinDelay:F2}ms, Max={result.MaxDelay:F2}ms");\n        }\n    }\n    \n    private class StrategyResult\n    {\n        public string StrategyName { get; set; }\n        public TimeSpan TotalTime { get; set; }\n        public List<TimeSpan> Delays { get; set; }\n        public double AverageDelay { get; set; }\n        public double MaxDelay { get; set; }\n        public double MinDelay { get; set; }\n    }\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Start Conservative"})," - Begin with shorter delays, increase if needed"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Monitor Metrics"})," - Track retry patterns and adjust based on data"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Use Jitter"})," - Essential for distributed systems to prevent thundering herd"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Test Thoroughly"})," - Use fixed delays in tests for predictability"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Document Decisions"})," - Comment why you chose specific strategies"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Measure Performance"})," - Profile retry behavior in production"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Handle Cancellation"})," - Always respect CancellationToken during delays"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Plan for Failover"})," - Have circuit breaker and deadletter mechanisms"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/retry-delay-architecture",children:"Retry Delay Architecture"})}),": Deep dive into the architectural components and design patterns of NPipeline's retry delay system"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/core-concepts/resilience/retries",children:"Retry Configuration"})}),": Basic retry configuration options and built-in strategies"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/core-concepts/resilience/",children:"Resilience Overview"})}),": Comprehensive guide to building fault-tolerant pipelines"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling Guide"})}),": How to integrate retry strategies with error handling"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/extensions/testing/advanced-testing",children:"Testing Pipelines"})}),": Comprehensive testing strategies for pipeline components including retry behavior"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling Guide"})}),": Comprehensive error handling strategies that work with retry delays"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/core-concepts/resilience/circuit-breakers",children:"Circuit Breaker Configuration"})}),": Combining circuit breakers with retry delays for enhanced resilience"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Hygiene"})}),": Best practices for building high-performance, low-allocation data pipelines"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting"})}),": Common issues and solutions for retry behavior problems"]}),"\n"]})]})}function y(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var a=n(6540);const r={},i=a.createContext(r);function s(e){const t=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);