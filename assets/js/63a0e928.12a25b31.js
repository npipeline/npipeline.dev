"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3597],{28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>c});var s=i(96540);const r={},l=s.createContext(r);function t(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(l.Provider,{value:n},e.children)}},86144:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"extensions/observability/metrics","title":"Metrics Reference","description":"Complete reference for all metrics collected by the NPipeline Observability extension, including node and pipeline metrics, calculations, and thread-safety guarantees.","source":"@site/docs/extensions/observability/metrics.md","sourceDirName":"extensions/observability","slug":"/extensions/observability/metrics","permalink":"/docs/extensions/observability/metrics","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Metrics Reference","description":"Complete reference for all metrics collected by the NPipeline Observability extension, including node and pipeline metrics, calculations, and thread-safety guarantees."},"sidebar":"docsSidebar","previous":{"title":"Observability Usage Examples","permalink":"/docs/extensions/observability/examples"},"next":{"title":"Connectors Overview","permalink":"/docs/connectors"}}');var r=i(74848),l=i(28453);const t={title:"Metrics Reference",description:"Complete reference for all metrics collected by the NPipeline Observability extension, including node and pipeline metrics, calculations, and thread-safety guarantees."},c="Metrics Reference",d={},o=[{value:"Node Metrics",id:"node-metrics",level:2},{value:"INodeMetrics Interface",id:"inodemetrics-interface",level:3},{value:"Node Metrics Properties",id:"node-metrics-properties",level:3},{value:"NodeId",id:"nodeid",level:4},{value:"StartTime",id:"starttime",level:4},{value:"EndTime",id:"endtime",level:4},{value:"DurationMs",id:"durationms",level:4},{value:"Success",id:"success",level:4},{value:"ItemsProcessed",id:"itemsprocessed",level:4},{value:"ItemsEmitted",id:"itemsemitted",level:4},{value:"Exception",id:"exception",level:4},{value:"RetryCount",id:"retrycount",level:4},{value:"PeakMemoryUsageMb",id:"peakmemoryusagemb",level:4},{value:"ProcessorTimeMs",id:"processortimems",level:4},{value:"AverageItemProcessingMs",id:"averageitemprocessingms",level:4},{value:"ThroughputItemsPerSec",id:"throughputitemspersec",level:4},{value:"ThreadId",id:"threadid",level:4},{value:"Pipeline Metrics",id:"pipeline-metrics",level:2},{value:"IPipelineMetrics Interface",id:"ipipelinemetrics-interface",level:3},{value:"Pipeline Metrics Properties",id:"pipeline-metrics-properties",level:3},{value:"PipelineName",id:"pipelinename",level:4},{value:"RunId",id:"runid",level:4},{value:"StartTime",id:"starttime-1",level:4},{value:"EndTime",id:"endtime-1",level:4},{value:"DurationMs",id:"durationms-1",level:4},{value:"Success",id:"success-1",level:4},{value:"TotalItemsProcessed",id:"totalitemsprocessed",level:4},{value:"NodeMetrics",id:"nodemetrics",level:4},{value:"Exception",id:"exception-1",level:4},{value:"Metrics Calculation Details",id:"metrics-calculation-details",level:2},{value:"Throughput Calculation",id:"throughput-calculation",level:3},{value:"Memory Usage Calculation",id:"memory-usage-calculation",level:3},{value:"Retry Count Calculation",id:"retry-count-calculation",level:3},{value:"Thread-Safety Considerations",id:"thread-safety-considerations",level:2},{value:"Concurrent Metrics Collection",id:"concurrent-metrics-collection",level:3},{value:"Atomic Counter Updates",id:"atomic-counter-updates",level:3},{value:"Retry Count Updates",id:"retry-count-updates",level:3},{value:"Immutable Metric Records",id:"immutable-metric-records",level:3},{value:"Scoped Lifetime",id:"scoped-lifetime",level:3},{value:"Performance Metrics Interpretation",id:"performance-metrics-interpretation",level:2},{value:"Identifying Bottlenecks",id:"identifying-bottlenecks",level:3},{value:"Analyzing Throughput",id:"analyzing-throughput",level:3},{value:"Memory Efficiency Analysis",id:"memory-efficiency-analysis",level:3},{value:"Retry Pattern Analysis",id:"retry-pattern-analysis",level:3},{value:"Related Topics",id:"related-topics",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"metrics-reference",children:"Metrics Reference"})}),"\n",(0,r.jsx)(n.p,{children:"This reference provides detailed documentation for all metrics collected by the NPipeline Observability extension, including how metrics are calculated, their data types, and thread-safety considerations."}),"\n",(0,r.jsx)(n.h2,{id:"node-metrics",children:"Node Metrics"}),"\n",(0,r.jsx)(n.p,{children:"Node metrics capture performance and execution data for individual nodes within a pipeline. Each node execution produces a complete set of metrics."}),"\n",(0,r.jsx)(n.h3,{id:"inodemetrics-interface",children:"INodeMetrics Interface"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public interface INodeMetrics\n{\n    string NodeId { get; }\n    DateTimeOffset? StartTime { get; }\n    DateTimeOffset? EndTime { get; }\n    long? DurationMs { get; }\n    bool Success { get; }\n    long ItemsProcessed { get; }\n    long ItemsEmitted { get; }\n    Exception? Exception { get; }\n    int RetryCount { get; }\n    long? PeakMemoryUsageMb { get; }\n    long? ProcessorTimeMs { get; }\n    double? ThroughputItemsPerSec { get; }\n    int? ThreadId { get; }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"node-metrics-properties",children:"Node Metrics Properties"}),"\n",(0,r.jsx)(n.h4,{id:"nodeid",children:"NodeId"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"string"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Unique identifier for the node within the pipeline"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Assigned during pipeline construction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": ",(0,r.jsx)(n.code,{children:'"TransformNode"'})," or ",(0,r.jsx)(n.code,{children:'"SourceNode_1"'})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Use this property to correlate metrics with specific nodes in your pipeline definition. The node ID matches the handle used when connecting nodes."]}),"\n",(0,r.jsx)(n.h4,{id:"starttime",children:"StartTime"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"DateTimeOffset?"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Timestamp when the node execution began"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Recorded when ",(0,r.jsx)(n.code,{children:"OnNodeStarted"})," event fires"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resolution"}),": System clock precision (typically 15-16ms on Windows)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),": Captured at the beginning of node execution using ",(0,r.jsx)(n.code,{children:"DateTimeOffset.UtcNow"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Calculate duration by comparing with ",(0,r.jsx)(n.code,{children:"EndTime"}),". Useful for identifying when nodes started relative to each other."]}),"\n",(0,r.jsx)(n.h4,{id:"endtime",children:"EndTime"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"DateTimeOffset?"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Timestamp when the node execution completed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Recorded when ",(0,r.jsx)(n.code,{children:"OnNodeCompleted"})," event fires"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resolution"}),": System clock precision"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),": Captured at the end of node execution using ",(0,r.jsx)(n.code,{children:"DateTimeOffset.UtcNow"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Calculate duration and identify when nodes finished. Can be null if the node is still executing or if metrics collection failed."]}),"\n",(0,r.jsx)(n.h4,{id:"durationms",children:"DurationMs"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"long?"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Total execution time in milliseconds"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Calculated from ",(0,r.jsx)(n.code,{children:"StartTime"})," and ",(0,r.jsx)(n.code,{children:"EndTime"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Precision"}),": Millisecond"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"DurationMs = (long)(EndTime - StartTime).TotalMilliseconds\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Primary metric for identifying performance bottlenecks. Compare duration across nodes to find slow components."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": Can be null if either ",(0,r.jsx)(n.code,{children:"StartTime"})," or ",(0,r.jsx)(n.code,{children:"EndTime"})," is null."]}),"\n",(0,r.jsx)(n.h4,{id:"success",children:"Success"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"bool"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Whether the node execution completed successfully"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Determined by exception presence"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),": ",(0,r.jsx)(n.code,{children:"true"})," if no exception occurred, ",(0,r.jsx)(n.code,{children:"false"})," if an exception was thrown."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Filter metrics to analyze successful vs. failed executions. Track success rates over time."]}),"\n",(0,r.jsx)(n.h4,{id:"itemsprocessed",children:"ItemsProcessed"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"long"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Total number of items processed by the node"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Aggregated from item processing events"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (uses ",(0,r.jsx)(n.code,{children:"Interlocked.Add"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Range"}),": 0 to ",(0,r.jsx)(n.code,{children:"long.MaxValue"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),": Incremented atomically as items are processed. For parallel execution, this represents the total across all threads."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Measure node throughput and identify processing volume. Compare with ",(0,r.jsx)(n.code,{children:"ItemsEmitted"})," to understand filtering ratios."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safety"}),": Uses ",(0,r.jsx)(n.code,{children:"Interlocked.Add"})," for atomic increments in concurrent scenarios."]}),"\n",(0,r.jsx)(n.h4,{id:"itemsemitted",children:"ItemsEmitted"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"long"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Total number of items emitted by the node"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Aggregated from item emission events"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (uses ",(0,r.jsx)(n.code,{children:"Interlocked.Add"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Range"}),": 0 to ",(0,r.jsx)(n.code,{children:"long.MaxValue"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),": Incremented atomically as items are emitted to downstream nodes."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Compare with ",(0,r.jsx)(n.code,{children:"ItemsProcessed"})," to understand filtering behavior. For source nodes, ",(0,r.jsx)(n.code,{children:"ItemsProcessed"})," equals ",(0,r.jsx)(n.code,{children:"ItemsEmitted"}),". For filter nodes, ",(0,r.jsx)(n.code,{children:"ItemsEmitted"})," may be less than ",(0,r.jsx)(n.code,{children:"ItemsProcessed"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safety"}),": Uses ",(0,r.jsx)(n.code,{children:"Interlocked.Add"})," for atomic increments in concurrent scenarios."]}),"\n",(0,r.jsx)(n.h4,{id:"exception",children:"Exception"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"Exception?"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Exception that caused node failure, if any"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Captured from execution context"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Debug failed executions, identify error patterns, and track exception types. Use ",(0,r.jsx)(n.code,{children:"Exception.Message"})," for logging and ",(0,r.jsx)(n.code,{children:"Exception.StackTrace"})," for detailed debugging."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": Null if the node executed successfully."]}),"\n",(0,r.jsx)(n.h4,{id:"retrycount",children:"RetryCount"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"int"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Maximum number of retry attempts for this node"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Aggregated from retry events"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (uses ",(0,r.jsx)(n.code,{children:"Interlocked.Exchange"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Range"}),": 0 to ",(0,r.jsx)(n.code,{children:"int.MaxValue"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),": Tracks the highest retry attempt number observed. If a node retries 3 times, this value will be 3."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Identify unreliable nodes or external dependencies that frequently fail. High retry counts may indicate:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Unstable external services"}),"\n",(0,r.jsx)(n.li,{children:"Transient network issues"}),"\n",(0,r.jsx)(n.li,{children:"Insufficient timeout values"}),"\n",(0,r.jsx)(n.li,{children:"Resource contention"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safety"}),": Uses ",(0,r.jsx)(n.code,{children:"Interlocked.Exchange"})," to ensure the maximum retry count is retained."]}),"\n",(0,r.jsx)(n.h4,{id:"peakmemoryusagemb",children:"PeakMemoryUsageMb"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"long?"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Per-node managed memory allocation delta in megabytes during node execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Calculated as delta between final and initial memory using ",(0,r.jsx)(n.code,{children:"GC.GetTotalMemory(false)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Granularity"}),": Per-node managed memory allocation delta"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Initial memory at node start\nvar initialMemoryBytes = GC.GetTotalMemory(false);\n\n// ... node execution ...\n\n// Final memory at node end\nvar finalMemoryBytes = GC.GetTotalMemory(false);\n\n// Calculate delta (memory allocated during node execution)\nvar deltaBytes = finalMemoryBytes - initialMemoryBytes;\nvar memoryDeltaMb = deltaBytes / (1024 * 1024);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Identify memory-intensive nodes and optimize memory usage. Track memory growth over time to detect leaks."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Important Notes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["This is a ",(0,r.jsx)(n.strong,{children:"per-node delta"})," of managed memory allocations, not global process memory"]}),"\n",(0,r.jsxs)(n.li,{children:["Memory is measured using ",(0,r.jsx)(n.code,{children:"GC.GetTotalMemory(false)"})," which captures managed memory allocations"]}),"\n",(0,r.jsx)(n.li,{children:"In parallel execution, this reflects the memory allocated during that specific node's execution"}),"\n",(0,r.jsx)(n.li,{children:"May be null if metrics collection fails or is disabled"}),"\n",(0,r.jsxs)(n.li,{children:["Memory metrics require both extension-level (",(0,r.jsx)(n.code,{children:"EnableMemoryMetrics"}),") and node-level (",(0,r.jsx)(n.code,{children:"RecordMemoryUsage"}),") options to be enabled"]}),"\n",(0,r.jsx)(n.li,{children:"Use for relative comparisons between nodes, not absolute memory requirements"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"processortimems",children:"ProcessorTimeMs"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"long?"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Total processor time used in milliseconds"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Not available per-node in current implementation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Granularity"}),": Process-level (not node-specific)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Important Notes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["This metric is ",(0,r.jsx)(n.strong,{children:"not available per-node"})," in the current implementation"]}),"\n",(0,r.jsxs)(n.li,{children:["The field is included for future compatibility but will always be ",(0,r.jsx)(n.code,{children:"null"})," for node metrics"]}),"\n",(0,r.jsx)(n.li,{children:"If you need CPU metrics, consider using system-level monitoring tools"}),"\n",(0,r.jsx)(n.li,{children:"May be null if metrics collection fails or is disabled"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"averageitemprocessingms",children:"AverageItemProcessingMs"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"double?"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Average time spent processing each item in milliseconds"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Calculated from ",(0,r.jsx)(n.code,{children:"DurationMs"})," and ",(0,r.jsx)(n.code,{children:"ItemsProcessed"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Precision"}),": Double-precision floating point"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"AverageItemProcessingMs = DurationMs / ItemsProcessed\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Measure per-item processing efficiency. Identify nodes with high per-item overhead. Compare processing time across different data volumes."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": If a node processes 1000 items in 500ms, average per-item time is 0.5ms."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": Can be null if ",(0,r.jsx)(n.code,{children:"DurationMs"})," is null or ",(0,r.jsx)(n.code,{children:"ItemsProcessed"})," is zero."]}),"\n",(0,r.jsx)(n.h4,{id:"throughputitemspersec",children:"ThroughputItemsPerSec"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"double?"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Processing throughput in items per second"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Calculated from ",(0,r.jsx)(n.code,{children:"ItemsProcessed"})," and ",(0,r.jsx)(n.code,{children:"DurationMs"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Precision"}),": Double-precision floating point"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"ThroughputItemsPerSec = ItemsProcessed / (DurationMs / 1000.0)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Primary performance metric for comparing node efficiency. Track throughput over time to identify degradation."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": If a node processes 1000 items in 500ms, throughput is 2000 items/sec."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": Can be null if ",(0,r.jsx)(n.code,{children:"DurationMs"})," is null or zero."]}),"\n",(0,r.jsx)(n.h4,{id:"threadid",children:"ThreadId"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"int?"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Thread ID that primarily processed this node"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": ",(0,r.jsx)(n.code,{children:"Environment.CurrentManagedThreadId"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Understand thread assignment in parallel execution scenarios. Identify thread affinity issues or thread pool contention."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Important Notes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"For single-threaded execution, this is the only thread used"}),"\n",(0,r.jsx)(n.li,{children:"For parallel execution, this is the thread that started execution"}),"\n",(0,r.jsx)(n.li,{children:"May be null if thread tracking is disabled"}),"\n",(0,r.jsx)(n.li,{children:"Thread IDs are process-specific and not meaningful across different executions"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"pipeline-metrics",children:"Pipeline Metrics"}),"\n",(0,r.jsx)(n.p,{children:"Pipeline metrics provide aggregate data for the entire pipeline execution, including summary statistics and individual node metrics."}),"\n",(0,r.jsx)(n.h3,{id:"ipipelinemetrics-interface",children:"IPipelineMetrics Interface"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public interface IPipelineMetrics\n{\n    string PipelineName { get; }\n    Guid RunId { get; }\n    DateTimeOffset StartTime { get; }\n    DateTimeOffset? EndTime { get; }\n    long? DurationMs { get; }\n    bool Success { get; }\n    long TotalItemsProcessed { get; }\n    IReadOnlyList<INodeMetrics> NodeMetrics { get; }\n    Exception? Exception { get; }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"pipeline-metrics-properties",children:"Pipeline Metrics Properties"}),"\n",(0,r.jsx)(n.h4,{id:"pipelinename",children:"PipelineName"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"string"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Name of the pipeline definition"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Pipeline definition type name or custom name"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": ",(0,r.jsx)(n.code,{children:'"DataProcessingPipeline"'})," or ",(0,r.jsx)(n.code,{children:'"ETLPipeline"'})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Correlate metrics with specific pipeline definitions. Useful when running multiple pipeline types in the same application."]}),"\n",(0,r.jsx)(n.h4,{id:"runid",children:"RunId"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"Guid"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Unique identifier for this pipeline execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Generated at pipeline start"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Uniqueness"}),": Globally unique across all executions"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Correlate all metrics from a single pipeline execution. Track executions across distributed systems or log aggregation tools."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": ",(0,r.jsx)(n.code,{children:"123e4567-e89b-12d3-a456-426614174000"})]}),"\n",(0,r.jsx)(n.h4,{id:"starttime-1",children:"StartTime"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"DateTimeOffset"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Timestamp when pipeline execution began"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Recorded at pipeline start"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resolution"}),": System clock precision"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Calculate pipeline duration and identify when pipelines started relative to each other."]}),"\n",(0,r.jsx)(n.h4,{id:"endtime-1",children:"EndTime"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"DateTimeOffset?"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Timestamp when pipeline execution completed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Recorded at pipeline completion"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resolution"}),": System clock precision"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Calculate pipeline duration. Can be null if the pipeline is still executing or if metrics collection failed."]}),"\n",(0,r.jsx)(n.h4,{id:"durationms-1",children:"DurationMs"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"long?"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Total pipeline execution time in milliseconds"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Calculated from ",(0,r.jsx)(n.code,{children:"StartTime"})," and ",(0,r.jsx)(n.code,{children:"EndTime"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Precision"}),": Millisecond"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"DurationMs = (long)(EndTime - StartTime).TotalMilliseconds\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Primary metric for overall pipeline performance. Track duration trends over time to identify degradation or improvements."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": Can be null if ",(0,r.jsx)(n.code,{children:"EndTime"})," is null."]}),"\n",(0,r.jsx)(n.h4,{id:"success-1",children:"Success"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"bool"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Whether the pipeline execution completed successfully"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Determined by exception presence"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),": ",(0,r.jsx)(n.code,{children:"true"})," if no exception occurred during pipeline execution, ",(0,r.jsx)(n.code,{children:"false"})," otherwise."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Track pipeline success rates and identify failure patterns. Filter metrics to analyze successful vs. failed executions."]}),"\n",(0,r.jsx)(n.h4,{id:"totalitemsprocessed",children:"TotalItemsProcessed"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"long"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Total number of items processed by all nodes in the pipeline"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Sum of all node ",(0,r.jsx)(n.code,{children:"ItemsProcessed"})," values"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Range"}),": 0 to ",(0,r.jsx)(n.code,{children:"long.MaxValue"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"TotalItemsProcessed = NodeMetrics.Sum(m => m.ItemsProcessed)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Measure pipeline throughput and processing volume. Compare with duration to calculate overall pipeline throughput."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Important Notes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"This is the sum across all nodes, not unique items"}),"\n",(0,r.jsx)(n.li,{children:"For pipelines with multiple nodes, this may be greater than the actual input count"}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"NodeMetrics[0].ItemsProcessed"})," for the actual input count (first node)"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"nodemetrics",children:"NodeMetrics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"IReadOnlyList<INodeMetrics>"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Collection of metrics for each node in the pipeline"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Collected during pipeline execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable collection)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Analyze individual node performance within the pipeline context. Identify bottlenecks and optimize specific nodes."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Access Patterns"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Get all node metrics\nvar allNodeMetrics = pipelineMetrics.NodeMetrics;\n\n// Find metrics for a specific node\nvar transformNodeMetrics = pipelineMetrics.NodeMetrics\n    .FirstOrDefault(m => m.NodeId == "TransformNode");\n\n// Find slowest node\nvar slowestNode = pipelineMetrics.NodeMetrics\n    .OrderByDescending(m => m.DurationMs)\n    .FirstOrDefault();\n\n// Calculate average node duration\nvar avgDuration = pipelineMetrics.NodeMetrics\n    .Where(m => m.DurationMs.HasValue)\n    .Average(m => m.DurationMs.Value);\n'})}),"\n",(0,r.jsx)(n.h4,{id:"exception-1",children:"Exception"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": ",(0,r.jsx)(n.code,{children:"Exception?"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description"}),": Exception that caused pipeline failure, if any"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Captured from execution context"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe"}),": Yes (immutable)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": Debug failed pipeline executions, identify error patterns, and track exception types. Use ",(0,r.jsx)(n.code,{children:"Exception.Message"})," for logging and ",(0,r.jsx)(n.code,{children:"Exception.StackTrace"})," for detailed debugging."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": Null if the pipeline executed successfully."]}),"\n",(0,r.jsx)(n.h2,{id:"metrics-calculation-details",children:"Metrics Calculation Details"}),"\n",(0,r.jsx)(n.h3,{id:"throughput-calculation",children:"Throughput Calculation"}),"\n",(0,r.jsx)(n.p,{children:"Throughput is calculated for each node based on items processed and execution duration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"ThroughputItemsPerSec = ItemsProcessed / (DurationMs / 1000.0)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"ItemsProcessed: 5000"}),"\n",(0,r.jsx)(n.li,{children:"DurationMs: 2500"}),"\n",(0,r.jsx)(n.li,{children:"ThroughputItemsPerSec: 5000 / (2500 / 1000) = 2000 items/sec"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Edge Cases"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"DurationMs"})," is null or zero, throughput is null"]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"ItemsProcessed"})," is zero, throughput is zero"]}),"\n",(0,r.jsx)(n.li,{children:"Throughput is calculated after node completion, not during execution"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"memory-usage-calculation",children:"Memory Usage Calculation"}),"\n",(0,r.jsxs)(n.p,{children:["Memory usage is measured as ",(0,r.jsx)(n.strong,{children:"per-node managed memory allocation deltas"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Initial memory at node start\nvar initialMemoryBytes = GC.GetTotalMemory(false);\n\n// ... node execution ...\n\n// Final memory at node end\nvar finalMemoryBytes = GC.GetTotalMemory(false);\n\n// Calculate delta (memory allocated during node execution)\nvar deltaBytes = finalMemoryBytes - initialMemoryBytes;\nvar memoryDeltaMb = deltaBytes / (1024 * 1024);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Important Considerations"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Memory is measured using ",(0,r.jsx)(n.code,{children:"GC.GetTotalMemory(false)"})," which captures managed memory allocations"]}),"\n",(0,r.jsxs)(n.li,{children:["This is a ",(0,r.jsx)(n.strong,{children:"per-node delta"}),", not global process memory or peak working set"]}),"\n",(0,r.jsx)(n.li,{children:"In parallel execution, each node gets its own isolated memory measurement"}),"\n",(0,r.jsx)(n.li,{children:"The delta represents memory allocated during that specific node's execution"}),"\n",(0,r.jsx)(n.li,{children:"Garbage collection may cause memory usage to fluctuate"}),"\n",(0,r.jsxs)(n.li,{children:["Memory metrics require both extension-level (",(0,r.jsx)(n.code,{children:"EnableMemoryMetrics"}),") and node-level (",(0,r.jsx)(n.code,{children:"RecordMemoryUsage"}),") options to be enabled"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"retry-count-calculation",children:"Retry Count Calculation"}),"\n",(0,r.jsx)(n.p,{children:"Retry count tracks the maximum retry attempt observed:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Uses Interlocked.Exchange to ensure maximum is retained\nRetryCount = Math.Max(currentRetryCount, newRetryCount)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Behavior"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If a node retries 3 times (attempts 1, 2, 3), ",(0,r.jsx)(n.code,{children:"RetryCount"})," will be 3"]}),"\n",(0,r.jsx)(n.li,{children:"If multiple retries occur with different reasons, only the count is retained"}),"\n",(0,r.jsx)(n.li,{children:"Retry reasons are not currently captured in metrics (see TODO in source)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"thread-safety-considerations",children:"Thread-Safety Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"concurrent-metrics-collection",children:"Concurrent Metrics Collection"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ObservabilityCollector"})," is designed for thread-safe operation:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"private readonly ConcurrentDictionary<string, NodeMetricsBuilder> _nodeMetrics = new();\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safety Guarantees"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Multiple nodes can record metrics simultaneously without race conditions"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ConcurrentDictionary"})," provides atomic operations for adding and updating entries"]}),"\n",(0,r.jsxs)(n.li,{children:["Each node has its own ",(0,r.jsx)(n.code,{children:"NodeMetricsBuilder"})," instance"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"atomic-counter-updates",children:"Atomic Counter Updates"}),"\n",(0,r.jsx)(n.p,{children:"Item counters use atomic operations for thread-safe increments:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public void RecordItemMetrics(long itemsProcessed, long itemsEmitted)\n{\n    Interlocked.Add(ref _itemsProcessed, itemsProcessed);\n    Interlocked.Add(ref _itemsEmitted, itemsEmitted);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safety Guarantees"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Interlocked.Add"})," ensures atomic addition without locks"]}),"\n",(0,r.jsx)(n.li,{children:"Multiple threads can increment counters simultaneously"}),"\n",(0,r.jsx)(n.li,{children:"No lost updates or race conditions"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"retry-count-updates",children:"Retry Count Updates"}),"\n",(0,r.jsx)(n.p,{children:"Retry count uses atomic exchange to retain the maximum:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public void RecordRetry(int retryCount)\n{\n    Interlocked.Exchange(ref _retryCount, Math.Max(_retryCount, retryCount));\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safety Guarantees"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Interlocked.Exchange"})," ensures atomic updates"]}),"\n",(0,r.jsx)(n.li,{children:"Maximum retry count is always retained"}),"\n",(0,r.jsx)(n.li,{children:"No race conditions when multiple retries occur"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"immutable-metric-records",children:"Immutable Metric Records"}),"\n",(0,r.jsx)(n.p,{children:"Once built, metric records are immutable:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public sealed record NodeMetrics(\n    string NodeId,\n    DateTimeOffset? StartTime,\n    // ... other properties\n) : INodeMetrics;\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safety Guarantees"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Records are immutable and safe to share across threads"}),"\n",(0,r.jsx)(n.li,{children:"No synchronization needed when reading built metrics"}),"\n",(0,r.jsx)(n.li,{children:"Safe to store in collections accessed by multiple threads"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"scoped-lifetime",children:"Scoped Lifetime"}),"\n",(0,r.jsx)(n.p,{children:"Collectors are scoped to ensure isolation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"services.TryAddScoped<IObservabilityCollector, ObservabilityCollector>();\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safety Guarantees"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each pipeline run gets its own collector instance"}),"\n",(0,r.jsx)(n.li,{children:"Concurrent pipeline runs don't interfere with each other"}),"\n",(0,r.jsx)(n.li,{children:"Metrics are automatically disposed when the scope ends"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"performance-metrics-interpretation",children:"Performance Metrics Interpretation"}),"\n",(0,r.jsx)(n.h3,{id:"identifying-bottlenecks",children:"Identifying Bottlenecks"}),"\n",(0,r.jsx)(n.p,{children:"Use node metrics to identify performance bottlenecks:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Find slowest nodes\nvar bottlenecks = pipelineMetrics.NodeMetrics\n    .Where(m => m.DurationMs.HasValue)\n    .OrderByDescending(m => m.DurationMs.Value)\n    .Take(3);\n\nforeach (var node in bottlenecks)\n{\n    Console.WriteLine($"{node.NodeId}: {node.DurationMs}ms, {node.ThroughputItemsPerSec} items/sec");\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"analyzing-throughput",children:"Analyzing Throughput"}),"\n",(0,r.jsx)(n.p,{children:"Compare throughput across nodes to understand efficiency:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Calculate throughput ratios\nvar throughputRatios = pipelineMetrics.NodeMetrics\n    .Where(m => m.ThroughputItemsPerSec.HasValue)\n    .Select(m => new\n    {\n        m.NodeId,\n        Throughput = m.ThroughputItemsPerSec.Value,\n        Ratio = m.ThroughputItemsPerSec.Value / pipelineMetrics.NodeMetrics[0].ThroughputItemsPerSec.Value\n    })\n    .OrderByDescending(m => m.Ratio);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"memory-efficiency-analysis",children:"Memory Efficiency Analysis"}),"\n",(0,r.jsx)(n.p,{children:"Identify memory-intensive nodes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Find nodes with high memory usage\nvar memoryIntensive = pipelineMetrics.NodeMetrics\n    .Where(m => m.PeakMemoryUsageMb.HasValue)\n    .OrderByDescending(m => m.PeakMemoryUsageMb.Value)\n    .Take(5);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"retry-pattern-analysis",children:"Retry Pattern Analysis"}),"\n",(0,r.jsx)(n.p,{children:"Identify unreliable nodes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Find nodes with high retry counts\nvar unreliableNodes = pipelineMetrics.NodeMetrics\n    .Where(m => m.RetryCount > 0)\n    .OrderByDescending(m => m.RetryCount);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/extensions/observability/",children:"Observability Overview"})}),": Introduction to observability features"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/extensions/observability/configuration",children:"Configuration Guide"})}),": Setup and configuration options"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/extensions/observability/examples",children:"Usage Examples"})}),": Complete code examples"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);