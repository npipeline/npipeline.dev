"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3099],{2417:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"analyzers/performance","title":"Performance Analyzers","description":"Identify blocking operations, non-streaming patterns, and async/await anti-patterns that harm performance.","source":"@site/docs/analyzers/performance.md","sourceDirName":"analyzers","slug":"/analyzers/performance","permalink":"/docs/analyzers/performance","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Performance Analyzers","description":"Identify blocking operations, non-streaming patterns, and async/await anti-patterns that harm performance.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Resilience Analyzers","permalink":"/docs/analyzers/resilience"},"next":{"title":"Data Processing Analyzers","permalink":"/docs/analyzers/data-processing"}}');var t=a(4848),r=a(8453);const o={title:"Performance Analyzers",description:"Identify blocking operations, non-streaming patterns, and async/await anti-patterns that harm performance.",sidebar_position:3},i=void 0,c={},l=[{value:"Performance Analyzers",id:"performance-analyzers",level:2},{value:"NP9102: Blocking Operations in Async Methods",id:"np9102-blocking-operations-in-async-methods",level:3},{value:"Why This Matters",id:"why-this-matters",level:4},{value:"Problematic Patterns",id:"problematic-patterns",level:4},{value:"Solution: Use await",id:"solution-use-await",level:4},{value:"NP9103: Swallowed OperationCanceledException",id:"np9103-swallowed-operationcanceledexception",level:3},{value:"Problematic Pattern",id:"problematic-pattern",level:4},{value:"Solution: Re-throw Cancellation",id:"solution-re-throw-cancellation",level:4},{value:"NP9104: Synchronous over Async Patterns",id:"np9104-synchronous-over-async-patterns",level:3},{value:"Problematic Sync-Over-Async Patterns",id:"problematic-sync-over-async-patterns",level:4},{value:"Solution: Always Await",id:"solution-always-await",level:4},{value:"NP9105: Cancellation Token Not Respected",id:"np9105-cancellation-token-not-respected",level:3},{value:"Problematic Cancellation Patterns",id:"problematic-cancellation-patterns",level:4},{value:"Solution: Check and Respect Cancellation",id:"solution-check-and-respect-cancellation",level:4},{value:"NP9209: Missing ValueTask Optimization",id:"np9209-missing-valuetask-optimization",level:3},{value:"Problem",id:"problem",level:4},{value:"Solution: Use ValueTask",id:"solution-use-valuetask",level:4},{value:"NP9211: Non-Streaming Patterns in SourceNode",id:"np9211-non-streaming-patterns-in-sourcenode",level:3},{value:"Best Practices for Performance",id:"best-practices-for-performance",level:2},{value:"Configuration",id:"configuration",level:2},{value:"See Also",id:"see-also",level:2}];function d(n){const e={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:"performance-analyzers",children:"Performance Analyzers"}),"\n",(0,t.jsx)(e.p,{children:"Performance analyzers detect patterns that harm throughput, increase latency, cause thread starvation, or prevent proper streaming of data. These violations directly contradict NPipeline's core mission of high-performance, non-blocking I/O."}),"\n",(0,t.jsx)(e.h3,{id:"np9102-blocking-operations-in-async-methods",children:"NP9102: Blocking Operations in Async Methods"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"ID:"})," ",(0,t.jsx)(e.code,{children:"NP9102"}),(0,t.jsx)(e.br,{}),"\n",(0,t.jsx)(e.strong,{children:"Severity:"})," Warning",(0,t.jsx)(e.br,{}),"\n",(0,t.jsx)(e.strong,{children:"Category:"})," Performance"]}),"\n",(0,t.jsx)(e.p,{children:"This analyzer detects blocking operations in async methods that can lead to deadlocks, thread pool starvation, and reduced performance. The analyzer identifies the following blocking patterns:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Task.Result and Task.Wait()"})," calls that block the current thread"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"GetAwaiter().GetResult()"})," patterns that synchronously wait for task completion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Thread.Sleep()"})," in async methods (should use Task.Delay instead)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Synchronous file I/O operations"})," (File.ReadAllText, File.WriteAllBytes, etc.)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Synchronous network I/O operations"})," (WebClient.DownloadString, unawaited HttpClient calls)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Unawaited StreamReader/Writer operations"})," (ReadToEnd, WriteLine without await)"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"why-this-matters",children:"Why This Matters"}),"\n",(0,t.jsx)(e.p,{children:"Blocking operations in async code:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Cause deadlocks"})," in certain synchronization contexts (UI threads, ASP.NET Classic)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Starve the thread pool"})," by blocking threads that should be available for other work"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Reduce scalability"})," because you can only handle as many concurrent operations as you have threads"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Increase latency"})," because blocked threads can't process other work"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Contradict async design"})," and defeat the purpose of asynchronous I/O"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"problematic-patterns",children:"Problematic Patterns"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'// \u274c PROBLEM: Blocking on Task.Result\npublic async Task<string> ProcessDataAsync()\n{\n    var task = SomeOperationAsync();\n    return task.Result; // NP9102: Blocks until task completes\n}\n\n// \u274c PROBLEM: Blocking on Task.Wait()\npublic async Task ProcessDataAsync()\n{\n    var task = SomeOperationAsync();\n    task.Wait(); // NP9102: Blocks until task completes\n}\n\n// \u274c PROBLEM: Using GetAwaiter().GetResult()\npublic async Task<string> ProcessDataAsync()\n{\n    var task = SomeOperationAsync();\n    return task.GetAwaiter().GetResult(); // NP9102: Synchronous blocking\n}\n\n// \u274c PROBLEM: Synchronous I/O in async method\npublic async Task ProcessFileAsync()\n{\n    var content = File.ReadAllText("file.txt"); // NP9102: Synchronous I/O\n    await ProcessAsync(content);\n}\n\n// \u274c PROBLEM: Thread.Sleep instead of Task.Delay\npublic async Task WaitAsync()\n{\n    Thread.Sleep(1000); // NP9102: Blocks the thread\n    await ContinueAsync();\n}\n'})}),"\n",(0,t.jsx)(e.h4,{id:"solution-use-await",children:"Solution: Use await"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'// \u2705 CORRECT: Use await\npublic async Task<string> ProcessDataAsync()\n{\n    var task = SomeOperationAsync();\n    return await task; // Properly awaits without blocking\n}\n\n// \u2705 CORRECT: Use async I/O\npublic async Task ProcessFileAsync()\n{\n    var content = await File.ReadAllTextAsync("file.txt"); // Async I/O\n    await ProcessAsync(content);\n}\n\n// \u2705 CORRECT: Use Task.Delay\npublic async Task WaitAsync()\n{\n    await Task.Delay(1000); // Non-blocking delay\n    await ContinueAsync();\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"np9103-swallowed-operationcanceledexception",children:"NP9103: Swallowed OperationCanceledException"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"ID:"})," ",(0,t.jsx)(e.code,{children:"NP9103"}),(0,t.jsx)(e.br,{}),"\n",(0,t.jsx)(e.strong,{children:"Severity:"})," Warning",(0,t.jsx)(e.br,{}),"\n",(0,t.jsx)(e.strong,{children:"Category:"})," Performance"]}),"\n",(0,t.jsxs)(e.p,{children:["This analyzer detects when ",(0,t.jsx)(e.code,{children:"OperationCanceledException"})," is caught but not re-thrown. Swallowing cancellation exceptions breaks the cancellation contract and causes the pipeline to continue processing when it should stop."]}),"\n",(0,t.jsx)(e.h4,{id:"problematic-pattern",children:"Problematic Pattern"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'// \u274c PROBLEM: Swallowing OperationCanceledException\npublic async Task ProcessAsync(CancellationToken cancellationToken)\n{\n    try\n    {\n        await SomeOperationAsync(cancellationToken);\n    }\n    catch (OperationCanceledException)\n    {\n        // NP9103: Silently swallowing cancellation\n        Console.WriteLine("Operation cancelled");\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h4,{id:"solution-re-throw-cancellation",children:"Solution: Re-throw Cancellation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:"// \u2705 CORRECT: Re-throw cancellation exception\npublic async Task ProcessAsync(CancellationToken cancellationToken)\n{\n    try\n    {\n        await SomeOperationAsync(cancellationToken);\n    }\n    catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)\n    {\n        throw; // Re-throw to propagate cancellation\n    }\n    catch (OperationCanceledException)\n    {\n        // Handle other cancellation scenarios\n        throw;\n    }\n}\n\n// \u2705 ALTERNATIVE: Handle other exceptions only\npublic async Task ProcessAsync(CancellationToken cancellationToken)\n{\n    try\n    {\n        await SomeOperationAsync(cancellationToken);\n    }\n    catch (Exception ex) when (!(ex is OperationCanceledException))\n    {\n        // Handle non-cancellation exceptions\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"np9104-synchronous-over-async-patterns",children:"NP9104: Synchronous over Async Patterns"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"ID:"})," ",(0,t.jsx)(e.code,{children:"NP9104"}),(0,t.jsx)(e.br,{}),"\n",(0,t.jsx)(e.strong,{children:"Severity:"})," Warning",(0,t.jsx)(e.br,{}),"\n",(0,t.jsx)(e.strong,{children:"Category:"})," Performance"]}),"\n",(0,t.jsx)(e.p,{children:'This analyzer detects "sync-over-async" patterns like unawaited async method calls or fire-and-forget operations. These patterns create unpredictable behavior and make it impossible to wait for completion or handle errors.'}),"\n",(0,t.jsx)(e.h4,{id:"problematic-sync-over-async-patterns",children:"Problematic Sync-Over-Async Patterns"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:"// \u274c PROBLEM: Fire-and-forget async call (unawaited)\npublic async Task ProcessDataAsync()\n{\n    SomeOperationAsync(); // NP9104: Async method not awaited\n    DoSomethingElse();\n}\n\n// \u274c PROBLEM: Async method called from sync method\npublic void ProcessData()\n{\n    var result = SomeOperationAsync(); // NP9104: Async method not awaited\n}\n\n// \u274c PROBLEM: Task.Run wrapping sync work\npublic async Task ProcessDataAsync()\n{\n    var result = await Task.Run(() => \n    {\n        return SomeSynchronousOperation(); // NP9104: Unnecessary Task.Run\n    });\n}\n"})}),"\n",(0,t.jsx)(e.h4,{id:"solution-always-await",children:"Solution: Always Await"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:"// \u2705 CORRECT: Await the async call\npublic async Task ProcessDataAsync()\n{\n    await SomeOperationAsync(); // Properly awaited\n    DoSomethingElse();\n}\n\n// \u2705 CORRECT: Make calling method async\npublic async Task ProcessDataAsync()\n{\n    var result = await SomeOperationAsync(); // Properly awaited\n}\n\n// \u2705 CORRECT: Call sync methods directly\npublic async Task ProcessDataAsync()\n{\n    var result = SomeSynchronousOperation(); // Direct call, no Task.Run\n    await ProcessResultAsync(result);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"np9105-cancellation-token-not-respected",children:"NP9105: Cancellation Token Not Respected"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"ID:"})," ",(0,t.jsx)(e.code,{children:"NP9105"}),(0,t.jsx)(e.br,{}),"\n",(0,t.jsx)(e.strong,{children:"Severity:"})," Warning",(0,t.jsx)(e.br,{}),"\n",(0,t.jsx)(e.strong,{children:"Category:"})," Performance"]}),"\n",(0,t.jsx)(e.p,{children:"This analyzer detects when a cancellation token is not checked or respected in long-running operations. When you receive a cancellation token, you must check it periodically and propagate cancellation requests."}),"\n",(0,t.jsx)(e.h4,{id:"problematic-cancellation-patterns",children:"Problematic Cancellation Patterns"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:"// \u274c PROBLEM: Not checking cancellation token in loop\npublic async Task ProcessItemsAsync(IEnumerable<Item> items, CancellationToken cancellationToken)\n{\n    foreach (var item in items)\n    {\n        // NP9105: Not checking cancellation token\n        await ProcessItemAsync(item);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h4,{id:"solution-check-and-respect-cancellation",children:"Solution: Check and Respect Cancellation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:"// \u2705 CORRECT: Check cancellation token before processing\npublic async Task ProcessItemsAsync(IEnumerable<Item> items, CancellationToken cancellationToken)\n{\n    foreach (var item in items)\n    {\n        cancellationToken.ThrowIfCancellationRequested();\n        await ProcessItemAsync(item, cancellationToken);\n    }\n}\n\n// \u2705 CORRECT: Pass token to async operations\npublic async Task ProcessItemsAsync(IEnumerable<Item> items, CancellationToken cancellationToken)\n{\n    await foreach (var item in GetItemsAsync(cancellationToken))\n    {\n        await ProcessItemAsync(item, cancellationToken);\n    }\n}\n\nprivate async IAsyncEnumerable<Item> GetItemsAsync([EnumeratorCancellation] CancellationToken cancellationToken)\n{\n    foreach (var item in _items)\n    {\n        cancellationToken.ThrowIfCancellationRequested();\n        yield return item;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"np9209-missing-valuetask-optimization",children:"NP9209: Missing ValueTask Optimization"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"ID:"})," ",(0,t.jsx)(e.code,{children:"NP9209"}),(0,t.jsx)(e.br,{}),"\n",(0,t.jsx)(e.strong,{children:"Severity:"})," Warning",(0,t.jsx)(e.br,{}),"\n",(0,t.jsx)(e.strong,{children:"Category:"})," Performance"]}),"\n",(0,t.jsxs)(e.p,{children:["This analyzer detects cases where a method frequently completes synchronously but returns ",(0,t.jsx)(e.code,{children:"Task"})," instead of ",(0,t.jsx)(e.code,{children:"ValueTask"}),". Using ",(0,t.jsx)(e.code,{children:"ValueTask"})," avoids heap allocations when the result is available synchronously, which is critical for high-throughput pipeline performance."]}),"\n",(0,t.jsx)(e.h4,{id:"problem",children:"Problem"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:"// \u274c PROBLEM: Allocates heap object even for synchronous completions\npublic async Task<string> GetDataAsync(string id)\n{\n    var cached = _cache.Get(id);\n    if (cached != null)\n    {\n        return cached; // Allocates Task on heap\n    }\n    \n    return await FetchFromDatabaseAsync(id);\n}\n"})}),"\n",(0,t.jsx)(e.h4,{id:"solution-use-valuetask",children:"Solution: Use ValueTask"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:"// \u2705 CORRECT: No allocation for synchronous returns\npublic async ValueTask<string> GetDataAsync(string id)\n{\n    var cached = _cache.Get(id);\n    if (cached != null)\n    {\n        return cached; // No allocation - synchronous completion\n    }\n    \n    return await FetchFromDatabaseAsync(id);\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Important:"})," ValueTask comes with critical constraints that you must understand to avoid subtle bugs. For complete implementation guidance, including dangerous constraints and real-world examples, see ",(0,t.jsx)(e.a,{href:"/docs/advanced-topics/synchronous-fast-paths",children:(0,t.jsx)(e.strong,{children:"Synchronous Fast Paths and ValueTask Optimization"})}),"\u2014the dedicated deep-dive guide that covers the complete pattern and critical safety considerations."]}),"\n",(0,t.jsx)(e.h3,{id:"np9211-non-streaming-patterns-in-sourcenode",children:"NP9211: Non-Streaming Patterns in SourceNode"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"ID:"})," ",(0,t.jsx)(e.code,{children:"NP9211"}),(0,t.jsx)(e.br,{}),"\n",(0,t.jsx)(e.strong,{children:"Severity:"})," Warning",(0,t.jsx)(e.br,{}),"\n",(0,t.jsx)(e.strong,{children:"Category:"})," Performance"]}),"\n",(0,t.jsxs)(e.p,{children:["This analyzer detects non-streaming patterns in SourceNode implementations that can lead to memory issues and poor performance. See the ",(0,t.jsx)(e.a,{href:"/docs/analyzers/data-processing",children:"Data Processing Analyzers"})," section for detailed information about this analyzer."]}),"\n",(0,t.jsx)(e.h2,{id:"best-practices-for-performance",children:"Best Practices for Performance"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Always use await"})," - Never block on async code with .Result, .Wait(), or .GetResult()"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Respect cancellation tokens"})," - Check them frequently and pass them to all async operations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Never swallow OperationCanceledException"})," - Always re-throw or handle it appropriately"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Use ValueTask for sync-heavy paths"})," - Avoid unnecessary allocations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Use async all the way down"})," - Don't mix sync and async code"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Use ConfigureAwait(false) in library code"})," - Improves performance and prevents deadlocks"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsxs)(e.p,{children:["Adjust analyzer severity in ",(0,t.jsx)(e.code,{children:".editorconfig"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ini",children:"# Treat blocking operations as errors\ndotnet_diagnostic.NP9102.severity = error\n\n# Treat swallowed cancellation as errors\ndotnet_diagnostic.NP9103.severity = error\n\n# Treat fire-and-forget async as errors\ndotnet_diagnostic.NP9104.severity = error\n\n# Treat ignored cancellation tokens as errors\ndotnet_diagnostic.NP9105.severity = error\n\n# Treat missing ValueTask optimization as warnings\ndotnet_diagnostic.NP9209.severity = warning\n\n# Treat non-streaming patterns as errors\ndotnet_diagnostic.NP9211.severity = error\n"})}),"\n",(0,t.jsx)(e.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Hygiene"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"/docs/advanced-topics/synchronous-fast-paths",children:"Synchronous Fast Paths"})}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>o,x:()=>i});var s=a(6540);const t={},r=s.createContext(t);function o(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);