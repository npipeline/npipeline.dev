"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3099],{2417:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"analyzers/performance","title":"Performance Analyzers","description":"Identify blocking operations, non-streaming patterns, and async/await anti-patterns that harm performance.","source":"@site/docs/analyzers/performance.md","sourceDirName":"analyzers","slug":"/analyzers/performance","permalink":"/docs/analyzers/performance","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Performance Analyzers","description":"Identify blocking operations, non-streaming patterns, and async/await anti-patterns that harm performance.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Resilience Analyzers","permalink":"/docs/analyzers/resilience"},"next":{"title":"Data Processing Analyzers","permalink":"/docs/analyzers/data-processing"}}');var a=t(4848),r=t(8453);const i={title:"Performance Analyzers",description:"Identify blocking operations, non-streaming patterns, and async/await anti-patterns that harm performance.",sidebar_position:3},o=void 0,c={},l=[{value:"Performance Analyzers",id:"performance-analyzers",level:2},{value:"NP9101: Blocking Operations in Async Methods",id:"np9101-blocking-operations-in-async-methods",level:3},{value:"Why This Matters",id:"why-this-matters",level:4},{value:"Problematic Patterns",id:"problematic-patterns",level:4},{value:"Solution: Use await",id:"solution-use-await",level:4},{value:"NP9102: Swallowed OperationCanceledException",id:"np9102-swallowed-operationcanceledexception",level:3},{value:"Problematic Pattern",id:"problematic-pattern",level:4},{value:"Solution: Re-throw Cancellation",id:"solution-re-throw-cancellation",level:4},{value:"NP9103: Synchronous over Async Patterns",id:"np9103-synchronous-over-async-patterns",level:3},{value:"Problematic Sync-Over-Async Patterns",id:"problematic-sync-over-async-patterns",level:4},{value:"Solution: Always Await",id:"solution-always-await",level:4},{value:"NP9104: Cancellation Token Not Respected",id:"np9104-cancellation-token-not-respected",level:3},{value:"Problematic Cancellation Patterns",id:"problematic-cancellation-patterns",level:4},{value:"Solution: Check and Respect Cancellation",id:"solution-check-and-respect-cancellation",level:4},{value:"NP9204: Missing ValueTask Optimization",id:"np9204-missing-valuetask-optimization",level:3},{value:"Problem",id:"problem",level:4},{value:"Solution: Use ValueTask",id:"solution-use-valuetask",level:4},{value:"NP9201: LINQ Operations in Hot Paths",id:"np9201-linq-operations-in-hot-paths",level:3},{value:"Why This Matters",id:"why-this-matters-1",level:4},{value:"Problematic Patterns",id:"problematic-patterns-1",level:4},{value:"Solution: Use Imperative Alternatives",id:"solution-use-imperative-alternatives",level:4},{value:"LINQ Alternatives Guidelines",id:"linq-alternatives-guidelines",level:4},{value:"NP9202: Inefficient String Operations",id:"np9202-inefficient-string-operations",level:3},{value:"Why This Matters",id:"why-this-matters-2",level:4},{value:"Problematic Patterns",id:"problematic-patterns-2",level:4},{value:"Solution: Use Efficient String Operations",id:"solution-use-efficient-string-operations",level:4},{value:"String Operation Guidelines",id:"string-operation-guidelines",level:4},{value:"NP9203: Anonymous Object Allocation",id:"np9203-anonymous-object-allocation",level:3},{value:"Why This Matters",id:"why-this-matters-3",level:4},{value:"Problematic Patterns",id:"problematic-patterns-3",level:4},{value:"Solution: Use Named Types or Value Types",id:"solution-use-named-types-or-value-types",level:4},{value:"Anonymous Object Alternatives",id:"anonymous-object-alternatives",level:4},{value:"NP9205: Non-Streaming Patterns in SourceNode",id:"np9205-non-streaming-patterns-in-sourcenode",level:3},{value:"Best Practices for Performance",id:"best-practices-for-performance",level:2},{value:"Configuration",id:"configuration",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"performance-analyzers",children:"Performance Analyzers"}),"\n",(0,a.jsx)(n.p,{children:"Performance analyzers detect patterns that harm throughput, increase latency, cause thread starvation, or prevent proper streaming of data. These violations directly contradict NPipeline's core mission of high-performance, non-blocking I/O."}),"\n",(0,a.jsx)(n.h3,{id:"np9101-blocking-operations-in-async-methods",children:"NP9101: Blocking Operations in Async Methods"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"ID:"})," ",(0,a.jsx)(n.code,{children:"NP9101"}),"\n",(0,a.jsx)(n.strong,{children:"Severity:"})," Warning",(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.strong,{children:"Category:"})," Performance"]}),"\n",(0,a.jsx)(n.p,{children:"This analyzer detects blocking operations in async methods that can lead to deadlocks, thread pool starvation, and reduced performance. The analyzer identifies the following blocking patterns:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Task.Result and Task.Wait()"})," calls that block the current thread"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"GetAwaiter().GetResult()"})," patterns that synchronously wait for task completion"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Thread.Sleep()"})," in async methods (should use Task.Delay instead)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Synchronous file I/O operations"})," (File.ReadAllText, File.WriteAllBytes, etc.)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Synchronous network I/O operations"})," (WebClient.DownloadString, unawaited HttpClient calls)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Unawaited StreamReader/Writer operations"})," (ReadToEnd, WriteLine without await)"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"why-this-matters",children:"Why This Matters"}),"\n",(0,a.jsx)(n.p,{children:"Blocking operations in async code:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cause deadlocks"})," in certain synchronization contexts (UI threads, ASP.NET Classic)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Starve the thread pool"})," by blocking threads that should be available for other work"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reduce scalability"})," because you can only handle as many concurrent operations as you have threads"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Increase latency"})," because blocked threads can't process other work"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Contradict async design"})," and defeat the purpose of asynchronous I/O"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"problematic-patterns",children:"Problematic Patterns"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// \u274c PROBLEM: Blocking on Task.Result\npublic async Task<string> ProcessDataAsync()\n{\n    var task = SomeOperationAsync();\n    return task.Result; // NP9101: Blocks until task completes\n}\n\n// \u274c PROBLEM: Blocking on Task.Wait()\npublic async Task ProcessDataAsync()\n{\n    var task = SomeOperationAsync();\n    task.Wait(); // NP9101: Blocks until task completes\n}\n\n// \u274c PROBLEM: Using GetAwaiter().GetResult()\npublic async Task<string> ProcessDataAsync()\n{\n    var task = SomeOperationAsync();\n    return task.GetAwaiter().GetResult(); // NP9101: Synchronous blocking\n}\n\n// \u274c PROBLEM: Synchronous I/O in async method\npublic async Task ProcessFileAsync()\n{\n    var content = File.ReadAllText("file.txt"); // NP9101: Synchronous I/O\n    await ProcessAsync(content);\n}\n\n// \u274c PROBLEM: Thread.Sleep instead of Task.Delay\npublic async Task WaitAsync()\n{\n    Thread.Sleep(1000); // NP9101: Blocks the thread\n    await ContinueAsync();\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"solution-use-await",children:"Solution: Use await"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// \u2705 CORRECT: Use await\npublic async Task<string> ProcessDataAsync()\n{\n    var task = SomeOperationAsync();\n    return await task; // Properly awaits without blocking\n}\n\n// \u2705 CORRECT: Use async I/O\npublic async Task ProcessFileAsync()\n{\n    var content = await File.ReadAllTextAsync("file.txt"); // Async I/O\n    await ProcessAsync(content);\n}\n\n// \u2705 CORRECT: Use Task.Delay\npublic async Task WaitAsync()\n{\n    await Task.Delay(1000); // Non-blocking delay\n    await ContinueAsync();\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"np9102-swallowed-operationcanceledexception",children:"NP9102: Swallowed OperationCanceledException"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"ID:"})," ",(0,a.jsx)(n.code,{children:"NP9102"}),"\n",(0,a.jsx)(n.strong,{children:"Severity:"})," Warning",(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.strong,{children:"Category:"})," Performance"]}),"\n",(0,a.jsxs)(n.p,{children:["This analyzer detects when ",(0,a.jsx)(n.code,{children:"OperationCanceledException"})," is caught but not re-thrown. Swallowing cancellation exceptions breaks the cancellation contract and causes the pipeline to continue processing when it should stop."]}),"\n",(0,a.jsx)(n.h4,{id:"problematic-pattern",children:"Problematic Pattern"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// \u274c PROBLEM: Swallowing OperationCanceledException\npublic async Task ProcessAsync(CancellationToken cancellationToken)\n{\n    try\n    {\n        await SomeOperationAsync(cancellationToken);\n    }\n    catch (OperationCanceledException)\n    {\n        // NP9102: Silently swallowing cancellation\n        Console.WriteLine("Operation cancelled");\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"solution-re-throw-cancellation",children:"Solution: Re-throw Cancellation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u2705 CORRECT: Re-throw cancellation exception\npublic async Task ProcessAsync(CancellationToken cancellationToken)\n{\n    try\n    {\n        await SomeOperationAsync(cancellationToken);\n    }\n    catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)\n    {\n        throw; // Re-throw to propagate cancellation\n    }\n    catch (OperationCanceledException)\n    {\n        // Handle other cancellation scenarios\n        throw;\n    }\n}\n\n// \u2705 ALTERNATIVE: Handle other exceptions only\npublic async Task ProcessAsync(CancellationToken cancellationToken)\n{\n    try\n    {\n        await SomeOperationAsync(cancellationToken);\n    }\n    catch (Exception ex) when (!(ex is OperationCanceledException))\n    {\n        // Handle non-cancellation exceptions\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"np9103-synchronous-over-async-patterns",children:"NP9103: Synchronous over Async Patterns"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"ID:"})," ",(0,a.jsx)(n.code,{children:"NP9103"}),"\n",(0,a.jsx)(n.strong,{children:"Severity:"})," Warning",(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.strong,{children:"Category:"})," Performance"]}),"\n",(0,a.jsx)(n.p,{children:'This analyzer detects "sync-over-async" patterns like unawaited async method calls or fire-and-forget operations. These patterns create unpredictable behavior and make it impossible to wait for completion or handle errors.'}),"\n",(0,a.jsx)(n.h4,{id:"problematic-sync-over-async-patterns",children:"Problematic Sync-Over-Async Patterns"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u274c PROBLEM: Fire-and-forget async call (unawaited)\npublic async Task ProcessDataAsync()\n{\n    SomeOperationAsync(); // NP9103: Async method not awaited\n    DoSomethingElse();\n}\n\n// \u274c PROBLEM: Async method called from sync method\npublic void ProcessData()\n{\n    var result = SomeOperationAsync(); // NP9103: Async method not awaited\n}\n\n// \u274c PROBLEM: Task.Run wrapping sync work\npublic async Task ProcessDataAsync()\n{\n    var result = await Task.Run(() => \n    {\n        return SomeSynchronousOperation(); // NP9103: Unnecessary Task.Run\n    });\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"solution-always-await",children:"Solution: Always Await"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u2705 CORRECT: Await the async call\npublic async Task ProcessDataAsync()\n{\n    await SomeOperationAsync(); // Properly awaited\n    DoSomethingElse();\n}\n\n// \u2705 CORRECT: Make calling method async\npublic async Task ProcessDataAsync()\n{\n    var result = await SomeOperationAsync(); // Properly awaited\n}\n\n// \u2705 CORRECT: Call sync methods directly\npublic async Task ProcessDataAsync()\n{\n    var result = SomeSynchronousOperation(); // Direct call, no Task.Run\n    await ProcessResultAsync(result);\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"np9104-cancellation-token-not-respected",children:"NP9104: Cancellation Token Not Respected"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"ID:"})," ",(0,a.jsx)(n.code,{children:"NP9104"}),"\n",(0,a.jsx)(n.strong,{children:"Severity:"})," Warning",(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.strong,{children:"Category:"})," Performance"]}),"\n",(0,a.jsx)(n.p,{children:"This analyzer detects when a cancellation token is not checked or respected in long-running operations. When you receive a cancellation token, you must check it periodically and propagate cancellation requests."}),"\n",(0,a.jsx)(n.h4,{id:"problematic-cancellation-patterns",children:"Problematic Cancellation Patterns"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u274c PROBLEM: Not checking cancellation token in loop\npublic async Task ProcessItemsAsync(IEnumerable<Item> items, CancellationToken cancellationToken)\n{\n    foreach (var item in items)\n    {\n        // NP9104: Not checking cancellation token\n        await ProcessItemAsync(item);\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"solution-check-and-respect-cancellation",children:"Solution: Check and Respect Cancellation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u2705 CORRECT: Check cancellation token before processing\npublic async Task ProcessItemsAsync(IEnumerable<Item> items, CancellationToken cancellationToken)\n{\n    foreach (var item in items)\n    {\n        cancellationToken.ThrowIfCancellationRequested();\n        await ProcessItemAsync(item, cancellationToken);\n    }\n}\n\n// \u2705 CORRECT: Pass token to async operations\npublic async Task ProcessItemsAsync(IEnumerable<Item> items, CancellationToken cancellationToken)\n{\n    await foreach (var item in GetItemsAsync(cancellationToken))\n    {\n        await ProcessItemAsync(item, cancellationToken);\n    }\n}\n\nprivate async IAsyncEnumerable<Item> GetItemsAsync([EnumeratorCancellation] CancellationToken cancellationToken)\n{\n    foreach (var item in _items)\n    {\n        cancellationToken.ThrowIfCancellationRequested();\n        yield return item;\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"np9204-missing-valuetask-optimization",children:"NP9204: Missing ValueTask Optimization"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"ID:"})," ",(0,a.jsx)(n.code,{children:"NP9204"}),"\n",(0,a.jsx)(n.strong,{children:"Severity:"})," Warning",(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.strong,{children:"Category:"})," Performance"]}),"\n",(0,a.jsxs)(n.p,{children:["This analyzer detects cases where a method frequently completes synchronously but returns ",(0,a.jsx)(n.code,{children:"Task"})," instead of ",(0,a.jsx)(n.code,{children:"ValueTask"}),". Using ",(0,a.jsx)(n.code,{children:"ValueTask"})," avoids heap allocations when the result is available synchronously, which is critical for high-throughput pipeline performance."]}),"\n",(0,a.jsx)(n.h4,{id:"problem",children:"Problem"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u274c PROBLEM: Allocates heap object even for synchronous completions\npublic async Task<string> GetDataAsync(string id)\n{\n    var cached = _cache.Get(id);\n    if (cached != null)\n    {\n        return cached; // Allocates Task on heap\n    }\n    \n    return await FetchFromDatabaseAsync(id);\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"solution-use-valuetask",children:"Solution: Use ValueTask"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u2705 CORRECT: No allocation for synchronous returns\npublic async ValueTask<string> GetDataAsync(string id)\n{\n    var cached = _cache.Get(id);\n    if (cached != null)\n    {\n        return cached; // No allocation - synchronous completion\n    }\n    \n    return await FetchFromDatabaseAsync(id);\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Important:"})," ValueTask comes with critical constraints that you must understand to avoid subtle bugs. For complete implementation guidance, including dangerous constraints and real-world examples, see ",(0,a.jsx)(n.a,{href:"/docs/advanced-topics/synchronous-fast-paths",children:(0,a.jsx)(n.strong,{children:"Synchronous Fast Paths and ValueTask Optimization"})}),"\u2014the dedicated deep-dive guide that covers the complete pattern and critical safety considerations."]}),"\n",(0,a.jsx)(n.h3,{id:"np9201-linq-operations-in-hot-paths",children:"NP9201: LINQ Operations in Hot Paths"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"ID:"})," ",(0,a.jsx)(n.code,{children:"NP9201"}),"\n",(0,a.jsx)(n.strong,{children:"Severity:"})," Warning\n",(0,a.jsx)(n.strong,{children:"Category:"})," Performance"]}),"\n",(0,a.jsx)(n.p,{children:"This analyzer detects LINQ operations in high-frequency execution paths that cause unnecessary allocations and GC pressure, significantly impacting performance in high-throughput NPipeline scenarios."}),"\n",(0,a.jsx)(n.h4,{id:"why-this-matters-1",children:"Why This Matters"}),"\n",(0,a.jsx)(n.p,{children:"LINQ in hot paths causes:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Excessive Allocations"}),": Each LINQ operation creates intermediate collections"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"GC Pressure"}),": Frequent garbage collection reduces throughput"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Poor Performance"}),": Overhead of delegates and iterators"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory Fragmentation"}),": Many small objects fragment the heap"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"problematic-patterns-1",children:"Problematic Patterns"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u274c PROBLEM: LINQ in ExecuteAsync method\npublic class BadTransform : ITransformNode<Input, Output>\n{\n    protected override async Task<Output> ExecuteAsync(Input input, PipelineContext context, CancellationToken cancellationToken)\n    {\n        // NP9201: LINQ in hot path creates allocations\n        var filtered = input.Items.Where(x => x.IsActive).ToList();\n        var sorted = filtered.OrderBy(x => x.Priority).ToList();\n        var grouped = sorted.GroupBy(x => x.Category).ToList();\n        \n        return new Output(grouped);\n    }\n}\n\n// \u274c PROBLEM: LINQ in loop\nforeach (var batch in batches)\n{\n    // NP9201: LINQ inside loop creates pressure\n    var processed = batch.Select(x => ProcessItem(x)).Where(x => x != null).ToList();\n    await SendBatchAsync(processed);\n}\n\n// \u274c PROBLEM: Materializing LINQ results\nvar items = sourceData.Where(x => x.IsValid).Select(x => x.Transform()).ToArray(); // NP9201: Immediate materialization\n"})}),"\n",(0,a.jsx)(n.h4,{id:"solution-use-imperative-alternatives",children:"Solution: Use Imperative Alternatives"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u2705 CORRECT: Use imperative processing\npublic class GoodTransform : ITransformNode<Input, Output>\n{\n    protected override async Task<Output> ExecuteAsync(Input input, PipelineContext context, CancellationToken cancellationToken)\n    {\n        var filtered = new List<Item>();\n        foreach (var item in input.Items)\n        {\n            if (item.IsActive)\n                filtered.Add(item);\n        }\n        \n        filtered.Sort((x, y) => x.Priority.CompareTo(y.Priority));\n        \n        var grouped = new Dictionary<string, List<Item>>();\n        foreach (var item in filtered)\n        {\n            if (!grouped.ContainsKey(item.Category))\n                grouped[item.Category] = new List<Item>();\n            grouped[item.Category].Add(item);\n        }\n        \n        return new Output(grouped.Values.ToList());\n    }\n}\n\n// \u2705 CORRECT: Process items directly in loop\nforeach (var batch in batches)\n{\n    var processed = new List<Item>();\n    foreach (var item in batch)\n    {\n        var result = ProcessItem(item);\n        if (result != null)\n            processed.Add(result);\n    }\n    await SendBatchAsync(processed);\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"linq-alternatives-guidelines",children:"LINQ Alternatives Guidelines"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"LINQ Operation"}),(0,a.jsx)(n.th,{children:"Imperative Alternative"}),(0,a.jsx)(n.th,{children:"Performance Benefit"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Where()"}),(0,a.jsx)(n.td,{children:"foreach with if"}),(0,a.jsx)(n.td,{children:"No intermediate collection"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Select()"}),(0,a.jsx)(n.td,{children:"foreach with transformation"}),(0,a.jsx)(n.td,{children:"No delegate overhead"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"OrderBy()"}),(0,a.jsx)(n.td,{children:"Sort() with comparer"}),(0,a.jsx)(n.td,{children:"In-place sorting"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"GroupBy()"}),(0,a.jsx)(n.td,{children:"Dictionary grouping"}),(0,a.jsx)(n.td,{children:"Direct grouping"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"ToList()/ToArray()"}),(0,a.jsx)(n.td,{children:"Pre-sized collection"}),(0,a.jsx)(n.td,{children:"No resizing"})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"np9202-inefficient-string-operations",children:"NP9202: Inefficient String Operations"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"ID:"})," ",(0,a.jsx)(n.code,{children:"NP9202"}),"\n",(0,a.jsx)(n.strong,{children:"Severity:"})," Warning\n",(0,a.jsx)(n.strong,{children:"Category:"})," Performance"]}),"\n",(0,a.jsx)(n.p,{children:"This analyzer detects inefficient string operations that cause excessive allocations and GC pressure in performance-critical NPipeline code, particularly in high-throughput scenarios."}),"\n",(0,a.jsx)(n.h4,{id:"why-this-matters-2",children:"Why This Matters"}),"\n",(0,a.jsx)(n.p,{children:"Inefficient string operations cause:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory Pressure"}),": Excessive allocations increase GC frequency"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Poor Performance"}),": String operations are expensive in hot paths"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reduced Throughput"}),": Time spent on string operations reduces processing capacity"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Scalability Issues"}),": Performance degrades with increased load"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"problematic-patterns-2",children:"Problematic Patterns"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// \u274c PROBLEM: String concatenation in loop\npublic class BadTransform : ITransformNode<Input, Output>\n{\n    protected override async Task<Output> ExecuteAsync(Input input, PipelineContext context, CancellationToken cancellationToken)\n    {\n        string result = "";\n        foreach (var item in input.Items) // NP9202: Concatenation in loop\n        {\n            result += item.ToString(); // Creates new string each iteration\n        }\n        return new Output(result);\n    }\n}\n\n// \u274c PROBLEM: Inefficient string formatting\nprotected override async Task<string> ProcessAsync(Data data, CancellationToken cancellationToken)\n{\n    return string.Format("{0}-{1}-{2}", data.Id, data.Name, data.Value); // NP9202: Inefficient formatting\n}\n\n// \u274c PROBLEM: String operations in LINQ\nvar results = items.Select(x => x.Name.ToUpper().Substring(0, 5).Trim()); // NP9202: Multiple allocations per item\n'})}),"\n",(0,a.jsx)(n.h4,{id:"solution-use-efficient-string-operations",children:"Solution: Use Efficient String Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// \u2705 CORRECT: Use StringBuilder for concatenation\npublic class GoodTransform : ITransformNode<Input, Output>\n{\n    protected override async Task<Output> ExecuteAsync(Input input, PipelineContext context, CancellationToken cancellationToken)\n    {\n        var sb = new StringBuilder();\n        foreach (var item in input.Items)\n        {\n            sb.Append(item.ToString());\n        }\n        return new Output(sb.ToString());\n    }\n}\n\n// \u2705 CORRECT: Use string interpolation\nprotected override async Task<string> ProcessAsync(Data data, CancellationToken cancellationToken)\n{\n    return $"{data.Id}-{data.Name}-{data.Value}"; // Efficient formatting\n}\n\n// \u2705 CORRECT: Use span-based operations\nprotected override async Task<string> ProcessAsync(string input, CancellationToken cancellationToken)\n{\n    return input.AsSpan().Slice(0, Math.Min(5, input.Length)).Trim().ToString(); // Zero-allocation where possible\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"string-operation-guidelines",children:"String Operation Guidelines"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Operation"}),(0,a.jsx)(n.th,{children:"Efficient Alternative"}),(0,a.jsx)(n.th,{children:"When to Use"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Concatenation in loop"}),(0,a.jsx)(n.td,{children:"StringBuilder"}),(0,a.jsx)(n.td,{children:"Multiple concatenations"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"String.Format"}),(0,a.jsx)(n.td,{children:"Interpolation"}),(0,a.jsx)(n.td,{children:"Simple formatting"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Substring/Trim"}),(0,a.jsx)(n.td,{children:"AsSpan().Slice()"}),(0,a.jsx)(n.td,{children:"Hot paths"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"ToUpper/ToLower"}),(0,a.jsx)(n.td,{children:"string.Create with Span"}),(0,a.jsx)(n.td,{children:"Case conversion in hot paths"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Join"}),(0,a.jsx)(n.td,{children:"string.Join with Span"}),(0,a.jsx)(n.td,{children:"Array/list joining"})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"np9203-anonymous-object-allocation",children:"NP9203: Anonymous Object Allocation"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"ID:"})," ",(0,a.jsx)(n.code,{children:"NP9203"}),"\n",(0,a.jsx)(n.strong,{children:"Severity:"})," Warning\n",(0,a.jsx)(n.strong,{children:"Category:"})," Performance"]}),"\n",(0,a.jsx)(n.p,{children:"This analyzer detects anonymous object creation in performance-critical NPipeline code that causes unnecessary GC pressure and allocation overhead, particularly in high-throughput scenarios."}),"\n",(0,a.jsx)(n.h4,{id:"why-this-matters-3",children:"Why This Matters"}),"\n",(0,a.jsx)(n.p,{children:"Anonymous object allocations cause:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"GC Pressure"}),": Each anonymous object creates heap allocation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory Overhead"}),": Anonymous objects have additional metadata"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Poor Cache Locality"}),": Scattered object references"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reduced Throughput"}),": Time spent in garbage collection"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"problematic-patterns-3",children:"Problematic Patterns"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u274c PROBLEM: Anonymous objects in ExecuteAsync\nprotected override async Task ExecuteAsync(IDataPipe<Output> output, PipelineContext context, CancellationToken cancellationToken)\n{\n    foreach (var item in inputItems)\n    {\n        // NP9203: Anonymous object allocation in hot path\n        var result = new { Id = item.Id, Name = item.Name, Value = item.Value * 2 };\n        await output.ProduceAsync(new Output(result), cancellationToken);\n    }\n}\n\n// \u274c PROBLEM: Anonymous objects in LINQ\nvar processed = items.Select(x => new // NP9203: Anonymous object in LINQ\n{\n    Id = x.Id,\n    ProcessedValue = x.Value * 2,\n    Timestamp = DateTime.UtcNow\n}).ToList();\n\n// \u274c PROBLEM: Anonymous objects in loops\nforeach (var item in largeCollection)\n{\n    // NP9203: Anonymous object allocation per iteration\n    var temp = new { Original = item, Processed = Process(item) };\n    results.Add(temp);\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"solution-use-named-types-or-value-types",children:"Solution: Use Named Types or Value Types"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u2705 CORRECT: Define named type for results\npublic record ProcessedItem(int Id, string Name, double Value);\n\nprotected override async Task ExecuteAsync(IDataPipe<Output> output, PipelineContext context, CancellationToken cancellationToken)\n{\n    foreach (var item in inputItems)\n    {\n        var result = new ProcessedItem(item.Id, item.Name, item.Value * 2);\n        await output.ProduceAsync(new Output(result), cancellationToken);\n    }\n}\n\n// \u2705 CORRECT: Use named type in LINQ\npublic record ProcessedData(int Id, double ProcessedValue, DateTime Timestamp);\n\nvar processed = items.Select(x => new ProcessedData(\n    x.Id,\n    x.Value * 2,\n    DateTime.UtcNow)).ToList();\n\n// \u2705 CORRECT: Use struct for value-type data\npublic readonly struct ProcessedItem\n{\n    public readonly int Id;\n    public readonly double ProcessedValue;\n    \n    public ProcessedItem(int id, double processedValue)\n    {\n        Id = id;\n        ProcessedValue = processedValue;\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"anonymous-object-alternatives",children:"Anonymous Object Alternatives"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Scenario"}),(0,a.jsx)(n.th,{children:"Recommended Alternative"}),(0,a.jsx)(n.th,{children:"Benefit"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Temporary data transfer"}),(0,a.jsx)(n.td,{children:"Named record/class"}),(0,a.jsx)(n.td,{children:"Type safety, reuse"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Key-value pairs"}),(0,a.jsx)(n.td,{children:"Tuple or struct"}),(0,a.jsx)(n.td,{children:"Stack allocation for structs"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Multiple return values"}),(0,a.jsx)(n.td,{children:"Out parameters or struct"}),(0,a.jsx)(n.td,{children:"No heap allocation"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"LINQ projections"}),(0,a.jsx)(n.td,{children:"Named type constructor"}),(0,a.jsx)(n.td,{children:"Clearer intent"})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"np9205-non-streaming-patterns-in-sourcenode",children:"NP9205: Non-Streaming Patterns in SourceNode"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"ID:"})," ",(0,a.jsx)(n.code,{children:"NP9205"}),"\n",(0,a.jsx)(n.strong,{children:"Severity:"})," Warning\n",(0,a.jsx)(n.strong,{children:"Category:"})," Performance"]}),"\n",(0,a.jsxs)(n.p,{children:["This analyzer detects non-streaming patterns in SourceNode implementations that can lead to memory issues and poor performance. See the ",(0,a.jsx)(n.a,{href:"/docs/analyzers/data-processing",children:"Data Processing Analyzers"})," section for detailed information about this analyzer."]}),"\n",(0,a.jsx)(n.h2,{id:"best-practices-for-performance",children:"Best Practices for Performance"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Always use await"})," - Never block on async code with .Result, .Wait(), or .GetResult()"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Respect cancellation tokens"})," - Check them frequently and pass them to all async operations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Never swallow OperationCanceledException"})," - Always re-throw or handle it appropriately"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use ValueTask for sync-heavy paths"})," - Avoid unnecessary allocations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use async all the way down"})," - Don't mix sync and async code"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use ConfigureAwait(false) in library code"})," - Improves performance and prevents deadlocks"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,a.jsxs)(n.p,{children:["Adjust analyzer severity in ",(0,a.jsx)(n.code,{children:".editorconfig"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ini",children:"# Treat blocking operations as errors\ndotnet_diagnostic.NP9101.severity = error\n\n# Treat swallowed cancellation as errors\ndotnet_diagnostic.NP9102.severity = error\n\n# Treat fire-and-forget async as errors\ndotnet_diagnostic.NP9103.severity = error\n\n# Treat ignored cancellation tokens as errors\ndotnet_diagnostic.NP9104.severity = error\n\n# Treat LINQ in hot paths as warnings\ndotnet_diagnostic.NP9201.severity = warning\n\n# Treat inefficient string operations as warnings\ndotnet_diagnostic.NP9202.severity = warning\n\n# Treat anonymous object allocation as warnings\ndotnet_diagnostic.NP9203.severity = warning\n\n# Treat missing ValueTask optimization as warnings\ndotnet_diagnostic.NP9204.severity = warning\n\n# Treat non-streaming patterns as errors\ndotnet_diagnostic.NP9205.severity = error\n"})}),"\n",(0,a.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Hygiene"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/docs/architecture/performance-characteristics",children:"Performance Characteristics"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);