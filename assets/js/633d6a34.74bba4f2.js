"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[6185],{8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>a});var r=i(6540);const t={},o=r.createContext(t);function s(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(o.Provider,{value:n},e.children)}},9920:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"core-concepts/pipeline-context","title":"Pipeline Context (PipelineContext)","description":"Understand how to manage and share state, configuration, and cancellation across your NPipeline nodes using PipelineContext.","source":"@site/docs/core-concepts/pipeline-context.md","sourceDirName":"core-concepts","slug":"/core-concepts/pipeline-context","permalink":"/npipeline.dev/docs/core-concepts/pipeline-context","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Pipeline Context (PipelineContext)","description":"Understand how to manage and share state, configuration, and cancellation across your NPipeline nodes using PipelineContext.","sidebar_position":7},"sidebar":"docsSidebar","previous":{"title":"Dead-Letter Queues","permalink":"/npipeline.dev/docs/core-concepts/pipeline-execution/dead-letter-queues"},"next":{"title":"Common Patterns","permalink":"/npipeline.dev/docs/core-concepts/common-patterns"}}');var t=i(4848),o=i(8453);const s={title:"Pipeline Context (PipelineContext)",description:"Understand how to manage and share state, configuration, and cancellation across your NPipeline nodes using PipelineContext.",sidebar_position:7},a="PipelineContext",l={},c=[{value:"What is <code>PipelineContext</code>?",id:"what-is-pipelinecontext",level:2},{value:"Constructor Parameters",id:"constructor-parameters",level:2},{value:"Creating a <code>PipelineContext</code>",id:"creating-a-pipelinecontext",level:2},{value:"Default Components",id:"default-components",level:3},{value:"Quick Start - No Configuration Needed",id:"quick-start---no-configuration-needed",level:3},{value:"With Cancellation Token",id:"with-cancellation-token",level:3},{value:"With Multiple Configurations",id:"with-multiple-configurations",level:3},{value:"Entry Points",id:"entry-points",level:3},{value:"Accessing <code>PipelineContext</code>",id:"accessing-pipelinecontext",level:2},{value:"Standard Access",id:"standard-access",level:3},{value:"Context-Aware Nodes",id:"context-aware-nodes",level:3},{value:"Key Properties and Methods",id:"key-properties-and-methods",level:2},{value:"State Management Capabilities",id:"state-management-capabilities",level:2},{value:"Difference Between Parameters, Items, and Properties",id:"difference-between-parameters-items-and-properties",level:2},{value:"Example: Using <code>PipelineContext</code> for Logging",id:"example-using-pipelinecontext-for-logging",level:2},{value:"Example: Using <code>IContextAwareNode</code>",id:"example-using-icontextawarenode",level:2},{value:"\u2705 Best Practices",id:"white_check_mark-best-practices",level:2},{value:"\ud83d\udd17 Related Topics",id:"link-related-topics",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"pipelinecontext",children:(0,t.jsx)(n.code,{children:"PipelineContext"})})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"src/NPipeline/PipelineContext.cs",children:(0,t.jsx)(n.code,{children:"PipelineContext"})})," is a crucial component in NPipeline that provides a mechanism for sharing runtime information, services, and state across different nodes within a pipeline. It acts as a lightweight, scoped container that is passed through the pipeline during execution, allowing nodes to access common resources without explicit dependency injection in their constructors."]}),"\n",(0,t.jsx)(n.p,{children:"This context is particularly useful for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Logging"}),": Providing a consistent logging mechanism."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Metrics"}),": Capturing and reporting performance metrics."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Correlation IDs"}),": Propagating unique identifiers for tracing requests across nodes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Shared State"}),": Storing transient state that needs to be accessible by multiple nodes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CancellationToken"}),": Propagating cancellation requests throughout the pipeline."]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"what-is-pipelinecontext",children:["What is ",(0,t.jsx)(n.code,{children:"PipelineContext"}),"?"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"PipelineContext"})," is a class that encapsulates runtime information relevant to a specific pipeline execution. It is automatically created when a pipeline starts its ",(0,t.jsx)(n.code,{children:"RunAsync"})," method and is passed implicitly to your nodes."]}),"\n",(0,t.jsxs)(n.p,{children:["Key elements managed by ",(0,t.jsx)(n.code,{children:"PipelineContext"})," include:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"CancellationToken"}),":"]})," A primary mechanism for cooperative cancellation of the pipeline. All nodes should respect this token for graceful shutdown."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parameters:"})," A dictionary for holding runtime parameters passed to the pipeline during initialization."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Items:"})," A dictionary for sharing transient state between pipeline nodes during execution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Properties:"})," A dictionary for storing properties that can be used by extensions and plugins, providing a way to extend PipelineContext without modifying its core structure."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Arbitrary State:"})," You can store and retrieve any custom data or objects that need to be accessible by multiple nodes during the pipeline's execution. This is particularly useful for configuration, metrics, or shared resources."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"constructor-parameters",children:"Constructor Parameters"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"PipelineContext"})," constructor accepts several optional parameters to customize the execution environment:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public PipelineContext(\r\n    Dictionary<string, object>? parameters = null,\r\n    IPipelineLoggerFactory? loggerFactory = null,\r\n    IPipelineTracer? tracer = null,\r\n    IPipelineErrorHandler? pipelineErrorHandler = null,\r\n    IDeadLetterSink? deadLetterSink = null,\r\n    Dictionary<string, object>? items = null,\r\n    IErrorHandlerFactory? errorHandlerFactory = null,\r\n    ILineageFactory? lineageFactory = null,\r\n    IObservabilityFactory? observabilityFactory = null,\r\n    PipelineRetryOptions? retryOptions = null,\r\n    Dictionary<string, object>? properties = null,\r\n    CancellationToken cancellationToken = default)\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"creating-a-pipelinecontext",children:["Creating a ",(0,t.jsx)(n.code,{children:"PipelineContext"})]}),"\n",(0,t.jsxs)(n.p,{children:["The simplest way to create a ",(0,t.jsx)(n.code,{children:"PipelineContext"})," is by using its public constructor. ",(0,t.jsx)(n.strong,{children:"All unspecified components automatically use sensible defaults"}),", so you only need to configure what you need."]}),"\n",(0,t.jsx)(n.h3,{id:"default-components",children:"Default Components"}),"\n",(0,t.jsx)(n.p,{children:"All of these components have built-in defaults - you don't need to explicitly set them:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ErrorHandlerFactory"})}),": ",(0,t.jsx)(n.code,{children:"DefaultErrorHandlerFactory"})," (handles errors according to pipeline settings)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"LineageFactory"})}),": ",(0,t.jsx)(n.code,{children:"DefaultLineageFactory"})," (tracks data lineage)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ObservabilityFactory"})}),": ",(0,t.jsx)(n.code,{children:"DefaultObservabilityFactory"})," (provides observability hooks)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"LoggerFactory"})}),": ",(0,t.jsx)(n.code,{children:"NullPipelineLoggerFactory"})," (no-op logger)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"Tracer"})}),": ",(0,t.jsx)(n.code,{children:"NullPipelineTracer"})," (no-op tracer)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"RetryOptions"})}),": ",(0,t.jsx)(n.code,{children:"PipelineRetryOptions.Default"})," (no retries)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"quick-start---no-configuration-needed",children:"Quick Start - No Configuration Needed"}),"\n",(0,t.jsx)(n.p,{children:"For the most basic case, just create a context:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// This gives you a fully configured context with all defaults\r\nvar context = new PipelineContext();\r\n\r\nvar runner = new PipelineRunner();\r\nawait runner.RunAsync<MyPipeline>(context);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"with-cancellation-token",children:"With Cancellation Token"}),"\n",(0,t.jsx)(n.p,{children:"The most common scenario:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var cts = new CancellationTokenSource(TimeSpan.FromMinutes(5));\r\n\r\n// Pass cancellation token directly through configuration\r\nvar context = new PipelineContext(PipelineContextConfiguration.WithCancellation(cts.Token));\r\n\r\nawait runner.RunAsync<MyPipeline>(context);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"with-multiple-configurations",children:"With Multiple Configurations"}),"\n",(0,t.jsxs)(n.p,{children:["For complex scenarios, use the ",(0,t.jsx)(n.code,{children:"PipelineContextBuilder"})," with fluent API:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'var context = new PipelineContextBuilder()\r\n    .WithCancellation(cancellationToken)\r\n    .WithRetry(new PipelineRetryOptions(maxItemRetries: 3))\r\n    .WithParameters(new Dictionary<string, object> { { "userId", 123 } })\r\n    .WithErrorHandlerFactory(myCustomErrorHandlerFactory)\r\n    .WithObservability(loggerFactory: myLoggerFactory, tracer: myTracer)\r\n    .Build();\r\n\r\nawait runner.RunAsync<MyPipeline>(context);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"entry-points",children:"Entry Points"}),"\n",(0,t.jsx)(n.p,{children:"You have several options depending on your needs:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Method"}),(0,t.jsx)(n.th,{children:"When to Use"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"new PipelineContext()"})}),(0,t.jsx)(n.td,{children:"Simple context with all defaults"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"new PipelineContext(PipelineContextConfiguration.WithCancellation(token))"})}),(0,t.jsx)(n.td,{children:"For cancellation token only"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"new PipelineContext(config)"})}),(0,t.jsxs)(n.td,{children:["When you have a ",(0,t.jsx)(n.code,{children:"PipelineContextConfiguration"})," object"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"new PipelineContextBuilder().Build()"})}),(0,t.jsx)(n.td,{children:"Complex multi-step configuration"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"PipelineContext.Default"})}),(0,t.jsx)(n.td,{children:"Simple read-only default context (rarely used)"})]})]})]}),"\n",(0,t.jsxs)(n.h2,{id:"accessing-pipelinecontext",children:["Accessing ",(0,t.jsx)(n.code,{children:"PipelineContext"})]}),"\n",(0,t.jsx)(n.h3,{id:"standard-access",children:"Standard Access"}),"\n",(0,t.jsxs)(n.p,{children:["Nodes that implement ",(0,t.jsx)(n.code,{children:"TransformNode<TInput, TOutput>"})," or ",(0,t.jsx)(n.code,{children:"SinkNode<TInput>"})," can access the ",(0,t.jsx)(n.a,{href:"src/NPipeline/PipelineContext.cs",children:(0,t.jsx)(n.code,{children:"PipelineContext"})})," through their ",(0,t.jsx)(n.code,{children:"ExecuteAsync"})," and ",(0,t.jsx)(n.code,{children:"ExecuteAsync"})," methods, respectively."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class ExecuteAsync<TInput, TOutput>\r\n{\r\n    IAsyncEnumerable<TOutput> ExecuteAsync(\r\n        IAsyncEnumerable<TInput> input,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken = default);\r\n}\r\n\r\npublic class SinkNode<TInput>\r\n{\r\n    Task ExecuteAsync(\r\n        IAsyncEnumerable<TInput> input,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken = default);\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"context-aware-nodes",children:"Context-Aware Nodes"}),"\n",(0,t.jsxs)(n.p,{children:["To access the full ",(0,t.jsx)(n.code,{children:"PipelineContext"})," object, your nodes can implement the ",(0,t.jsx)(n.code,{children:"IContextAwareNode"})," interface."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public interface IContextAwareNode\r\n{\r\n    void SetContext(PipelineContext context);\r\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["NPipeline will automatically detect if your node implements ",(0,t.jsx)(n.code,{children:"IContextAwareNode"})," and inject the ",(0,t.jsx)(n.code,{children:"PipelineContext"})," instance into it before the pipeline starts."]}),"\n",(0,t.jsx)(n.h2,{id:"key-properties-and-methods",children:"Key Properties and Methods"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"src/NPipeline/PipelineContext.cs",children:(0,t.jsx)(n.code,{children:"PipelineContext"})})," includes properties and methods for:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"CancellationToken"})}),": A token that signals if the pipeline execution has been requested to stop. Nodes should monitor this token and cease operations if cancellation is requested."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"Parameters"})}),": A dictionary to hold any runtime parameters for the pipeline. These are typically set during pipeline initialization and remain constant throughout execution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"Items"})}),": A dictionary for sharing state between pipeline nodes. This is used for transient data that needs to be accessible by multiple nodes during execution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"Properties"})}),": A dictionary for storing properties that can be used by extensions and plugins. This provides a way to extend PipelineContext without modifying its core structure."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"LoggerFactory"})}),": The logger factory for this pipeline run, providing consistent logging across all nodes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"Tracer"})}),": The tracer for this pipeline run, enabling distributed tracing."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"PipelineErrorHandler"})}),": The error handler for the entire pipeline."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"DeadLetterSink"})}),": The sink for items that have failed processing and have been redirected."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ErrorHandlerFactory"})}),": The factory for creating error handlers and dead-letter sinks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"LineageFactory"})}),": The factory for creating lineage sinks and resolving lineage collectors."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ObservabilityFactory"})}),": The factory for resolving observability collectors."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"RetryOptions"})}),": Execution / retry configuration for this pipeline run. Values here override builder defaults when provided."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"CurrentNodeId"})}),": The ID of the node currently being executed. This is automatically managed by the pipeline runner."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ExecutionObserver"})}),": Optional execution observer for instrumentation (node lifecycle, retries, queue/backpressure events)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"StateManager"})}),": Gets the state manager for this pipeline run, if available. This is accessed through the Properties dictionary."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"StatefulRegistry"})}),": Gets the stateful registry for this pipeline run, if available. This is accessed through the Properties dictionary."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Logging/Metrics Interfaces"}),": References to logging or metrics services (e.g., ",(0,t.jsx)(n.code,{children:"ILogger"}),", ",(0,t.jsx)(n.code,{children:"IMetricsRecorder"}),") that nodes can use to report events or data."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"state-management-capabilities",children:"State Management Capabilities"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"PipelineContext"})," provides several methods for managing state and resources:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"RegisterForDisposal(IAsyncDisposable disposable)"})}),": Registers an ",(0,t.jsx)(n.code,{children:"IAsyncDisposable"})," resource to be disposed when the pipeline context is disposed. This ensures proper cleanup of resources created during pipeline execution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ScopedNode(string nodeId)"})}),": Sets the ",(0,t.jsx)(n.code,{children:"CurrentNodeId"})," for the duration of the returned disposable scope. This is used internally by the pipeline runner to track which node is currently executing."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"TryGetStatefulRegistry(out IStatefulRegistry? registry)"})}),": Attempts to get the stateful registry for this pipeline run. Returns true if a stateful registry is available, false otherwise."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"difference-between-parameters-items-and-properties",children:"Difference Between Parameters, Items, and Properties"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parameters"}),": These are typically set during pipeline initialization and are meant to be configuration values that remain constant throughout the pipeline execution. They are used to pass configuration to the pipeline as a whole."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Items"}),": These are used for sharing transient state between pipeline nodes during execution. Items can be modified by nodes and are meant for data that needs to be shared between different parts of the pipeline during a single run."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Properties"}),": These are used for storing properties that can be used by extensions and plugins. They provide a way to extend PipelineContext without modifying its core structure and are typically used by framework components rather than user code."]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"example-using-pipelinecontext-for-logging",children:["Example: Using ",(0,t.jsx)(n.code,{children:"PipelineContext"})," for Logging"]}),"\n",(0,t.jsx)(n.p,{children:"Consider a scenario where you want to log the processing of each item within a transform node, including a correlation ID for tracing."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.DataFlow;\r\nusing NPipeline.DataFlow.DataPipes;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n// Assume ILogger is an interface for logging\r\npublic interface ILogger\r\n{\r\n    void LogInformation(string message, params object[] args);\r\n}\r\n\r\n// Assume a simple Logger implementation\r\npublic sealed class ConsoleLogger : ILogger\r\n{\r\n    public void LogInformation(string message, params object[] args)\r\n    {\r\n        Console.WriteLine($"[INFO] {string.Format(message, args)}");\r\n    }\r\n}\r\n\r\npublic sealed record DataItem(Guid Id, string Payload);\r\n\r\npublic sealed class MyTransformWithContext : ITransformNode<DataItem, DataItem>\r\n{\r\n    public async IAsyncEnumerable<DataItem> ExecuteAsync(\r\n        IAsyncEnumerable<DataItem> input,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken = default)\r\n    {\r\n        // Retrieve logger from context (or get a default if not present)\r\n        var logger = context.GetItem<ILogger>("Logger") ?? new ConsoleLogger();\r\n        var correlationId = context.GetItem<Guid>("CorrelationId");\r\n\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            if (cancellationToken.IsCancellationRequested) yield break;\r\n\r\n            logger.LogInformation(\r\n                "[{CorrelationId}] Processing item {ItemId} with payload: {Payload}",\r\n                correlationId,\r\n                item.Id,\r\n                item.Payload);\r\n\r\n            // Simulate some transformation\r\n            var transformedItem = item with { Payload = item.Payload.ToUpperInvariant() };\r\n            yield return transformedItem;\r\n        }\r\n    }\r\n}\r\n\r\npublic sealed class MySource : SourceNode<DataItem>\r\n{\r\n    public override IDataPipe<DataItem> ExecuteAsync(PipelineContext context, CancellationToken cancellationToken = default)\r\n    {\r\n        static IAsyncEnumerable<DataItem> Stream()\r\n        {\r\n            return Generate();\r\n\r\n            async IAsyncEnumerable<DataItem> Generate()\r\n            {\r\n                for (int i = 0; i < 3; i++)\r\n                {\r\n                    yield return new DataItem(Guid.NewGuid(), $"item-{i}");\r\n                }\r\n            }\r\n        }\r\n\r\n        return new StreamingDataPipe<DataItem>(Stream(), "Source Data Stream");\r\n    }\r\n}\r\n\r\npublic sealed class MySink : SinkNode<DataItem>\r\n{\r\n    public override async Task ExecuteAsync(\r\n        IDataPipe<DataItem> input,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken = default)\r\n    {\r\n        var logger = context.Items.TryGetValue("Logger", out var loggerObj) && loggerObj is ILogger loggerInstance\r\n            ? loggerInstance\r\n            : new ConsoleLogger();\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            logger.LogInformation("Sink consumed: {ItemId} - {Payload}", item.Id, item.Payload);\r\n        }\r\n    }\r\n}\r\n\r\npublic sealed class MyPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<MySource, DataItem>();\r\n        var transformHandle = builder.AddTransform<MyTransformWithContext, DataItem, DataItem>();\r\n        var sinkHandle = builder.AddSink<MySink, DataItem>();\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var logger = new ConsoleLogger();\r\n        var correlationId = Guid.NewGuid();\r\n\r\n        // Create a custom PipelineContext and add shared resources\r\n        var context = PipelineContext.Default;\r\n        context.Items["Logger"] = logger;\r\n        context.Items["CorrelationId"] = correlationId;\r\n\r\n        var runner = new PipelineRunner();\r\n\r\n        Console.WriteLine($"Starting pipeline with CorrelationId: {correlationId}");\r\n        await runner.RunAsync<MyPipelineDefinition>(context); // Pass the custom context\r\n        Console.WriteLine("Pipeline finished.");\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, a ",(0,t.jsx)(n.code,{children:"ConsoleLogger"})," and a ",(0,t.jsx)(n.code,{children:"CorrelationId"})," are added to the ",(0,t.jsx)(n.code,{children:"PipelineContext"}),". The ",(0,t.jsx)(n.code,{children:"MyTransformWithContext"})," and ",(0,t.jsx)(n.code,{children:"MySink"})," nodes then retrieve these items from the context to perform logging with the shared correlation ID."]}),"\n",(0,t.jsxs)(n.h2,{id:"example-using-icontextawarenode",children:["Example: Using ",(0,t.jsx)(n.code,{children:"IContextAwareNode"})]}),"\n",(0,t.jsx)(n.p,{children:"Let's imagine a scenario where you want to pass a configuration setting (e.g., a batch size) to multiple nodes, or log information with a unique pipeline run ID."}),"\n",(0,t.jsxs)(n.p,{children:["First, define a custom context object or simply use ",(0,t.jsx)(n.code,{children:"PipelineContext"})," directly:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.DataFlow;\r\nusing NPipeline.DataFlow.DataPipes;\r\nusing NPipeline.Nodes;\r\n\r\npublic sealed class MyConfig\r\n{\r\n    public int BatchSize { get; set; } = 10;\r\n    public Guid RunId { get; } = Guid.NewGuid();\r\n}\r\n\r\npublic sealed class ConfigurableSource : SourceNode<string>, IContextAwareNode\r\n{\r\n    private PipelineContext _context;\r\n\r\n    public void SetContext(PipelineContext context)\r\n    {\r\n        _context = context;\r\n    }\r\n\r\n    public override IDataPipe<string> ExecuteAsync(PipelineContext context, CancellationToken cancellationToken = default)\r\n    {\r\n        var config = _context.GetOrAdd("MyConfig", () => new MyConfig());\r\n        Console.WriteLine($"Source (RunId: {config.RunId}): Producing up to {config.BatchSize} items.");\r\n\r\n        static IAsyncEnumerable<string> Stream(int batchSize)\r\n        {\r\n            return Generate();\r\n\r\n            async IAsyncEnumerable<string> Generate()\r\n            {\r\n                for (int i = 0; i < batchSize; i++)\r\n                {\r\n                    yield return $"Item {i}";\r\n                }\r\n            }\r\n        }\r\n\r\n        return new StreamingDataPipe<string>(Stream(config.BatchSize), "Configurable Source Stream");\r\n    }\r\n}\r\n\r\npublic sealed class ContextAwareTransform : TransformNode<string, string>, IContextAwareNode\r\n{\r\n    private PipelineContext _context;\r\n\r\n    public void SetContext(PipelineContext context)\r\n    {\r\n        _context = context;\r\n    }\r\n\r\n    public override async Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken = default)\r\n    {\r\n        var config = _context.GetOrAdd("MyConfig", () => new MyConfig()); // Retrieve the same config\r\n        Console.WriteLine($"Transform (RunId: {config.RunId}): Transforming {item}");\r\n        return item.ToUpperInvariant();\r\n    }\r\n}\r\n\r\npublic sealed class ContextAwareSink : SinkNode<string>, IContextAwareNode\r\n{\r\n    private PipelineContext _context;\r\n\r\n    public void SetContext(PipelineContext context)\r\n    {\r\n        _context = context;\r\n    }\r\n\r\n    public override async Task ExecuteAsync(\r\n        IDataPipe<string> input,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken = default)\r\n    {\r\n        var config = _context.GetOrAdd("MyConfig", () => new MyConfig()); // Retrieve the same config\r\n        Console.WriteLine($"Sink (RunId: {config.RunId}): Consuming items.");\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            Console.WriteLine($"Sink (RunId: {config.RunId}): Received {item}");\r\n        }\r\n    }\r\n}\r\n\r\npublic sealed class ContextAwarePipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<ConfigurableSource, string>();\r\n        var transformHandle = builder.AddTransform<ContextAwareTransform, string, string>();\r\n        var sinkHandle = builder.AddSink<ContextAwareSink, string>();\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var runner = new PipelineRunner();\r\n        await runner.RunAsync<ContextAwarePipelineDefinition>();\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, ",(0,t.jsx)(n.code,{children:"MyConfig"})," is stored in ",(0,t.jsx)(n.code,{children:"PipelineContext"}),' using a key ("MyConfig"). Each ',(0,t.jsx)(n.code,{children:"IContextAwareNode"})," can then retrieve this shared configuration. The ",(0,t.jsx)(n.code,{children:"GetOrAdd"})," method ensures that the object is created only once per pipeline run if it doesn't already exist for that key."]}),"\n",(0,t.jsxs)(n.h2,{id:"white_check_mark-best-practices",children:["\u2705"," Best Practices"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Keep it Lightweight"}),": Avoid adding large or frequently changing data structures to the context. For complex state management, consider dedicated state management nodes or services."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transient State:"})," Use ",(0,t.jsx)(n.code,{children:"PipelineContext"})," for state that is specific to a single pipeline run. Avoid using it for global application state."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Immutability (where possible)"}),": While the context itself is mutable, consider making items retrieved from it immutable or thread-safe if they are to be shared and modified across multiple concurrent nodes. Where possible, store immutable objects in context to prevent unexpected side effects from nodes modifying shared state."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Clarity"}),": Use meaningful keys for items stored in the context to improve readability and prevent naming collisions. Consider defining static string constants for your keys."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Optional Access"}),": Design nodes to gracefully handle cases where an expected item might not be present in the context (e.g., provide default values or log warnings)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cancellation:"})," Always respect the ",(0,t.jsx)(n.code,{children:"CancellationToken"})," provided by the ",(0,t.jsx)(n.code,{children:"PipelineContext"})," (or directly via method parameters) to ensure your nodes can respond to cancellation requests."]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"link-related-topics",children:["\ud83d\udd17"," Related Topics"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/npipeline.dev/docs/core-concepts/streaming-vs-buffering",children:"Streaming vs. Buffering"})}),": Understand how NPipeline handles data flow and memory management."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/error-handling",children:"Error Handling"})}),": Learn about NPipeline's error handling mechanisms."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);