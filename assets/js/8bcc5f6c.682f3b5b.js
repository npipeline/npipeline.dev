"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[2311],{9916:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"advanced-topics/synchronous-fast-paths","title":"Synchronous Fast Paths and ValueTask Optimization","description":"Deep-dive guide on optimizing transformer nodes for high-throughput scenarios using ValueTask to eliminate GC pressure.","source":"@site/docs/advanced-topics/synchronous-fast-paths.md","sourceDirName":"advanced-topics","slug":"/advanced-topics/synchronous-fast-paths","permalink":"/docs/advanced-topics/synchronous-fast-paths","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Synchronous Fast Paths and ValueTask Optimization","description":"Deep-dive guide on optimizing transformer nodes for high-throughput scenarios using ValueTask to eliminate GC pressure.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Performance Hygiene","permalink":"/docs/advanced-topics/performance-hygiene"},"next":{"title":"Build-Time Analyzers","permalink":"/docs/analyzers/"}}');var a=r(74848),t=r(28453);const i={title:"Synchronous Fast Paths and ValueTask Optimization",description:"Deep-dive guide on optimizing transformer nodes for high-throughput scenarios using ValueTask to eliminate GC pressure.",sidebar_position:3},o="Synchronous Fast Paths and ValueTask Optimization",l={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"The Performance Paradox",id:"the-performance-paradox",level:2},{value:"The Solution: ValueTask",id:"the-solution-valuetask",level:2},{value:"The Pattern: Synchronous Fast Path + Asynchronous Slow Path",id:"the-pattern-synchronous-fast-path--asynchronous-slow-path",level:2},{value:"Real-World Example: Cached Data Enrichment",id:"real-world-example-cached-data-enrichment",level:2},{value:"Performance Impact",id:"performance-impact",level:2},{value:"Practical Guidelines",id:"practical-guidelines",level:2},{value:"When to Use <code>ValueTask</code> for Transforms",id:"when-to-use-valuetask-for-transforms",level:3},{value:"Implementation Checklist",id:"implementation-checklist",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Example 1: Simple Transformation (Always Synchronous)",id:"example-1-simple-transformation-always-synchronous",level:3},{value:"Example 2: Format Transformation with Optional Fallback",id:"example-2-format-transformation-with-optional-fallback",level:3},{value:"\u26a0\ufe0f MANDATORY: ValueTask Safety Checklist",id:"\ufe0f-mandatory-valuetask-safety-checklist",level:2},{value:"The Risks: What Happens When You Break These Rules",id:"the-risks-what-happens-when-you-break-these-rules",level:3},{value:"Risk #1: Multiple Awaits = Undefined Behavior",id:"risk-1-multiple-awaits--undefined-behavior",level:4},{value:"Never Await More Than Once",id:"never-await-more-than-once",level:3},{value:"Risk #2: No ConfigureAwait Support",id:"risk-2-no-configureawait-support",level:4},{value:"Risk #3: Always-Async Methods Waste Effort",id:"risk-3-always-async-methods-waste-effort",level:4},{value:"Risk #4: Public APIs Need Safe Defaults",id:"risk-4-public-apis-need-safe-defaults",level:4},{value:"Recommended: Implement ExecuteValueTaskAsync for Optimization",id:"recommended-implement-executevaluetaskasync-for-optimization",level:3},{value:"See Also",id:"see-also",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"synchronous-fast-paths-and-valuetask-optimization",children:"Synchronous Fast Paths and ValueTask Optimization"})}),"\n",(0,a.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsx)(n.p,{children:"Before implementing ValueTask optimization, you should be familiar with:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts",children:"Core Concepts Overview"})," - Basic NPipeline concepts and terminology"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts/nodes/",children:"Nodes Overview"})," - Understanding how nodes process data"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts/nodes/transform-nodes",children:"Transform Nodes"})," - Node implementation details"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/architecture/optimization-principles",children:"Optimization Principles"})," - Understanding why ValueTask improves performance"]}),"\n"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["For general performance best practices, see ",(0,a.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Hygiene"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["This is ",(0,a.jsx)(n.strong,{children:"definitive guide"})," for understanding and implementing ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," pattern in transformer nodes. For a quick introduction, see ",(0,a.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene#use-valuetaskt-for-fast-path-scenarios",children:"Performance Hygiene: Use ValueTask<T> for Fast Path Scenarios"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"the-performance-paradox",children:"The Performance Paradox"}),"\n",(0,a.jsx)(n.p,{children:"A common performance pitfall in high-throughput ETL pipelines is contradiction between advice and implementation:"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"The advice says:"}),' "Minimize memory allocations to reduce GC pressure"\r\n',(0,a.jsx)(n.strong,{children:"The code does:"})," Return ",(0,a.jsx)(n.code,{children:"Task<T>"})," for all transformer nodes"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["This creates a subtle but critical performance problem: even when your transform work is ",(0,a.jsx)(n.strong,{children:"completely synchronous"})," (a cache hit, a simple calculation), you're still creating a heap-allocated ",(0,a.jsx)(n.code,{children:"Task<T>"})," object to wrap the result."]}),"\n",(0,a.jsxs)(n.p,{children:["In a pipeline processing ",(0,a.jsx)(n.strong,{children:"millions of items per second"}),", where many transforms are synchronous or have high synchronous fast-path rates, you can easily be creating ",(0,a.jsx)(n.strong,{children:"millions of tiny heap allocations per second"}),". This creates constant pressure on garbage collector, causing pauses that directly undermine your throughput goals."]}),"\n",(0,a.jsx)(n.h2,{id:"the-solution-valuetask",children:"The Solution: ValueTask"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"ValueTask<T>"})," is a struct-based alternative to ",(0,a.jsx)(n.code,{children:"Task<T>"})," that:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Allocates on stack"})," (not heap) when result is available synchronously"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Zero allocations"})," for common case in cache-hit or synchronous scenarios"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Seamlessly transitions"})," to true async work when needed"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The tradeoff: You need to implement a two-path pattern\u2014checking for synchronous case first."}),"\n",(0,a.jsx)(n.h2,{id:"the-pattern-synchronous-fast-path--asynchronous-slow-path",children:"The Pattern: Synchronous Fast Path + Asynchronous Slow Path"}),"\n",(0,a.jsx)(n.p,{children:"Here's pattern that balances performance with practicality:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// High-performance transform with cache optimization using ValueTask.\r\n/// Demonstrates zero-allocation pattern for high-throughput scenarios.\r\n/// In pipelines with 90% cache hits processing 10k items/sec,\r\n/// this eliminates ~9000 allocations/sec compared to Task&lt;T&gt;.\r\n/// </summary>\r\npublic sealed class CachedTransform : TransformNode<string, UserData>\r\n{\r\n    private readonly ConcurrentDictionary<string, UserData> _cache = new();\r\n\r\n    /// <summary>\r\n    /// Processes user data with cache-first strategy.\r\n    /// Fast path: cache hit - no Task allocation\r\n    /// Slow path: cache miss - async database call\r\n    /// </summary>\r\n    public override ValueTask<UserData> ExecuteAsync(\r\n        string userId, \r\n        PipelineContext context, \r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Fast path: cache hit - no Task allocation\r\n        if (_cache.TryGetValue(userId, out var cached))\r\n            return new ValueTask<UserData>(cached);\r\n\r\n        // Slow path: async database call\r\n        return new ValueTask<UserData>(FetchAndCacheAsync(userId, cancellationToken));\r\n    }\r\n\r\n    /// <summary>\r\n    /// Fetches user data from database and caches the result.\r\n    /// This method is only called on cache misses.\r\n    /// </summary>\r\n    private async Task<UserData> FetchAndCacheAsync(string userId, CancellationToken ct)\r\n    {\r\n        var data = await _database.GetUserAsync(userId, ct);\r\n        _cache.TryAdd(userId, data);\r\n        return data;\r\n    }\r\n}\r\n\r\n// Supporting types for the example\r\npublic record UserData(string Id, string Name, string Email);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"real-world-example-cached-data-enrichment",children:"Real-World Example: Cached Data Enrichment"}),"\n",(0,a.jsx)(n.p,{children:"Consider a typical ETL scenario where you enrich data by looking up additional information:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Transform for enriching user data with caching optimization.\r\n/// Demonstrates ValueTask pattern for real-world cache-hit scenarios.\r\n/// </summary>\r\npublic sealed class UserEnrichmentTransform : TransformNode<UserId, EnrichedUser>\r\n{\r\n    private readonly ConcurrentDictionary<string, UserProfile> _profileCache = new();\r\n    private readonly IUserDatabase _userDatabase;\r\n\r\n    public UserEnrichmentTransform(IUserDatabase userDatabase)\r\n    {\r\n        _userDatabase = userDatabase;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Enriches user data with profile information.\r\n    /// Uses cache-first strategy to minimize database calls.\r\n    /// </summary>\r\n    public override ValueTask<EnrichedUser> ExecuteAsync(\r\n        UserId userId,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Check cache first (usually succeeds - fast path)\r\n        if (_profileCache.TryGetValue(userId.Value, out var cachedProfile))\r\n        {\r\n            // Fast path: Return immediately, zero heap allocation\r\n            return new ValueTask<EnrichedUser>(\r\n                new EnrichedUser(userId, cachedProfile)\r\n            );\r\n        }\r\n\r\n        // Cache miss: Fall back to database lookup (slow path)\r\n        return new ValueTask<EnrichedUser>(\r\n            FetchAndEnrichAsync(userId, context, cancellationToken)\r\n        );\r\n    }\r\n\r\n    /// <summary>\r\n    /// Fetches user profile from database and caches the result.\r\n    /// Only executed on cache misses, then cached for future requests.\r\n    /// </summary>\r\n    private async Task<EnrichedUser> FetchAndEnrichAsync(\r\n        UserId userId,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        var profile = await _userDatabase.GetProfileAsync(userId.Value, cancellationToken);\r\n        _profileCache.TryAdd(userId.Value, profile);\r\n        return new EnrichedUser(userId, profile);\r\n    }\r\n}\r\n\r\n// Supporting types for the example\r\npublic record UserId(string Value);\r\npublic record UserProfile(string Name, string Email, DateTime CreatedAt);\r\npublic record EnrichedUser(UserId Id, UserProfile Profile);\r\n\r\n// Interface for database access\r\npublic interface IUserDatabase\r\n{\r\n    Task<UserProfile> GetProfileAsync(string userId, CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-impact",children:"Performance Impact"}),"\n",(0,a.jsx)(n.p,{children:"In a realistic high-volume ETL pipeline:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Scenario"}),(0,a.jsx)(n.th,{children:"Items/Sec"}),(0,a.jsx)(n.th,{children:"Cache Hit Rate"}),(0,a.jsx)(n.th,{children:"Task Allocations/Sec"}),(0,a.jsx)(n.th,{children:"ValueTask Allocations/Sec"}),(0,a.jsx)(n.th,{children:"GC Pressure Reduction"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Simple enrichment"}),(0,a.jsx)(n.td,{children:"1,000,000"}),(0,a.jsx)(n.td,{children:"90%"}),(0,a.jsx)(n.td,{children:"1,000,000"}),(0,a.jsx)(n.td,{children:"100,000"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"90%"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Lookup pipeline"}),(0,a.jsx)(n.td,{children:"5,000,000"}),(0,a.jsx)(n.td,{children:"85%"}),(0,a.jsx)(n.td,{children:"5,000,000"}),(0,a.jsx)(n.td,{children:"750,000"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"85%"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Stream transformation"}),(0,a.jsx)(n.td,{children:"10,000,000"}),(0,a.jsx)(n.td,{children:"95%"}),(0,a.jsx)(n.td,{children:"10,000,000"}),(0,a.jsx)(n.td,{children:"500,000"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"95%"})})]})]})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"The compounding effect:"})," Reduced allocations \u2192 Less GC pressure \u2192 Fewer GC pauses \u2192 More throughput \u2192 Lower latency"]}),"\n",(0,a.jsx)(n.h2,{id:"practical-guidelines",children:"Practical Guidelines"}),"\n",(0,a.jsxs)(n.h3,{id:"when-to-use-valuetask-for-transforms",children:["When to Use ",(0,a.jsx)(n.code,{children:"ValueTask"})," for Transforms"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["Use ",(0,a.jsx)(n.code,{children:"ValueTask"})," when:"]})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The transform can complete synchronously in common case"}),"\n",(0,a.jsx)(n.li,{children:"You have a cache, in-memory lookup, or fast path"}),"\n",(0,a.jsx)(n.li,{children:"The synchronous case is likely to happen frequently"}),"\n",(0,a.jsx)(n.li,{children:"You're optimizing for throughput in high-volume scenarios"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["Use ",(0,a.jsx)(n.code,{children:"Task"})," when:"]})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The transform is almost always asynchronous (database queries, network calls every time)"}),"\n",(0,a.jsx)(n.li,{children:"You want simpler code and performance benefit is marginal"}),"\n",(0,a.jsx)(n.li,{children:"You're building a library and want to keep interface simple"}),"\n",(0,a.jsx)(n.li,{children:"The pipeline volume is low enough that allocations don't matter"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"implementation-checklist",children:"Implementation Checklist"}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"Identify fast path:"})," Where can transform return synchronously?"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"Measure fast-path hit rate:"})," Is it worth optimizing? (Usually yes if > 50%)"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsxs)(n.strong,{children:["Implement ",(0,a.jsx)(n.code,{children:"TryGetSynchronousResult()"}),":"]})," Extract synchronous case"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"Benchmark it:"})," Use BenchmarkDotNet to measure allocation reduction"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"Document it:"})," Explain why ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," is used and what fast path is"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"Test both paths:"})," Ensure your code works when fast path returns and when it doesn't"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,a.jsx)(n.h3,{id:"example-1-simple-transformation-always-synchronous",children:"Example 1: Simple Transformation (Always Synchronous)"}),"\n",(0,a.jsxs)(n.p,{children:["If your transform is ",(0,a.jsx)(n.strong,{children:"always"})," synchronous, even simpler:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Transform for simple synchronous calculations.\r\n/// Demonstrates ValueTask for always-synchronous operations.\r\n/// Using ValueTask eliminates Task allocation even for simple calculations.\r\n/// </summary>\r\npublic sealed class SimpleCalculationTransform : TransformNode<int, int>\r\n{\r\n    /// <summary>\r\n    /// Performs square operation on input integer.\r\n    /// Pure synchronous work - no async operations needed.\r\n    /// </summary>\r\n    public override ValueTask<int> ExecuteAsync(\r\n        int item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // No async work at all - direct calculation\r\n        return new ValueTask<int>(item * item);\r\n    }\r\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"example-2-format-transformation-with-optional-fallback",children:"Example 2: Format Transformation with Optional Fallback"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Transform for data formatting with optional fallback.\r\n/// Demonstrates hybrid pattern with local cache and network service.\r\n/// </summary>\r\npublic sealed class DataFormatTransform : TransformNode<RawData, FormattedData>\r\n{\r\n    private readonly IFormatterCache _formatterCache;\r\n    private readonly INetworkFormatterService _networkFormatter;\r\n\r\n    public DataFormatTransform(\r\n        IFormatterCache formatterCache,\r\n        INetworkFormatterService networkFormatter)\r\n    {\r\n        _formatterCache = formatterCache;\r\n        _networkFormatter = networkFormatter;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Formats raw data using cache-first strategy.\r\n    /// Fast path: local cache hit\r\n    /// Slow path: network service call\r\n    /// </summary>\r\n    public override ValueTask<FormattedData> ExecuteAsync(\r\n        RawData item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Try local cache (fast synchronous path)\r\n        if (_formatterCache.TryFormat(item, out var formatted))\r\n        {\r\n            return new ValueTask<FormattedData>(formatted);\r\n        }\r\n\r\n        // Fall back to network service if needed (slow async path)\r\n        return new ValueTask<FormattedData>(\r\n            _networkFormatter.FormatAsync(item, cancellationToken)\r\n        );\r\n    }\r\n}\r\n\r\n// Supporting types for the example\r\npublic record RawData(string Id, string Content);\r\npublic record FormattedData(string Id, string FormattedContent, DateTime ProcessedAt);\r\n\r\n// Interfaces for dependencies\r\npublic interface IFormatterCache\r\n{\r\n    bool TryFormat(RawData data, out FormattedData formatted);\r\n}\r\n\r\npublic interface INetworkFormatterService\r\n{\r\n    Task<FormattedData> FormatAsync(RawData data, CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"\ufe0f-mandatory-valuetask-safety-checklist",children:"\u26a0\ufe0f MANDATORY: ValueTask Safety Checklist"}),"\n",(0,a.jsxs)(n.p,{children:["Before using ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," in any transform, you MUST acknowledge and follow these constraints. Violating these rules leads to undefined behavior, random exceptions, and production crashes that are extremely difficult to debug."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Mandatory Requirements (ALL must be true):"})}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"Single Await Only"}),": You will ",(0,a.jsx)(n.code,{children:"await"})," the result exactly once. Never store and await multiple times."]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"No ConfigureAwait"}),": Your code does not use ",(0,a.jsx)(n.code,{children:".ConfigureAwait(false)"})," or any ConfigureAwait variant."]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"Fast Path Exists"}),": The synchronous case actually occurs frequently (>50%) in your workload. If always async, use ",(0,a.jsx)(n.code,{children:"Task<T>"}),"."]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"Internal or Documented"}),": This is internal implementation detail OR explicitly documented as requiring single-await semantics."]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"Benchmarked"}),": You measured actual performance improvement from ValueTask. Don't optimize without data."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["If ANY of these are false, ",(0,a.jsxs)(n.strong,{children:["use ",(0,a.jsx)(n.code,{children:"Task<T>"})," instead."]})," The framework defaults to ",(0,a.jsx)(n.code,{children:"Task<T>"})," on public APIs for good reason\u2014it's safer."]}),"\n",(0,a.jsx)(n.h3,{id:"the-risks-what-happens-when-you-break-these-rules",children:"The Risks: What Happens When You Break These Rules"}),"\n",(0,a.jsx)(n.h4,{id:"risk-1-multiple-awaits--undefined-behavior",children:"Risk #1: Multiple Awaits = Undefined Behavior"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"The Rule:"})," You can only ",(0,a.jsx)(n.code,{children:"await"})," a ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," exactly once. Multiple awaits on same ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," are undefined behavior and will cause exceptions or incorrect results."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// INCORRECT - DO NOT DO THIS\r\nvar valueTask = GetValueAsync("key");\r\nvar result1 = await valueTask;  // First await - OK\r\nvar result2 = await valueTask;  // Second await - UNDEFINED BEHAVIOR (exception or wrong result)\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Why?"})," The struct-based nature of ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," means its state is mutable. After first await completes, internal state is consumed. A second await has nowhere to go."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Real-world scenario:"})," You implement ValueTask optimization, it works fine. Six months later, someone adds logging:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'var vt = GetValueAsync(key);\r\nlogger.Log($"Starting operation");\r\nvar result = await vt;  // Second implicit await through logging\r\nlogger.Log($"Completed"); // ERROR: You just caused undefined behavior\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Correct usage:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// CORRECT\r\nvar result1 = await GetValueAsync("key");\r\nvar result2 = await GetValueAsync("key"); // Call method again\n'})}),"\n",(0,a.jsx)(n.h3,{id:"never-await-more-than-once",children:"Never Await More Than Once"}),"\n",(0,a.jsx)(n.h4,{id:"risk-2-no-configureawait-support",children:"Risk #2: No ConfigureAwait Support"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"ValueTask<T>"})," does not support ",(0,a.jsx)(n.code,{children:"ConfigureAwait()"}),". If your code requires ",(0,a.jsx)(n.code,{children:"ConfigureAwait(false)"})," for library code or UI synchronization context handling, you cannot use ",(0,a.jsx)(n.code,{children:"ValueTask<T>"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// WRONG - ConfigureAwait not supported on ValueTask\r\nvar result = await GetValueAsync().ConfigureAwait(false);\r\n\r\n// CORRECT if you need ConfigureAwait\r\npublic Task<string> GetValueAsync()\r\n{\r\n    return FetchAsync().ConfigureAwait(false);\r\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"risk-3-always-async-methods-waste-effort",children:"Risk #3: Always-Async Methods Waste Effort"}),"\n",(0,a.jsxs)(n.p,{children:["If your method ",(0,a.jsx)(n.strong,{children:"always"})," performs async work\u2014never returns synchronously\u2014there's no benefit to ",(0,a.jsx)(n.code,{children:"ValueTask<T>"}),". The wrapper adds complexity without any allocation savings."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// WRONG - Always async, so no benefit\r\npublic ValueTask<int> ComputeExpensiveAsync()\r\n{\r\n    return new ValueTask<int>(ExpensiveComputationAsync());\r\n}\r\n\r\n// CORRECT - Use Task for always async operations\r\npublic Task<int> ComputeExpensiveAsync()\r\n{\r\n    return ExpensiveComputationAsync();\r\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"risk-4-public-apis-need-safe-defaults",children:"Risk #4: Public APIs Need Safe Defaults"}),"\n",(0,a.jsxs)(n.p,{children:["Public APIs that external callers will use should default to ",(0,a.jsx)(n.code,{children:"Task<T>"}),". External callers might not understand ValueTask constraints, and can easily violate the single-await rule, creating subtle bugs in their code."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// If this is internal or well-documented, ValueTask is acceptable\r\ninternal ValueTask<int> GetItemAsync(string key)\r\n{\r\n    // Internal implementation - documented constraints are fine\r\n}\r\n\r\n// If this is public, prefer Task<T> for API stability\r\npublic Task<int> GetItemAsync(string key)\r\n{\r\n    // Simpler contract, no surprise constraints for external callers\r\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"recommended-implement-executevaluetaskasync-for-optimization",children:"Recommended: Implement ExecuteValueTaskAsync for Optimization"}),"\n",(0,a.jsx)(n.p,{children:"NPipeline provides a two-method pattern that gets you all the ValueTask performance benefits WITHOUT exposing ValueTask constraints to callers:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"The Pattern:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'public sealed class OptimizedTransform : TransformNode<Order, Order>\r\n{\r\n    // Keep public method returning Task<T> for API stability\r\n    public override Task<Order> ExecuteAsync(Order item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        return FromValueTask(ExecuteValueTaskAsync(item, context, cancellationToken));\r\n    }\r\n\r\n    // Override ExecuteValueTaskAsync for optimized implementation\r\n    protected internal override ValueTask<Order> ExecuteValueTaskAsync(Order item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Safe to use ValueTask here - it\'s internal-facing\r\n        // No single-await constraint risk for external callers\r\n        // Execution strategies automatically use this when available\r\n        \r\n        if (item.Total < 0)\r\n            throw new ArgumentException("Total must be non-negative");\r\n\r\n        return ValueTask.FromResult(item);\r\n    }\r\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Benefits of this approach:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"You get 90% of the performance win"})," - Execution strategies automatically detect and use ",(0,a.jsx)(n.code,{children:"ExecuteValueTaskAsync"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"No ValueTask constraints exposed"})," - ",(0,a.jsx)(n.code,{children:"ExecuteAsync"})," returns ",(0,a.jsx)(n.code,{children:"Task<T>"}),", so external callers don't see ValueTask limitations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"API stability"})," - Public contract stays the same; optimization is an implementation detail"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Automatic detection"})," - Framework handles routing to the ValueTask path transparently"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["See ",(0,a.jsx)(n.a,{href:"/docs/core-concepts/best-practices",children:"Principle 6b: Optimize Synchronous Transforms with ValueTask"})," for a complete example."]}),"\n",(0,a.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Hygiene"})," - Comprehensive performance best practices"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts/nodes/transform-nodes",children:"Transform Nodes"})," - Node implementation details and ValueTask optimization patterns"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/architecture/optimization-principles",children:"Optimization Principles"})," - Understanding why ValueTask improves performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../../samples/Sample_HighPerformanceTransform/",children:"Sample: High-Performance Transforms"})," - Complete working example"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/execution-strategies",children:"Execution Strategies"})," - How ValueTask integrates with execution strategies"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling Guide"})," - Error handling with ValueTask patterns"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Hygiene"})," - Comprehensive performance best practices"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts/nodes/transform-nodes",children:"Transform Nodes"})," - Node implementation details and ValueTask optimization patterns"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/architecture/optimization-principles",children:"Optimization Principles"})," - Understanding why ValueTask improves performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../../samples/Sample_HighPerformanceTransform/",children:"Sample: High-Performance Transforms"})," - Complete working example"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/execution-strategies",children:"Execution Strategies"})," - How ValueTask integrates with execution strategies"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var s=r(96540);const a={},t=s.createContext(a);function i(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);