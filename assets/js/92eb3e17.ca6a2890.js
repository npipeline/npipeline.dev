"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3523],{8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>s});var i=r(6540);const t={},a=i.createContext(t);function o(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(a.Provider,{value:n},e.children)}},9220:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-concepts/best-practices","title":"Best Practices","description":"Design principles and recommendations for building robust NPipeline pipelines.","source":"@site/docs/core-concepts/best-practices.md","sourceDirName":"core-concepts","slug":"/core-concepts/best-practices","permalink":"/docs/core-concepts/best-practices","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"title":"Best Practices","description":"Design principles and recommendations for building robust NPipeline pipelines.","sidebar_position":9},"sidebar":"docsSidebar","previous":{"title":"Streaming vs. Buffering","permalink":"/docs/core-concepts/streaming-vs-buffering"},"next":{"title":"Pipeline Validation Extensions - Usage Guide","permalink":"/docs/core-concepts/pipeline-validation"}}');var t=r(4848),a=r(8453);const o={title:"Best Practices",description:"Design principles and recommendations for building robust NPipeline pipelines.",sidebar_position:9},s="Best Practices",l={},c=[{value:"Principle 1: Single Responsibility",id:"principle-1-single-responsibility",level:2},{value:"\u2714\ufe0f Good Example",id:"heavy_check_mark-good-example",level:3},{value:"\u274c Avoid: God Nodes",id:"x-avoid-god-nodes",level:3},{value:"Principle 2: Dependency Injection",id:"principle-2-dependency-injection",level:2},{value:"\u2714\ufe0f Good Example",id:"heavy_check_mark-good-example-1",level:3},{value:"Principle 3: Handle Errors Explicitly",id:"principle-3-handle-errors-explicitly",level:2},{value:"\u2714\ufe0f Good Example",id:"heavy_check_mark-good-example-2",level:3},{value:"Principle 4: Stream Data Efficiently",id:"principle-4-stream-data-efficiently",level:2},{value:"\u2714\ufe0f Good Example",id:"heavy_check_mark-good-example-3",level:3},{value:"\u274c Avoid: Loading All Data Into Memory",id:"x-avoid-loading-all-data-into-memory",level:3},{value:"Principle 5: Make Nodes Testable",id:"principle-5-make-nodes-testable",level:2},{value:"\u2714\ufe0f Good Example",id:"heavy_check_mark-good-example-4",level:3},{value:"Principle 6: Use Appropriate Execution Strategies",id:"principle-6-use-appropriate-execution-strategies",level:2},{value:"\u2714\ufe0f Good Example",id:"heavy_check_mark-good-example-5",level:3},{value:"Principle 6b: Optimize Synchronous Transforms with ValueTask",id:"principle-6b-optimize-synchronous-transforms-with-valuetask",level:2},{value:"\u2714\ufe0f Synchronous Transform Optimization",id:"heavy_check_mark-synchronous-transform-optimization",level:3},{value:"Principle 7: Monitor and Log Appropriately",id:"principle-7-monitor-and-log-appropriately",level:2},{value:"\u2714\ufe0f Good Example",id:"heavy_check_mark-good-example-6",level:3},{value:"Principle 8: Design for Failure",id:"principle-8-design-for-failure",level:2},{value:"\u2714\ufe0f Good Example",id:"heavy_check_mark-good-example-7",level:3},{value:"Principle 9: Document Your Pipelines",id:"principle-9-document-your-pipelines",level:2},{value:"\u2714\ufe0f Good Example",id:"heavy_check_mark-good-example-8",level:3},{value:"Principle 10: Profile and Optimize",id:"principle-10-profile-and-optimize",level:2},{value:"Performance Optimization Checklist",id:"performance-optimization-checklist",level:3},{value:"Summary of Best Practices",id:"summary-of-best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"best-practices",children:"Best Practices"})}),"\n",(0,t.jsx)(n.p,{children:"This guide provides design principles and recommendations for building robust, maintainable, and performant NPipeline pipelines."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Looking for implementation examples?"})," See ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/common-patterns",children:"Common Patterns"})," for practical code recipes demonstrating these principles in action."]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Principle-focused."}),' This guide answers the "why" - the reasoning and principles behind building good pipelines.',(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Implementation-focused"})," guides like ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/common-patterns",children:"Common Patterns"}),' show you the "how" with working code examples.']}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"principle-1-single-responsibility",children:"Principle 1: Single Responsibility"}),"\n",(0,t.jsx)(n.p,{children:"Each node should have a single, well-defined responsibility. This makes nodes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Easier to understand and maintain"}),"\n",(0,t.jsx)(n.li,{children:"More reusable across pipelines"}),"\n",(0,t.jsx)(n.li,{children:"Simpler to test"}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"heavy_check_mark-good-example",children:["\u2714\ufe0f"," Good Example"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Focused transform that only validates prices\r\npublic sealed class PriceValidator : TransformNode<Product, Product>\r\n{\r\n    public override Task<Product> ExecuteAsync(Product item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        if (item.Price < 0)\r\n            throw new InvalidOperationException("Price cannot be negative");\r\n        return Task.FromResult(item);\r\n    }\r\n}\r\n\r\n// Separate transform for tax calculations\r\npublic sealed class TaxCalculator : TransformNode<Product, Product>\r\n{\r\n    public override Task<Product> ExecuteAsync(Product item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        item.Tax = item.Price * 0.08m;\r\n        return Task.FromResult(item);\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"x-avoid-god-nodes",children:["\u274c"," Avoid: God Nodes"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// BAD: Node doing validation, tax calculation, formatting, and logging\r\npublic sealed class MegaTransform : TransformNode<Product, Product>\r\n{\r\n    public override async Task<Product> ExecuteAsync(Product item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Validation logic\r\n        if (item.Price < 0) throw new InvalidOperationException();\r\n\r\n        // Tax calculation\r\n        item.Tax = item.Price * 0.08m;\r\n\r\n        // Formatting\r\n        item.FormattedName = FormatName(item.Name);\r\n\r\n        // Logging\r\n        await LogAsync(item);\r\n\r\n        return item;\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"principle-2-dependency-injection",children:"Principle 2: Dependency Injection"}),"\n",(0,t.jsx)(n.p,{children:"Use dependency injection to manage external dependencies like services, loggers, and configuration."}),"\n",(0,t.jsxs)(n.h3,{id:"heavy_check_mark-good-example-1",children:["\u2714\ufe0f"," Good Example"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public sealed class EnrichedTransform : TransformNode<Customer, EnrichedCustomer>\r\n{\r\n    private readonly IEmailService _emailService;\r\n    private readonly ILogger<EnrichedTransform> _logger;\r\n\r\n    // Dependencies injected via constructor\r\n    public EnrichedTransform(IEmailService emailService, ILogger<EnrichedTransform> logger)\r\n    {\r\n        _emailService = emailService;\r\n        _logger = logger;\r\n    }\r\n\r\n    public override async Task<EnrichedCustomer> ExecuteAsync(Customer item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        _logger.LogInformation($"Processing customer: {item.Id}");\r\n        var isValid = await _emailService.ValidateEmailAsync(item.Email, cancellationToken);\r\n        return new EnrichedCustomer(item.Id, item.Name, item.Email, isValid);\r\n    }\r\n}\r\n\r\n// Register with DI container\r\nvar services = new ServiceCollection();\r\nservices.AddNPipeline(Assembly.GetExecutingAssembly());\r\nservices.AddSingleton<IEmailService, EmailService>();\r\nservices.AddLogging();\n'})}),"\n",(0,t.jsx)(n.h2,{id:"principle-3-handle-errors-explicitly",children:"Principle 3: Handle Errors Explicitly"}),"\n",(0,t.jsx)(n.p,{children:"Don't let errors propagate silently. Handle them explicitly or route them appropriately."}),"\n",(0,t.jsxs)(n.h3,{id:"heavy_check_mark-good-example-2",children:["\u2714\ufe0f"," Good Example"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public sealed class ResilientTransform : TransformNode<Order, ProcessedOrder>\r\n{\r\n    public override async Task<ProcessedOrder> ExecuteAsync(Order item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        try\r\n        {\r\n            // Attempt the operation\r\n            return await ProcessOrderAsync(item, cancellationToken);\r\n        }\r\n        catch (OperationCanceledException)\r\n        {\r\n            // Re-throw cancellation - don\'t swallow it\r\n            throw;\r\n        }\r\n        catch (InvalidOperationException ex)\r\n        {\r\n            // Log validation errors\r\n            Console.WriteLine($"Validation failed for order {item.Id}: {ex.Message}");\r\n            throw;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            // Log unexpected errors\r\n            Console.WriteLine($"Unexpected error processing order {item.Id}: {ex}");\r\n            throw;\r\n        }\r\n    }\r\n\r\n    private async Task<ProcessedOrder> ProcessOrderAsync(Order item, CancellationToken cancellationToken)\r\n    {\r\n        // Actual processing logic\r\n        await Task.CompletedTask;\r\n        return new ProcessedOrder(item.Id, item.Total);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"principle-4-stream-data-efficiently",children:"Principle 4: Stream Data Efficiently"}),"\n",(0,t.jsx)(n.p,{children:"Process data as it flows; don't load entire datasets into memory."}),"\n",(0,t.jsxs)(n.h3,{id:"heavy_check_mark-good-example-3",children:["\u2714\ufe0f"," Good Example"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public sealed class StreamingSourceNode : SourceNode<Customer>\r\n{\r\n    public override IDataPipe<Customer> Initialize(PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        static IAsyncEnumerable<Customer> GetCustomersAsync(string connectionString, CancellationToken ct)\r\n        {\r\n            return Get();\r\n\r\n            // Use async enumerable to stream data from database\r\n            async IAsyncEnumerable<Customer> Get()\r\n            {\r\n                using var connection = new SqlConnection(connectionString);\r\n                await connection.OpenAsync(ct);\r\n\r\n                using var command = connection.CreateCommand();\r\n                command.CommandText = "SELECT * FROM Customers";\r\n\r\n                using var reader = await command.ExecuteReaderAsync(ct);\r\n                while (await reader.ReadAsync(ct))\r\n                {\r\n                    yield return new Customer(\r\n                        (int)reader["Id"],\r\n                        (string)reader["Name"]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return new StreamingDataPipe<Customer>(\r\n            GetCustomersAsync(_connectionString, cancellationToken));\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"x-avoid-loading-all-data-into-memory",children:["\u274c"," Avoid: Loading All Data Into Memory"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// BAD: Loading all data before streaming\r\npublic sealed class BadSourceNode : SourceNode<Customer>\r\n{\r\n    public override IDataPipe<Customer> Initialize(PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // This loads ALL customers into memory at once!\r\n        var allCustomers = new List<Customer>();\r\n        using var connection = new SqlConnection(_connectionString);\r\n        // Note: This is still BAD synchronously - don't block on async I/O!\r\n        // connection.Open();\r\n\r\n        // ... read all customers into list ...\r\n\r\n        return new StreamingDataPipe<Customer>(\r\n            allCustomers.ToAsyncEnumerable());\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"principle-5-make-nodes-testable",children:"Principle 5: Make Nodes Testable"}),"\n",(0,t.jsx)(n.p,{children:"Design nodes that are easy to unit test using NPipeline's testing utilities."}),"\n",(0,t.jsxs)(n.h3,{id:"heavy_check_mark-good-example-4",children:["\u2714\ufe0f"," Good Example"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public sealed class DiscountCalculator : TransformNode<Order, Order>\r\n{\r\n    private readonly decimal _discountRate;\r\n\r\n    public DiscountCalculator(decimal discountRate = 0.1m)\r\n    {\r\n        _discountRate = discountRate;\r\n    }\r\n\r\n    public override Task<Order> ExecuteAsync(Order item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        item.DiscountAmount = item.Total * _discountRate;\r\n        return Task.FromResult(item);\r\n    }\r\n}\r\n\r\n// Test it easily\r\npublic class DiscountCalculatorTests\r\n{\r\n    [Fact]\r\n    public async Task AppliesCorrectDiscountRate()\r\n    {\r\n        // Arrange\r\n        var transform = new DiscountCalculator(discountRate: 0.1m);\r\n        var order = new Order(1, 100m);\r\n        var context = PipelineContext.Default;\r\n\r\n        // Act\r\n        var result = await transform.ExecuteAsync(order, context, CancellationToken.None);\r\n\r\n        // Assert\r\n        Assert.Equal(10m, result.DiscountAmount);\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"principle-6-use-appropriate-execution-strategies",children:"Principle 6: Use Appropriate Execution Strategies"}),"\n",(0,t.jsx)(n.p,{children:"Choose the right execution strategy (sequential, parallel, batched) for each node based on its nature."}),"\n",(0,t.jsxs)(n.h3,{id:"heavy_check_mark-good-example-5",children:["\u2714\ufe0f"," Good Example"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// CPU-bound work - good candidate for parallelism\r\npublic sealed class ExpensiveTransform : TransformNode<Data, Result>\r\n{\r\n    public override Task<Result> ExecuteAsync(Data item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Heavy computation\r\n        var result = PerformExpensiveCalculation(item);\r\n        return Task.FromResult(result);\r\n    }\r\n}\r\n\r\n// Use parallelism extension for CPU-bound work\r\nvar pipeline = new PipelineBuilder()\r\n    .AddSource<DataSource, Data>()\r\n    .AddTransform<ExpensiveTransform, Data, Result>()\r\n    .WithParallelism(degreeOfParallelism: Environment.ProcessorCount)\r\n    .AddSink<ResultSink, Result>();\n"})}),"\n",(0,t.jsx)(n.h2,{id:"principle-6b-optimize-synchronous-transforms-with-valuetask",children:"Principle 6b: Optimize Synchronous Transforms with ValueTask"}),"\n",(0,t.jsxs)(n.p,{children:["For synchronous transforms in hot paths, override ",(0,t.jsx)(n.code,{children:"ExecuteValueTaskAsync"})," to eliminate Task allocation overhead."]}),"\n",(0,t.jsxs)(n.h3,{id:"heavy_check_mark-synchronous-transform-optimization",children:["\u2714\ufe0f"," Synchronous Transform Optimization"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Synchronous transform optimized with ValueTask\r\npublic sealed class FastValidation : TransformNode<Order, Order>\r\n{\r\n    public override Task<Order> ExecuteAsync(Order item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Delegate to ValueTask implementation\r\n        return FromValueTask(ExecuteValueTaskAsync(item, context, cancellationToken));\r\n    }\r\n\r\n    protected internal override ValueTask<Order> ExecuteValueTaskAsync(Order item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // No Task allocation - synchronous work\r\n        if (item.Total < 0)\r\n            throw new ArgumentException("Total must be non-negative");\r\n\r\n        return ValueTask.FromResult(item);\r\n    }\r\n}\r\n\r\n// Execution strategies automatically detect and use the ValueTask path\r\nvar pipeline = new PipelineBuilder()\r\n    .AddSource<OrderSource, Order>()\r\n    .AddTransform<FastValidation, Order, Order>()  // Uses ValueTask path automatically\r\n    .AddSink<ResultSink, Order>();\n'})}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"/docs/advanced-topics/synchronous-fast-paths",children:"Synchronous Fast Paths"})," for detailed guidance on when and how to use this optimization."]}),"\n",(0,t.jsx)(n.h2,{id:"principle-7-monitor-and-log-appropriately",children:"Principle 7: Monitor and Log Appropriately"}),"\n",(0,t.jsx)(n.p,{children:"Instrument your pipelines with logging at appropriate levels."}),"\n",(0,t.jsxs)(n.h3,{id:"heavy_check_mark-good-example-6",children:["\u2714\ufe0f"," Good Example"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public sealed class MonitoredTransform : TransformNode<Order, ProcessedOrder>\r\n{\r\n    private readonly ILogger<MonitoredTransform> _logger;\r\n\r\n    public MonitoredTransform(ILogger<MonitoredTransform> logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    public override async Task<ProcessedOrder> ExecuteAsync(Order item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        _logger.LogDebug("Starting processing for order {OrderId}", item.Id);\r\n\r\n        try\r\n        {\r\n            var result = await ProcessAsync(item, cancellationToken);\r\n            _logger.LogInformation("Successfully processed order {OrderId}", item.Id);\r\n            return result;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Failed to process order {OrderId}", item.Id);\r\n            throw;\r\n        }\r\n    }\r\n\r\n    private async Task<ProcessedOrder> ProcessAsync(Order item, CancellationToken cancellationToken)\r\n    {\r\n        await Task.CompletedTask;\r\n        return new ProcessedOrder(item.Id, item.Total);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"principle-8-design-for-failure",children:"Principle 8: Design for Failure"}),"\n",(0,t.jsx)(n.p,{children:"Anticipate failures and design recovery mechanisms."}),"\n",(0,t.jsxs)(n.h3,{id:"heavy_check_mark-good-example-7",children:["\u2714\ufe0f"," Good Example"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public sealed class ResilientSink : SinkNode<Data>\r\n{\r\n    private readonly ILogger<ResilientSink> _logger;\r\n\r\n    public ResilientSink(ILogger<ResilientSink> logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    public override async Task ExecuteAsync(IDataPipe<Data> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        var successCount = 0;\r\n        var failureCount = 0;\r\n\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            try\r\n            {\r\n                await SaveItemAsync(item, cancellationToken);\r\n                successCount++;\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                failureCount++;\r\n                _logger.LogError(ex, "Failed to save item, continuing with next item");\r\n                // Continue processing rather than failing completely\r\n            }\r\n        }\r\n\r\n        _logger.LogInformation("Processing complete. Successful: {Success}, Failed: {Failed}", successCount, failureCount);\r\n    }\r\n\r\n    private async Task SaveItemAsync(Data item, CancellationToken cancellationToken)\r\n    {\r\n        await Task.CompletedTask;\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"principle-9-document-your-pipelines",children:"Principle 9: Document Your Pipelines"}),"\n",(0,t.jsx)(n.p,{children:"Clearly document the purpose, inputs, and outputs of your pipelines and nodes."}),"\n",(0,t.jsxs)(n.h3,{id:"heavy_check_mark-good-example-8",children:["\u2714\ufe0f"," Good Example"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'/// <summary>\r\n/// Processes customer orders by validating prices, calculating taxes, and enriching with regional data.\r\n/// </summary>\r\n/// <remarks>\r\n/// Input: Raw order data from CSV\r\n/// Output: Processed orders with tax and region information\r\n/// Error handling: Invalid prices are logged and skipped\r\n/// </remarks>\r\npublic sealed class OrderProcessingPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        // Implementation\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// Validates order prices are within acceptable ranges.\r\n/// </summary>\r\n/// <exception cref="InvalidOperationException">Thrown when price is negative or exceeds limit</exception>\r\npublic sealed class PriceValidator : TransformNode<Order, Order>\r\n{\r\n    public override Task<Order> ExecuteAsync(Order item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Implementation\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"principle-10-profile-and-optimize",children:"Principle 10: Profile and Optimize"}),"\n",(0,t.jsx)(n.p,{children:"Identify bottlenecks before optimizing."}),"\n",(0,t.jsx)(n.h3,{id:"performance-optimization-checklist",children:"Performance Optimization Checklist"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\u2714\ufe0f"," Use profiling tools to identify actual bottlenecks"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2714\ufe0f"," Measure before and after optimizations"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2714\ufe0f"," Consider memory usage, not just speed"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2714\ufe0f"," Evaluate parallelism trade-offs"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2714\ufe0f"," Use appropriate batch sizes for I/O operations"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2714\ufe0f"," Minimize allocations in hot paths"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2714\ufe0f"," Cache expensive computations appropriately"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary-of-best-practices",children:"Summary of Best Practices"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Practice"}),(0,t.jsx)(n.th,{children:"Benefit"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Single Responsibility"}),(0,t.jsx)(n.td,{children:"Easier to understand, test, and maintain"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Dependency Injection"}),(0,t.jsx)(n.td,{children:"Flexible, testable, decoupled code"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Explicit Error Handling"}),(0,t.jsx)(n.td,{children:"Reliable, debuggable pipelines"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Efficient Streaming"}),(0,t.jsx)(n.td,{children:"Lower memory usage, higher throughput"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Testability"}),(0,t.jsx)(n.td,{children:"Confidence in correctness"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Appropriate Execution Strategy"}),(0,t.jsx)(n.td,{children:"Optimal performance"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"ValueTask Optimization"}),(0,t.jsx)(n.td,{children:"Reduced allocations in hot paths"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Monitoring & Logging"}),(0,t.jsx)(n.td,{children:"Visibility and debuggability"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Failure Design"}),(0,t.jsx)(n.td,{children:"Resilient, production-ready pipelines"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Documentation"}),(0,t.jsx)(n.td,{children:"Easier adoption and maintenance"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Profiling"}),(0,t.jsx)(n.td,{children:"Data-driven optimization"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/common-patterns",children:"Common Patterns"})}),": See these practices in action with practical examples"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/extensions/testing",children:"Testing Pipelines"})}),": Learn how to test your pipelines effectively"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling"})}),": Implement robust error handling in your pipelines"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);