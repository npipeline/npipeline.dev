"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[1118],{670:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>s,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"core-concepts/pipeline-execution/error-handling","title":"Error Handling","description":"Overview of error handling in NPipeline including node-level and pipeline-level error handling, retry configuration, circuit breakers, and dead-letter queues.","source":"@site/docs/core-concepts/pipeline-execution/error-handling.md","sourceDirName":"core-concepts/pipeline-execution","slug":"/core-concepts/pipeline-execution/error-handling","permalink":"/npipeline.dev/docs/core-concepts/pipeline-execution/error-handling","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Error Handling","description":"Overview of error handling in NPipeline including node-level and pipeline-level error handling, retry configuration, circuit breakers, and dead-letter queues.","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Execution Strategies","permalink":"/npipeline.dev/docs/core-concepts/pipeline-execution/execution-strategies"},"next":{"title":"Node-level Error Handling","permalink":"/npipeline.dev/docs/core-concepts/pipeline-execution/node-error-handling"}}');var o=n(4848),t=n(8453);const l={title:"Error Handling",description:"Overview of error handling in NPipeline including node-level and pipeline-level error handling, retry configuration, circuit breakers, and dead-letter queues.",sidebar_position:4},a="Error Handling",s={},d=[{value:"Default Error Behavior",id:"default-error-behavior",level:2},{value:"Types of Errors",id:"types-of-errors",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Error Handling Flow",id:"error-handling-flow",level:3},{value:"Error Handling Components",id:"error-handling-components",level:2},{value:"Node-level Error Handling",id:"node-level-error-handling",level:3},{value:"Pipeline-level Error Handling",id:"pipeline-level-error-handling",level:3},{value:"Retry Configuration",id:"retry-configuration",level:3},{value:"Circuit Breaker Configuration",id:"circuit-breaker-configuration",level:3},{value:"Dead-Letter Queues",id:"dead-letter-queues",level:3},{value:"Basic Error Handling Configuration",id:"basic-error-handling-configuration",level:2},{value:"Complete Example: Production-Ready Error Handling",id:"complete-example-production-ready-error-handling",level:2}];function c(e){const r={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"error-handling",children:"Error Handling"})}),"\n",(0,o.jsx)(r.p,{children:"Robust error handling is critical for building reliable data pipelines. NPipeline provides several mechanisms to manage errors that occur during data processing, allowing you to gracefully recover, retry operations, or isolate problematic data."}),"\n",(0,o.jsx)(r.h2,{id:"default-error-behavior",children:"Default Error Behavior"}),"\n",(0,o.jsx)(r.p,{children:"By default, if an unhandled exception occurs within a node during pipeline execution, the exception will propagate up the call stack, potentially halting the entire pipeline. While this behavior is suitable for critical errors that should stop processing immediately, it's often desirable to handle errors more selectively without bringing down the entire system."}),"\n",(0,o.jsx)(r.h2,{id:"types-of-errors",children:"Types of Errors"}),"\n",(0,o.jsx)(r.p,{children:"Errors in NPipeline can generally be categorized by their source and impact:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Node-Specific Errors"}),": Exceptions originating from logic within a specific ",(0,o.jsx)(r.code,{children:"ISourceNode"}),", ",(0,o.jsx)(r.code,{children:"ITransformNode"}),", or ",(0,o.jsx)(r.code,{children:"ISinkNode"}),"."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Data-Related Errors"}),": Issues caused by the data itself (e.g., invalid format, missing values) that a node attempts to process."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Infrastructure Errors"}),": Problems related to external dependencies like databases, APIs, or network connectivity."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Cancellation"}),': While not strictly an "error," a ',(0,o.jsx)(r.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken",children:(0,o.jsx)(r.code,{children:"CancellationToken"})})," can signal an intentional halt to processing, which nodes should handle gracefully."]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,o.jsx)(r.p,{children:"NPipeline distinguishes between two levels of error handling:"}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Node-level Error Handling"}),": Deals with errors that occur while processing an individual item within a specific node. You define what happens to that item (e.g., skip, retry, redirect to dead-letter)."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Pipeline-level Error Handling"}),": Deals with more severe errors that might affect an entire node's stream or the pipeline's execution flow (e.g., restarting a failing node, failing the entire pipeline)."]}),"\n"]}),"\n",(0,o.jsx)(r.h3,{id:"error-handling-flow",children:"Error Handling Flow"}),"\n",(0,o.jsx)(r.mermaid,{value:"flowchart TD\r\n    A[Item Processing Starts] --\x3e B{Error Occurs?}\r\n    B --\x3e|No| C[Continue Processing]\r\n    B --\x3e|Yes| D[Error Handler Invoked]\r\n\r\n    D --\x3e E{Error Type}\r\n    E --\x3e|Node-level<br>&#40;Item Error&#41;| F[INodeErrorHandler]\r\n    E --\x3e|Pipeline-level<br>&#40;Stream Error&#41;| G[IPipelineErrorHandler]\r\n\r\n    %% Node-level Error Handling\r\n    F --\x3e H{NodeErrorDecision}\r\n    H --\x3e|Retry| I[Retry Item]\r\n    H --\x3e|Skip| J[Discard Item]\r\n    H --\x3e|Redirect| K[Send to Dead Letter]\r\n    H --\x3e|Fail| L[Pipeline Failure]\r\n\r\n    I --\x3e M{Max Retries Reached?}\r\n    M --\x3e|No| B\r\n    M --\x3e|Yes| N{Circuit Breaker Active?}\r\n    N --\x3e|No| O[Increment Failure Count]\r\n    N --\x3e|Yes| P[Pipeline Abort]\r\n    O --\x3e Q{Failure Threshold Reached?}\r\n    Q --\x3e|No| H\r\n    Q --\x3e|Yes| P\r\n\r\n    %% Pipeline-level Error Handling\r\n    G --\x3e R{PipelineErrorDecision}\r\n    R --\x3e|Restart Node| S[Restart Node Stream]\r\n    R --\x3e|Continue Without Node| T[Bypass Node]\r\n    R --\x3e|Fail Pipeline| L\r\n\r\n    S --\x3e U{Max Node Restarts Reached?}\r\n    U --\x3e|No| V[Materialize Stream<br>if Needed]\r\n    U --\x3e|Yes| W{Circuit Breaker Active?}\r\n    W --\x3e|No| X[Increment Failure Count]\r\n    W --\x3e|Yes| P\r\n    X --\x3e Y{Failure Threshold Reached?}\r\n    Y --\x3e|No| R\r\n    Y --\x3e|Yes| P\r\n\r\n    V --\x3e Z[Restart Processing]\r\n    Z --\x3e B\r\n\r\n    %% Dead Letter Processing\r\n    K --\x3e AA[Dead Letter Sink]\r\n    AA --\x3e AB[Log Error Details]\r\n    AB --\x3e AC[Store Failed Item]\r\n    AC --\x3e C\r\n\r\n    %% Outcomes\r\n    C --\x3e AD[Next Item]\r\n    J --\x3e AD\r\n    T --\x3e AE[Continue Pipeline<br>Without Node]\r\n    L --\x3e AF[Pipeline Terminates]\r\n    P --\x3e AF\r\n\r\n    %% Styling\r\n    classDef nodeError fill:#ffe6e6,stroke:#ff6666,stroke-width:2px\r\n    classDef pipelineError fill:#e6f3ff,stroke:#66aaff,stroke-width:2px\r\n    classDef decision fill:#fff2cc,stroke:#ffcc00,stroke-width:2px\r\n    classDef outcome fill:#e6ffe6,stroke:#66cc66,stroke-width:2px\r\n    classDef circuitBreaker fill:#ffcccc,stroke:#ff0000,stroke-width:2px\r\n\r\n    class F,H,I,J,K,L nodeError\r\n    class G,R,S,T,W pipelineError\r\n    class B,E,M,N,Q,U,W,Y decision\r\n    class C,AD,AE,AF outcome\r\n    class N,P,W circuitBreaker"}),"\n",(0,o.jsx)(r.p,{children:(0,o.jsx)(r.em,{children:"Figure: Error handling flow in NPipeline showing the decision tree for both node-level and pipeline-level error handling, including retry logic, circuit breaker behavior, and dead letter queue routing."})}),"\n",(0,o.jsx)(r.h2,{id:"error-handling-components",children:"Error Handling Components"}),"\n",(0,o.jsx)(r.h3,{id:"node-level-error-handling",children:"Node-level Error Handling"}),"\n",(0,o.jsx)(r.p,{children:"Node-level error handling allows you to manage errors that occur while processing individual items within a specific node. This granular approach enables you to define what happens to each problematic item without affecting the entire pipeline."}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Learn more:"})," ",(0,o.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/node-error-handling",children:"Node-level Error Handling"})]}),"\n",(0,o.jsx)(r.h3,{id:"pipeline-level-error-handling",children:"Pipeline-level Error Handling"}),"\n",(0,o.jsx)(r.p,{children:"Pipeline-level error handling is designed to manage errors that affect an entire node's stream rather than individual items. These are typically more severe errors that might impact the entire pipeline execution flow, such as infrastructure failures or external service outages."}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Learn more:"})," ",(0,o.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/pipeline-error-handling",children:"Pipeline-level Error Handling"})]}),"\n",(0,o.jsx)(r.h3,{id:"retry-configuration",children:"Retry Configuration"}),"\n",(0,o.jsx)(r.p,{children:"Retry configuration allows you to define how the pipeline should respond to transient failures by retrying operations. This is essential for building resilient pipelines that can recover from temporary issues without manual intervention."}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Learn more:"})," ",(0,o.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/retry-configuration",children:"Retry Configuration"})]}),"\n",(0,o.jsx)(r.h3,{id:"circuit-breaker-configuration",children:"Circuit Breaker Configuration"}),"\n",(0,o.jsx)(r.p,{children:"Circuit breaker configuration allows you to implement circuit breaker pattern to prevent constantly failing nodes from continuously consuming resources or causing cascading failures throughout your pipeline. The CircuitBreaker implementation provides:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Complete State Machine"}),": Three states (Closed, Open, Half-Open) with automatic transitions"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Rolling Window Tracking"}),": Time-based operation tracking for sophisticated failure analysis"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Multiple Threshold Types"}),": ConsecutiveFailures, RollingWindowCount, RollingWindowRate, and Hybrid"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Automatic Recovery"}),": Timer-based transition from Open to Half-Open state"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Thread Safety"}),": Safe for concurrent pipeline execution"]}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Learn more:"})," ",(0,o.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/circuit-breaker-configuration",children:"Circuit Breaker Configuration"})]}),"\n",(0,o.jsx)(r.h3,{id:"dead-letter-queues",children:"Dead-Letter Queues"}),"\n",(0,o.jsx)(r.p,{children:"Dead-letter queues provide a mechanism to capture and store items that repeatedly fail processing, allowing you to analyze and potentially reprocess problematic data outside the main pipeline flow."}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Learn more:"})," ",(0,o.jsx)(r.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/dead-letter-queues",children:"Dead-Letter Queues"})]}),"\n",(0,o.jsx)(r.h2,{id:"basic-error-handling-configuration",children:"Basic Error Handling Configuration"}),"\n",(0,o.jsx)(r.p,{children:"To get started with error handling, you can configure basic error handling directly in your pipeline definition:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.ErrorHandling;\r\nusing NPipeline.Pipeline;\r\n\r\n// Example 1: Basic error handling with default retry options\r\npublic sealed class ErrorHandlingPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<DataSource, string>();\r\n        var transformHandle = builder.AddTransform<DataTransform, string, string>();\r\n        var sinkHandle = builder.AddSink<DataSink, string>();\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n\r\n        // Configure retry options using PipelineRetryOptions\r\n        builder.WithRetryOptions(new PipelineRetryOptions(\r\n            MaxItemRetries: 3,\r\n            MaxNodeRestartAttempts: 2,\r\n            MaxSequentialNodeAttempts: 5\r\n        ));\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var runner = new PipelineRunner();\r\n        var context = PipelineContext.Default;\r\n\r\n        var pipeline = PipelineBuilder.Create<ErrorHandlingPipelineDefinition>();\r\n        await runner.RunAsync<ErrorHandlingPipelineDefinition>(context);\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(r.h2,{id:"complete-example-production-ready-error-handling",children:"Complete Example: Production-Ready Error Handling"}),"\n",(0,o.jsx)(r.p,{children:"Here's a complete example that combines all error handling concepts:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.ErrorHandling;\r\nusing NPipeline.Pipeline;\r\n\r\n// 1. Define custom error handlers\r\npublic class ProductionNodeErrorHandler : INodeErrorHandler<ITransformNode<string, string>, string>\r\n{\r\n    private readonly ILogger _logger;\r\n    private readonly IMetrics _metrics;\r\n\r\n    public ProductionNodeErrorHandler(ILogger logger, IMetrics metrics)\r\n    {\r\n        _logger = logger;\r\n        _metrics = metrics;\r\n    }\r\n\r\n    public Task<NodeErrorDecision> HandleAsync(\r\n        ITransformNode<string, string> node,\r\n        string failedItem,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        _metrics.Increment("node_errors", new[] { new KeyValuePair<string, object>("node_type", node.GetType().Name) });\r\n        _logger.LogError(error, "Error processing item in node {NodeName}", node.Name);\r\n\r\n        return error switch\r\n        {\r\n            ValidationException => Task.FromResult(NodeErrorDecision.DeadLetter),\r\n            TimeoutException => Task.FromResult(NodeErrorDecision.Retry),\r\n            HttpRequestException => Task.FromResult(NodeErrorDecision.Retry),\r\n            _ => Task.FromResult(NodeErrorDecision.Skip)\r\n        };\r\n    }\r\n}\r\n\r\npublic class ProductionPipelineErrorHandler : IPipelineErrorHandler\r\n{\r\n    private readonly ILogger _logger;\r\n    private readonly Dictionary<string, int> _failureCounts = new();\r\n\r\n    public ProductionPipelineErrorHandler(ILogger logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        _failureCounts.TryGetValue(nodeId, out var count);\r\n        _failureCounts[nodeId] = count + 1;\r\n\r\n        _logger.LogError(error, "Node {NodeId} failed (attempt {Attempt})", nodeId, _failureCounts[nodeId]);\r\n\r\n        return error switch\r\n        {\r\n            OutOfMemoryException => Task.FromResult(PipelineErrorDecision.FailPipeline),\r\n            _ when _failureCounts[nodeId] < 3 => Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            _ => Task.FromResult(PipelineErrorDecision.ContinueWithoutNode)\r\n        };\r\n    }\r\n}\r\n\r\n// 2. Configure the pipeline with comprehensive error handling\r\npublic sealed class ProductionPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<DataSource, string>();\r\n        var transformHandle = builder.AddTransform<DataTransform, string, string>();\r\n        var sinkHandle = builder.AddSink<DataSink, string>();\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n\r\n        // Configure retry options\r\n        builder.WithRetryOptions(new PipelineRetryOptions(\r\n            MaxItemRetries: 3,\r\n            MaxNodeRestartAttempts: 2,\r\n            MaxSequentialNodeAttempts: 5\r\n        ));\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var runner = new PipelineRunner();\r\n\r\n        // Configure retry options at context level\r\n        var retryOptions = new PipelineRetryOptions(\r\n            MaxItemRetries: 3,\r\n            MaxNodeRestartAttempts: 2,\r\n            MaxSequentialNodeAttempts: 5\r\n        );\r\n\r\n        var context = PipelineContext.WithRetry(retryOptions);\r\n\r\n        var pipeline = PipelineBuilder.Create<ProductionPipelineDefinition>();\r\n        \r\n        // Configure error handlers through the pipeline runner or register via dependency injection\r\n        // The PipelineErrorHandler can be registered in the service container:\r\n        var serviceProvider = new ServiceCollection()\r\n            .AddSingleton<IPipelineErrorHandler, ProductionPipelineErrorHandler>()\r\n            .AddSingleton<INodeErrorHandler<ITransformNode<string, string>, string>, ProductionNodeErrorHandler>()\r\n            .AddSingleton<IDeadLetterSink, FileDeadLetterSink>()\r\n            .BuildServiceProvider();\r\n\r\n        var runner = new PipelineRunner();\r\n        await runner.RunAsync<ProductionPipelineDefinition>(context);\r\n    }\r\n}\r\n\r\n## Retry Options Precedence\r\n\r\nNPipeline follows a clear precedence order when determining which retry options to use:\r\n\r\n1. **Node-specific options**: Options set directly on a specific node using `WithRetryOptions(nodeHandle, options)`\r\n2. **Graph-level options**: Options set at the pipeline level using `builder.WithRetryOptions(options)`\r\n3. **Context-level options**: Options provided through `PipelineContext(retryOptions: options)`\r\n\r\nThis hierarchy allows for fine-grained control where you can:\r\n* Override retry behavior for specific nodes that need special handling\r\n* Set default behavior for the entire pipeline\r\n* Provide runtime options through the context\r\n\r\n## Propagating Contextual Information\r\n\r\nThe [`PipelineContext`](../../../src/NPipeline/PipelineContext.cs) can be invaluable for error handling. You can store error-specific information, such as correlation IDs, loggers, or even error reporting services, within the context, making them accessible to any node that needs to handle or report an error.\r\n\r\n## :warning:  Dependency Chain Requirements\r\n\r\nFor resilience features like `PipelineErrorDecision.RestartNode` to work properly, you must understand the dependency chain between components. See [Dependency Chains](../resilience/dependency-chains.md) in the resilience section for detailed prerequisites.\r\n\r\n## :information_source: See Also\r\n\r\n* **[Resilience Overview](../resilience/index.md)**: Comprehensive guide to building fault-tolerant pipelines\r\n* **[Dependency Chains](../resilience/dependency-chains.md)**: Understanding critical prerequisite relationships for resilience features\r\n* **[Configuration Guide](../resilience/configuration-guide.md)**: Practical implementation guidance with code examples\r\n* **[Troubleshooting](../resilience/troubleshooting.md)**: Diagnose and resolve common resilience issues\r\n* **[Error Codes Reference](../../reference/error-codes.md)**: Complete reference for NPipeline error codes and their solutions\r\n\r\n## :link: Related Topics\r\n\r\n* **[Pipeline Execution Index](index.md)**: Return to the pipeline execution overview.\r\n\n'})})]})}function p(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>a});var i=n(6540);const o={},t=i.createContext(o);function l(e){const r=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),i.createElement(t.Provider,{value:r},e.children)}}}]);