"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[6254],{4971:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"core-concepts/resilience/error-handling","title":"Error Handling in NPipeline","description":"Comprehensive guide to error handling at both node and pipeline levels in NPipeline","source":"@site/docs/core-concepts/resilience/error-handling.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/error-handling","permalink":"/docs/core-concepts/resilience/error-handling","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Error Handling in NPipeline","description":"Comprehensive guide to error handling at both node and pipeline levels in NPipeline","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Resilience Overview","permalink":"/docs/core-concepts/resilience/"},"next":{"title":"Resilience Quick Start","permalink":"/docs/core-concepts/resilience/getting-started"}}');var o=r(4848),t=r(8453);const s={title:"Error Handling in NPipeline",description:"Comprehensive guide to error handling at both node and pipeline levels in NPipeline",sidebar_position:1},l="Error Handling in NPipeline",a={},d=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Overview",id:"overview",level:2},{value:"Choosing Your Error Handling Approach",id:"choosing-your-error-handling-approach",level:2},{value:"Error Handling Levels",id:"error-handling-levels",level:2},{value:"Node-Level Error Handling",id:"node-level-error-handling",level:3},{value:"INodeErrorHandler Interface",id:"inodeerrorhandler-interface",level:4},{value:"NodeErrorDecision",id:"nodeerrordecision",level:4},{value:"Implementing a Custom Node Error Handler",id:"implementing-a-custom-node-error-handler",level:4},{value:"Registering a Node Error Handler",id:"registering-a-node-error-handler",level:4},{value:"Common Node Error Handling Scenarios",id:"common-node-error-handling-scenarios",level:4},{value:"Pipeline-Level Error Handling",id:"pipeline-level-error-handling",level:3},{value:"IPipelineErrorHandler Interface",id:"ipipelineerrorhandler-interface",level:4},{value:"PipelineErrorDecision",id:"pipelineerrordecision",level:4},{value:"Implementing a Custom Pipeline Error Handler",id:"implementing-a-custom-pipeline-error-handler",level:4},{value:"Registering a Pipeline Error Handler",id:"registering-a-pipeline-error-handler",level:4},{value:"Common Pipeline Error Handling Scenarios",id:"common-pipeline-error-handling-scenarios",level:4},{value:"Error Flow Diagram",id:"error-flow-diagram",level:3},{value:"Configuration Examples",id:"configuration-examples",level:2},{value:"Basic Error Handling Configuration",id:"basic-error-handling-configuration",level:3},{value:"Production-Ready Error Handling Example",id:"production-ready-error-handling-example",level:3},{value:"Retry Options Precedence",id:"retry-options-precedence",level:3},{value:"Propagating Contextual Information",id:"propagating-contextual-information",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Node-level Error Handling Best Practices",id:"node-level-error-handling-best-practices",level:3},{value:"Pipeline-level Error Handling Best Practices",id:"pipeline-level-error-handling-best-practices",level:3},{value:"\u26a0\ufe0f Dependency Chain Requirements",id:"warning-dependency-chain-requirements",level:2},{value:"See Also",id:"see-also",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"error-handling-in-npipeline",children:"Error Handling in NPipeline"})}),"\n",(0,o.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsx)(n.p,{children:"Before understanding error handling, you should be familiar with:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts",children:"Core Concepts Overview"})," - Basic NPipeline concepts and terminology"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/nodes/",children:"Nodes Overview"})," - Understanding the node types where errors occur"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/pipelinebuilder",children:"PipelineBuilder"})," - How to configure error handling in pipeline construction"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/execution-strategies",children:"Execution Strategies"})," - How error handling integrates with execution"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:"Robust error handling is critical for building reliable data pipelines. NPipeline provides several mechanisms to manage errors that occur during data processing, allowing you to gracefully recover, retry operations, or isolate problematic data."}),"\n",(0,o.jsx)(n.p,{children:"By default, if an unhandled exception occurs within a node during pipeline execution, the exception will propagate up the call stack, potentially halting the entire pipeline. While this behavior is suitable for critical errors that should stop processing immediately, it's often desirable to handle errors more selectively without bringing down the entire system."}),"\n",(0,o.jsx)(n.p,{children:"Errors in NPipeline can generally be categorized by their source and impact:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Node-Specific Errors"}),": Exceptions originating from logic within a specific ",(0,o.jsx)(n.code,{children:"ISourceNode"}),", ",(0,o.jsx)(n.code,{children:"ITransformNode"}),", or ",(0,o.jsx)(n.code,{children:"ISinkNode"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Data-Related Errors"}),": Issues caused by the data itself (e.g., invalid format, missing values) that a node attempts to process."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Infrastructure Errors"}),": Problems related to external dependencies like databases, APIs, or network connectivity."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Cancellation"}),': While not strictly an "error," a ',(0,o.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken",children:(0,o.jsx)(n.code,{children:"CancellationToken"})})," can signal an intentional halt to processing, which nodes should handle gracefully."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"NPipeline distinguishes between two levels of error handling:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Node-level Error Handling"}),": Deals with errors that occur while processing an individual item within a specific node. You define what happens to that item (e.g., skip, retry, redirect to dead-letter)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Pipeline-level Error Handling"}),": Deals with more severe errors that might affect an entire node's stream or the pipeline's execution flow (e.g., restarting a failing node, failing the entire pipeline)."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"choosing-your-error-handling-approach",children:"Choosing Your Error Handling Approach"}),"\n",(0,o.jsx)(n.mermaid,{value:"graph TD\n    A[I need to handle errors] --\x3e B{What type of errors?}\n    B --\x3e|Individual item failures| C[Use NODE-LEVEL ERROR HANDLING]\n    B --\x3e|Entire stream/node failures| D[Use PIPELINE-LEVEL ERROR HANDLING]\n    B --\x3e|Both types of errors| E[Implement BOTH LEVELS]\n    \n    C --\x3e F{What should happen to failed items?}\n    F --\x3e|Retry and continue| G[NodeErrorDecision.Retry<br>Configure MaxItemRetries]\n    F --\x3e|Skip and continue| H[NodeErrorDecision.Skip<br>Log and continue]\n    F --\x3e|Redirect for review| I[NodeErrorDecision.DeadLetter<br>Configure dead-letter sink]\n    F --\x3e|Stop processing| J[NodeErrorDecision.Fail<br>Terminate pipeline]\n    \n    D --\x3e K{What should happen to failed nodes?}\n    K --\x3e|Restart and retry| L[PipelineErrorDecision.RestartNode<br>Configure MaxNodeRestartAttempts]\n    K --\x3e|Continue without node| M[PipelineErrorDecision.ContinueWithoutNode<br>Bypass failed component]\n    K --\x3e|Stop entire pipeline| N[PipelineErrorDecision.FailPipeline<br>Terminate all processing]\n    \n    E --\x3e O[Combine node and pipeline error handling]\n    O --\x3e P[Implement INodeErrorHandler<br>for item-level errors]\n    O --\x3e Q[Implement IPipelineErrorHandler<br>for stream-level errors]\n    P --\x3e R[Configure ResilientExecutionStrategy]\n    Q --\x3e R"}),"\n",(0,o.jsx)(n.p,{children:"This decision tree helps you determine the appropriate error handling approach based on your specific needs:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Node-level Error Handling"})," for individual item failures:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Retry"})," transient errors (network issues, temporary resource constraints)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Skip"})," non-critical errors or malformed data"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dead Letter"})," problematic items for later analysis"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Fail"})," when errors indicate critical system issues"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Pipeline-level Error Handling"})," for entire stream/node failures:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Restart Node"})," when failures are transient and recoverable"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Continue Without Node"})," when the node is non-critical to overall operation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Fail Pipeline"})," when errors indicate system-wide problems"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Combined Approach"})," when you need to handle both individual item and stream-level errors"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"error-handling-levels",children:"Error Handling Levels"}),"\n",(0,o.jsx)(n.h3,{id:"node-level-error-handling",children:"Node-Level Error Handling"}),"\n",(0,o.jsx)(n.p,{children:"Node-level error handling in NPipeline allows you to manage errors that occur while processing individual items within a specific node. This granular approach enables you to define what happens to each problematic item without affecting the entire pipeline."}),"\n",(0,o.jsxs)(n.p,{children:["When an error occurs during the processing of an individual item in a node, NPipeline's error handling mechanism invokes the appropriate ",(0,o.jsx)(n.code,{children:"INodeErrorHandler"})," to determine how to proceed. This allows you to implement strategies like retrying the item, skipping it, or redirecting it to a dead-letter queue."]}),"\n",(0,o.jsx)(n.h4,{id:"inodeerrorhandler-interface",children:"INodeErrorHandler Interface"}),"\n",(0,o.jsxs)(n.p,{children:["To handle errors within a specific node, you implement ",(0,o.jsx)(n.a,{href:"../../../src/NPipeline/Abstractions/ErrorHandling/INodeErrorHandler.cs",children:(0,o.jsx)(n.code,{children:"INodeErrorHandler<in TNode, in TData>"})})," interface."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public interface INodeErrorHandler\n{\n}\n\n/// <summary>\n///     Defines the contract for handling errors that occur within a specific node.\n/// </summary>\n/// <typeparam name="TNode">The type of node where the error occurred.</typeparam>\n/// <typeparam name="TData">The type of the data item that failed.</typeparam>\npublic interface INodeErrorHandler<in TNode, in TData> : INodeErrorHandler where TNode : INode\n{\n    /// <summary>\n    ///     Handles an error that occurred during node execution.\n    /// </summary>\n    /// <param name="node">The instance of node that failed.</param>\n    /// <param name="failedItem">The data item that caused the error.</param>\n    /// <param name="error">The exception that was thrown.</param>\n    /// <param name="context">The current pipeline context.</param>\n    /// <param name="cancellationToken">A token to observe for cancellation requests.</param>\n    /// <returns>A <see cref="NodeErrorDecision" /> indicating how to proceed.</returns>\n    Task<NodeErrorDecision> HandleAsync(\n        TNode node,\n        TData failedItem,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken);\n}\n'})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"INodeErrorHandler"})}),": Marker interface for dependency injection registration of node error handlers."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"INodeErrorHandler<in TNode, in TData>"})}),": Generic interface that inherits from the marker interface and defines the actual error handling logic."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"TNode"})}),": The type of node where the error occurred."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"TData"})}),": The type of the data item that caused the error."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"HandleAsync"})}),": This method is called when an error occurs. It receives the failing node, item, exception, and pipeline context. It must return a ",(0,o.jsx)(n.code,{children:"NodeErrorDecision"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"nodeerrordecision",children:"NodeErrorDecision"}),"\n",(0,o.jsx)(n.p,{children:"This enum dictates how the pipeline should proceed after a node-level error:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"Skip"})}),": The failed item is discarded, and the pipeline continues processing subsequent items."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"Retry"})}),": The pipeline attempts to re-process the failed item. The number of retries is configured via ",(0,o.jsx)(n.code,{children:"PipelineRetryOptions"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"DeadLetter"})}),": The failed item is sent to a configured dead-letter sink, and the pipeline continues."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"Fail"})}),": The pipeline immediately terminates with an exception."]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"implementing-a-custom-node-error-handler",children:"Implementing a Custom Node Error Handler"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Nodes;\nusing NPipeline.Pipeline;\n\n/// <summary>\n/// Custom node error handler for transform nodes processing string data.\n/// Demonstrates error classification and appropriate response strategies.\n/// </summary>\npublic sealed class MyNodeErrorHandler : INodeErrorHandler<ITransformNode<string, string>, string>\n{\n    private readonly ILogger _logger;\n\n    public MyNodeErrorHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles errors that occur during string transformation.\n    /// Implements different strategies based on error type for optimal recovery.\n    /// </summary>\n    public Task<NodeErrorDecision> HandleAsync(\n        ITransformNode<string, string> node,\n        string failedItem,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Log error with full context for troubleshooting\n        _logger.LogError(error, \"Error in node '{NodeName}' processing '{FailedItem}': {ErrorMessage}\",\n            node.Name, failedItem, error.Message);\n\n        // Choose error handling strategy based on exception type\n        return error switch\n        {\n            // Data format errors are permanent - send to dead letter queue\n            FormatException => Task.FromResult(NodeErrorDecision.DeadLetter),\n            \n            // Items marked for retry get another chance\n            _ when failedItem.Contains(\"retry\") => Task.FromResult(NodeErrorDecision.Retry),\n            \n            // All other errors are skipped to continue processing\n            _ => Task.FromResult(NodeErrorDecision.Skip)\n        };\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"registering-a-node-error-handler",children:"Registering a Node Error Handler"}),"\n",(0,o.jsxs)(n.p,{children:["You register a node error handler for a specific node using the ",(0,o.jsx)(n.code,{children:"WithErrorHandler"})," method on ",(0,o.jsx)(n.code,{children:"PipelineBuilder"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\npublic sealed class ErrorHandlingPipelineDefinition : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var sourceHandle = builder.AddSource<DataSource, string>();\n        var transformHandle = builder.AddTransform<DataTransform, string, string>();\n        var sinkHandle = builder.AddSink<DataSink, string>();\n\n        builder.Connect(sourceHandle, transformHandle);\n        builder.Connect(transformHandle, sinkHandle);\n\n        // Configure retry options\n        builder.WithRetryOptions(new PipelineRetryOptions(\n            MaxItemRetries: 3,\n            MaxNodeRestartAttempts: 2,\n            MaxSequentialNodeAttempts: 5\n        ));\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"You also need to register your custom error handler with your DI container:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"services.AddSingleton<INodeErrorHandler<ITransformNode<string, string>, string>, MyNodeErrorHandler>();\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The marker interface ",(0,o.jsx)(n.code,{children:"INodeErrorHandler"})," (non-generic version) is used for dependency injection registration purposes, allowing the DI container to discover all node error handler implementations."]}),"\n",(0,o.jsx)(n.h4,{id:"common-node-error-handling-scenarios",children:"Common Node Error Handling Scenarios"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Scenario 1: Handling Transient Network Errors"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public class NetworkErrorHandler : INodeErrorHandler<IApiTransformNode, string>\n{\n    private readonly ILogger _logger;\n    private int _retryCount = 0;\n\n    public NetworkErrorHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles network errors with exponential backoff retry strategy.\n    /// Transient errors are retried, persistent failures are redirected.\n    /// </summary>\n    public Task<NodeErrorDecision> HandleAsync(\n        IApiTransformNode node,\n        string failedItem,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Handle network-related errors specifically\n        if (error is HttpRequestException httpEx)\n        {\n            _retryCount++;\n            _logger.LogWarning("Network error (attempt {RetryCount}): {ErrorMessage}", \n                _retryCount, httpEx.Message);\n\n            // Retry up to 3 times for transient network errors\n            if (_retryCount <= 3)\n            {\n                return Task.FromResult(NodeErrorDecision.Retry);\n            }\n            else\n            {\n                // After max retries, reset counter and redirect to dead letter\n                _retryCount = 0;\n                return Task.FromResult(NodeErrorDecision.DeadLetter);\n            }\n        }\n\n        // Non-network errors are skipped to continue processing\n        return Task.FromResult(NodeErrorDecision.Skip);\n    }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Scenario 2: Data Validation Errors"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public class ValidationErrorHandler : INodeErrorHandler<IValidatorNode, string>\n{\n    private readonly ILogger _logger;\n\n    public ValidationErrorHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles validation errors by redirecting to dead letter queue.\n    /// Data quality issues are logged separately from system errors.\n    /// </summary>\n    public Task<NodeErrorDecision> HandleAsync(\n        IValidatorNode node,\n        string failedItem,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Handle validation errors specifically\n        if (error is ValidationException validationEx)\n        {\n            _logger.LogWarning("Validation failed for item: {Item}. Error: {Error}", \n                failedItem, validationEx.Message);\n\n            // Validation failures indicate data quality issues - redirect for manual review\n            return Task.FromResult(NodeErrorDecision.DeadLetter);\n        }\n\n        // Other types of errors are skipped to continue processing\n        return Task.FromResult(NodeErrorDecision.Skip);\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"pipeline-level-error-handling",children:"Pipeline-Level Error Handling"}),"\n",(0,o.jsx)(n.p,{children:"Pipeline-level error handling in NPipeline is designed to manage errors that affect an entire node's stream rather than individual items. These are typically more severe errors that might impact the entire pipeline execution flow, such as infrastructure failures or external service outages."}),"\n",(0,o.jsxs)(n.p,{children:["When an error occurs that affects an entire node's stream (e.g., an external service going down), NPipeline's ",(0,o.jsx)(n.code,{children:"ResilientExecutionStrategy"})," consults the configured ",(0,o.jsx)(n.code,{children:"IPipelineErrorHandler"})," to determine how to react to such failures. This allows you to implement strategies like restarting a failing node, continuing without it, or failing the entire pipeline."]}),"\n",(0,o.jsx)(n.h4,{id:"ipipelineerrorhandler-interface",children:"IPipelineErrorHandler Interface"}),"\n",(0,o.jsxs)(n.p,{children:["For errors that affect an entire node's stream, you implement ",(0,o.jsx)(n.a,{href:"../../../src/NPipeline/Abstractions/ErrorHandling/IPipelineErrorHandler.cs",children:(0,o.jsx)(n.code,{children:"IPipelineErrorHandler"})})," interface."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public interface IPipelineErrorHandler\n{\n    Task<PipelineErrorDecision> HandleNodeFailureAsync(\n        string nodeId,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken);\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"pipelineerrordecision",children:"PipelineErrorDecision"}),"\n",(0,o.jsx)(n.p,{children:"This enum defines the decision when a node stream fails:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"RestartNode"})}),": The node's entire input stream will be re-processed from the beginning (requires the input stream to be replayable, e.g., if materialized by ",(0,o.jsx)(n.code,{children:"ResilientExecutionStrategy"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"ContinueWithoutNode"})}),": The failing node is effectively removed from the pipeline, and its output stream will be empty. The pipeline continues without it."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"FailPipeline"})}),": The entire pipeline execution terminates."]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"implementing-a-custom-pipeline-error-handler",children:"Implementing a Custom Pipeline Error Handler"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\n/// <summary>\n/// Pipeline-level error handler for managing node failures.\n/// Demonstrates circuit breaker pattern and restart logic.\n/// </summary>\npublic sealed class MyPipelineErrorHandler : IPipelineErrorHandler\n{\n    private readonly ILogger _logger;\n    private readonly Dictionary<string, int> _nodeRestartAttempts = new();\n\n    public MyPipelineErrorHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles node-level failures that affect entire stream processing.\n    /// Implements circuit breaker pattern to prevent infinite restart loops.\n    /// </summary>\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n        string nodeId,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Track restart attempts for each node\n        _nodeRestartAttempts.TryGetValue(nodeId, out var attempts);\n        attempts++;\n        _nodeRestartAttempts[nodeId] = attempts;\n\n        // Log failure with context for monitoring\n        _logger.LogError(error, \"Pipeline-level error in node '{NodeId}': {ErrorMessage}\",\n            nodeId, error.Message);\n\n        // Implement circuit breaker pattern - limit restart attempts\n        if (attempts < 3)\n        {\n            _logger.LogInformation(\"Attempting to restart node '{NodeId}'. Attempt: {Attempt}\",\n                nodeId, attempts);\n            return Task.FromResult(PipelineErrorDecision.RestartNode);\n        }\n        else\n        {\n            _logger.LogError(\"Node '{NodeId}' failed too many times, failing pipeline.\", nodeId);\n            return Task.FromResult(PipelineErrorDecision.FailPipeline);\n        }\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"registering-a-pipeline-error-handler",children:"Registering a Pipeline Error Handler"}),"\n",(0,o.jsxs)(n.p,{children:["You register a pipeline error handler using the ",(0,o.jsx)(n.code,{children:"AddPipelineErrorHandler"})," method on ",(0,o.jsx)(n.code,{children:"PipelineBuilder"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\npublic sealed class ErrorHandlingPipelineDefinition : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var sourceHandle = builder.AddSource<DataSource, string>();\n        var transformHandle = builder.AddTransform<DataTransform, string, string>();\n        var sinkHandle = builder.AddSink<DataSink, string>();\n\n        builder.Connect(sourceHandle, transformHandle);\n        builder.Connect(transformHandle, sinkHandle);\n\n        // Configure retry options\n        builder.WithRetryOptions(new PipelineRetryOptions(\n            MaxItemRetries: 3,\n            MaxNodeRestartAttempts: 2,\n            MaxSequentialNodeAttempts: 5\n        ));\n\n        // Register the pipeline error handler\n        builder.AddPipelineErrorHandler<MyPipelineErrorHandler>();\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"You also need to register your custom error handler with your DI container:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"services.AddSingleton<IPipelineErrorHandler, MyPipelineErrorHandler>();\n"})}),"\n",(0,o.jsx)(n.h4,{id:"common-pipeline-error-handling-scenarios",children:"Common Pipeline Error Handling Scenarios"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Scenario 1: Resource Exhaustion Handling"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\n/// <summary>\n/// Pipeline definition with basic error handling configuration.\n/// Demonstrates how to configure retry options at pipeline level.\n/// </summary>\npublic sealed class ErrorHandlingPipelineDefinition : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        // Add nodes to pipeline\n        var sourceHandle = builder.AddSource<DataSource, string>("data_source");\n        var transformHandle = builder.AddTransform<DataTransform, string, string>("data_transform");\n        var sinkHandle = builder.AddSink<DataSink, string>("data_sink");\n\n        // Connect nodes to define data flow\n        builder.Connect(sourceHandle, transformHandle);\n        builder.Connect(transformHandle, sinkHandle);\n\n        // Configure retry options for resilience\n        // These settings control how many times items/nodes can be retried\n        builder.WithRetryOptions(new PipelineRetryOptions(\n            MaxItemRetries: 3,           // Retry individual items up to 3 times\n            MaxNodeRestartAttempts: 2,     // Allow node to restart up to 2 times\n            MaxSequentialNodeAttempts: 5     // Limit sequential attempts to prevent infinite loops\n        ));\n    }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Scenario 2: External Service Dependency Handling"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\n/// <summary>\n/// Node error handler for network-related operations.\n/// Demonstrates transient error handling with retry logic.\n/// </summary>\npublic class NetworkErrorHandler : INodeErrorHandler<IApiTransformNode, string>\n{\n    private readonly ILogger _logger;\n    private int _retryCount = 0;\n\n    public NetworkErrorHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles network errors with exponential backoff retry strategy.\n    /// Transient errors are retried, persistent failures are redirected.\n    /// </summary>\n    public Task<NodeErrorDecision> HandleAsync(\n        IApiTransformNode node,\n        string failedItem,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Handle network-related errors specifically\n        if (error is HttpRequestException httpEx)\n        {\n            _retryCount++;\n            _logger.LogWarning("Network error (attempt {RetryCount}): {ErrorMessage}", \n                _retryCount, httpEx.Message);\n\n            // Retry up to 3 times for transient network errors\n            if (_retryCount <= 3)\n            {\n                return Task.FromResult(NodeErrorDecision.Retry);\n            }\n            else\n            {\n                // After max retries, reset counter and redirect to dead letter\n                _retryCount = 0;\n                return Task.FromResult(NodeErrorDecision.DeadLetter);\n            }\n        }\n\n        // Non-network errors are skipped to continue processing\n        return Task.FromResult(NodeErrorDecision.Skip);\n    }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Scenario 3: Data Validation Errors"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\n/// <summary>\n/// Node error handler for data validation scenarios.\n/// Demonstrates how to handle data quality issues separately from system errors.\n/// </summary>\npublic class ValidationErrorHandler : INodeErrorHandler<IValidatorNode, string>\n{\n    private readonly ILogger _logger;\n\n    public ValidationErrorHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles validation errors by redirecting to dead letter queue.\n    /// Data quality issues are logged separately from system errors.\n    /// </summary>\n    public Task<NodeErrorDecision> HandleAsync(\n        IValidatorNode node,\n        string failedItem,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Handle validation errors specifically\n        if (error is ValidationException validationEx)\n        {\n            _logger.LogWarning("Validation failed for item: {Item}. Error: {Error}", \n                failedItem, validationEx.Message);\n\n            // Validation failures indicate data quality issues - redirect for manual review\n            return Task.FromResult(NodeErrorDecision.DeadLetter);\n        }\n\n        // Other types of errors are skipped to continue processing\n        return Task.FromResult(NodeErrorDecision.Skip);\n    }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Scenario 4: Resource Exhaustion Handling"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\n/// <summary>\n/// Pipeline error handler for resource exhaustion scenarios.\n/// Demonstrates critical error handling for system resource issues.\n/// </summary>\npublic class ResourceExhaustionHandler : IPipelineErrorHandler\n{\n    private readonly ILogger _logger;\n    private readonly Dictionary<string, int> _nodeFailureCounts = new();\n\n    public ResourceExhaustionHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles resource exhaustion by failing fast to prevent system damage.\n    /// Critical resource errors should immediately terminate processing.\n    /// </summary>\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n        string nodeId,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Track failure count for each node\n        _nodeFailureCounts.TryGetValue(nodeId, out var count);\n        _nodeFailureCounts[nodeId] = count + 1;\n\n        // Handle critical resource errors immediately\n        if (error is OutOfMemoryException or InsufficientMemoryException)\n        {\n            _logger.LogCritical(\"Resource exhaustion in node '{NodeId}': {Error}\", nodeId, error.Message);\n            return Task.FromResult(PipelineErrorDecision.FailPipeline);\n        }\n\n        // For other errors, allow limited restarts\n        if (_nodeFailureCounts[nodeId] <= 3)\n        {\n            _logger.LogWarning(\"Restarting node '{NodeId}' (attempt {Attempt})\", \n                nodeId, _nodeFailureCounts[nodeId]);\n            return Task.FromResult(PipelineErrorDecision.RestartNode);\n        }\n\n        // Too many failures - continue without the problematic node\n        _logger.LogError(\"Node '{NodeId}' failed too many times, continuing without it\", nodeId);\n        return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Scenario 5: Production-ready Node Error Handler with Metrics Integration"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\n/// <summary>\n/// Production-ready node error handler with metrics integration.\n/// Demonstrates comprehensive error handling with observability.\n/// </summary>\npublic class ProductionNodeErrorHandler : INodeErrorHandler<ITransformNode<string, string>, string>\n{\n    private readonly ILogger _logger;\n    private readonly IMetrics _metrics;\n\n    public ProductionNodeErrorHandler(ILogger logger, IMetrics metrics)\n    {\n        _logger = logger;\n        _metrics = metrics;\n    }\n\n    /// <summary>\n    /// Handles errors with comprehensive logging and metrics collection.\n    /// Enables monitoring and alerting for production environments.\n    /// </summary>\n    public Task<NodeErrorDecision> HandleAsync(\n        ITransformNode<string, string> node,\n        string failedItem,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Record error metrics for monitoring\n        _metrics.Increment("node_errors", new[] { \n            new KeyValuePair<string, object>("node_type", node.GetType().Name),\n            new KeyValuePair<string, object>("error_type", error.GetType().Name)\n        });\n\n        // Log error with full context\n        _logger.LogError(error, "Error processing item in node {NodeName}", node.Name);\n\n        // Implement error handling strategy based on exception type\n        return error switch\n        {\n            // Data validation errors - redirect to dead letter\n            ValidationException => Task.FromResult(NodeErrorDecision.DeadLetter),\n            \n            // Transient errors - retry\n            TimeoutException => Task.FromResult(NodeErrorDecision.Retry),\n            HttpRequestException => Task.FromResult(NodeErrorDecision.Retry),\n            \n            // All other errors - skip\n            _ => Task.FromResult(NodeErrorDecision.Skip)\n        };\n    }\n}\n\n/// <summary>\n/// Production-ready pipeline error handler with circuit breaker pattern.\n/// Demonstrates sophisticated error handling for production environments.\n/// </summary>\npublic class ProductionPipelineErrorHandler : IPipelineErrorHandler\n{\n    private readonly ILogger _logger;\n    private readonly Dictionary<string, int> _failureCounts = new();\n\n    public ProductionPipelineErrorHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles node failures with circuit breaker pattern.\n    /// Prevents cascading failures by limiting restart attempts.\n    /// </summary>\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n        string nodeId,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Track failure count for circuit breaker logic\n        _failureCounts.TryGetValue(nodeId, out var count);\n        _failureCounts[nodeId] = count + 1;\n\n        // Log failure for monitoring\n        _logger.LogError(error, "Node {NodeId} failed (attempt {Attempt})", \n            nodeId, _failureCounts[nodeId]);\n\n        // Implement circuit breaker based on error type and count\n        return error switch\n        {\n            // Critical resource errors - fail immediately\n            OutOfMemoryException => Task.FromResult(PipelineErrorDecision.FailPipeline),\n            \n            // Transient errors - allow limited restarts\n            _ when _failureCounts[nodeId] < 3 => Task.FromResult(PipelineErrorDecision.RestartNode),\n            \n            // Persistent failures - continue without node\n            _ => Task.FromResult(PipelineErrorDecision.ContinueWithoutNode)\n        };\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"error-flow-diagram",children:"Error Flow Diagram"}),"\n",(0,o.jsx)(n.mermaid,{value:"flowchart TD\n    A[Item Processing Starts] --\x3e B{Error Occurs?}\n    B --\x3e|No| C[Continue Processing]\n    B --\x3e|Yes| D[Error Handler Invoked]\n\n    D --\x3e E{Error Type}\n    E --\x3e|Node-level<br>&#40;Item Error&#41;| F[INodeErrorHandler]\n    E --\x3e|Pipeline-level<br>&#40;Stream Error&#41;| G[IPipelineErrorHandler]\n\n    %% Node-level Error Handling\n    F --\x3e H{NodeErrorDecision}\n    H --\x3e|Retry| I[Retry Item]\n    H --\x3e|Skip| J[Discard Item]\n    H --\x3e|Redirect| K[Send to Dead Letter]\n    H --\x3e|Fail| L[Pipeline Failure]\n\n    I --\x3e M{Max Retries Reached?}\n    M --\x3e|No| B\n    M --\x3e|Yes| N{Circuit Breaker Active?}\n    N --\x3e|No| O[Increment Failure Count]\n    N --\x3e|Yes| P[Pipeline Abort]\n    O --\x3e Q{Failure Threshold Reached?}\n    Q --\x3e|No| H\n    Q --\x3e|Yes| P\n\n    %% Pipeline-level Error Handling\n    G --\x3e R{PipelineErrorDecision}\n    R --\x3e|Restart Node| S[Restart Node Stream]\n    R --\x3e|Continue Without Node| T[Bypass Node]\n    R --\x3e|Fail Pipeline| L\n\n    S --\x3e U{Max Node Restarts Reached?}\n    U --\x3e|No| V[Materialize Stream<br>if Needed]\n    U --\x3e|Yes| W{Circuit Breaker Active?}\n    W --\x3e|No| X[Increment Failure Count]\n    W --\x3e|Yes| P\n    X --\x3e Y{Failure Threshold Reached?}\n    Y --\x3e|No| R\n    Y --\x3e|Yes| P\n\n    V --\x3e Z[Restart Processing]\n    Z --\x3e B\n\n    %% Dead Letter Processing\n    K --\x3e AA[Dead Letter Sink]\n    AA --\x3e AB[Log Error Details]\n    AB --\x3e AC[Store Failed Item]\n    AC --\x3e C\n\n    %% Outcomes\n    C --\x3e AD[Next Item]\n    J --\x3e AD\n    T --\x3e AE[Continue Pipeline<br>Without Node]\n    L --\x3e AF[Pipeline Terminates]\n    P --\x3e AF\n\n    %% Styling\n    classDef nodeError fill:#ffe6e6,stroke:#ff6666,stroke-width:2px\n    classDef pipelineError fill:#e6f3ff,stroke:#66aaff,stroke-width:2px\n    classDef decision fill:#fff2cc,stroke:#ffcc00,stroke-width:2px\n    classDef outcome fill:#e6ffe6,stroke:#66cc66,stroke-width:2px\n    classDef circuitBreaker fill:#ffcccc,stroke:#ff0000,stroke-width:2px\n\n    class F,H,I,J,K,L nodeError\n    class G,R,S,T,W pipelineError\n    class B,E,M,N,Q,U,W,Y decision\n    class C,AD,AE,AF outcome\n    class N,P,W circuitBreaker"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Figure: Error handling flow in NPipeline showing the decision tree for both node-level and pipeline-level error handling, including retry logic, circuit breaker behavior, and dead letter queue routing."})}),"\n",(0,o.jsx)(n.h2,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,o.jsx)(n.h3,{id:"basic-error-handling-configuration",children:"Basic Error Handling Configuration"}),"\n",(0,o.jsx)(n.p,{children:"To get started with error handling, you can configure basic error handling directly in your pipeline definition:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\n// Example 1: Basic error handling with default retry options\npublic sealed class ErrorHandlingPipelineDefinition : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var sourceHandle = builder.AddSource<DataSource, string>();\n        var transformHandle = builder.AddTransform<DataTransform, string, string>();\n        var sinkHandle = builder.AddSink<DataSink, string>();\n\n        builder.Connect(sourceHandle, transformHandle);\n        builder.Connect(transformHandle, sinkHandle);\n\n        // Configure retry options using PipelineRetryOptions\n        builder.WithRetryOptions(new PipelineRetryOptions(\n            MaxItemRetries: 3,\n            MaxNodeRestartAttempts: 2,\n            MaxSequentialNodeAttempts: 5\n        ));\n    }\n}\n\npublic static class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var runner = PipelineRunner.Create();\n        var context = PipelineContext.Default;\n\n        var pipeline = PipelineBuilder.Create<ErrorHandlingPipelineDefinition>();\n        await runner.RunAsync<ErrorHandlingPipelineDefinition>(context);\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"production-ready-error-handling-example",children:"Production-Ready Error Handling Example"}),"\n",(0,o.jsx)(n.p,{children:"Here's a complete example that combines all error handling concepts:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\n// 1. Define custom error handlers\npublic class ProductionNodeErrorHandler : INodeErrorHandler<ITransformNode<string, string>, string>\n{\n    private readonly ILogger _logger;\n    private readonly IMetrics _metrics;\n\n    public ProductionNodeErrorHandler(ILogger logger, IMetrics metrics)\n    {\n        _logger = logger;\n        _metrics = metrics;\n    }\n\n    /// <summary>\n    /// Handles errors with comprehensive logging and metrics collection.\n    /// Enables monitoring and alerting for production environments.\n    /// </summary>\n    public Task<NodeErrorDecision> HandleAsync(\n        ITransformNode<string, string> node,\n        string failedItem,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Record error metrics for monitoring\n        _metrics.Increment("node_errors", new[] { \n            new KeyValuePair<string, object>("node_type", node.GetType().Name),\n            new KeyValuePair<string, object>("error_type", error.GetType().Name)\n        });\n\n        // Log error with full context\n        _logger.LogError(error, "Error processing item in node {NodeName}", node.Name);\n\n        // Implement error handling strategy based on exception type\n        return error switch\n        {\n            // Data validation errors - redirect to dead letter\n            ValidationException => Task.FromResult(NodeErrorDecision.DeadLetter),\n            \n            // Transient errors - retry\n            TimeoutException => Task.FromResult(NodeErrorDecision.Retry),\n            HttpRequestException => Task.FromResult(NodeErrorDecision.Retry),\n            \n            // All other errors - skip\n            _ => Task.FromResult(NodeErrorDecision.Skip)\n        };\n    }\n}\n\npublic class ProductionPipelineErrorHandler : IPipelineErrorHandler\n{\n    private readonly ILogger _logger;\n    private readonly Dictionary<string, int> _failureCounts = new();\n\n    public ProductionPipelineErrorHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles node failures with circuit breaker pattern.\n    /// Prevents cascading failures by limiting restart attempts.\n    /// </summary>\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\n        string nodeId,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Track failure count for circuit breaker logic\n        _failureCounts.TryGetValue(nodeId, out var count);\n        _failureCounts[nodeId] = count + 1;\n\n        // Log failure for monitoring\n        _logger.LogError(error, "Node {NodeId} failed (attempt {Attempt})", \n            nodeId, _failureCounts[nodeId]);\n\n        // Implement circuit breaker based on error type and count\n        return error switch\n        {\n            // Critical resource errors - fail immediately\n            OutOfMemoryException => Task.FromResult(PipelineErrorDecision.FailPipeline),\n            \n            // Transient errors - allow limited restarts\n            _ when _failureCounts[nodeId] < 3 => Task.FromResult(PipelineErrorDecision.RestartNode),\n            \n            // Persistent failures - continue without node\n            _ => Task.FromResult(PipelineErrorDecision.ContinueWithoutNode)\n        };\n    }\n}\n\n// 2. Configure the pipeline with comprehensive error handling\npublic sealed class ProductionPipelineDefinition : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var sourceHandle = builder.AddSource<DataSource, string>();\n        var transformHandle = builder.AddTransform<DataTransform, string, string>();\n        var sinkHandle = builder.AddSink<DataSink, string>();\n\n        builder.Connect(sourceHandle, transformHandle);\n        builder.Connect(transformHandle, sinkHandle);\n\n        // Configure retry options\n        builder.WithRetryOptions(new PipelineRetryOptions(\n            MaxItemRetries: 3,\n            MaxNodeRestartAttempts: 2,\n            MaxSequentialNodeAttempts: 5\n        ));\n    }\n}\n\npublic static class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var runner = PipelineRunner.Create();\n\n        // Configure retry options at context level\n        var retryOptions = new PipelineRetryOptions(\n            MaxItemRetries: 3,\n            MaxNodeRestartAttempts: 2,\n            MaxSequentialNodeAttempts: 5\n        );\n\n        var context = PipelineContext.WithRetry(retryOptions);\n\n        var pipeline = PipelineBuilder.Create<ProductionPipelineDefinition>();\n        \n        // Configure error handlers through the pipeline runner or register via dependency injection\n        // The PipelineErrorHandler can be registered in the service container:\n        var serviceProvider = new ServiceCollection()\n            .AddSingleton<IPipelineErrorHandler, ProductionPipelineErrorHandler>()\n            .AddSingleton<INodeErrorHandler<ITransformNode<string, string>, string>, ProductionNodeErrorHandler>()\n            .AddSingleton<IDeadLetterSink, FileDeadLetterSink>()\n            .BuildServiceProvider();\n\n        var runner = PipelineRunner.Create();\n        await runner.RunAsync<ProductionPipelineDefinition>(context);\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"retry-options-precedence",children:"Retry Options Precedence"}),"\n",(0,o.jsx)(n.p,{children:"NPipeline follows a clear precedence order when determining which retry options to use:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Node-specific options"}),": Options set directly on a specific node using ",(0,o.jsx)(n.code,{children:"WithRetryOptions(nodeHandle, options)"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Graph-level options"}),": Options set at the pipeline level using ",(0,o.jsx)(n.code,{children:"builder.WithRetryOptions(options)"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Context-level options"}),": Options provided through ",(0,o.jsx)(n.code,{children:"PipelineContext(retryOptions: options)"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This hierarchy allows for fine-grained control where you can:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Override retry behavior for specific nodes that need special handling"}),"\n",(0,o.jsx)(n.li,{children:"Set default behavior for the entire pipeline"}),"\n",(0,o.jsx)(n.li,{children:"Provide runtime options through the context"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"propagating-contextual-information",children:"Propagating Contextual Information"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.a,{href:"../../../src/NPipeline/PipelineContext.cs",children:(0,o.jsx)(n.code,{children:"PipelineContext"})})," can be invaluable for error handling. You can store error-specific information, such as correlation IDs, loggers, or even error reporting services, within the context, making them accessible to any node that needs to handle or report an error."]}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(n.h3,{id:"node-level-error-handling-best-practices",children:"Node-level Error Handling Best Practices"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Be specific about error types"}),": Different error types should be handled differently. Transient errors (like network issues) might be worth retrying, while data validation errors should probably be redirected."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Implement retry limits"}),": Always limit the number of retries to prevent infinite loops and resource exhaustion."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Log detailed error information"}),": Include sufficient context in your error logs to help with troubleshooting."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use dead-letter queues for problematic items"}),": Items that consistently fail should be redirected to a dead-letter queue for later analysis."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Consider performance implications"}),": Error handling logic adds overhead to normal processing, so keep it efficient."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"pipeline-level-error-handling-best-practices",children:"Pipeline-level Error Handling Best Practices"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Track failure patterns"}),": Keep track of when and how often nodes fail to detect persistent issues."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Implement circuit breaker patterns"}),": Prevent cascading failures by temporarily stopping attempts to failing nodes."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Differentiate between error types"}),": Critical errors should fail the pipeline immediately, while transient errors might be worth retrying."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Set reasonable limits"}),": Prevent infinite restarts by setting limits on the number of restart attempts."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Monitor and alert"}),": Implement proper monitoring and alerting for pipeline failures."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Consider graceful degradation"}),": Design your pipeline to continue functioning even when some nodes fail."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"warning-dependency-chain-requirements",children:["\u26a0\ufe0f"," Dependency Chain Requirements"]}),"\n",(0,o.jsxs)(n.p,{children:["For resilience features like ",(0,o.jsx)(n.code,{children:"PipelineErrorDecision.RestartNode"})," to work properly, you must understand the dependency chain between components. See ",(0,o.jsx)(n.a,{href:"/docs/core-concepts/resilience/getting-started",children:"Getting Started with Resilience"})," in the resilience section for detailed prerequisites."]}),"\n",(0,o.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/resilience/retries",children:"Retries"})," - Detailed retry policy configuration"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/resilience/circuit-breakers",children:"Circuit Breakers"})," - Circuit breaker patterns and settings"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/resilience/getting-started",children:"Getting Started with Resilience"})," - Quick guide to node restart functionality and common retry patterns"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/resilience/getting-started",children:"Getting Started with Resilience"})," - Critical prerequisite relationships and foundational concepts"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/resilience/retries",children:"Retries"})," - Retry configuration and strategies"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/resilience/circuit-breakers",children:"Circuit Breakers"})," - Circuit breaker configuration options"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting"})," - Common error handling issues and solutions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/reference/error-codes",children:"Error Codes Reference"})," - Complete error code reference"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/execution-strategies",children:"Execution Strategies"})," - How error handling integrates with execution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/pipelinebuilder",children:"PipelineBuilder"})," - Configuring error handling during pipeline construction"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/execution-strategies",children:"Execution Strategies"})," - Learn how to use error handling with execution strategies"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/resilience/retries",children:"Retries"})," - Configure detailed retry policies"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/resilience/circuit-breakers",children:"Circuit Breakers"})," - Implement circuit breaker patterns"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/extensions/testing/advanced-testing",children:"Testing Resilient Pipelines"})," - Test your error handling strategies"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>l});var i=r(6540);const o={},t=i.createContext(o);function s(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);