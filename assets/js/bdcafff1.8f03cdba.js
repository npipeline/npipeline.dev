"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[2182],{569:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"connectors/storage-provider","title":"Storage Provider Interface","description":"Understanding the IStorageProvider abstraction and implementing custom storage backends.","source":"@site/docs/connectors/storage-provider.md","sourceDirName":"connectors","slug":"/connectors/storage-provider","permalink":"/docs/connectors/storage-provider","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Storage Provider Interface","description":"Understanding the IStorageProvider abstraction and implementing custom storage backends.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"CSV Connector","permalink":"/docs/connectors/csv"},"next":{"title":"Advanced Topics","permalink":"/docs/advanced-topics"}}');var t=n(4848),s=n(8453);const a={title:"Storage Provider Interface",description:"Understanding the IStorageProvider abstraction and implementing custom storage backends.",sidebar_position:2},l="Storage Provider Interface",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Core Interface",id:"core-interface",level:2},{value:"Essential Operations",id:"essential-operations",level:3},{value:"Extended Operations (Optional)",id:"extended-operations-optional",level:3},{value:"Capability Discovery",id:"capability-discovery",level:2},{value:"Capability Flags",id:"capability-flags",level:3},{value:"Storage Types",id:"storage-types",level:2},{value:"StorageUri",id:"storageuri",level:3},{value:"StorageItem",id:"storageitem",level:3},{value:"StorageMetadata",id:"storagemetadata",level:3},{value:"Built-in Providers",id:"built-in-providers",level:2},{value:"FileSystem Provider",id:"filesystem-provider",level:3},{value:"Common Operations",id:"common-operations",level:2},{value:"Reading Data",id:"reading-data",level:3},{value:"Writing Data",id:"writing-data",level:3},{value:"Checking Existence",id:"checking-existence",level:3},{value:"Listing Resources",id:"listing-resources",level:3},{value:"Getting Metadata",id:"getting-metadata",level:3},{value:"Deleting Resources",id:"deleting-resources",level:3},{value:"StorageUri Format",id:"storageuri-format",level:2},{value:"Examples",id:"examples",level:3},{value:"Creating URIs",id:"creating-uris",level:3},{value:"Implementation Guide",id:"implementation-guide",level:2},{value:"Creating a Custom Provider",id:"creating-a-custom-provider",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Using Custom Providers",id:"using-custom-providers",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Filesystem-Specific Resilience",id:"filesystem-specific-resilience",level:3},{value:"Permission Restrictions",id:"permission-restrictions",level:4},{value:"Concurrent Modifications",id:"concurrent-modifications",level:4},{value:"Symbolic Links and Junctions",id:"symbolic-links-and-junctions",level:4},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Streaming Large Files",id:"streaming-large-files",level:3},{value:"Batch Operations",id:"batch-operations",level:3},{value:"Design Considerations",id:"design-considerations",level:2},{value:"Recursion Semantics",id:"recursion-semantics",level:3},{value:"Error Handling",id:"error-handling-1",level:3},{value:"Performance",id:"performance",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"storage-provider-interface",children:"Storage Provider Interface"})}),"\n",(0,t.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"IStorageProvider"})," interface is a foundational abstraction that enables NPipeline connectors to work with multiple storage backends\u2014from local filesystems to cloud services and databases. This document explains the core concepts, capabilities, and patterns for working with storage providers."]}),"\n",(0,t.jsx)(r.h2,{id:"core-interface",children:"Core Interface"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"IStorageProvider"})," defines the following operations:"]}),"\n",(0,t.jsx)(r.h3,{id:"essential-operations",children:"Essential Operations"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"OpenReadAsync(uri, cancellationToken)"})})," - Opens a readable stream for a resource"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"OpenWriteAsync(uri, cancellationToken)"})})," - Opens a writable stream for a resource"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"ExistsAsync(uri, cancellationToken)"})})," - Checks whether a resource exists"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"extended-operations-optional",children:"Extended Operations (Optional)"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"DeleteAsync(uri, cancellationToken)"})})," - Deletes a resource (default throws ",(0,t.jsx)(r.code,{children:"NotSupportedException"}),")"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"ListAsync(prefix, recursive, cancellationToken)"})})," - Lists resources at a location (default throws ",(0,t.jsx)(r.code,{children:"NotSupportedException"}),")"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"GetMetadataAsync(uri, cancellationToken)"})})," - Retrieves detailed metadata (default returns null)"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"capability-discovery",children:"Capability Discovery"}),"\n",(0,t.jsxs)(r.p,{children:["Use ",(0,t.jsx)(r.code,{children:"IStorageProviderMetadataProvider"})," to discover what operations a provider supports:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"if (provider is IStorageProviderMetadataProvider metadataProvider)\r\n{\r\n    var metadata = metadataProvider.GetMetadata();\r\n    \r\n    if (metadata.SupportsDelete)\r\n    {\r\n        await provider.DeleteAsync(uri);\r\n    }\r\n    \r\n    if (metadata.SupportsListing)\r\n    {\r\n        await foreach (var item in provider.ListAsync(prefix))\r\n        {\r\n            Console.WriteLine(item.Uri);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"capability-flags",children:"Capability Flags"}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Flag"}),(0,t.jsx)(r.th,{children:"Description"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"SupportsRead"})}),(0,t.jsxs)(r.td,{children:["Provider supports ",(0,t.jsx)(r.code,{children:"OpenReadAsync()"})]})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"SupportsWrite"})}),(0,t.jsxs)(r.td,{children:["Provider supports ",(0,t.jsx)(r.code,{children:"OpenWriteAsync()"})]})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"SupportsDelete"})}),(0,t.jsxs)(r.td,{children:["Provider supports ",(0,t.jsx)(r.code,{children:"DeleteAsync()"})]})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"SupportsListing"})}),(0,t.jsxs)(r.td,{children:["Provider supports ",(0,t.jsx)(r.code,{children:"ListAsync()"})]})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"SupportsMetadata"})}),(0,t.jsxs)(r.td,{children:["Provider supports ",(0,t.jsx)(r.code,{children:"GetMetadataAsync()"})]})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"SupportsHierarchy"})}),(0,t.jsx)(r.td,{children:"Provider has meaningful directory/prefix structure"})]})]})]}),"\n",(0,t.jsx)(r.h2,{id:"storage-types",children:"Storage Types"}),"\n",(0,t.jsx)(r.h3,{id:"storageuri",children:"StorageUri"}),"\n",(0,t.jsxs)(r.p,{children:["Represents a location in the storage system with structure: ",(0,t.jsx)(r.code,{children:"scheme://host/path?param=value"})]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Examples:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"file:///C:/data/file.csv                           // Local filesystem\r\nfile://\\\\server\\share\\data.csv                     // UNC path\r\ns3://my-bucket/data/2024/file.parquet              // AWS S3\r\nazure://mycontainer/logs/app.log                   // Azure Blob Storage\r\ndb://server/database/table                         // Database table\n"})}),"\n",(0,t.jsx)(r.h3,{id:"storageitem",children:"StorageItem"}),"\n",(0,t.jsxs)(r.p,{children:["Lightweight representation of a resource returned by ",(0,t.jsx)(r.code,{children:"ListAsync()"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public sealed record StorageItem\r\n{\r\n    public required StorageUri Uri { get; init; }\r\n    public required long Size { get; init; }\r\n    public required DateTimeOffset LastModified { get; init; }\r\n    public bool IsDirectory { get; init; }  // Logical grouping (S3 prefixes, directories)\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"storagemetadata",children:"StorageMetadata"}),"\n",(0,t.jsx)(r.p,{children:"Detailed metadata for a specific resource:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public sealed record StorageMetadata\r\n{\r\n    public required long Size { get; init; }\r\n    public required DateTimeOffset LastModified { get; init; }\r\n    public string? ContentType { get; init; }           // MIME type (if available)\r\n    public IReadOnlyDictionary<string, string> CustomMetadata { get; init; }\r\n    public bool IsDirectory { get; init; }\r\n    public string? ETag { get; init; }                  // For optimistic concurrency\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"built-in-providers",children:"Built-in Providers"}),"\n",(0,t.jsx)(r.h3,{id:"filesystem-provider",children:"FileSystem Provider"}),"\n",(0,t.jsx)(r.p,{children:"The default provider for local file access with full feature support."}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Characteristics:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"True directory hierarchy"}),"\n",(0,t.jsx)(r.li,{children:"Full read/write/delete/list support"}),"\n",(0,t.jsx)(r.li,{children:"MIME type detection"}),"\n",(0,t.jsx)(r.li,{children:"File metadata with timestamps"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Example:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'var provider = new FileSystemStorageProvider();\r\nvar uri = StorageUri.FromFilePath("C:\\\\data\\\\input.csv");\r\n\r\n// Read file\r\nusing var stream = await provider.OpenReadAsync(uri);\r\n\r\n// List directory recursively\r\nawait foreach (var item in provider.ListAsync(uri, recursive: true))\r\n{\r\n    Console.WriteLine($"{item.Uri}: {item.Size} bytes");\r\n}\r\n\r\n// Get metadata\r\nvar metadata = await provider.GetMetadataAsync(uri);\r\nif (metadata != null)\r\n{\r\n    Console.WriteLine($"Content-Type: {metadata.ContentType}");\r\n    Console.WriteLine($"ETag: {metadata.ETag}");\r\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Resilience Handling:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Gracefully skips inaccessible directories during recursive listing"}),"\n",(0,t.jsx)(r.li,{children:"Handles concurrent file deletions"}),"\n",(0,t.jsx)(r.li,{children:"Skips symbolic links/junctions in recursive traversal"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"common-operations",children:"Common Operations"}),"\n",(0,t.jsx)(r.h3,{id:"reading-data",children:"Reading Data"}),"\n",(0,t.jsxs)(r.p,{children:["All connectors support reading through ",(0,t.jsx)(r.code,{children:"OpenReadAsync"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'var uri = StorageUri.FromFilePath("data.csv");\r\nvar source = new CsvSourceNode<MyData>(uri);\r\n\r\n// When the pipeline runs, the CSV connector uses the storage provider\r\n// to open the file for reading\n'})}),"\n",(0,t.jsx)(r.h3,{id:"writing-data",children:"Writing Data"}),"\n",(0,t.jsxs)(r.p,{children:["All connectors support writing through ",(0,t.jsx)(r.code,{children:"OpenWriteAsync"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'var uri = StorageUri.FromFilePath("output.csv");\r\nvar sink = new CsvSinkNode<MyResult>(uri);\r\n\r\n// When the pipeline runs, the CSV connector uses the storage provider\r\n// to create/overwrite the file\n'})}),"\n",(0,t.jsx)(r.h3,{id:"checking-existence",children:"Checking Existence"}),"\n",(0,t.jsxs)(r.p,{children:["Use ",(0,t.jsx)(r.code,{children:"ExistsAsync"})," to check if a resource exists:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'var uri = StorageUri.FromFilePath("config.json");\r\nvar provider = new FileSystemStorageProvider();\r\n\r\nif (await provider.ExistsAsync(uri))\r\n{\r\n    Console.WriteLine("Configuration file exists");\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"listing-resources",children:"Listing Resources"}),"\n",(0,t.jsxs)(r.p,{children:["List resources in a directory using ",(0,t.jsx)(r.code,{children:"ListAsync"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'var uri = StorageUri.FromFilePath("C:\\\\data\\\\csv_files");\r\nvar provider = new FileSystemStorageProvider();\r\n\r\n// List only top-level files\r\nawait foreach (var item in provider.ListAsync(uri, recursive: false))\r\n{\r\n    Console.WriteLine($"{item.Uri}: {item.Size} bytes");\r\n    if (item.IsDirectory)\r\n    {\r\n        Console.WriteLine("  (directory)");\r\n    }\r\n}\r\n\r\n// List all files recursively\r\nawait foreach (var item in provider.ListAsync(uri, recursive: true))\r\n{\r\n    Console.WriteLine($"{item.Uri}: {item.Size} bytes");\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"getting-metadata",children:"Getting Metadata"}),"\n",(0,t.jsx)(r.p,{children:"Retrieve detailed metadata about a resource:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'var uri = StorageUri.FromFilePath("data.csv");\r\nvar provider = new FileSystemStorageProvider();\r\n\r\nvar metadata = await provider.GetMetadataAsync(uri);\r\nif (metadata != null)\r\n{\r\n    Console.WriteLine($"Size: {metadata.Size} bytes");\r\n    Console.WriteLine($"Modified: {metadata.LastModified}");\r\n    Console.WriteLine($"Content-Type: {metadata.ContentType}");\r\n    Console.WriteLine($"ETag: {metadata.ETag}");\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"deleting-resources",children:"Deleting Resources"}),"\n",(0,t.jsx)(r.p,{children:"Delete files and directories:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'var uri = StorageUri.FromFilePath("C:\\\\temp\\\\old_data.csv");\r\nvar provider = new FileSystemStorageProvider();\r\n\r\nif (metadata.SupportsDelete)\r\n{\r\n    await provider.DeleteAsync(uri);\r\n    Console.WriteLine("File deleted");\r\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"storageuri-format",children:"StorageUri Format"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"StorageUri"})," represents a location in any storage system:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"scheme://[host]/path[?param=value]\n"})}),"\n",(0,t.jsx)(r.h3,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"// Local filesystem (Windows)\r\nfile:///C:/data/users.csv\r\n\r\n// Local filesystem (Unix)\r\nfile:///home/user/data/users.csv\r\n\r\n// UNC path (Windows network share)\r\nfile://server/share/data.csv\r\n\r\n// AWS S3\r\ns3://my-bucket/data/2024/users.parquet\r\n\r\n// Azure Blob Storage\r\nazure://container/logs/app.log?connection-string=...\r\n\r\n// Custom backend\r\ncustom://my-system/resource?auth=token\n"})}),"\n",(0,t.jsx)(r.h3,{id:"creating-uris",children:"Creating URIs"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'// From local file path\r\nvar uri = StorageUri.FromFilePath("C:\\\\data\\\\file.csv");\r\n\r\n// From URI string\r\nvar uri = StorageUri.Parse("s3://bucket/key");\r\n\r\n// Combining paths\r\nvar baseUri = StorageUri.FromFilePath("C:\\\\data");\r\nvar fullUri = baseUri.Combine("subfolder/file.csv");\r\n\r\n// Adding parameters\r\nvar uri = StorageUri.FromFilePath("data.csv")\r\n    .WithParameter("compression", "gzip")\r\n    .WithParameter("encoding", "utf-8");\n'})}),"\n",(0,t.jsx)(r.h2,{id:"implementation-guide",children:"Implementation Guide"}),"\n",(0,t.jsx)(r.h3,{id:"creating-a-custom-provider",children:"Creating a Custom Provider"}),"\n",(0,t.jsx)(r.p,{children:"To implement a custom storage provider (e.g., for S3, Azure, or a custom system):"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public sealed class MyCustomStorageProvider : IStorageProvider, IStorageProviderMetadataProvider\r\n{\r\n    public StorageScheme Scheme => StorageScheme.Parse("custom");\r\n    \r\n    public bool CanHandle(StorageUri uri) => uri.Scheme == Scheme;\r\n    \r\n    public async Task<Stream> OpenReadAsync(StorageUri uri, CancellationToken cancellationToken = default)\r\n    {\r\n        // Your implementation here\r\n        throw new NotImplementedException();\r\n    }\r\n    \r\n    public async Task<Stream> OpenWriteAsync(StorageUri uri, CancellationToken cancellationToken = default)\r\n    {\r\n        // Your implementation here\r\n        throw new NotImplementedException();\r\n    }\r\n    \r\n    public async Task<bool> ExistsAsync(StorageUri uri, CancellationToken cancellationToken = default)\r\n    {\r\n        // Your implementation here\r\n        throw new NotImplementedException();\r\n    }\r\n    \r\n    // Implement DeleteAsync if deletion is supported\r\n    public async Task DeleteAsync(StorageUri uri, CancellationToken cancellationToken = default)\r\n    {\r\n        // Your implementation here\r\n        throw new NotImplementedException();\r\n    }\r\n    \r\n    // Implement ListAsync if listing is supported\r\n    public async IAsyncEnumerable<StorageItem> ListAsync(\r\n        StorageUri prefix,\r\n        bool recursive = false,\r\n        [EnumeratorCancellation] CancellationToken cancellationToken = default)\r\n    {\r\n        // Your implementation here\r\n        throw new NotImplementedException();\r\n        yield break;\r\n    }\r\n    \r\n    // Implement GetMetadataAsync if metadata retrieval is supported\r\n    public async Task<StorageMetadata?> GetMetadataAsync(StorageUri uri, CancellationToken cancellationToken = default)\r\n    {\r\n        // Your implementation here\r\n        return null;\r\n    }\r\n    \r\n    public StorageProviderMetadata GetMetadata()\r\n    {\r\n        return new StorageProviderMetadata\r\n        {\r\n            Name = "My Custom Provider",\r\n            SupportedSchemes = ["custom"],\r\n            SupportsRead = true,\r\n            SupportsWrite = true,\r\n            SupportsDelete = true,\r\n            SupportsListing = true,\r\n            SupportsMetadata = true,\r\n            SupportsHierarchy = true\r\n        };\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Normalize Exceptions"}),": Map provider-specific exceptions to standard .NET exceptions:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["Resource not found \u2192 ",(0,t.jsx)(r.code,{children:"FileNotFoundException"})]}),"\n",(0,t.jsxs)(r.li,{children:["Access denied \u2192 ",(0,t.jsx)(r.code,{children:"UnauthorizedAccessException"})]}),"\n",(0,t.jsxs)(r.li,{children:["Network/timeout issues \u2192 ",(0,t.jsx)(r.code,{children:"IOException"})," or ",(0,t.jsx)(r.code,{children:"OperationCanceledException"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Document Recursion Semantics"}),": Clearly explain how ",(0,t.jsx)(r.code,{children:"recursive"})," works in your implementation:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'/// <remarks>\r\n/// With recursive=false, returns objects matching the prefix with "/" delimiter applied.\r\n/// With recursive=true, returns all objects with the prefix (flat list).\r\n/// </remarks>\n'})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Implement Capabilities Accurately"}),": Set capability flags to match actual implementation:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public StorageProviderMetadata GetMetadata()\r\n{\r\n    return new StorageProviderMetadata\r\n    {\r\n        SupportsRead = true,\r\n        SupportsWrite = false,    // This provider is read-only\r\n        SupportsDelete = false,\r\n        SupportsListing = true,\r\n        SupportsHierarchy = false // No directory concept\r\n    };\r\n}\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Respect Cancellation"}),": Always check the ",(0,t.jsx)(r.code,{children:"CancellationToken"})," during enumeration:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public async IAsyncEnumerable<StorageItem> ListAsync(\r\n    StorageUri prefix,\r\n    bool recursive = false,\r\n    [EnumeratorCancellation] CancellationToken cancellationToken = default)\r\n{\r\n    foreach (var item in GetItems(prefix))\r\n    {\r\n        cancellationToken.ThrowIfCancellationRequested();\r\n        yield return item;\r\n    }\r\n}\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Populate Metadata Fields"}),": Provide all available metadata:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'return new StorageMetadata\r\n{\r\n    Size = contentLength,\r\n    LastModified = dateModified,\r\n    ContentType = "application/json",        // If available\r\n    CustomMetadata = objectTags,             // If available\r\n    ETag = response.ETag,                    // If available\r\n    IsDirectory = false\r\n};\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"using-custom-providers",children:"Using Custom Providers"}),"\n",(0,t.jsx)(r.p,{children:"Register custom providers with dependency injection:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"services.AddSingleton<IStorageProvider>(new MyCustomStorageProvider());\n"})}),"\n",(0,t.jsx)(r.p,{children:"Then use them with connectors:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'var uri = StorageUri.Parse("custom://bucket/key");\r\nvar pipeline = new PipelineBuilder()\r\n    .AddSource<CsvSourceNode<MyData>>("source")\r\n    // ... transforms ...\r\n    .Build();\n'})}),"\n",(0,t.jsx)(r.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(r.p,{children:"Storage providers normalize backend-specific errors to standard .NET exceptions:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'try\r\n{\r\n    using var stream = await provider.OpenReadAsync(uri);\r\n}\r\ncatch (FileNotFoundException ex)\r\n{\r\n    Console.WriteLine("Resource not found");\r\n}\r\ncatch (UnauthorizedAccessException ex)\r\n{\r\n    Console.WriteLine("Access denied");\r\n}\r\ncatch (IOException ex)\r\n{\r\n    Console.WriteLine("I/O error (network, timeout, etc.)");\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"filesystem-specific-resilience",children:"Filesystem-Specific Resilience"}),"\n",(0,t.jsx)(r.p,{children:"The filesystem provider includes automatic resilience handling:"}),"\n",(0,t.jsx)(r.h4,{id:"permission-restrictions",children:"Permission Restrictions"}),"\n",(0,t.jsx)(r.p,{children:"During recursive listing, inaccessible directories are automatically skipped:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'var uri = StorageUri.FromFilePath("C:\\\\data");\r\n\r\n// Even if some subdirectories are restricted, listing completes successfully\r\nawait foreach (var item in provider.ListAsync(uri, recursive: true))\r\n{\r\n    // Gets all accessible items, skips restricted directories\r\n}\n'})}),"\n",(0,t.jsx)(r.h4,{id:"concurrent-modifications",children:"Concurrent Modifications"}),"\n",(0,t.jsx)(r.p,{children:"Files deleted during enumeration are automatically skipped:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// If a file is deleted during enumeration, it's skipped without error\r\nawait foreach (var item in provider.ListAsync(uri, recursive: true))\r\n{\r\n    // Enumeration continues even if files are deleted\r\n}\n"})}),"\n",(0,t.jsx)(r.h4,{id:"symbolic-links-and-junctions",children:"Symbolic Links and Junctions"}),"\n",(0,t.jsx)(r.p,{children:"Circular symlinks and junctions are automatically detected and skipped:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// If C:\\data\\link points to C:\\data (creating a cycle),\r\n// the link is yielded but not traversed\r\nawait foreach (var item in provider.ListAsync(uri, recursive: true))\r\n{\r\n    // Includes link as an item, but doesn't follow it\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsx)(r.h3,{id:"streaming-large-files",children:"Streaming Large Files"}),"\n",(0,t.jsx)(r.p,{children:"Always use streaming for large files rather than buffering:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Good: Streaming\r\nusing var stream = await provider.OpenReadAsync(uri);\r\nusing var reader = new StreamReader(stream);\r\nstring line;\r\nwhile ((line = await reader.ReadLineAsync()) != null)\r\n{\r\n    // Process line by line\r\n}\r\n\r\n// Bad: Buffering entire file\r\nvar content = await File.ReadAllTextAsync(path);\r\n// Uses lots of memory for large files\n"})}),"\n",(0,t.jsx)(r.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,t.jsx)(r.p,{children:"When processing multiple files, consider batch operations:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"var files = new List<StorageUri> { uri1, uri2, uri3 };\r\n\r\n// Process concurrently (with appropriate limits)\r\nvar semaphore = new SemaphoreSlim(3); // 3 concurrent operations\r\nvar tasks = files.Select(async f =>\r\n{\r\n    await semaphore.WaitAsync();\r\n    try\r\n    {\r\n        var metadata = await provider.GetMetadataAsync(f);\r\n        // Process\r\n    }\r\n    finally\r\n    {\r\n        semaphore.Release();\r\n    }\r\n});\r\n\r\nawait Task.WhenAll(tasks);\n"})}),"\n",(0,t.jsx)(r.h2,{id:"design-considerations",children:"Design Considerations"}),"\n",(0,t.jsx)(r.h3,{id:"recursion-semantics",children:"Recursion Semantics"}),"\n",(0,t.jsx)(r.p,{children:"Different backends have different recursion behaviors:"}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Backend"}),(0,t.jsx)(r.th,{children:"Non-Recursive (recursive=false)"}),(0,t.jsx)(r.th,{children:"Recursive (recursive=true)"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Filesystem"}),(0,t.jsx)(r.td,{children:"Direct children only"}),(0,t.jsx)(r.td,{children:"All descendants"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"S3/Azure"}),(0,t.jsx)(r.td,{children:'Objects with prefix, "/" delimiter applied'}),(0,t.jsx)(r.td,{children:"All objects with prefix"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Database"}),(0,t.jsx)(r.td,{children:"N/A"}),(0,t.jsx)(r.td,{children:"Query-based filtering"})]})]})]}),"\n",(0,t.jsx)(r.h3,{id:"error-handling-1",children:"Error Handling"}),"\n",(0,t.jsx)(r.p,{children:"During recursive listing, providers should gracefully handle:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Permission restrictions on subdirectories"}),"\n",(0,t.jsx)(r.li,{children:"Concurrent deletions during enumeration"}),"\n",(0,t.jsx)(r.li,{children:"Circular references (symlinks/junctions)"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"For filesystem, these are automatically handled by the built-in provider."}),"\n",(0,t.jsx)(r.h3,{id:"performance",children:"Performance"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Use appropriate buffer sizes for streaming"}),"\n",(0,t.jsx)(r.li,{children:"Consider pagination for large datasets"}),"\n",(0,t.jsx)(r.li,{children:"Minimize allocations in hot paths"}),"\n",(0,t.jsx)(r.li,{children:"Cache provider metadata during pipeline lifetime"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/connectors/csv",children:"CSV Connector"})})," - Example using the filesystem storage provider"]}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>l});var i=n(6540);const t={},s=i.createContext(t);function a(e){const r=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:r},e.children)}}}]);