"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[1529],{6755:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"core-concepts/resilience/materialization-and-buffering","title":"Materialization and Buffering","description":"Understand how materialization and buffering enable replay functionality for resilient pipeline execution.","source":"@site/docs/core-concepts/resilience/materialization-and-buffering.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/materialization-and-buffering","permalink":"/docs/core-concepts/resilience/materialization-and-buffering","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Materialization and Buffering","description":"Understand how materialization and buffering enable replay functionality for resilient pipeline execution.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Circuit Breaker Advanced Configuration","permalink":"/docs/core-concepts/resilience/circuit-breaker-advanced-configuration"},"next":{"title":"Dependency Chains","permalink":"/docs/core-concepts/resilience/dependency-chains"}}');var t=i(4848),a=i(8453);const s={title:"Materialization and Buffering",description:"Understand how materialization and buffering enable replay functionality for resilient pipeline execution.",sidebar_position:3},l="Materialization and Buffering",o={},d=[{value:"What is Materialization?",id:"what-is-materialization",level:2},{value:"The Critical Role of MaxMaterializedItems",id:"the-critical-role-of-maxmaterializeditems",level:2},{value:"CappedReplayableDataPipe Implementation",id:"cappedreplayabledatapipe-implementation",level:2},{value:"Memory vs. Durability Trade-offs",id:"memory-vs-durability-trade-offs",level:2},{value:"Unbounded Materialization (Default)",id:"unbounded-materialization-default",level:3},{value:"Bounded Materialization",id:"bounded-materialization",level:3},{value:"Practical Guidance for Setting Buffer Limits",id:"practical-guidance-for-setting-buffer-limits",level:2},{value:"Factors to Consider",id:"factors-to-consider",level:3},{value:"Calculation Examples",id:"calculation-examples",level:3},{value:"Example 1: Small Items with High Throughput",id:"example-1-small-items-with-high-throughput",level:4},{value:"Example 2: Large Items with Low Throughput",id:"example-2-large-items-with-low-throughput",level:4},{value:"Configuration Examples",id:"configuration-examples",level:2},{value:"Basic Materialization Setup",id:"basic-materialization-setup",level:3},{value:"Per-Node Materialization Configuration",id:"per-node-materialization-configuration",level:3},{value:"Monitoring and Observability",id:"monitoring-and-observability",level:2},{value:"Buffer Usage Metrics",id:"buffer-usage-metrics",level:3},{value:"Detecting Buffer Overflow",id:"detecting-buffer-overflow",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Start with Conservative Limits",id:"1-start-with-conservative-limits",level:3},{value:"2. Monitor and Adjust",id:"2-monitor-and-adjust",level:3},{value:"3. Plan for Growth",id:"3-plan-for-growth",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Pitfall 1: Underestimating Item Size",id:"pitfall-1-underestimating-item-size",level:3},{value:"Pitfall 2: Ignoring Memory Pressure",id:"pitfall-2-ignoring-memory-pressure",level:3},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"materialization-and-buffering",children:"Materialization and Buffering"})}),"\n",(0,t.jsxs)(n.p,{children:["Materialization is the process of buffering incoming items before processing them, which enables replay functionality when a node needs to restart. This capability is essential for the ",(0,t.jsx)(n.code,{children:"PipelineErrorDecision.RestartNode"})," feature and is a critical component of NPipeline's resilience framework."]}),"\n",(0,t.jsx)(n.h2,{id:"what-is-materialization",children:"What is Materialization?"}),"\n",(0,t.jsx)(n.p,{children:"In NPipeline, data flows through nodes as streams. By default, streaming data is processed once and discarded - it cannot be replayed. Materialization changes this by:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Buffering incoming items"})," in memory before processing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Maintaining a replayable buffer"})," that can be re-enumerated"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Enabling restart functionality"})," by replaying buffered items after failures"]}),"\n"]}),"\n",(0,t.jsx)(n.mermaid,{value:"graph TD\r\n    A[Streaming Input] --\x3e B{Materialization Applied?}\r\n    B --\x3e|No| C[Process Once<br>No Replay Possible]\r\n    B --\x3e|Yes| D[Buffer Items]\r\n    D --\x3e E[Process Items]\r\n    E --\x3e F{Success?}\r\n    F --\x3e|Yes| G[Continue Processing]\r\n    F --\x3e|No| H[Node Restart]\r\n    H --\x3e I[Replay from Buffer]\r\n    I --\x3e E\r\n\r\n    style B fill:#ffecb3\r\n    style D fill:#e8f5e9\r\n    style H fill:#fff3e0\r\n    style I fill:#e8f5e9"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Figure: Materialization enables replay functionality by buffering items before processing."})}),"\n",(0,t.jsx)(n.h2,{id:"the-critical-role-of-maxmaterializeditems",children:"The Critical Role of MaxMaterializedItems"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," parameter in ",(0,t.jsx)(n.code,{children:"PipelineRetryOptions"})," controls the materialization behavior:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["When ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," is null"]})," (default): Unbounded materialization - all items are buffered"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["When ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," has a value"]}),": Limited materialization - only the specified number of items are buffered"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This parameter is critical because it determines:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"How many items can be replayed"})," during a node restart"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory usage"})," for the buffer"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Whether restart functionality works at all"})," for streaming inputs"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u26a0\ufe0f Critical Warning"}),": Setting ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," to ",(0,t.jsx)(n.code,{children:"null"})," (unbounded) silently disables node restart functionality. For detailed explanation of why unbounded buffers break resilience guarantees, see the ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/node-restart-quickstart#why-unbounded-memory-buffers-break-resilience-guarantees",children:"Node Restart Quick Start Checklist"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"cappedreplayabledatapipe-implementation",children:"CappedReplayableDataPipe Implementation"}),"\n",(0,t.jsxs)(n.p,{children:["NPipeline uses the ",(0,t.jsx)(n.a,{href:"../../../src/NPipeline/DataFlow/DataPipes/CappedReplayableDataPipe.cs",children:(0,t.jsx)(n.code,{children:"CappedReplayableDataPipe"})})," to implement materialization:"]}),"\n",(0,t.jsx)(n.mermaid,{value:"graph TD\r\n    A[Input Stream] --\x3e B[CappedReplayableDataPipe]\r\n    B --\x3e C[Internal Buffer]\r\n    C --\x3e D[Processing Pipeline]\r\n\r\n    E[Restart Request] --\x3e F[Replay from Buffer]\r\n    F --\x3e C\r\n\r\n    G[New Items] --\x3e H{Buffer Full?}\r\n    H --\x3e|No| I[Add to Buffer]\r\n    H --\x3e|Yes| J[Throw Exception]\r\n    I --\x3e C\r\n\r\n    style B fill:#e1f5fe\r\n    style C fill:#e8f5e9\r\n    style F fill:#fff3e0\r\n    style H fill:#ffecb3\r\n    style J fill:#ffebee"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"CappedReplayableDataPipe"})," provides:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Replay capability"}),": Can be re-enumerated multiple times"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory limits"}),": Enforces ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," when specified"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Overflow protection"}),": Throws exceptions when buffer limits are exceeded"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"memory-vs-durability-trade-offs",children:"Memory vs. Durability Trade-offs"}),"\n",(0,t.jsx)(n.p,{children:"Materialization involves a fundamental trade-off between memory usage and resilience capabilities:"}),"\n",(0,t.jsx)(n.h3,{id:"unbounded-materialization-default",children:"Unbounded Materialization (Default)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var unboundedOptions = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: null // No limit\r\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Pros:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Maximum resilience - all items can be replayed"}),"\n",(0,t.jsx)(n.li,{children:"Simple configuration - no need to estimate buffer size"}),"\n",(0,t.jsx)(n.li,{children:"Works for any data volume within memory constraints"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Cons:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Potential memory exhaustion with large datasets"}),"\n",(0,t.jsx)(n.li,{children:"OutOfMemoryException risk in production"}),"\n",(0,t.jsx)(n.li,{children:"Not suitable for long-running pipelines with high throughput"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Silently disables restart functionality"})," - see ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/node-restart-quickstart",children:"Node Restart Quick Start Checklist"})," for details"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"bounded-materialization",children:"Bounded Materialization"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var boundedOptions = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: 1000 // Limit to 1000 items\r\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Pros:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Predictable memory usage"}),"\n",(0,t.jsx)(n.li,{children:"Protection against memory exhaustion"}),"\n",(0,t.jsx)(n.li,{children:"Suitable for production environments"}),"\n",(0,t.jsx)(n.li,{children:"Enables restart functionality"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Cons:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Limited replay capability"}),"\n",(0,t.jsx)(n.li,{children:"Buffer overflow exceptions if limits exceeded"}),"\n",(0,t.jsx)(n.li,{children:"Requires careful capacity planning"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"practical-guidance-for-setting-buffer-limits",children:"Practical Guidance for Setting Buffer Limits"}),"\n",(0,t.jsx)(n.h3,{id:"factors-to-consider",children:"Factors to Consider"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Item Size"}),": Larger items require more memory per item"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Failure Window"}),": How many items might be processed between failures"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory Constraints"}),": Available memory for the buffer"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Throughput"}),": Items processed per second"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recovery Requirements"}),": How far back you need to replay"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"calculation-examples",children:"Calculation Examples"}),"\n",(0,t.jsx)(n.h4,{id:"example-1-small-items-with-high-throughput",children:"Example 1: Small Items with High Throughput"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Scenario: Processing 1000 small JSON objects per second\r\n// Each object ~1KB, want to buffer 30 seconds of data\r\nvar itemsPerSecond = 1000;\r\nvar bufferSizeKB = 1;\r\nvar secondsToBuffer = 30;\r\nvar calculatedLimit = itemsPerSecond * secondsToBuffer; // 30,000 items\r\nvar memoryUsageMB = (calculatedLimit * bufferSizeKB) / 1024; // ~29MB\r\n\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: calculatedLimit // 30,000 items\r\n);\n"})}),"\n",(0,t.jsx)(n.h4,{id:"example-2-large-items-with-low-throughput",children:"Example 2: Large Items with Low Throughput"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Scenario: Processing 10 large documents per second\r\n// Each document ~10MB, want to buffer 60 seconds of data\r\nvar itemsPerSecond = 10;\r\nvar bufferSizeMB = 10;\r\nvar secondsToBuffer = 60;\r\nvar calculatedLimit = itemsPerSecond * secondsToBuffer; // 600 items\r\nvar memoryUsageMB = calculatedLimit * bufferSizeMB; // 6000MB (6GB)\r\n\r\n// Since 6GB is too much, we need to compromise\r\nvar realisticLimit = 100; // 100 items = 1GB\r\nvar realisticSecondsBuffered = realisticLimit / itemsPerSecond; // 10 seconds\r\n\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: realisticLimit // 100 items\r\n);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,t.jsx)(n.h3,{id:"basic-materialization-setup",children:"Basic Materialization Setup"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.ErrorHandling;\r\nusing NPipeline.Execution.Strategies;\r\nusing NPipeline.Pipeline;\r\n\r\npublic class BufferingPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<StreamingDataSource, Data>("source");\r\n        var transformHandle = builder\r\n            .AddTransform<DataTransform, Data, ProcessedData>("transform")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new SequentialExecutionStrategy()\r\n            ));\r\n        var sinkHandle = builder.AddSink<DataSink, ProcessedData>("sink");\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n\r\n        builder.AddPipelineErrorHandler<DefaultPipelineErrorHandler>();\r\n        \r\n        builder.WithRetryOptions(new PipelineRetryOptions(\r\n            MaxItemRetries: 3,\r\n            MaxNodeRestartAttempts: 2,\r\n            MaxSequentialNodeAttempts: 5\r\n        ));\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"per-node-materialization-configuration",children:"Per-Node Materialization Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class PerNodeMaterializationPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<StreamingDataSource, Data>("source");\r\n        var criticalHandle = builder\r\n            .AddTransform<CriticalTransform, Data, ProcessedData>("criticalNode")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new SequentialExecutionStrategy()\r\n            ))\r\n            .WithRetryOptions(builder, new PipelineRetryOptions(\r\n                MaxItemRetries: 5,\r\n                MaxNodeRestartAttempts: 5,\r\n                MaxSequentialNodeAttempts: 10\r\n            ));\r\n        var nonCriticalHandle = builder\r\n            .AddTransform<NonCriticalTransform, ProcessedData, FinalData>("nonCriticalNode")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new SequentialExecutionStrategy()\r\n            ))\r\n            .WithRetryOptions(builder, new PipelineRetryOptions(\r\n                MaxItemRetries: 2,\r\n                MaxNodeRestartAttempts: 1,\r\n                MaxSequentialNodeAttempts: 3\r\n            ));\r\n        var sinkHandle = builder.AddSink<DataSink, FinalData>("sink");\r\n\r\n        builder.Connect(sourceHandle, criticalHandle);\r\n        builder.Connect(criticalHandle, nonCriticalHandle);\r\n        builder.Connect(nonCriticalHandle, sinkHandle);\r\n\r\n        builder.AddPipelineErrorHandler<DefaultPipelineErrorHandler>();\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"monitoring-and-observability",children:"Monitoring and Observability"}),"\n",(0,t.jsx)(n.h3,{id:"buffer-usage-metrics",children:"Buffer Usage Metrics"}),"\n",(0,t.jsx)(n.p,{children:"Monitor materialization buffer usage to detect potential issues:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Custom observer to track buffer usage\r\npublic class MaterializationObserver : IExecutionObserver\r\n{\r\n    public void OnRetry(NodeRetryEvent retryEvent)\r\n    {\r\n        if (retryEvent.RetryKind == RetryKind.NodeRestart)\r\n        {\r\n            Console.WriteLine($"Node restart: {retryEvent.NodeId}, Attempt: {retryEvent.Attempt}");\r\n        }\r\n    }\r\n\r\n    public void OnBufferUsage(string nodeId, int currentItems, int maxItems)\r\n    {\r\n        var usagePercent = (currentItems * 100) / maxItems;\r\n        if (usagePercent > 80)\r\n        {\r\n            Console.WriteLine($"Warning: Node {nodeId} buffer at {usagePercent}% capacity");\r\n        }\r\n    }\r\n}\r\n\r\n// Register the observer\r\nvar context = PipelineContext.Default;\r\ncontext.ExecutionObserver = new MaterializationObserver();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"detecting-buffer-overflow",children:"Detecting Buffer Overflow"}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"MaxMaterializedItems"})," is set, monitor for overflow exceptions:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class OverflowAwareErrorHandler : IPipelineErrorHandler\r\n{\r\n    public async Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Detect buffer overflow\r\n        if (error.Message.Contains("Resilience materialization exceeded MaxMaterializedItems"))\r\n        {\r\n            Console.WriteLine($"Buffer overflow detected for node {nodeId}");\r\n            // Consider alternative recovery strategy\r\n            return PipelineErrorDecision.ContinueWithoutNode;\r\n        }\r\n\r\n        // Normal error handling logic\r\n        return await HandleNormalFailure(nodeId, error, context, cancellationToken);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-start-with-conservative-limits",children:"1. Start with Conservative Limits"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Conservative starting point\r\nvar conservativeOptions = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: 1000 // Start with 1000 items\r\n);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-monitor-and-adjust",children:"2. Monitor and Adjust"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Production monitoring approach\r\npublic class ProductionBufferMonitor\r\n{\r\n    private readonly Dictionary<string, BufferStats> _stats = new();\r\n\r\n    public void RecordBufferUsage(string nodeId, int currentItems, int maxItems)\r\n    {\r\n        if (!_stats.ContainsKey(nodeId))\r\n            _stats[nodeId] = new BufferStats();\r\n\r\n        _stats[nodeId].Update(currentItems, maxItems);\r\n\r\n        // Alert if consistently high usage\r\n        if (_stats[nodeId].AverageUsagePercent > 80)\r\n        {\r\n            AlertHighBufferUsage(nodeId, _stats[nodeId]);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-plan-for-growth",children:"3. Plan for Growth"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Growth-aware configuration\r\nvar growthFactor = 1.5; // 50% growth buffer\r\nvar baselineItems = 1000;\r\nvar growthAwareLimit = (int)(baselineItems * growthFactor);\r\n\r\nvar growthAwareOptions = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: growthAwareLimit\r\n);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,t.jsx)(n.h3,{id:"pitfall-1-underestimating-item-size",children:"Pitfall 1: Underestimating Item Size"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// WRONG: Assuming small items\r\nvar wrongOptions = new PipelineRetryOptions(\r\n    MaxMaterializedItems: 10000 // 10,000 items\r\n);\r\n\r\n// CORRECT: Accounting for actual item size\r\nvar itemSizeKB = EstimateItemSize();\r\nvar memoryBudgetMB = 500; // 500MB budget\r\nvar calculatedLimit = (memoryBudgetMB * 1024) / itemSizeKB;\r\n\r\nvar correctOptions = new PipelineRetryOptions(\r\n    MaxMaterializedItems: calculatedLimit\r\n);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"pitfall-2-ignoring-memory-pressure",children:"Pitfall 2: Ignoring Memory Pressure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// WRONG: No monitoring\r\npublic class UnmonitoredPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var nodeHandle = builder\r\n            .AddTransform<MyTransform, Input, Output>("node")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new SequentialExecutionStrategy()\r\n            ));\r\n    }\r\n}\r\n\r\n// CORRECT: With memory monitoring\r\npublic class MonitoredPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var nodeHandle = builder\r\n            .AddTransform<MyTransform, Input, Output>("node")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new SequentialExecutionStrategy()\r\n            ));\r\n        builder.AddPipelineErrorHandler<MemoryAwareErrorHandler>();\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/node-restart-quickstart",children:"Node Restart Quick Start Checklist"})}),": Complete step-by-step configuration guide for node restart functionality"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/dependency-chains",children:"Dependency Chains"})}),": Understand the critical prerequisite relationships"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/configuration-guide",children:"Configuration Guide"})}),": Get practical implementation guidance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting"})}),": Learn to diagnose and resolve materialization issues"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var r=i(6540);const t={},a=r.createContext(t);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);