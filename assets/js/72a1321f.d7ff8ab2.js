"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3056],{8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function l(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(s.Provider,{value:n},e.children)}},8962:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"core-concepts/resilience/node-restart-quickstart","title":"Node Restart - Quick Start Checklist","description":"Three-step mandatory checklist for configuring node restarts. Read this before you enable RestartNode error handling.","source":"@site/docs/core-concepts/resilience/node-restart-quickstart.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/node-restart-quickstart","permalink":"/docs/core-concepts/resilience/node-restart-quickstart","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Node Restart - Quick Start Checklist","description":"Three-step mandatory checklist for configuring node restarts. Read this before you enable RestartNode error handling.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Resilience Overview","permalink":"/docs/core-concepts/resilience/"},"next":{"title":"Resilient Execution Strategy","permalink":"/docs/core-concepts/resilience/resilient-execution-strategy"}}');var i=t(4848),s=t(8453);const l={title:"Node Restart - Quick Start Checklist",description:"Three-step mandatory checklist for configuring node restarts. Read this before you enable RestartNode error handling.",sidebar_position:2},o=void 0,a={},c=[{value:"Node Restart - Quick Start Checklist",id:"node-restart---quick-start-checklist",level:2},{value:"The Three-Step Mandatory Checklist",id:"the-three-step-mandatory-checklist",level:2},{value:"\u2705 STEP 1: Apply ResilientExecutionStrategy",id:"-step-1-apply-resilientexecutionstrategy",level:3},{value:"\u2705 STEP 2: Configure Maximum Restart Attempts",id:"-step-2-configure-maximum-restart-attempts",level:3},{value:"\u2705 STEP 3: Enable Input Materialization (\u26a0\ufe0f CRITICAL)",id:"-step-3-enable-input-materialization-\ufe0f-critical",level:3},{value:"Conservative Starting Point",id:"conservative-starting-point",level:3},{value:"\u26a0\ufe0f CRITICAL WARNING: Unbounded Materialization",id:"\ufe0f-critical-warning-unbounded-materialization",level:2},{value:"Complete Configuration Example",id:"complete-configuration-example",level:2},{value:"Verification Checklist",id:"verification-checklist",level:2},{value:"What Happens If One Is Missing",id:"what-happens-if-one-is-missing",level:2},{value:"\u27a1\ufe0f Next Steps",id:"arrow_right-next-steps",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",hr:"hr",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"node-restart---quick-start-checklist",children:"Node Restart - Quick Start Checklist"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["\u26a0\ufe0f BEFORE YOU USE ",(0,i.jsx)(n.code,{children:"PipelineErrorDecision.RestartNode"}),", READ THIS."]})}),"\n",(0,i.jsxs)(n.p,{children:["Node restart is a powerful resilience feature, but it requires ",(0,i.jsx)(n.strong,{children:"three mandatory prerequisites"}),". Missing even one silently disables the feature."]}),"\n",(0,i.jsx)(n.p,{children:"If you've experienced mysterious pipeline failures where restart seemed enabled but didn't work, one of these requirements was missing."}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\ud83d\udca1 Tip:"})," The NPipeline build-time analyzer automatically detects incomplete restart configurations at compile time. Enable ",(0,i.jsx)(n.a,{href:"/docs/reference/error-codes#npl9002-incomplete-resilient-configuration",children:"NP9002"})," to catch these issues before deployment."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"the-three-step-mandatory-checklist",children:"The Three-Step Mandatory Checklist"}),"\n",(0,i.jsx)(n.h3,{id:"-step-1-apply-resilientexecutionstrategy",children:"\u2705 STEP 1: Apply ResilientExecutionStrategy"}),"\n",(0,i.jsxs)(n.p,{children:["Your node must be wrapped with ",(0,i.jsx)(n.code,{children:"ResilientExecutionStrategy"}),". This enables the restart capability at the node level."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What it does:"})," Allows the pipeline to restart the node when an error occurs."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Without it:"})," Restart decisions are ignored; the node cannot recover."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How to configure:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'var nodeHandle = builder\r\n    .AddTransform<MyTransform, Input, Output>("myNode")\r\n    .WithExecutionStrategy(\r\n        builder,\r\n        new ResilientExecutionStrategy(new SequentialExecutionStrategy())\r\n    );\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Learn more:"})," ",(0,i.jsx)(n.a,{href:"/docs/core-concepts/resilience/resilient-execution-strategy",children:"Resilient Execution Strategy"})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-step-2-configure-maximum-restart-attempts",children:"\u2705 STEP 2: Configure Maximum Restart Attempts"}),"\n",(0,i.jsxs)(n.p,{children:["Set ",(0,i.jsx)(n.code,{children:"MaxNodeRestartAttempts > 0"})," in ",(0,i.jsx)(n.code,{children:"PipelineRetryOptions"}),". This tells the pipeline how many times to attempt restarting a failed node."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What it does:"})," Limits how many restart attempts the pipeline will make before giving up."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Without it:"})," No restarts will be attempted."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How to configure:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,  // \u2190 At least 1\r\n    MaxMaterializedItems: 1000   // (see Step 3!)\r\n);\r\n\r\nvar context = PipelineContext.WithRetry(options);\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Recommended starting values:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Transient failures (network, temporary service issues):"})," 2-3 attempts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Persistent issues (resource exhaustion):"})," 3-5 attempts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Critical nodes:"})," 5+ attempts"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Learn more:"})," ",(0,i.jsx)(n.a,{href:"/docs/core-concepts/resilience/configuration-guide",children:"Configuration Guide"})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-step-3-enable-input-materialization-\ufe0f-critical",children:"\u2705 STEP 3: Enable Input Materialization (\u26a0\ufe0f CRITICAL)"}),"\n",(0,i.jsxs)(n.p,{children:["Set ",(0,i.jsx)(n.code,{children:"MaxMaterializedItems"})," to a ",(0,i.jsx)(n.strong,{children:"non-null, positive number"})," on the input to the node you want to be restartable. This is the replay buffer."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What it does:"})," Buffers items from the input source so the node can be replayed from a known state if it fails."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u26a0\ufe0f CRITICAL ISSUE:"})," If ",(0,i.jsx)(n.code,{children:"MaxMaterializedItems"})," is ",(0,i.jsx)(n.code,{children:"null"})," (unbounded), the system silently falls back to ",(0,i.jsx)(n.code,{children:"FailPipeline"}),", even if you've configured restart logic. Your entire pipeline crashes instead of just restarting the node."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How to configure:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxMaterializedItems: 1000  // \u2190 Must be set! Not null!\r\n);\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Choosing a value:"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Scenario"}),(0,i.jsx)(n.th,{children:"Recommended Value"}),(0,i.jsx)(n.th,{children:"Rationale"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Small objects (< 100 bytes)"}),(0,i.jsx)(n.td,{children:"5,000-10,000"}),(0,i.jsx)(n.td,{children:"Minimal memory overhead"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Medium objects (100-1KB)"}),(0,i.jsx)(n.td,{children:"1,000-5,000"}),(0,i.jsx)(n.td,{children:"Balanced buffer size"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Large objects (1KB+)"}),(0,i.jsx)(n.td,{children:"500-1,000"}),(0,i.jsx)(n.td,{children:"Respect memory constraints"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Critical/high-priority node"}),(0,i.jsx)(n.td,{children:"2,000-5,000"}),(0,i.jsx)(n.td,{children:"More replay buffer = higher restart success rate"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"conservative-starting-point",children:"Conservative Starting Point"}),"\n",(0,i.jsx)(n.p,{children:"Here's a good default configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxMaterializedItems: 1000  // \u2190 Good default: buffers ~1000 items\r\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Learn more:"})," ",(0,i.jsx)(n.a,{href:"/docs/core-concepts/resilience/materialization-and-buffering",children:"Materialization and Buffering"})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"\ufe0f-critical-warning-unbounded-materialization",children:"\u26a0\ufe0f CRITICAL WARNING: Unbounded Materialization"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Never set ",(0,i.jsx)(n.code,{children:"MaxMaterializedItems"})," to ",(0,i.jsx)(n.code,{children:"null"}),":"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// \u274c WRONG - This disables restart silently!\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxMaterializedItems: null  // \u2190 DANGER!\r\n);\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"If you do:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Your pipeline will NOT restart on failures"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsxs)(n.strong,{children:["The system silently falls back to ",(0,i.jsx)(n.code,{children:"FailPipeline"})]})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Your entire pipeline will crash"})," (not just the failing node)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Risk of Out-of-Memory exceptions"})," with unbounded data streams"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Symptom:"})," You've configured restart logic, but when an error occurs, the pipeline fails completely instead of restarting the node."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"complete-configuration-example",children:"Complete Configuration Example"}),"\n",(0,i.jsx)(n.p,{children:"Here's a complete example with all three requirements:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// Step 1: Create retry options with ALL three settings\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,           // \u2190 Step 2: Restart attempts\r\n    MaxMaterializedItems: 1000            // \u2190 Step 3: Replay buffer\r\n);\r\n\r\nvar context = PipelineContext.WithRetry(options);\r\n\r\n// Step 2: Build pipeline with resilient nodes\r\nvar definition = new MyPipelineDefinition();\r\ndefinition.Define(builder, context);\r\n\r\n// In MyPipelineDefinition.Define():\r\n// \r\n//   Step 1: Wrap node with ResilientExecutionStrategy\r\n//   var nodeHandle = builder\r\n//       .AddTransform<MyTransform, Input, Output>("risky")\r\n//       .WithExecutionStrategy(\r\n//           builder,\r\n//           new ResilientExecutionStrategy(\r\n//               new SequentialExecutionStrategy()\r\n//           )\r\n//       );\r\n//\r\n//   Add error handler that returns RestartNode\r\n//   builder.AddPipelineErrorHandler<MyErrorHandler>();\r\n//\r\n// In MyErrorHandler.HandleNodeFailureAsync():\r\n//\r\n//   return error switch\r\n//   {\r\n//       TimeoutException => Task.FromResult(\r\n//           PipelineErrorDecision.RestartNode  // \u2190 RestartNode requires all 3!\r\n//       ),\r\n//       _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\r\n//   };\r\n\r\nvar runner = new PipelineRunner();\r\nawait runner.RunAsync<MyPipelineDefinition>(context);\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"verification-checklist",children:"Verification Checklist"}),"\n",(0,i.jsx)(n.p,{children:"Before you assume restarts are working, verify all three:"}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Strategy:"})," Node is wrapped with ",(0,i.jsx)(n.code,{children:"ResilientExecutionStrategy"})]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Attempts:"})," ",(0,i.jsx)(n.code,{children:"MaxNodeRestartAttempts > 0"})," in ",(0,i.jsx)(n.code,{children:"PipelineRetryOptions"})]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Materialization:"})," ",(0,i.jsx)(n.code,{children:"MaxMaterializedItems"})," is set to a positive number (not null)"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Error Handler:"})," Handler returns ",(0,i.jsx)(n.code,{children:"PipelineErrorDecision.RestartNode"})," for your error type"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If any are missing, restarts won't work."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"what-happens-if-one-is-missing",children:"What Happens If One Is Missing"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Missing Component"}),(0,i.jsx)(n.th,{children:"Symptom"}),(0,i.jsx)(n.th,{children:"What Happens"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"ResilientExecutionStrategy"})}),(0,i.jsx)(n.td,{children:"Node not wrapped"}),(0,i.jsx)(n.td,{children:"Error handler decisions are ignored; pipeline always fails"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"MaxNodeRestartAttempts"})}),(0,i.jsx)(n.td,{children:"Not configured or = 0"}),(0,i.jsx)(n.td,{children:"No restarts are attempted; pipeline fails immediately"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"MaxMaterializedItems"})}),(0,i.jsx)(n.td,{children:"Not set (null)"}),(0,i.jsxs)(n.td,{children:["RestartNode falls back to ",(0,i.jsx)(n.code,{children:"FailPipeline"}),"; ",(0,i.jsx)(n.strong,{children:"entire pipeline crashes"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Error Handler"})}),(0,i.jsxs)(n.td,{children:["Returns ",(0,i.jsx)(n.code,{children:"FailPipeline"})," for all errors"]}),(0,i.jsx)(n.td,{children:"Restarts never triggered; all errors kill the pipeline"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h2,{id:"arrow_right-next-steps",children:["\u27a1\ufe0f"," Next Steps"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.a,{href:"/docs/analyzers/resilience",children:"Build-Time Resilience Analyzer"}),":"]})," Catch incomplete configurations at compile time"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.a,{href:"/docs/core-concepts/resilience/resilient-execution-strategy",children:"Resilient Execution Strategy"}),":"]})," Deep dive into how ResilientExecutionStrategy works"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.a,{href:"/docs/core-concepts/resilience/materialization-and-buffering",children:"Materialization and Buffering"}),":"]})," Understand the replay buffer and memory implications"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/error-handling",children:"Error Handling"}),":"]})," Learn how to write error handlers that return RestartNode"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.a,{href:"/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting"}),":"]})," Diagnose restart issues in your pipeline"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);