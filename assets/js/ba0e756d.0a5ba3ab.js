"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[7451],{28453:(e,r,n)=>{n.d(r,{R:()=>t,x:()=>s});var i=n(96540);const o={},l=i.createContext(o);function t(e){const r=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),i.createElement(l.Provider,{value:r},e.children)}},42586:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"core-concepts/resilience/error-handling-overview","title":"Error Handling Overview","description":"Understand the two levels of error handling in NPipeline and choose the right approach for your pipeline","source":"@site/docs/core-concepts/resilience/error-handling-overview.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/error-handling-overview","permalink":"/docs/core-concepts/resilience/error-handling-overview","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Error Handling Overview","description":"Understand the two levels of error handling in NPipeline and choose the right approach for your pipeline","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Resilience Overview","permalink":"/docs/core-concepts/resilience/"},"next":{"title":"Error Handling in NPipeline","permalink":"/docs/core-concepts/resilience/error-handling"}}');var o=n(74848),l=n(28453);const t={title:"Error Handling Overview",description:"Understand the two levels of error handling in NPipeline and choose the right approach for your pipeline",sidebar_position:1},s="Error Handling Overview",a={},d=[{value:"Why Error Handling Matters",id:"why-error-handling-matters",level:2},{value:"Types of Errors in NPipeline",id:"types-of-errors-in-npipeline",level:2},{value:"Two Levels of Error Handling",id:"two-levels-of-error-handling",level:2},{value:"1. Node-Level Error Handling",id:"1-node-level-error-handling",level:3},{value:"2. Pipeline-Level Error Handling",id:"2-pipeline-level-error-handling",level:3},{value:"Decision Tree: Choosing Your Approach",id:"decision-tree-choosing-your-approach",level:2},{value:"Error Handling Strategies",id:"error-handling-strategies",level:2},{value:"For Individual Item Failures (Node-Level)",id:"for-individual-item-failures-node-level",level:3},{value:"For Entire Stream Failures (Pipeline-Level)",id:"for-entire-stream-failures-pipeline-level",level:3},{value:"Error Flow Visualization",id:"error-flow-visualization",level:2},{value:"Related Documentation",id:"related-documentation",level:2},{value:"Quick Start",id:"quick-start",level:2}];function c(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"error-handling-overview",children:"Error Handling Overview"})}),"\n",(0,o.jsx)(r.p,{children:"Robust error handling is critical for building reliable data pipelines. NPipeline provides several mechanisms to manage errors that occur during data processing, allowing you to gracefully recover, retry operations, or isolate problematic data."}),"\n",(0,o.jsx)(r.h2,{id:"why-error-handling-matters",children:"Why Error Handling Matters"}),"\n",(0,o.jsx)(r.p,{children:"By default, if an unhandled exception occurs within a node during pipeline execution, the exception will propagate up the call stack, potentially halting the entire pipeline. While this behavior is suitable for critical errors that should stop processing immediately, it's often desirable to handle errors more selectively without bringing down the entire system."}),"\n",(0,o.jsx)(r.h2,{id:"types-of-errors-in-npipeline",children:"Types of Errors in NPipeline"}),"\n",(0,o.jsx)(r.p,{children:"Errors can generally be categorized by their source and impact:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Node-Specific Errors"}),": Exceptions originating from logic within a specific ",(0,o.jsx)(r.code,{children:"ISourceNode"}),", ",(0,o.jsx)(r.code,{children:"ITransformNode"}),", or ",(0,o.jsx)(r.code,{children:"ISinkNode"}),"."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Data-Related Errors"}),": Issues caused by the data itself (e.g., invalid format, missing values) that a node attempts to process."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Infrastructure Errors"}),": Problems related to external dependencies like databases, APIs, or network connectivity."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Cancellation"}),': While not strictly an "error," a ',(0,o.jsx)(r.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken",children:(0,o.jsx)(r.code,{children:"CancellationToken"})})," can signal an intentional halt to processing, which nodes should handle gracefully."]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"two-levels-of-error-handling",children:"Two Levels of Error Handling"}),"\n",(0,o.jsx)(r.p,{children:"NPipeline distinguishes between two complementary levels of error handling:"}),"\n",(0,o.jsx)(r.h3,{id:"1-node-level-error-handling",children:"1. Node-Level Error Handling"}),"\n",(0,o.jsx)(r.p,{children:"Deals with errors that occur while processing an individual item within a specific node. You define what happens to that item:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"Skip it and continue"}),"\n",(0,o.jsx)(r.li,{children:"Retry the operation"}),"\n",(0,o.jsx)(r.li,{children:"Redirect it to a dead-letter queue"}),"\n",(0,o.jsx)(r.li,{children:"Fail the entire pipeline"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Use this when:"})," Individual items fail during processing and you want to handle them without affecting other items."]}),"\n",(0,o.jsx)(r.h3,{id:"2-pipeline-level-error-handling",children:"2. Pipeline-Level Error Handling"}),"\n",(0,o.jsx)(r.p,{children:"Deals with more severe errors that might affect an entire node's stream or the pipeline's execution flow:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"Restart the failing node"}),"\n",(0,o.jsx)(r.li,{children:"Continue without the failing node"}),"\n",(0,o.jsx)(r.li,{children:"Fail the entire pipeline"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Use this when:"})," An entire node's stream fails (e.g., external service goes down) and you need to decide how the pipeline should recover."]}),"\n",(0,o.jsx)(r.h2,{id:"decision-tree-choosing-your-approach",children:"Decision Tree: Choosing Your Approach"}),"\n",(0,o.jsx)(r.mermaid,{value:"graph TD\n    A[I need to handle errors] --\x3e B{What type of errors?}\n    B --\x3e|Individual item failures| C[Use NODE-LEVEL ERROR HANDLING]\n    B --\x3e|Entire stream/node failures| D[Use PIPELINE-LEVEL ERROR HANDLING]\n    B --\x3e|Both types of errors| E[Implement BOTH LEVELS]\n    \n    C --\x3e F{What should happen to failed items?}\n    F --\x3e|Retry and continue| G[NodeErrorDecision.Retry<br>Configure MaxItemRetries]\n    F --\x3e|Skip and continue| H[NodeErrorDecision.Skip<br>Log and continue]\n    F --\x3e|Redirect for review| I[NodeErrorDecision.DeadLetter<br>Configure dead-letter sink]\n    F --\x3e|Stop processing| J[NodeErrorDecision.Fail<br>Terminate pipeline]\n    \n    D --\x3e K{What should happen to failed nodes?}\n    K --\x3e|Restart and retry| L[PipelineErrorDecision.RestartNode<br>Configure MaxNodeRestartAttempts]\n    K --\x3e|Continue without node| M[PipelineErrorDecision.ContinueWithoutNode<br>Bypass failed component]\n    K --\x3e|Stop entire pipeline| N[PipelineErrorDecision.FailPipeline<br>Terminate all processing]\n    \n    E --\x3e O[Combine node and pipeline error handling]\n    O --\x3e P[Implement INodeErrorHandler<br>for item-level errors]\n    O --\x3e Q[Implement IPipelineErrorHandler<br>for stream-level errors]\n    P --\x3e R[Configure ResilientExecutionStrategy]\n    Q --\x3e R"}),"\n",(0,o.jsx)(r.h2,{id:"error-handling-strategies",children:"Error Handling Strategies"}),"\n",(0,o.jsx)(r.h3,{id:"for-individual-item-failures-node-level",children:"For Individual Item Failures (Node-Level)"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Retry"}),": Transient errors (network issues, temporary resource constraints)"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Skip"}),": Non-critical errors or malformed data"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Dead Letter"}),": Problematic items for later analysis"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Fail"}),": When errors indicate critical system issues"]}),"\n"]}),"\n",(0,o.jsx)(r.h3,{id:"for-entire-stream-failures-pipeline-level",children:"For Entire Stream Failures (Pipeline-Level)"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Restart Node"}),": When failures are transient and recoverable"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Continue Without Node"}),": When the node is non-critical to overall operation"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Fail Pipeline"}),": When errors indicate system-wide problems"]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"error-flow-visualization",children:"Error Flow Visualization"}),"\n",(0,o.jsx)(r.mermaid,{value:"flowchart TD\n    A[Item Processing Starts] --\x3e B{Error Occurs?}\n    B --\x3e|No| C[Continue Processing]\n    B --\x3e|Yes| D[Error Handler Invoked]\n\n    D --\x3e E{Error Type}\n    E --\x3e|Node-level<br>&#40;Item Error&#41;| F[INodeErrorHandler]\n    E --\x3e|Pipeline-level<br>&#40;Stream Error&#41;| G[IPipelineErrorHandler]\n\n    %% Node-level Error Handling\n    F --\x3e H{NodeErrorDecision}\n    H --\x3e|Retry| I[Retry Item]\n    H --\x3e|Skip| J[Discard Item]\n    H --\x3e|Redirect| K[Send to Dead Letter]\n    H --\x3e|Fail| L[Pipeline Failure]\n\n    I --\x3e M{Max Retries Reached?}\n    M --\x3e|No| B\n    M --\x3e|Yes| O[Proceed with Decision]\n\n    %% Pipeline-level Error Handling\n    G --\x3e R{PipelineErrorDecision}\n    R --\x3e|Restart Node| S[Restart Node Stream]\n    R --\x3e|Continue Without Node| T[Bypass Node]\n    R --\x3e|Fail Pipeline| L\n\n    S --\x3e Z[Restart Processing]\n    Z --\x3e B\n\n    %% Outcomes\n    C --\x3e AD[Next Item]\n    J --\x3e AD\n    T --\x3e AE[Continue Pipeline<br>Without Node]\n    L --\x3e AF[Pipeline Terminates]\n    K --\x3e AC[Log and Store<br>Failed Item]\n    AC --\x3e C\n\n    classDef nodeError fill:#ffe6e6,stroke:#ff6666,stroke-width:2px\n    classDef pipelineError fill:#e6f3ff,stroke:#66aaff,stroke-width:2px\n    classDef decision fill:#fff2cc,stroke:#ffcc00,stroke-width:2px\n    classDef outcome fill:#e6ffe6,stroke:#66cc66,stroke-width:2px\n\n    class F,H,I,J,K,L nodeError\n    class G,R,S,T pipelineError\n    class B,E,M decision\n    class C,AD,AE,AF outcome"}),"\n",(0,o.jsx)(r.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.a,{href:"/docs/core-concepts/resilience/node-error-handling",children:"Node-Level Error Handling"})," - Implement custom error handlers for individual items"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.a,{href:"/docs/core-concepts/resilience/pipeline-error-handling",children:"Pipeline-Level Error Handling"})," - Manage errors affecting entire node streams"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.a,{href:"/docs/core-concepts/resilience/getting-started",children:"Getting Started with Resilience"})," - Quick guide to common error handling patterns"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.a,{href:"/docs/core-concepts/resilience/retries",children:"Retries"})," - Configure retry policies and strategies"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.a,{href:"/docs/core-concepts/resilience/circuit-breakers",children:"Circuit Breakers"})," - Prevent cascading failures with circuit breaker patterns"]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,o.jsxs)(r.p,{children:["For a quick introduction to error handling, see ",(0,o.jsx)(r.a,{href:"/docs/core-concepts/resilience/getting-started",children:"Getting Started with Resilience"}),". This guide covers the mandatory prerequisites and basic patterns to get you started."]}),"\n",(0,o.jsx)(r.p,{children:"For detailed implementation of specific error handlers, see:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.a,{href:"/docs/core-concepts/resilience/node-error-handling",children:"Node-Level Error Handling"})," for handling individual item failures"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.a,{href:"/docs/core-concepts/resilience/pipeline-error-handling",children:"Pipeline-Level Error Handling"})," for handling stream/node failures"]}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,l.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);