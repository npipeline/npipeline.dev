"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3909],{608:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"core-concepts/resilience/circuit-breakers","title":"Circuit Breakers","description":"Learn how to configure circuit breaker patterns in NPipeline using PipelineCircuitBreakerOptions to prevent cascading failures.","source":"@site/docs/core-concepts/resilience/circuit-breakers.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/circuit-breakers","permalink":"/docs/core-concepts/resilience/circuit-breakers","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Circuit Breakers","description":"Learn how to configure circuit breaker patterns in NPipeline using PipelineCircuitBreakerOptions to prevent cascading failures.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Resilience Quick Start","permalink":"/docs/core-concepts/resilience/getting-started"},"next":{"title":"Materialization and Buffering","permalink":"/docs/core-concepts/resilience/materialization"}}');var s=i(4848),t=i(8453);const a={title:"Circuit Breakers",description:"Learn how to configure circuit breaker patterns in NPipeline using PipelineCircuitBreakerOptions to prevent cascading failures.",sidebar_position:3},o="Circuit Breakers",l={},c=[{value:"Overview",id:"overview",level:2},{value:"PipelineCircuitBreakerOptions",id:"pipelinecircuitbreakeroptions",level:2},{value:"Configuration Parameters",id:"configuration-parameters",level:3},{value:"Circuit Breaker State Machine",id:"circuit-breaker-state-machine",level:2},{value:"State Descriptions",id:"state-descriptions",level:3},{value:"Basic Configuration",id:"basic-configuration",level:2},{value:"Threshold Types",id:"threshold-types",level:2},{value:"ConsecutiveFailures (Default)",id:"consecutivefailures-default",level:3},{value:"RollingWindowCount",id:"rollingwindowcount",level:3},{value:"RollingWindowRate",id:"rollingwindowrate",level:3},{value:"Hybrid",id:"hybrid",level:3},{value:"Recovery Configuration",id:"recovery-configuration",level:2},{value:"Real-World Configuration Scenarios",id:"real-world-configuration-scenarios",level:2},{value:"Scenario 1: High-Throughput API Integration",id:"scenario-1-high-throughput-api-integration",level:3},{value:"Scenario 2: Critical Database Operations",id:"scenario-2-critical-database-operations",level:3},{value:"Scenario 3: Bursty Service with Degradation Tolerance",id:"scenario-3-bursty-service-with-degradation-tolerance",level:3},{value:"Scenario 4: Multi-Level Protection",id:"scenario-4-multi-level-protection",level:3},{value:"Scenario 5: High-Tolerance Circuit Breaker",id:"scenario-5-high-tolerance-circuit-breaker",level:3},{value:"Scenario 6: Sensitive Circuit Breaker",id:"scenario-6-sensitive-circuit-breaker",level:3},{value:"Scenario 7: Rate-Based Circuit Breaker",id:"scenario-7-rate-based-circuit-breaker",level:3},{value:"Circuit Breaker Memory Management",id:"circuit-breaker-memory-management",level:2},{value:"Default Behavior",id:"default-behavior",level:3},{value:"Configuration Example",id:"configuration-example",level:3},{value:"Cleanup Timeout Configuration",id:"cleanup-timeout-configuration",level:3},{value:"When to Customize Memory Management",id:"when-to-customize-memory-management",level:3},{value:"Memory Management Scenarios",id:"memory-management-scenarios",level:3},{value:"Scenario 1: Short-Lived Nodes (e.g., Request-Based Pipelines)",id:"scenario-1-short-lived-nodes-eg-request-based-pipelines",level:4},{value:"Scenario 2: Large Pipelines with Many Nodes",id:"scenario-2-large-pipelines-with-many-nodes",level:4},{value:"Scenario 3: Disable Automatic Cleanup",id:"scenario-3-disable-automatic-cleanup",level:4},{value:"Scenario 4: Aggressive Memory Management",id:"scenario-4-aggressive-memory-management",level:4},{value:"Cleanup Behavior",id:"cleanup-behavior",level:3},{value:"Monitoring Cleanup",id:"monitoring-cleanup",level:3},{value:"Performance Impact",id:"performance-impact",level:3},{value:"Memory Management Notes",id:"memory-management-notes",level:3},{value:"Integration with ResilientExecutionStrategy",id:"integration-with-resilientexecutionstrategy",level:2},{value:"Monitoring Circuit Breaker Statistics",id:"monitoring-circuit-breaker-statistics",level:2},{value:"Disabling Circuit Breaker",id:"disabling-circuit-breaker",level:2},{value:"Important Notes",id:"important-notes",level:2},{value:"Distinction from Retry Options",id:"distinction-from-retry-options",level:3},{value:"Thread Safety",id:"thread-safety",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"circuit-breakers",children:"Circuit Breakers"})}),"\n",(0,s.jsx)(n.p,{children:"Circuit breaker configuration in NPipeline allows you to implement the circuit breaker pattern to prevent constantly failing nodes from continuously consuming resources or causing cascading failures throughout your pipeline."}),"\n",(0,s.jsx)(n.p,{children:"The CircuitBreaker implementation provides:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State Machine"}),": Complete implementation with Closed, Open, and Half-Open states"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rolling Window"}),": Time-based operation tracking for sophisticated failure analysis"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multiple Threshold Types"}),": ConsecutiveFailures, RollingWindowCount, RollingWindowRate, and Hybrid"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic Recovery"}),": Timer-based transition from Open to Half-Open state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Thread Safety"}),": Safe for concurrent pipeline execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Management"}),": Automatic cleanup of inactive circuit breakers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Backward Compatibility"}),": Existing configurations continue to work"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"The circuit breaker pattern is a design pattern used in software development to detect failures and encapsulate the logic of preventing a failure from constantly recurring. In NPipeline, this helps maintain system stability by temporarily stopping attempts to execute nodes that are experiencing persistent failures."}),"\n",(0,s.jsx)(n.h2,{id:"pipelinecircuitbreakeroptions",children:"PipelineCircuitBreakerOptions"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"../../../src/NPipeline/Configuration/PipelineCircuitBreakerOptions.cs",children:(0,s.jsx)(n.code,{children:"PipelineCircuitBreakerOptions"})})," record allows you to configure a circuit breaker pattern with enhanced functionality."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public sealed record PipelineCircuitBreakerOptions(\n    int FailureThreshold,\n    TimeSpan OpenDuration,\n    TimeSpan SamplingWindow,\n    bool Enabled = true,\n    CircuitBreakerThresholdType ThresholdType = CircuitBreakerThresholdType.ConsecutiveFailures,\n    double FailureRateThreshold = 0.5,\n    int HalfOpenSuccessThreshold = 1,\n    int HalfOpenMaxAttempts = 5,\n    bool TrackOperationsInWindow = true)\n{\n    public static PipelineCircuitBreakerOptions Disabled { get; } = new(int.MaxValue, TimeSpan.Zero, TimeSpan.Zero, false);\n    public static PipelineCircuitBreakerOptions Default { get; } = new(5, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(5));\n    \n    // Backward-compatible constructor\n    public PipelineCircuitBreakerOptions(int failureThreshold, TimeSpan openDuration, TimeSpan samplingWindow, bool enabled)\n        : this(failureThreshold, openDuration, samplingWindow, enabled, CircuitBreakerThresholdType.ConsecutiveFailures, 0.5, 1, 5, true)\n    {\n    }\n}\n\n/// <summary>\n///     Defines the type of failure threshold used for circuit breaking.\n/// </summary>\npublic enum CircuitBreakerThresholdType\n{\n    /// <summary>\n    ///     Uses consecutive failure count (default behavior).\n    /// </summary>\n    ConsecutiveFailures,\n\n    /// <summary>\n    ///     Uses failure count within the sampling window.\n    /// </summary>\n    RollingWindowCount,\n\n    /// <summary>\n    ///     Uses failure rate within the sampling window.\n    /// </summary>\n    RollingWindowRate,\n\n    /// <summary>\n    ///     Uses both count and rate thresholds.\n    /// </summary>\n    Hybrid\n}\n\n/// <summary>\n///     Exception thrown when the circuit breaker is open and blocks execution.\n/// </summary>\npublic sealed class CircuitBreakerOpenException : PipelineException\n{\n    public CircuitBreakerOpenException() : base("Circuit breaker is open and blocking execution.")\n    {\n        ErrorCode = "CIRCUIT_BREAKER_OPEN";\n    }\n\n    public CircuitBreakerOpenException(string message) : base(message)\n    {\n        ErrorCode = "CIRCUIT_BREAKER_OPEN";\n    }\n\n    public CircuitBreakerOpenException(string message, Exception innerException) : base(message, innerException)\n    {\n        ErrorCode = "CIRCUIT_BREAKER_OPEN";\n    }\n\n    /// <summary>\n    ///     Gets the error code associated with this exception.\n    /// </summary>\n    public string ErrorCode { get; }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"configuration-parameters",children:"Configuration Parameters"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"FailureThreshold"})}),": The threshold value used for circuit breaking (interpretation depends on ThresholdType)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"OpenDuration"})}),": How long the breaker remains open before transitioning to Half-Open state."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"SamplingWindow"})}),": Time window for rolling window failure tracking."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"Enabled"})}),": Whether the circuit breaker is active."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"ThresholdType"})}),": Type of failure threshold to use (ConsecutiveFailures, RollingWindowCount, RollingWindowRate, Hybrid)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"FailureRateThreshold"})}),": Failure rate threshold (0.0-1.0) when using RollingWindowRate or Hybrid threshold types."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"HalfOpenSuccessThreshold"})}),": Number of consecutive successes required in Half-Open state to transition to Closed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"HalfOpenMaxAttempts"})}),": Maximum number of operation attempts allowed in Half-Open state."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"TrackOperationsInWindow"})}),": Whether to track operations in the rolling window for statistics."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"circuit-breaker-state-machine",children:"Circuit Breaker State Machine"}),"\n",(0,s.jsx)(n.p,{children:"The circuit breaker has three main states with automatic transitions:"}),"\n",(0,s.jsx)(n.mermaid,{value:"stateDiagram-v2\n    [*] --\x3e Closed\n    Closed --\x3e Open: Failure threshold exceeded\n    Open --\x3e HalfOpen: OpenDuration elapsed\n    HalfOpen --\x3e Closed: Success threshold met\n    HalfOpen --\x3e Open: Any failure\n    Closed --\x3e Closed: Success (resets counters)"}),"\n",(0,s.jsx)(n.h3,{id:"state-descriptions",children:"State Descriptions"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Closed"}),": The circuit breaker allows operations to proceed normally. It tracks failures based on the configured threshold type and trips when the threshold is reached."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Open"}),": The circuit breaker has tripped and prevents operations from proceeding. After the OpenDuration expires, it automatically transitions to Half-Open state."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Half-Open"}),": The circuit breaker allows a limited number of operations to test if the underlying issue has been resolved. If enough operations succeed, it transitions to Closed. If any operation fails, it immediately returns to Open."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"basic-configuration",children:"Basic Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["The simplest way to add circuit breaker protection is with the fluent API or via ",(0,s.jsx)(n.code,{children:"PipelineRetryOptions"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class BasicCircuitBreakerPipelineDefinition : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var sourceHandle = builder.AddSource<DataSource, string>("source");\n        var transformHandle = builder.AddTransform<DataTransform, string, string>("transform");\n        var sinkHandle = builder.AddSink<DataSink, string>("sink");\n\n        builder.Connect(sourceHandle, transformHandle);\n        builder.Connect(transformHandle, sinkHandle);\n    }\n}\n\n// Configure the circuit breaker via PipelineRetryOptions:\nvar retryOptions = new PipelineRetryOptions(\n    MaxItemRetries: 3,\n    MaxNodeRestartAttempts: 2,\n    MaxSequentialNodeAttempts: 5,\n    MaxMaterializedItems: 1000,\n    CircuitBreakerOptions: new PipelineCircuitBreakerOptions(\n        failureThreshold: 5, // Trip after 5 consecutive failures\n        openDuration: TimeSpan.FromMinutes(1),\n        samplingWindow: TimeSpan.FromMinutes(5),\n        thresholdType: CircuitBreakerThresholdType.ConsecutiveFailures\n    )\n);\n\nvar context = PipelineContext.WithRetry(retryOptions);\nvar runner = PipelineRunner.Create();\nawait runner.RunAsync<BasicCircuitBreakerPipelineDefinition>(context);\n'})}),"\n",(0,s.jsx)(n.p,{children:"Or use the fluent API:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var builder = new PipelineBuilder();\n\n// Simple configuration: trip after 3 consecutive failures\nbuilder.WithCircuitBreaker(\n    failureThreshold: 3,\n    openDuration: TimeSpan.FromMinutes(1),\n    samplingWindow: TimeSpan.FromMinutes(5)\n);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"threshold-types",children:"Threshold Types"}),"\n",(0,s.jsx)(n.h3,{id:"consecutivefailures-default",children:"ConsecutiveFailures (Default)"}),"\n",(0,s.jsx)(n.p,{children:"Tracks consecutive failures without considering time. This is the original behavior and maintains backward compatibility."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineCircuitBreakerOptions(\n    failureThreshold: 5,\n    openDuration: TimeSpan.FromMinutes(1),\n    samplingWindow: TimeSpan.FromMinutes(5),\n    thresholdType: CircuitBreakerThresholdType.ConsecutiveFailures\n);\n\n// Trip after any 3 consecutive failures\nbuilder.WithCircuitBreaker(\n    failureThreshold: 3,\n    openDuration: TimeSpan.FromMinutes(1),\n    samplingWindow: TimeSpan.FromMinutes(5)\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use when:"})," You want simple, immediate failure detection. Best for services where even a few failures indicate a problem."]}),"\n",(0,s.jsx)(n.h3,{id:"rollingwindowcount",children:"RollingWindowCount"}),"\n",(0,s.jsx)(n.p,{children:"Tracks the total number of failures within a time window, regardless of whether they're consecutive."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Trip after 10 failures within a 5-minute window\nvar options = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 10,\n    OpenDuration: TimeSpan.FromMinutes(2),\n    SamplingWindow: TimeSpan.FromMinutes(5),\n    Enabled: true,\n    ThresholdType: CircuitBreakerThresholdType.RollingWindowCount\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use when:"})," You care about the absolute number of failures in a time period, regardless of how they're distributed."]}),"\n",(0,s.jsx)(n.h3,{id:"rollingwindowrate",children:"RollingWindowRate"}),"\n",(0,s.jsx)(n.p,{children:"Tracks the failure rate (failures/total operations) within a time window."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Trip if more than 10% of operations fail in a 5-minute window\nvar options = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 100,  // Minimum operations before rate is evaluated\n    OpenDuration: TimeSpan.FromMinutes(2),\n    SamplingWindow: TimeSpan.FromMinutes(5),\n    Enabled: true,\n    ThresholdType: CircuitBreakerThresholdType.RollingWindowRate,\n    FailureRateThreshold: 0.1  // 10% failure rate\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use when:"})," You want to tolerate occasional failures but trip on consistent degradation."]}),"\n",(0,s.jsx)(n.h3,{id:"hybrid",children:"Hybrid"}),"\n",(0,s.jsx)(n.p,{children:"Combines count and rate thresholds - trips if either is exceeded."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Trip if EITHER 5 failures in window OR 30% failure rate\nvar options = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 5,\n    OpenDuration: TimeSpan.FromMinutes(1),\n    SamplingWindow: TimeSpan.FromMinutes(5),\n    Enabled: true,\n    ThresholdType: CircuitBreakerThresholdType.Hybrid,\n    FailureRateThreshold: 0.3  // 30% failure rate\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use when:"})," You want comprehensive protection against both sudden failures and gradual degradation."]}),"\n",(0,s.jsx)(n.h2,{id:"recovery-configuration",children:"Recovery Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Control how your circuit breaker recovers after tripping:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 3,\n    OpenDuration: TimeSpan.FromMinutes(1),\n    SamplingWindow: TimeSpan.FromMinutes(5),\n    Enabled: true,\n    HalfOpenSuccessThreshold: 2,     // Require 2 consecutive successes\n    HalfOpenMaxAttempts: 5            // Allow up to 5 attempts in Half-Open\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"State transitions:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Closed \u2192 Open"}),": Failure threshold exceeded"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Open \u2192 Half-Open"}),": After ",(0,s.jsx)(n.code,{children:"OpenDuration"})," expires"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Half-Open \u2192 Closed"}),": After ",(0,s.jsx)(n.code,{children:"HalfOpenSuccessThreshold"})," consecutive successes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Half-Open \u2192 Open"}),": On any failure, or exceeding ",(0,s.jsx)(n.code,{children:"HalfOpenMaxAttempts"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"real-world-configuration-scenarios",children:"Real-World Configuration Scenarios"}),"\n",(0,s.jsx)(n.h3,{id:"scenario-1-high-throughput-api-integration",children:"Scenario 1: High-Throughput API Integration"}),"\n",(0,s.jsx)(n.p,{children:"For operations calling external APIs with occasional glitches:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineCircuitBreakerOptions(\n    failureThreshold: 50,  // Allow some failures before tripping\n    openDuration: TimeSpan.FromSeconds(30),  // Quick recovery window\n    samplingWindow: TimeSpan.FromMinutes(5),\n    thresholdType: CircuitBreakerThresholdType.RollingWindowCount\n);\n\n// Or with fluent API:\nbuilder.WithCircuitBreaker(\n    failureThreshold: 50,\n    openDuration: TimeSpan.FromSeconds(30),\n    samplingWindow: TimeSpan.FromMinutes(5)\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scenario-2-critical-database-operations",children:"Scenario 2: Critical Database Operations"}),"\n",(0,s.jsx)(n.p,{children:"For operations where any failure indicates a serious problem:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 2,\n    OpenDuration: TimeSpan.FromSeconds(10),\n    SamplingWindow: TimeSpan.FromMinutes(1),\n    Enabled: true,\n    ThresholdType: CircuitBreakerThresholdType.ConsecutiveFailures,\n    HalfOpenSuccessThreshold: 1,\n    HalfOpenMaxAttempts: 2\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scenario-3-bursty-service-with-degradation-tolerance",children:"Scenario 3: Bursty Service with Degradation Tolerance"}),"\n",(0,s.jsx)(n.p,{children:"For services that can tolerate occasional failures but need protection from persistent issues:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 100,\n    OpenDuration: TimeSpan.FromMinutes(2),\n    SamplingWindow: TimeSpan.FromMinutes(5),\n    Enabled: true,\n    ThresholdType: CircuitBreakerThresholdType.RollingWindowRate,\n    FailureRateThreshold: 0.2  // 20% failure rate threshold\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scenario-4-multi-level-protection",children:"Scenario 4: Multi-Level Protection"}),"\n",(0,s.jsx)(n.p,{children:"Combine multiple strategies across pipeline:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var builder = new PipelineBuilder();\n\n// Strict protection on critical transform\nvar criticalOptions = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 2,\n    OpenDuration: TimeSpan.FromSeconds(30),\n    SamplingWindow: TimeSpan.FromMinutes(1),\n    Enabled: true\n);\n\n// Lenient protection on resilient transform\nvar resilientOptions = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 100,\n    OpenDuration: TimeSpan.FromMinutes(5),\n    SamplingWindow: TimeSpan.FromMinutes(10),\n    Enabled: true,\n    ThresholdType: CircuitBreakerThresholdType.RollingWindowRate,\n    FailureRateThreshold: 0.25\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scenario-5-high-tolerance-circuit-breaker",children:"Scenario 5: High-Tolerance Circuit Breaker"}),"\n",(0,s.jsx)(n.p,{children:"For non-critical nodes where you want more resilience:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var tolerantOptions = new PipelineCircuitBreakerOptions(\n    failureThreshold: 20,\n    openDuration: TimeSpan.FromMinutes(5),\n    samplingWindow: TimeSpan.FromMinutes(10),\n    thresholdType: CircuitBreakerThresholdType.Hybrid,\n    failureRateThreshold: 0.4, // 40% failure rate\n    halfOpenSuccessThreshold: 3, // Require 3 consecutive successes\n    halfOpenMaxAttempts: 10 // Allow up to 10 attempts in Half-Open\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scenario-6-sensitive-circuit-breaker",children:"Scenario 6: Sensitive Circuit Breaker"}),"\n",(0,s.jsx)(n.p,{children:"For critical nodes where you want quick failure detection:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var sensitiveOptions = new PipelineCircuitBreakerOptions(\n    failureThreshold: 3,\n    openDuration: TimeSpan.FromSeconds(30),\n    samplingWindow: TimeSpan.FromMinutes(1),\n    thresholdType: CircuitBreakerThresholdType.ConsecutiveFailures,\n    halfOpenSuccessThreshold: 1,\n    halfOpenMaxAttempts: 2\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scenario-7-rate-based-circuit-breaker",children:"Scenario 7: Rate-Based Circuit Breaker"}),"\n",(0,s.jsx)(n.p,{children:"For nodes with high throughput where rate is more important than count:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var rateBasedOptions = new PipelineCircuitBreakerOptions(\n    failureThreshold: 100, // Minimum operations before rate is considered\n    openDuration: TimeSpan.FromMinutes(2),\n    samplingWindow: TimeSpan.FromMinutes(5),\n    thresholdType: CircuitBreakerThresholdType.RollingWindowRate,\n    failureRateThreshold: 0.1 // 10% failure rate\n);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"circuit-breaker-memory-management",children:"Circuit Breaker Memory Management"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"../../../src/NPipeline/Configuration/CircuitBreakerMemoryManagementOptions.cs:12",children:(0,s.jsx)(n.code,{children:"CircuitBreakerMemoryManagementOptions"})})," class provides configuration for managing circuit breaker memory usage and automatic cleanup:"]}),"\n",(0,s.jsx)(n.p,{children:"Circuit breaker instances are cached per node ID to maintain state across calls. In long-running applications or pipelines with many dynamic nodes, inactive breakers should be cleaned up to prevent memory leaks."}),"\n",(0,s.jsx)(n.h3,{id:"default-behavior",children:"Default Behavior"}),"\n",(0,s.jsx)(n.p,{children:"By default, NPipeline automatically manages circuit breaker memory:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cleanup interval"}),": 5 minutes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inactivity threshold"}),": 30 minutes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Max tracked breakers"}),": 1,000"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic cleanup"}),": Enabled"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"A circuit breaker is considered inactive if it hasn't been accessed (checked or updated) within the inactivity threshold. Inactive breakers are removed automatically."}),"\n",(0,s.jsx)(n.h3,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var memoryOptions = new CircuitBreakerMemoryManagementOptions(\n    cleanupInterval: TimeSpan.FromMinutes(5),    // How often cleanup runs\n    inactivityThreshold: TimeSpan.FromMinutes(30),  // When circuit breakers become eligible for removal\n    enableAutomaticCleanup: true,                  // Whether cleanup is enabled\n    maxTrackedCircuitBreakers: 1000,            // Maximum circuit breakers to track\n    cleanupTimeout: TimeSpan.FromSeconds(30)         // Timeout for cleanup operations\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cleanup-timeout-configuration",children:"Cleanup Timeout Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"CleanupTimeout"})," property controls the timeout for circuit breaker cleanup operations:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Default value"}),": 30 seconds"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Prevents deadlocks during cleanup operations by setting a maximum time limit"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Behavior"}),": If cleanup operations exceed this timeout, they are aborted to prevent system hangs"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When to adjust CleanupTimeout:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Increase"})," (e.g., 60 seconds) for:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Systems with very large numbers of circuit breakers (>1000)"}),"\n",(0,s.jsx)(n.li,{children:"Environments with slow I/O or high contention"}),"\n",(0,s.jsx)(n.li,{children:"Complex circuit breaker hierarchies with deep dependency chains"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Decrease"})," (e.g., 10-15 seconds) for:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Real-time systems where quick recovery is critical"}),"\n",(0,s.jsx)(n.li,{children:"Environments with limited circuit breaker counts"}),"\n",(0,s.jsx)(n.li,{children:"Systems where cleanup failures should be detected quickly"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Example: Extended timeout for systems with many circuit breakers\nvar highVolumeOptions = new CircuitBreakerMemoryManagementOptions(\n    cleanupInterval: TimeSpan.FromMinutes(5),\n    inactivityThreshold: TimeSpan.FromMinutes(30),\n    enableAutomaticCleanup: true,\n    maxTrackedCircuitBreakers: 5000,  // High volume\n    cleanupTimeout: TimeSpan.FromMinutes(1) // Extended timeout for large cleanup operations\n);\n\n// Example: Quick timeout for real-time systems\nvar realtimeOptions = new CircuitBreakerMemoryManagementOptions(\n    cleanupInterval: TimeSpan.FromMinutes(1),\n    inactivityThreshold: TimeSpan.FromMinutes(10),\n    enableAutomaticCleanup: true,\n    maxTrackedCircuitBreakers: 100,\n    cleanupTimeout: TimeSpan.FromSeconds(10) // Quick timeout for fast recovery\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"when-to-customize-memory-management",children:"When to Customize Memory Management"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Customize cleanup for these scenarios:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Scenario"}),(0,s.jsx)(n.th,{children:"Issue"}),(0,s.jsx)(n.th,{children:"Solution"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Many short-lived nodes"}),(0,s.jsx)(n.td,{children:"Memory grows unbounded"}),(0,s.jsxs)(n.td,{children:["Lower ",(0,s.jsx)(n.code,{children:"InactivityThreshold"})," and ",(0,s.jsx)(n.code,{children:"MaxTrackedCircuitBreakers"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"High-frequency cleanup overhead"}),(0,s.jsx)(n.td,{children:"Cleanup CPU cost too high"}),(0,s.jsxs)(n.td,{children:["Increase ",(0,s.jsx)(n.code,{children:"CleanupInterval"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Rapid node creation/destruction"}),(0,s.jsx)(n.td,{children:"Eviction happens too often"}),(0,s.jsxs)(n.td,{children:["Increase ",(0,s.jsx)(n.code,{children:"MaxTrackedCircuitBreakers"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Long-running pipelines"}),(0,s.jsx)(n.td,{children:"Need stricter memory control"}),(0,s.jsx)(n.td,{children:"Enable aggressive cleanup with lower thresholds"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"memory-management-scenarios",children:"Memory Management Scenarios"}),"\n",(0,s.jsx)(n.h4,{id:"scenario-1-short-lived-nodes-eg-request-based-pipelines",children:"Scenario 1: Short-Lived Nodes (e.g., Request-Based Pipelines)"}),"\n",(0,s.jsx)(n.p,{children:"For pipelines where nodes are created per request and disposed after:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"builder.ConfigureCircuitBreakerMemoryManagement(opts =>\n    opts with\n    {\n        InactivityThreshold = TimeSpan.FromMinutes(5),    // Clean up faster\n        MaxTrackedCircuitBreakers = 100,                  // Limit tracked breakers\n        CleanupInterval = TimeSpan.FromSeconds(30)        // Check frequently\n    }\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"When the limit is reached, the least-recently-used breaker is evicted."}),"\n",(0,s.jsx)(n.h4,{id:"scenario-2-large-pipelines-with-many-nodes",children:"Scenario 2: Large Pipelines with Many Nodes"}),"\n",(0,s.jsx)(n.p,{children:"For pipelines with hundreds of nodes that may or may not be accessed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"builder.ConfigureCircuitBreakerMemoryManagement(opts =>\n    opts with\n    {\n        MaxTrackedCircuitBreakers = 5000,                 // Allow more breakers\n        InactivityThreshold = TimeSpan.FromHours(1),      // Longer inactivity window\n        CleanupInterval = TimeSpan.FromMinutes(10)        // Less frequent cleanup\n    }\n);\n"})}),"\n",(0,s.jsx)(n.h4,{id:"scenario-3-disable-automatic-cleanup",children:"Scenario 3: Disable Automatic Cleanup"}),"\n",(0,s.jsx)(n.p,{children:"For controlled scenarios where you manage cleanup manually:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'builder.ConfigureCircuitBreakerMemoryManagement(opts =>\n    opts with\n    {\n        EnableAutomaticCleanup = false\n    }\n);\n\n// Later, manually trigger cleanup when appropriate\n// (Requires access to CircuitBreakerManager from pipeline context)\nif (context.Items.TryGetValue(PipelineContextKeys.CircuitBreakerManager, out var manager) &&\n    manager is ICircuitBreakerManager cbManager)\n{\n    int removedCount = cbManager.TriggerCleanup();\n    logger.LogInformation("Cleaned up {Count} inactive circuit breakers", removedCount);\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"scenario-4-aggressive-memory-management",children:"Scenario 4: Aggressive Memory Management"}),"\n",(0,s.jsx)(n.p,{children:"For memory-constrained environments:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"builder.ConfigureCircuitBreakerMemoryManagement(opts =>\n    opts with\n    {\n        MaxTrackedCircuitBreakers = 50,                   // Very strict limit\n        InactivityThreshold = TimeSpan.FromMinutes(2),    // Aggressive cleanup\n        CleanupInterval = TimeSpan.FromSeconds(10),       // Frequent checks\n        EnableAutomaticCleanup = true\n    }\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cleanup-behavior",children:"Cleanup Behavior"}),"\n",(0,s.jsx)(n.p,{children:"When cleanup runs, NPipeline:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Identifies inactive breakers"}),": Breakers not accessed within ",(0,s.jsx)(n.code,{children:"InactivityThreshold"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Removes inactive breakers"}),": Disposes stale circuit breaker instances"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Evicts if necessary"}),": If ",(0,s.jsx)(n.code,{children:"MaxTrackedCircuitBreakers"})," is exceeded, removes least-recently-used (LRU) breaker"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Logs activity"}),": Records cleanup events at DEBUG/WARNING levels"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"monitoring-cleanup",children:"Monitoring Cleanup"}),"\n",(0,s.jsx)(n.p,{children:"Track circuit breaker lifecycle in your observability infrastructure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// Get current tracking count\nif (context.Items.TryGetValue(PipelineContextKeys.CircuitBreakerManager, out var manager) &&\n    manager is ICircuitBreakerManager cbManager)\n{\n    int trackedCount = cbManager.GetTrackedCircuitBreakerCount();\n    metrics.Gauge("circuitbreaker.tracked_count", trackedCount);\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"performance-impact",children:"Performance Impact"}),"\n",(0,s.jsx)(n.p,{children:"Memory management is designed to be lightweight:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cleanup operation"}),": O(n) where n = tracked breakers; typically < 10ms"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tracking overhead"}),": ~100 bytes per circuit breaker (timestamp + node ID)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"LRU eviction"}),": O(n) scan to find least-recently-used"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For most applications, defaults provide good balance. Customize only if:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Monitoring shows excessive memory growth"}),"\n",(0,s.jsx)(n.li,{children:"Cleanup CPU cost is significant (> 5% of pipeline execution time)"}),"\n",(0,s.jsx)(n.li,{children:"You have specific memory constraints"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"memory-management-notes",children:"Memory Management Notes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Access updates"}),": Any access (check or state change) updates the breaker's last-accessed timestamp"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Persistent state"}),": Circuit breaker state is ",(0,s.jsx)(n.strong,{children:"not"})," restored after removal and recreation\u2014it starts as Closed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Thread-safe"}),": All cleanup operations are thread-safe; no synchronization needed"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-resilientexecutionstrategy",children:"Integration with ResilientExecutionStrategy"}),"\n",(0,s.jsx)(n.p,{children:"The CircuitBreaker is automatically integrated with the ResilientExecutionStrategy:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// The circuit breaker is automatically used when ResilientExecutionStrategy is enabled\n// and CircuitBreakerOptions are configured in the retry options\n\nvar resilientOptions = new PipelineRetryOptions(\n    MaxItemRetries: 3,\n    MaxNodeRestartAttempts: 5,\n    CircuitBreakerOptions: new PipelineCircuitBreakerOptions(\n        failureThreshold: 3,\n        openDuration: TimeSpan.FromMinutes(1),\n        samplingWindow: TimeSpan.FromMinutes(5),\n        thresholdType: CircuitBreakerThresholdType.RollingWindowRate,\n        failureRateThreshold: 0.2\n    )\n);\n\n// The ResilientExecutionStrategy will automatically:\n// 1. Track operations in the rolling window\n// 2. Check circuit breaker state before each operation\n// 3. Record successes and failures\n// 4. Handle state transitions automatically\n// 5. Throw CircuitBreakerOpenException when the circuit is open\n"})}),"\n",(0,s.jsx)(n.h2,{id:"monitoring-circuit-breaker-statistics",children:"Monitoring Circuit Breaker Statistics"}),"\n",(0,s.jsx)(n.p,{children:"The CircuitBreaker provides detailed statistics that can be accessed for monitoring:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// The CircuitBreakerManager tracks circuit breakers for each node\n// You can access statistics through the circuit breaker instance\n\nWindowStatistics stats = circuitBreaker.GetStatistics();\n// stats.TotalOperations - Total operations in the window\n// stats.FailureCount - Number of failed operations\n// stats.SuccessCount - Number of successful operations\n// stats.FailureRate - Failure rate (0.0 to 1.0)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"disabling-circuit-breaker",children:"Disabling Circuit Breaker"}),"\n",(0,s.jsx)(n.p,{children:"If needed, you can disable circuit breaking:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 5,\n    OpenDuration: TimeSpan.FromMinutes(1),\n    SamplingWindow: TimeSpan.FromMinutes(5),\n    Enabled: false  // Disabled - no circuit breaker checks\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or use the predefined disabled option:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var disabledOptions = PipelineCircuitBreakerOptions.Disabled;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,s.jsx)(n.h3,{id:"distinction-from-retry-options",children:"Distinction from Retry Options"}),"\n",(0,s.jsxs)(n.p,{children:["Circuit breaker configuration is ",(0,s.jsx)(n.strong,{children:"separate"})," from retry configuration:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"WithCircuitBreaker()"})}),": Prevents repeated attempts when failure threshold is reached"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"WithRetryOptions()"})}),": Controls how many retries are allowed per item or per node"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Both can be used together for comprehensive resilience:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var builder = new PipelineBuilder();\n\n// Control retries at the item/node level\nbuilder.WithRetryOptions(o => o.With(maxNodeRestartAttempts: 3));\n\n// Prevent cascade failures across the pipeline\nbuilder.WithCircuitBreaker(failureThreshold: 5);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,s.jsx)(n.p,{children:"Circuit breakers are fully thread-safe and designed for concurrent pipeline execution. Multiple threads can safely check and update breaker state simultaneously."}),"\n",(0,s.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Circuit breakers add minimal overhead (~50-100ns per check in Closed state)"}),"\n",(0,s.jsx)(n.li,{children:"Operation tracking uses efficient rolling windows with automatic cleanup"}),"\n",(0,s.jsx)(n.li,{children:"No significant memory overhead for typical usage patterns"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Circuit breaker trips too frequently:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Increase ",(0,s.jsx)(n.code,{children:"FailureThreshold"})," to tolerate more failures"]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"RollingWindowRate"})," to tolerate occasional failures"]}),"\n",(0,s.jsxs)(n.li,{children:["Extend ",(0,s.jsx)(n.code,{children:"SamplingWindow"})," to smooth out bursty failures"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Circuit breaker never trips:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Reduce ",(0,s.jsx)(n.code,{children:"FailureThreshold"})]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"ConsecutiveFailures"})," for immediate detection"]}),"\n",(0,s.jsxs)(n.li,{children:["Reduce ",(0,s.jsx)(n.code,{children:"SamplingWindow"})," for faster detection"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Slow recovery:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Reduce ",(0,s.jsx)(n.code,{children:"OpenDuration"})]}),"\n",(0,s.jsxs)(n.li,{children:["Lower ",(0,s.jsx)(n.code,{children:"HalfOpenSuccessThreshold"})," to recover faster"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For more troubleshooting help, see the ",(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting guide"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Choose the right threshold type"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"ConsecutiveFailures"})," for simple scenarios"]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"RollingWindowCount"})," for high-volume operations"]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"RollingWindowRate"})," for rate-sensitive scenarios"]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"Hybrid"})," for comprehensive protection"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Set appropriate sampling windows"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Shorter windows (1-5 minutes) for quick detection"}),"\n",(0,s.jsx)(n.li,{children:"Longer windows (10-30 minutes) for stability in volatile environments"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Configure Half-Open parameters carefully"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Higher ",(0,s.jsx)(n.code,{children:"HalfOpenSuccessThreshold"})," for more conservative recovery"]}),"\n",(0,s.jsxs)(n.li,{children:["Lower ",(0,s.jsx)(n.code,{children:"HalfOpenMaxAttempts"})," to prevent flooding recovering services"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Monitor circuit breaker state transitions"}),": Track when circuit breakers open and close to identify systemic issues."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use different thresholds for different nodes"}),": Critical nodes might have lower thresholds than non-critical ones."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Implement alerting"}),": Set up alerts when circuit breakers open to notify operations teams."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Consider graceful degradation"}),": Design your pipeline to continue functioning even when some nodes are isolated by circuit breakers."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Test circuit breaker behavior"}),": Include circuit breaker scenarios in your testing to ensure they work as expected."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/",children:"Resilience Overview"})}),": Comprehensive guide to building fault-tolerant pipelines"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling"})}),": Learn about handling errors at node and pipeline levels"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retries",children:"Retries"})}),": Configure retry behavior for items and node restarts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/dead-letter-queues",children:"Dead-Letter Queues"})}),": Implement dead-letter queues for problematic items"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting"})}),": Diagnose and resolve common resilience issues"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var r=i(6540);const s={},t=r.createContext(s);function a(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);