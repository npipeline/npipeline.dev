"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[4610],{7732:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>f,frontMatter:()=>s,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"architecture/retry-delay-architecture","title":"Retry Delay Strategies Architecture","description":"How NPipeline\'s retry delay system works internally, including design patterns, components, and architectural decisions.","source":"@site/docs/architecture/retry-delay-architecture.md","sourceDirName":"architecture","slug":"/architecture/retry-delay-architecture","permalink":"/docs/architecture/retry-delay-architecture","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"Retry Delay Strategies Architecture","description":"How NPipeline\'s retry delay system works internally, including design patterns, components, and architectural decisions.","sidebar_position":8},"sidebar":"docsSidebar","previous":{"title":"Performance Characteristics","permalink":"/docs/architecture/performance-characteristics"},"next":{"title":"Extension Points","permalink":"/docs/architecture/extension-points"}}');var r=n(4848),a=n(8453);const s={title:"Retry Delay Strategies Architecture",description:"How NPipeline's retry delay system works internally, including design patterns, components, and architectural decisions.",sidebar_position:8},l="Retry Delay Strategies Architecture",c={},o=[{value:"Overview",id:"overview",level:2},{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Architecture Components",id:"architecture-components",level:2},{value:"1. Backoff Strategies",id:"1-backoff-strategies",level:3},{value:"2. Jitter Strategies",id:"2-jitter-strategies",level:3},{value:"3. Strategy Implementation",id:"3-strategy-implementation",level:3},{value:"4. Composite Strategy",id:"4-composite-strategy",level:3},{value:"5. Factory",id:"5-factory",level:3},{value:"6. PipelineContext Integration",id:"6-pipelinecontext-integration",level:3},{value:"Design Patterns Used",id:"design-patterns-used",level:2},{value:"Strategy Pattern",id:"strategy-pattern",level:3},{value:"Composite Pattern",id:"composite-pattern",level:3},{value:"Factory Pattern",id:"factory-pattern",level:3},{value:"Configuration Pattern",id:"configuration-pattern",level:3},{value:"Data Flow",id:"data-flow",level:2},{value:"Configuration to Execution",id:"configuration-to-execution",level:3},{value:"Async Execution Flow",id:"async-execution-flow",level:3},{value:"Validation Architecture",id:"validation-architecture",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Memory Usage",id:"memory-usage",level:3},{value:"CPU Usage",id:"cpu-usage",level:3},{value:"Thread Safety",id:"thread-safety",level:3},{value:"Extensibility",id:"extensibility",level:2},{value:"Adding Custom Backoff Strategy",id:"adding-custom-backoff-strategy",level:3},{value:"Adding Custom Jitter Strategy",id:"adding-custom-jitter-strategy",level:3},{value:"Integration Points",id:"integration-points",level:2},{value:"With ResilientExecutionStrategy",id:"with-resilientexecutionstrategy",level:3},{value:"With PipelineContext",id:"with-pipelinecontext",level:3},{value:"Testing Architecture",id:"testing-architecture",level:2},{value:"Unit Testing Strategies",id:"unit-testing-strategies",level:3},{value:"Integration Testing",id:"integration-testing",level:3},{value:"Factory Testing",id:"factory-testing",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"See Also",id:"see-also",level:2},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"retry-delay-strategies-architecture",children:"Retry Delay Strategies Architecture"})}),"\n",(0,r.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(t.p,{children:"NPipeline's retry delay system is built on a modular architecture that separates concerns into distinct components. This guide explains the design, components, and how they work together."}),"\n",(0,r.jsx)(t.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#architecture-components",children:"Architecture Components"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#design-patterns-used",children:"Design Patterns Used"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#data-flow",children:"Data Flow"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#validation-architecture",children:"Validation Architecture"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#performance-considerations",children:"Performance Considerations"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#extensibility",children:"Extensibility"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#integration-points",children:"Integration Points"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#testing-architecture",children:"Testing Architecture"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"architecture-components",children:"Architecture Components"}),"\n",(0,r.jsx)(t.h3,{id:"1-backoff-strategies",children:"1. Backoff Strategies"}),"\n",(0,r.jsx)(t.p,{children:"Backoff strategies determine how delays increase between retry attempts."}),"\n",(0,r.jsx)(t.mermaid,{value:'graph TD\n    subgraph "Backoff Strategy Configuration"\n        A[BackoffStrategyConfiguration<br>Interface] --\x3e B[ExponentialBackoffConfiguration]\n        A --\x3e C[LinearBackoffConfiguration]\n        A --\x3e D[FixedDelayConfiguration]\n    end\n    \n    subgraph "Backoff Strategy Implementation"\n        E[BackoffStrategy<br>Delegate Type] --\x3e F[BackoffStrategies.ExponentialBackoff()]\n        E --\x3e G[BackoffStrategies.LinearBackoff()]\n        E --\x3e H[BackoffStrategies.FixedDelay()]\n    end\n    \n    B --\x3e I[Validates parameters<br>Creates immutable config]\n    C --\x3e I\n    D --\x3e I\n    \n    F --\x3e J[Calculates: baseDelay \xd7 multiplier^attempt<br>Capped at maxDelay]\n    G --\x3e K[Calculates: baseDelay + (increment \xd7 attempt)<br>Capped at maxDelay]\n    H --\x3e L[Returns: constant delay for all attempts]\n    \n    style A fill:#e1f5fe\n    style E fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#f3e5f5\n    style D fill:#f3e5f5\n    style F fill:#e8f5e9\n    style G fill:#e8f5e9\n    style H fill:#e8f5e9\n    style I fill:#fff3e0\n    style J fill:#e3f2fd\n    style K fill:#e3f2fd\n    style L fill:#e3f2fd'}),"\n",(0,r.jsx)(t.p,{children:"Each configuration:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Defines parameters for delay calculation"}),"\n",(0,r.jsx)(t.li,{children:"Implements validation to ensure valid parameters"}),"\n",(0,r.jsx)(t.li,{children:"Can be serialized/deserialized for persistence"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Key Characteristics:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Immutable (uses ",(0,r.jsx)(t.code,{children:"init"})," properties)"]}),"\n",(0,r.jsx)(t.li,{children:"Validated on creation"}),"\n",(0,r.jsx)(t.li,{children:"Deterministic (same input produces same output)"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"2-jitter-strategies",children:"2. Jitter Strategies"}),"\n",(0,r.jsx)(t.p,{children:"Jitter strategies add randomness to backoff delays to prevent synchronized retries. The implementation has been simplified to use delegate-based strategies instead of interface-based classes."}),"\n",(0,r.jsx)(t.mermaid,{value:'graph TD\n    subgraph "Jitter Strategy Configuration"\n        A[JitterStrategyConfiguration<br>Interface] --\x3e B[FullJitterConfiguration]\n        A --\x3e C[EqualJitterConfiguration]\n        A --\x3e D[DecorrelatedJitterConfiguration]\n        A --\x3e E[NoJitterConfiguration]\n    end\n    \n    subgraph "Jitter Strategy Implementation"\n        F[JitterStrategy<br>Delegate Type] --\x3e G[JitterStrategies.FullJitter()]\n        F --\x3e H[JitterStrategies.EqualJitter()]\n        F --\x3e I[JitterStrategies.DecorrelatedJitter()]\n        F --\x3e J[JitterStrategies.NoJitter()]\n    end\n    \n    subgraph "Jitter Application"\n        K[Base Delay from Backoff] --\x3e L{Jitter Strategy}\n        L --\x3e|Full Jitter|M[random(0, baseDelay)]\n        L --\x3e|Equal Jitter|N[baseDelay/2 + random(0, baseDelay/2)]\n        L --\x3e|Decorrelated Jitter|O[random(baseDelay, min(maxDelay, previousDelay \xd7 multiplier))]\n        L --\x3e|No Jitter|P[Return baseDelay unchanged]\n    end\n    \n    style A fill:#e1f5fe\n    style F fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#f3e5f5\n    style D fill:#f3e5f5\n    style E fill:#f3e5f5\n    style G fill:#e8f5e9\n    style H fill:#e8f5e9\n    style I fill:#e8f5e9\n    style J fill:#e8f5e9\n    style K fill:#fff3e0\n    style L fill:#ffecb3\n    style M fill:#e3f2fd\n    style N fill:#e3f2fd\n    style O fill:#e3f2fd\n    style P fill:#e3f2fd'}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Benefits of Jitter:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:'Prevents "thundering herd" problem'}),"\n",(0,r.jsx)(t.li,{children:"Spreads retry load over time"}),"\n",(0,r.jsx)(t.li,{children:"Improves system stability"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"3-strategy-implementation",children:"3. Strategy Implementation"}),"\n",(0,r.jsx)(t.p,{children:"The actual retry delay calculation is performed by strategy implementations:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"BackoffStrategy (Delegate)\n\u251c\u2500\u2500 BackoffStrategies.ExponentialBackoff()\n\u251c\u2500\u2500 BackoffStrategies.LinearBackoff()\n\u2514\u2500\u2500 BackoffStrategies.FixedDelay()\n\nJitterStrategy (Delegate)\n\u251c\u2500\u2500 JitterStrategies.FullJitter()\n\u251c\u2500\u2500 JitterStrategies.EqualJitter()\n\u251c\u2500\u2500 JitterStrategies.DecorrelatedJitter()\n\u2514\u2500\u2500 JitterStrategies.NoJitter()\n"})}),"\n",(0,r.jsx)(t.p,{children:"These implement the mathematical formulas for delay calculation. Both backoff and jitter strategies are now implemented as static methods that return delegates, providing a more streamlined API while maintaining the same functionality."}),"\n",(0,r.jsx)(t.h3,{id:"4-composite-strategy",children:"4. Composite Strategy"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"IRetryDelayStrategy\n\u2514\u2500\u2500 CompositeRetryDelayStrategy\n    \u251c\u2500\u2500 Combines: BackoffStrategy (delegate)\n    \u251c\u2500\u2500 Combines: JitterStrategy (delegate)\n    \u2514\u2500\u2500 Handles: Cancellation, async execution\n"})}),"\n",(0,r.jsx)(t.p,{children:"The composite strategy:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Orchestrates backoff and jitter"}),"\n",(0,r.jsxs)(t.li,{children:["Manages async execution with ",(0,r.jsx)(t.code,{children:"ValueTask"})]}),"\n",(0,r.jsx)(t.li,{children:"Respects cancellation tokens"}),"\n",(0,r.jsx)(t.li,{children:"Caches state for stateful jitter (e.g., decorrelated)"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"5-factory",children:"5. Factory"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"DefaultRetryDelayStrategyFactory\n\u251c\u2500\u2500 Creates individual strategies\n\u251c\u2500\u2500 Validates configurations\n\u2514\u2500\u2500 Combines strategies appropriately\n"})}),"\n",(0,r.jsx)(t.p,{children:"The factory:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Handles configuration validation"}),"\n",(0,r.jsx)(t.li,{children:"Creates appropriate strategy instances"}),"\n",(0,r.jsx)(t.li,{children:"Manages strategy lifecycle"}),"\n",(0,r.jsx)(t.li,{children:"Provides centralized creation logic"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"6-pipelinecontext-integration",children:"6. PipelineContext Integration"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"PipelineContextRetryDelayExtensions\n\u251c\u2500\u2500 GetRetryDelayStrategy() - retrieves/caches strategy\n\u251c\u2500\u2500 GetRetryDelayAsync() - gets delay for attempt\n\u251c\u2500\u2500 UseExponentialBackoffDelay() - runtime config\n\u251c\u2500\u2500 UseLinearBackoffDelay() - runtime config\n\u2514\u2500\u2500 UseExponentialBackoffWithJitter() - runtime config\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Integration Features:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Caches strategies to avoid recreation"}),"\n",(0,r.jsx)(t.li,{children:"Supports runtime configuration"}),"\n",(0,r.jsx)(t.li,{children:"Integrates with resilient execution strategy"}),"\n",(0,r.jsx)(t.li,{children:"Provides convenient API for common patterns"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"design-patterns-used",children:"Design Patterns Used"}),"\n",(0,r.jsx)(t.h3,{id:"strategy-pattern",children:"Strategy Pattern"}),"\n",(0,r.jsx)(t.p,{children:"Each backoff/jitter type implements a different strategy:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"// Backoff strategy delegate type\npublic delegate TimeSpan BackoffStrategy(int attemptNumber);\n\n// Static factory methods for creating strategies\npublic static class BackoffStrategies\n{\n    public static BackoffStrategy ExponentialBackoff(TimeSpan baseDelay, double multiplier = 2.0, TimeSpan? maxDelay = null);\n    public static BackoffStrategy LinearBackoff(TimeSpan baseDelay, TimeSpan? increment = null, TimeSpan? maxDelay = null);\n    public static BackoffStrategy FixedDelay(TimeSpan delay);\n}\n\n// Jitter strategy delegate type\npublic delegate TimeSpan JitterStrategy(TimeSpan baseDelay, Random random);\n\n// Static factory methods for creating jitter strategies\npublic static class JitterStrategies\n{\n    public static JitterStrategy FullJitter();\n    public static JitterStrategy EqualJitter();\n    public static JitterStrategy DecorrelatedJitter();\n    public static JitterStrategy NoJitter();\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"composite-pattern",children:"Composite Pattern"}),"\n",(0,r.jsx)(t.p,{children:"Combines backoff and jitter into a single strategy:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class CompositeRetryDelayStrategy : IRetryDelayStrategy\n{\n    private readonly BackoffStrategy _backoff;\n    private readonly JitterStrategy _jitter;\n    \n    public async ValueTask<TimeSpan> GetDelayAsync(int attemptNumber)\n    {\n        // Get base delay from backoff strategy\n        var baseDelay = _backoff(attemptNumber);\n        \n        // Apply jitter if present\n        if (_jitter != null)\n            return _jitter(baseDelay, _random);\n        \n        return baseDelay;\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"factory-pattern",children:"Factory Pattern"}),"\n",(0,r.jsx)(t.p,{children:"Creates strategies from configurations:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class DefaultRetryDelayStrategyFactory\n{\n    public IRetryDelayStrategy CreateExponentialBackoff(\n        ExponentialBackoffConfiguration config,\n        JitterStrategy jitterStrategy = null)\n    {\n        config.Validate();\n        var backoff = BackoffStrategies.ExponentialBackoff(\n            config.BaseDelay, \n            config.Multiplier, \n            config.MaxDelay);\n        return new CompositeRetryDelayStrategy(backoff, jitterStrategy);\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"configuration-pattern",children:"Configuration Pattern"}),"\n",(0,r.jsx)(t.p,{children:"Separates configuration from implementation:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"// Configuration - data only\npublic class ExponentialBackoffConfiguration\n{\n    public TimeSpan BaseDelay { get; init; }\n    public double Multiplier { get; init; }\n    public TimeSpan MaxDelay { get; init; }\n}\n\n// Implementation - uses configuration with delegate\nvar backoff = BackoffStrategies.ExponentialBackoff(\n    config.BaseDelay, \n    config.Multiplier, \n    config.MaxDelay);\n"})}),"\n",(0,r.jsx)(t.h2,{id:"data-flow",children:"Data Flow"}),"\n",(0,r.jsx)(t.h3,{id:"configuration-to-execution",children:"Configuration to Execution"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"1. PipelineRetryOptions\n   \u2514\u2500\u2500 RetryDelayStrategyConfiguration\n       \u251c\u2500\u2500 BackoffStrategyConfiguration\n       \u2514\u2500\u2500 JitterStrategyConfiguration\n\n2. Factory.CreateStrategy(configuration)\n   \u251c\u2500\u2500 Validate configurations\n   \u251c\u2500\u2500 Create backoff strategy delegate\n   \u251c\u2500\u2500 Create jitter strategy delegate\n   \u2514\u2500\u2500 Return composite strategy\n\n3. PipelineContext.GetRetryDelayStrategy()\n   \u251c\u2500\u2500 Check cache\n   \u251c\u2500\u2500 If not cached:\n   \u2502   \u2514\u2500\u2500 factory.CreateStrategy()\n   \u2514\u2500\u2500 Return strategy\n\n4. ResilientExecutionStrategy\n   \u2514\u2500\u2500 On failure:\n       \u251c\u2500\u2500 Get strategy from context\n       \u251c\u2500\u2500 Calculate delay for attempt\n       \u251c\u2500\u2500 Wait for delay\n       \u2514\u2500\u2500 Retry operation\n"})}),"\n",(0,r.jsx)(t.h3,{id:"async-execution-flow",children:"Async Execution Flow"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"async Task<TimeSpan> GetDelayAsync(attemptNumber)\n\u2502\n\u251c\u2500 BackoffStrategy(attemptNumber) (synchronous delegate)\n\u2502  \u2514\u2500 Returns base delay\n\u2502\n\u251c\u2500 JitterStrategy.ApplyJitter (may be async)\n\u2502  \u2514\u2500 Adds randomness\n\u2502\n\u2514\u2500 Return combined delay\n"})}),"\n",(0,r.jsx)(t.h2,{id:"validation-architecture",children:"Validation Architecture"}),"\n",(0,r.jsx)(t.p,{children:"Each configuration component validates independently:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"RetryDelayStrategyConfiguration\n\u251c\u2500\u2500 Validates self\n\u251c\u2500\u2500 BackoffStrategyConfiguration.Validate()\n\u2502  \u2514\u2500 Specific validation rules\n\u2514\u2500\u2500 JitterStrategyConfiguration.Validate()\n   \u2514\u2500 Specific validation rules\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Validation Timing:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Configuration creation: Optional (deferred)"}),"\n",(0,r.jsx)(t.li,{children:"Factory creation: Mandatory (immediate)"}),"\n",(0,r.jsx)(t.li,{children:"Strategy usage: Pre-validated"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(t.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Configurations"}),": Immutable, small (few properties)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Strategies"}),": Stateless delegates - minimal memory footprint"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Factory"}),": Singleton pattern recommended"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"PipelineContext"}),": Caches single strategy per context"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"cpu-usage",children:"CPU Usage"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Delay calculation"}),": O(1) - simple arithmetic"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Validation"}),": One-time cost at factory creation"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Random generation"}),": Minimal overhead, only if jitter enabled"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Async overhead"}),": Minimal for synchronous paths with ValueTask"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Configurations"}),": Immutable - fully thread-safe"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Strategies"}),": Stateless delegates - thread-safe"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Decorrelated Jitter"}),": Thread-safe with proper locking"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Factory"}),": Thread-safe (pure function pattern)"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"extensibility",children:"Extensibility"}),"\n",(0,r.jsx)(t.h3,{id:"adding-custom-backoff-strategy",children:"Adding Custom Backoff Strategy"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class CustomBackoffConfiguration : BackoffStrategyConfiguration\n{\n    public override void Validate()\n    {\n        // Your validation logic\n    }\n}\n\n// Create a custom backoff delegate\nBackoffStrategy customBackoff = (attemptNumber) =>\n{\n    // Your delay calculation logic\n    return TimeSpan.FromSeconds(Math.Pow(2, attemptNumber));\n};\n\n// Extend factory\npublic class ExtendedFactory : DefaultRetryDelayStrategyFactory\n{\n    public IRetryDelayStrategy CreateCustomBackoff(\n        CustomBackoffConfiguration config)\n    {\n        config.Validate();\n        var backoff = BackoffStrategies.ExponentialBackoff(\n            config.BaseDelay, \n            config.Multiplier, \n            config.MaxDelay);\n        return new CompositeRetryDelayStrategy(backoff, null);\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"adding-custom-jitter-strategy",children:"Adding Custom Jitter Strategy"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"// Create a custom jitter delegate\nJitterStrategy customJitter = (baseDelay, random) =>\n{\n    // Your custom jitter calculation logic\n    var jitterMs = random.NextDouble() * baseDelay.TotalMilliseconds * 0.1;\n    return TimeSpan.FromMilliseconds(jitterMs);\n};\n\n// Use with configuration\nvar config = new CustomJitterConfiguration();\nvar jitter = JitterStrategies.Custom(config);\n\n// Or use directly with backoff\nvar backoff = BackoffStrategies.ExponentialBackoff(\n    TimeSpan.FromSeconds(1), \n    2.0, \n    TimeSpan.FromMinutes(1));\nvar composite = new CompositeRetryDelayStrategy(backoff, customJitter);\n"})}),"\n",(0,r.jsx)(t.p,{children:"For configuration-based custom jitter:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public class CustomJitterConfiguration : JitterStrategyConfiguration\n{\n    public double JitterFactor { get; init; } = 0.1;\n    \n    public override void Validate()\n    {\n        if (JitterFactor < 0 || JitterFactor > 1.0)\n            throw new ArgumentException("JitterFactor must be between 0 and 1.0");\n    }\n}\n\n// Extend JitterStrategies with a static method\npublic static class JitterStrategies\n{\n    public static JitterStrategy Custom(CustomJitterConfiguration config)\n    {\n        config.Validate();\n        return (baseDelay, random) =>\n        {\n            var jitterMs = random.NextDouble() * baseDelay.TotalMilliseconds * config.JitterFactor;\n            return TimeSpan.FromMilliseconds(jitterMs);\n        };\n    }\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,r.jsx)(t.h3,{id:"with-resilientexecutionstrategy",children:"With ResilientExecutionStrategy"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class ResilientExecutionStrategy\n{\n    public async Task ExecuteAsync(/* ... */)\n    {\n        for (int attempt = 0; attempt <= maxRetries; attempt++)\n        {\n            try\n            {\n                return await Execute();\n            }\n            catch when (attempt < maxRetries)\n            {\n                // Integration point: Get delay from context\n                var strategy = context.GetRetryDelayStrategy();\n                var delay = await strategy.GetDelayAsync(attempt);\n                \n                // Wait respecting cancellation\n                await Task.Delay(delay, cancellationToken);\n            }\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"with-pipelinecontext",children:"With PipelineContext"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public class PipelineContext\n{\n    private Dictionary<string, object> _items;\n    \n    public IRetryDelayStrategy GetRetryDelayStrategy()\n    {\n        // Cache key: "NPipeline.RetryDelayStrategy"\n        if (!_items.TryGetValue(key, out var cached))\n        {\n            var factory = new DefaultRetryDelayStrategyFactory();\n            cached = factory.CreateStrategy(\n                RetryOptions.DelayStrategyConfiguration);\n            _items[key] = cached;\n        }\n        \n        return (IRetryDelayStrategy)cached;\n    }\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"testing-architecture",children:"Testing Architecture"}),"\n",(0,r.jsx)(t.h3,{id:"unit-testing-strategies",children:"Unit Testing Strategies"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"[Fact]\npublic void ExponentialBackoff_WithValidParameters_CalculatesCorrectly()\n{\n    var backoff = BackoffStrategies.ExponentialBackoff(\n        TimeSpan.FromSeconds(1), \n        2.0, \n        TimeSpan.FromMinutes(1));\n    \n    Assert.Equal(TimeSpan.FromSeconds(1), backoff(0));\n    Assert.Equal(TimeSpan.FromSeconds(2), backoff(1));\n    Assert.Equal(TimeSpan.FromSeconds(4), backoff(2));\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"[Fact]\npublic async Task CompositeStrategy_WithBackoffAndJitter_WorksTogether()\n{\n    var backoff = BackoffStrategies.ExponentialBackoff(\n        TimeSpan.FromSeconds(1), \n        2.0, \n        TimeSpan.FromMinutes(1));\n    var jitter = JitterStrategies.FullJitter();\n    var composite = new CompositeRetryDelayStrategy(backoff, jitter);\n    \n    var delay = await composite.GetDelayAsync(1);\n    \n    Assert.InRange(delay, TimeSpan.Zero, TimeSpan.FromSeconds(2));\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"factory-testing",children:"Factory Testing"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"[Fact]\npublic void Factory_CreatesCorrectStrategies()\n{\n    var factory = new DefaultRetryDelayStrategyFactory();\n    \n    var strategy = factory.CreateExponentialBackoff(\n        new ExponentialBackoffConfiguration(),\n        null);\n    \n    Assert.IsType<CompositeRetryDelayStrategy>(strategy);\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(t.p,{children:"NPipeline's retry delay architecture provides:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Separation of Concerns"}),": Backoff and jitter are independent"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Flexibility"}),": Easy to add new strategies through delegates"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Performance"}),": Minimal overhead with caching and stateless delegates"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Testability"}),": Each component can be tested independently"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Observability"}),": Clear design makes debugging easier"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Extensibility"}),": Custom strategies can be added as delegates"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"This architecture enables robust, configurable retry behavior for resilient data pipelines."}),"\n",(0,r.jsx)(t.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/core-concepts/resilience/retry-delay-advanced",children:"Advanced Retry Delay Strategies"})}),": Advanced patterns and scenarios for using retry delay strategies in production environments"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/core-concepts/resilience/retries",children:"Retries"})}),": Basic retry configuration options and built-in strategies"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/core-concepts/resilience/",children:"Resilience Overview"})}),": Comprehensive guide to building fault-tolerant pipelines"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/component-architecture",children:"Component Architecture"})}),": Overview of major NPipeline system components and their interactions"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/execution-flow",children:"Execution Flow"})}),": How pipelines execute data and flow through the system"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/error-handling-architecture",children:"Error Handling Architecture"})}),": Error propagation and handling mechanisms in NPipeline"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/design-principles",children:"Design Principles"})}),": Core philosophy behind NPipeline's design including separation of concerns and composability"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/performance-characteristics",children:"Performance Characteristics"})}),": Understanding performance implications of retry strategies and other architectural decisions"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/extension-points",children:"Extension Points"})}),": How to extend NPipeline functionality including custom retry strategies"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/optimization-principles",children:"Optimization Principles"})}),": Performance optimizations that influence retry delay system design"]}),"\n"]})]})}function f(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var i=n(6540);const r={},a=i.createContext(r);function s(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);