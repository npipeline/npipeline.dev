"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[2661],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>s});var r=i(96540);const t={},a=r.createContext(t);function o(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(a.Provider,{value:n},e.children)}},86770:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"extensions/composition/error-handling","title":"Error Handling in Composite Pipelines","description":"Overview","source":"@site/docs/extensions/composition/error-handling.md","sourceDirName":"extensions/composition","slug":"/extensions/composition/error-handling","permalink":"/docs/extensions/composition/error-handling","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Context Inheritance","permalink":"/docs/extensions/composition/context-inheritance"},"next":{"title":"Nested Composition","permalink":"/docs/extensions/composition/nested-composition"}}');var t=i(74848),a=i(28453);const o={},s="Error Handling in Composite Pipelines",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Error Propagation",id:"error-propagation",level:2},{value:"Basic Flow",id:"basic-flow",level:3},{value:"Example",id:"example",level:3},{value:"Error Handling Strategies",id:"error-handling-strategies",level:2},{value:"Strategy 1: Catch in Sub-Pipeline",id:"strategy-1-catch-in-sub-pipeline",level:3},{value:"Strategy 2: Let Errors Propagate",id:"strategy-2-let-errors-propagate",level:3},{value:"Strategy 3: Hybrid Approach",id:"strategy-3-hybrid-approach",level:3},{value:"Error Context",id:"error-context",level:2},{value:"Accessing Error Information",id:"accessing-error-information",level:3},{value:"Adding Context in Sub-Pipelines",id:"adding-context-in-sub-pipelines",level:3},{value:"Retry and Circuit Breaker",id:"retry-and-circuit-breaker",level:2},{value:"Retry in Sub-Pipelines",id:"retry-in-sub-pipelines",level:3},{value:"Circuit Breaker for Composite Nodes",id:"circuit-breaker-for-composite-nodes",level:3},{value:"Cancellation Handling",id:"cancellation-handling",level:2},{value:"Respecting Cancellation in Sub-Pipelines",id:"respecting-cancellation-in-sub-pipelines",level:3},{value:"Handling Cancellation in Transforms",id:"handling-cancellation-in-transforms",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Fail Fast",id:"1-fail-fast",level:3},{value:"2. Provide Context",id:"2-provide-context",level:3},{value:"3. Log Appropriately",id:"3-log-appropriately",level:3},{value:"4. Use Typed Exceptions",id:"4-use-typed-exceptions",level:3},{value:"5. Test Error Scenarios",id:"5-test-error-scenarios",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"error-handling-in-composite-pipelines",children:"Error Handling in Composite Pipelines"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Error handling in composite pipelines follows NPipeline's standard error handling model, with errors propagating through the pipeline hierarchy in a predictable manner."}),"\n",(0,t.jsx)(n.h2,{id:"error-propagation",children:"Error Propagation"}),"\n",(0,t.jsx)(n.h3,{id:"basic-flow",children:"Basic Flow"}),"\n",(0,t.jsx)(n.p,{children:"Errors in sub-pipelines propagate to the parent pipeline:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Main Pipeline\n  \u2193 (executes)\nComposite Node\n  \u2193 (executes)\nSub-Pipeline\n  \u2193 (throws error)\nTransform Node (error occurs here)\n\nError propagates:\n  \u2191 Sub-Pipeline error handler\n  \u2191 Composite Node (re-throws)\n  \u2191 Main Pipeline error handler\n"})}),"\n",(0,t.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Sub-pipeline with potential error\npublic class ValidationPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<Data>, Data>("input");\n        \n        // This transform might throw\n        var validate = builder.AddTransform<ValidatorNode, Data, Data>("validate");\n        \n        var output = builder.AddSink<PipelineOutputSink<Data>, Data>("output");\n        \n        builder.Connect(input, validate);\n        builder.Connect(validate, output);\n    }\n}\n\n// ValidatorNode that throws on invalid data\npublic class ValidatorNode : TransformNode<Data, Data>\n{\n    public override Task<Data> ExecuteAsync(Data input, PipelineContext context, CancellationToken ct)\n    {\n        if (!input.IsValid)\n        {\n            throw new ValidationException($"Invalid data: {input.Id}");\n        }\n        \n        return Task.FromResult(input);\n    }\n}\n\n// Parent pipeline\npublic class ProcessingPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<DataSource, Data>("source");\n        var validate = builder.AddComposite<Data, Data, ValidationPipeline>("validate");\n        var sink = builder.AddSink<DataSink, Data>("sink");\n        \n        builder.Connect(source, validate);\n        builder.Connect(validate, sink);\n    }\n}\n\n// Usage with error handling\ntry\n{\n    await runner.RunAsync<ProcessingPipeline>(context);\n}\ncatch (ValidationException ex)\n{\n    // Error from sub-pipeline caught here\n    Console.WriteLine($"Validation failed: {ex.Message}");\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling-strategies",children:"Error Handling Strategies"}),"\n",(0,t.jsx)(n.h3,{id:"strategy-1-catch-in-sub-pipeline",children:"Strategy 1: Catch in Sub-Pipeline"}),"\n",(0,t.jsx)(n.p,{children:"Handle errors within the sub-pipeline:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class ResilientSubPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<Data>, Data>("input");\n        \n        // Transform that handles its own errors\n        var transform = builder.AddTransform<ResilientTransform, Data, Result>("transform");\n        \n        var output = builder.AddSink<PipelineOutputSink<Result>, Result>("output");\n        \n        builder.Connect(input, transform);\n        builder.Connect(transform, output);\n    }\n}\n\npublic class ResilientTransform : TransformNode<Data, Result>\n{\n    public override async Task<Result> ExecuteAsync(Data input, PipelineContext context, CancellationToken ct)\n    {\n        try\n        {\n            var processed = await ProcessAsync(input);\n            return Result.Success(processed);\n        }\n        catch (Exception ex)\n        {\n            // Handle error and return error result\n            return Result.Failure(ex.Message);\n        }\n    }\n    \n    private Task<Data> ProcessAsync(Data input) { /* ... */ }\n}\n\n// Result type encapsulates success/failure\npublic class Result\n{\n    public bool IsSuccess { get; init; }\n    public Data? Data { get; init; }\n    public string? Error { get; init; }\n    \n    public static Result Success(Data data) => new() { IsSuccess = true, Data = data };\n    public static Result Failure(string error) => new() { IsSuccess = false, Error = error };\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"strategy-2-let-errors-propagate",children:"Strategy 2: Let Errors Propagate"}),"\n",(0,t.jsx)(n.p,{children:"Allow errors to bubble up to parent:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class SubPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<Data>, Data>("input");\n        \n        // Transform that throws on error\n        var transform = builder.AddTransform<ThrowingTransform, Data, Data>("transform");\n        \n        var output = builder.AddSink<PipelineOutputSink<Data>, Data>("output");\n        \n        builder.Connect(input, transform);\n        builder.Connect(transform, output);\n    }\n}\n\n// Parent handles all errors\npublic class ParentPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        // Configure error handling at parent level\n        builder.WithErrorHandler(new CustomErrorHandler());\n        \n        var source = builder.AddSource<DataSource, Data>("source");\n        var process = builder.AddComposite<Data, Data, SubPipeline>("process");\n        var sink = builder.AddSink<DataSink, Data>("sink");\n        \n        builder.Connect(source, process);\n        builder.Connect(process, sink);\n    }\n}\n\npublic class CustomErrorHandler : IErrorHandler\n{\n    public Task<ErrorHandlingDecision> HandleAsync(NodeExecutionContext nodeContext, Exception exception)\n    {\n        // Log error\n        Log.Error(exception, "Error in node {NodeId}", nodeContext.NodeId);\n        \n        // Decide how to proceed\n        if (exception is ValidationException)\n        {\n            // Continue with next item\n            return Task.FromResult(ErrorHandlingDecision.Continue);\n        }\n        \n        // Fail pipeline\n        return Task.FromResult(ErrorHandlingDecision.Fail);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"strategy-3-hybrid-approach",children:"Strategy 3: Hybrid Approach"}),"\n",(0,t.jsx)(n.p,{children:"Handle some errors in sub-pipeline, let others propagate:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class HybridSubPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<Data>, Data>("input");\n        \n        // Handle expected errors\n        var transform = builder.AddTransform<SafeTransform, Data, Data>("transform");\n        \n        // Let unexpected errors propagate\n        var verify = builder.AddTransform<VerifierTransform, Data, Data>("verify");\n        \n        var output = builder.AddSink<PipelineOutputSink<Data>, Data>("output");\n        \n        builder.Connect(input, transform);\n        builder.Connect(transform, verify);\n        builder.Connect(verify, output);\n    }\n}\n\npublic class SafeTransform : TransformNode<Data, Data>\n{\n    public override async Task<Data> ExecuteAsync(Data input, PipelineContext context, CancellationToken ct)\n    {\n        try\n        {\n            return await ProcessAsync(input);\n        }\n        catch (ExpectedException ex)\n        {\n            // Handle expected errors\n            LogWarning(ex);\n            return input; // Return original data\n        }\n        // Other exceptions propagate\n    }\n}\n\npublic class VerifierTransform : TransformNode<Data, Data>\n{\n    public override Task<Data> ExecuteAsync(Data input, PipelineContext context, CancellationToken ct)\n    {\n        // Throws on critical errors\n        if (input.IsCriticallyInvalid)\n        {\n            throw new CriticalException("Critical validation failure");\n        }\n        \n        return Task.FromResult(input);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"error-context",children:"Error Context"}),"\n",(0,t.jsx)(n.h3,{id:"accessing-error-information",children:"Accessing Error Information"}),"\n",(0,t.jsx)(n.p,{children:"Errors include context about where they occurred:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'try\n{\n    await runner.RunAsync<MainPipeline>(context);\n}\ncatch (NodeExecutionException ex)\n{\n    Console.WriteLine($"Node: {ex.NodeId}");\n    Console.WriteLine($"Pipeline: {ex.PipelineId}");\n    Console.WriteLine($"Error: {ex.InnerException?.Message}");\n    \n    // For composite nodes, check if error came from sub-pipeline\n    if (ex.NodeId.Contains("composite"))\n    {\n        Console.WriteLine("Error occurred in sub-pipeline");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"adding-context-in-sub-pipelines",children:"Adding Context in Sub-Pipelines"}),"\n",(0,t.jsx)(n.p,{children:"Enrich errors with context:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class ContextEnrichingTransform : TransformNode<Data, Data>\n{\n    public override async Task<Data> ExecuteAsync(Data input, PipelineContext context, CancellationToken ct)\n    {\n        try\n        {\n            return await ProcessAsync(input);\n        }\n        catch (Exception ex)\n        {\n            // Add context and rethrow\n            throw new ProcessingException(\n                $"Failed to process item {input.Id} in sub-pipeline",\n                ex);\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"retry-and-circuit-breaker",children:"Retry and Circuit Breaker"}),"\n",(0,t.jsx)(n.h3,{id:"retry-in-sub-pipelines",children:"Retry in Sub-Pipelines"}),"\n",(0,t.jsx)(n.p,{children:"Configure retry behavior for sub-pipelines:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class RetrySubPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        // Configure retry for this sub-pipeline\n        builder.WithRetryOptions(new RetryOptions\n        {\n            MaxRetries = 3,\n            RetryDelay = TimeSpan.FromSeconds(1),\n            RetryableExceptions = new[] { typeof(TransientException) }\n        });\n        \n        var input = builder.AddSource<PipelineInputSource<Data>, Data>("input");\n        var transform = builder.AddTransform<UnreliableTransform, Data, Data>("transform");\n        var output = builder.AddSink<PipelineOutputSink<Data>, Data>("output");\n        \n        builder.Connect(input, transform);\n        builder.Connect(transform, output);\n    }\n}\n\n// Usage in parent (retry happens at sub-pipeline level)\nbuilder.AddComposite<Data, Data, RetrySubPipeline>("retry-pipeline");\n'})}),"\n",(0,t.jsx)(n.h3,{id:"circuit-breaker-for-composite-nodes",children:"Circuit Breaker for Composite Nodes"}),"\n",(0,t.jsx)(n.p,{children:"Protect parent pipeline from failing sub-pipelines:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class ProtectedParentPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        // Configure circuit breaker\n        builder.WithCircuitBreaker(new CircuitBreakerOptions\n        {\n            FailureThreshold = 5,\n            ResetTimeout = TimeSpan.FromMinutes(1)\n        });\n        \n        var source = builder.AddSource<DataSource, Data>("source");\n        \n        // If sub-pipeline fails repeatedly, circuit opens\n        var process = builder.AddComposite<Data, Data, UnstableSubPipeline>("process");\n        \n        var sink = builder.AddSink<DataSink, Data>("sink");\n        \n        builder.Connect(source, process);\n        builder.Connect(process, sink);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"cancellation-handling",children:"Cancellation Handling"}),"\n",(0,t.jsx)(n.h3,{id:"respecting-cancellation-in-sub-pipelines",children:"Respecting Cancellation in Sub-Pipelines"}),"\n",(0,t.jsx)(n.p,{children:"Sub-pipelines automatically respect cancellation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Cancellation propagates through hierarchy\nvar cts = new CancellationTokenSource();\n\n// Start pipeline\nvar task = runner.RunAsync<MainPipeline>(context);\n\n// Cancel after 5 seconds\ncts.CancelAfter(TimeSpan.FromSeconds(5));\n\ntry\n{\n    await task;\n}\ncatch (OperationCanceledException)\n{\n    // Cancellation occurred in main or sub-pipeline\n    Console.WriteLine("Pipeline cancelled");\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"handling-cancellation-in-transforms",children:"Handling Cancellation in Transforms"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class CancellableTransform : TransformNode<Data, Data>\n{\n    public override async Task<Data> ExecuteAsync(Data input, PipelineContext context, CancellationToken ct)\n    {\n        // Check cancellation before expensive operation\n        ct.ThrowIfCancellationRequested();\n        \n        await ExpensiveOperationAsync(input, ct);\n        \n        // Check cancellation after operation\n        ct.ThrowIfCancellationRequested();\n        \n        return input;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-fail-fast",children:"1. Fail Fast"}),"\n",(0,t.jsx)(n.p,{children:"Don't catch errors you can't handle:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"\u2705 Good: Let critical errors propagate\npublic override Task<Data> ExecuteAsync(Data input, PipelineContext context, CancellationToken ct)\n{\n    // Let critical errors propagate\n    ValidateCritical(input);\n    \n    try\n    {\n        return ProcessAsync(input);\n    }\n    catch (TransientException ex)\n    {\n        // Only handle transient errors\n        return HandleTransientError(ex, input);\n    }\n}\n\n\u274c Bad: Catch everything\npublic override Task<Data> ExecuteAsync(Data input, PipelineContext context, CancellationToken ct)\n{\n    try\n    {\n        return ProcessAsync(input);\n    }\n    catch (Exception ex)\n    {\n        // Swallowing all errors\n        return Task.FromResult(input);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-provide-context",children:"2. Provide Context"}),"\n",(0,t.jsx)(n.p,{children:"Include relevant information in error messages:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'\u2705 Good: Detailed error message\nthrow new ProcessingException(\n    $"Failed to process customer {input.Id} in validation pipeline. " +\n    $"Error: {ex.Message}", ex);\n\n\u274c Bad: Generic error\nthrow new Exception("Error occurred");\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-log-appropriately",children:"3. Log Appropriately"}),"\n",(0,t.jsx)(n.p,{children:"Log errors at the appropriate level:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class LoggingTransform : TransformNode<Data, Data>\n{\n    private readonly ILogger _logger;\n    \n    public LoggingTransform(ILogger logger)\n    {\n        _logger = logger;\n    }\n    \n    public override async Task<Data> ExecuteAsync(Data input, PipelineContext context, CancellationToken ct)\n    {\n        try\n        {\n            return await ProcessAsync(input);\n        }\n        catch (Exception ex)\n        {\n            // Log with context\n            _logger.LogError(ex,\n                "Processing failed for item {ItemId} in pipeline {Pipeline}",\n                input.Id,\n                context.Properties.GetValueOrDefault("PipelineId"));\n            \n            throw; // Re-throw for upstream handling\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"4-use-typed-exceptions",children:"4. Use Typed Exceptions"}),"\n",(0,t.jsx)(n.p,{children:"Create specific exception types for different error scenarios:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class ValidationException : Exception\n{\n    public string ItemId { get; }\n    public List<string> Errors { get; }\n    \n    public ValidationException(string itemId, List<string> errors)\n        : base($"Validation failed for {itemId}")\n    {\n        ItemId = itemId;\n        Errors = errors;\n    }\n}\n\npublic class ProcessingException : Exception\n{\n    public ProcessingException(string message, Exception inner)\n        : base(message, inner) { }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"5-test-error-scenarios",children:"5. Test Error Scenarios"}),"\n",(0,t.jsx)(n.p,{children:"Test how your pipelines handle errors:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"[Fact]\npublic async Task SubPipeline_WithInvalidData_ShouldThrowValidationException()\n{\n    // Arrange\n    var context = new PipelineContext();\n    context.Parameters[CompositeContextKeys.InputItem] = CreateInvalidData();\n    \n    // Act & Assert\n    await Assert.ThrowsAsync<ValidationException>(() =>\n        runner.RunAsync<ValidationPipeline>(context));\n}\n\n[Fact]\npublic async Task ParentPipeline_WithSubPipelineError_ShouldHandleGracefully()\n{\n    // Arrange\n    var context = new PipelineContext();\n    var errorHandler = new MockErrorHandler();\n    builder.WithErrorHandler(errorHandler);\n    \n    // Act\n    await runner.RunAsync<ParentPipeline>(context);\n    \n    // Assert\n    Assert.True(errorHandler.WasCalled);\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Strategy"}),(0,t.jsx)(n.th,{children:"Pros"}),(0,t.jsx)(n.th,{children:"Cons"}),(0,t.jsx)(n.th,{children:"Use When"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Catch in Sub-Pipeline"})}),(0,t.jsx)(n.td,{children:"Isolated errors, graceful degradation"}),(0,t.jsx)(n.td,{children:"May hide issues"}),(0,t.jsx)(n.td,{children:"Expected, recoverable errors"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Propagate to Parent"})}),(0,t.jsx)(n.td,{children:"Centralized handling, fail fast"}),(0,t.jsx)(n.td,{children:"Less isolation"}),(0,t.jsx)(n.td,{children:"Unexpected, critical errors"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Hybrid"})}),(0,t.jsx)(n.td,{children:"Flexibility, best of both"}),(0,t.jsx)(n.td,{children:"More complexity"}),(0,t.jsx)(n.td,{children:"Complex error scenarios"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"Choose the error handling strategy that best fits your:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error types"}),": Expected vs unexpected"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recovery options"}),": Retry, fallback, or fail"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Observability needs"}),": Logging and monitoring requirements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"User experience"}),": How errors should affect the pipeline flow"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);