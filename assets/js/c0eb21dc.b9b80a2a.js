"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[9087],{1146:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-concepts/resilience/resilient-execution-strategy","title":"Resilient Execution Strategy","description":"Learn how ResilientExecutionStrategy wraps other execution strategies to provide fault tolerance and recovery capabilities.","source":"@site/docs/core-concepts/resilience/resilient-execution-strategy.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/resilient-execution-strategy","permalink":"/docs/core-concepts/resilience/resilient-execution-strategy","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Resilient Execution Strategy","description":"Learn how ResilientExecutionStrategy wraps other execution strategies to provide fault tolerance and recovery capabilities.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Node Restart - Quick Start Checklist","permalink":"/docs/core-concepts/resilience/node-restart-quickstart"},"next":{"title":"Circuit Breaker Advanced Configuration","permalink":"/docs/core-concepts/resilience/circuit-breaker-advanced-configuration"}}');var t=n(4848),a=n(8453);const l={title:"Resilient Execution Strategy",description:"Learn how ResilientExecutionStrategy wraps other execution strategies to provide fault tolerance and recovery capabilities.",sidebar_position:2},s="Resilient Execution Strategy",o={},c=[{value:"How It Works",id:"how-it-works",level:2},{value:"Key Responsibilities",id:"key-responsibilities",level:2},{value:"Wrapper Pattern",id:"wrapper-pattern",level:2},{value:"Materialization Behavior",id:"materialization-behavior",level:2},{value:"Configuration Examples",id:"configuration-examples",level:2},{value:"Basic Resilient Sequential Execution",id:"basic-resilient-sequential-execution",level:3},{value:"Resilient Parallel Execution",id:"resilient-parallel-execution",level:3},{value:"Per-Node Retry Options",id:"per-node-retry-options",level:3},{value:"Prerequisite Relationship",id:"prerequisite-relationship",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Memory Usage",id:"memory-usage",level:3},{value:"Latency Impact",id:"latency-impact",level:3},{value:"Throughput Considerations",id:"throughput-considerations",level:3},{value:"Integration with Error Handling",id:"integration-with-error-handling",level:2},{value:"Common Configuration Patterns",id:"common-configuration-patterns",level:2},{value:"E-commerce Order Processing",id:"e-commerce-order-processing",level:3},{value:"High-Volume Data Analytics",id:"high-volume-data-analytics",level:3},{value:"Microservice Integration",id:"microservice-integration",level:3},{value:"Configuration Decision Matrix",id:"configuration-decision-matrix",level:3},{value:"Common Configuration Mistakes to Avoid",id:"common-configuration-mistakes-to-avoid",level:3},{value:"\u27a1\ufe0f Next Steps",id:"arrow_right-next-steps",level:2}];function d(e){const r={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"resilient-execution-strategy",children:"Resilient Execution Strategy"})}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsxs)(r.p,{children:["\u2139\ufe0f"," ",(0,t.jsx)(r.strong,{children:"Documentation Scope"}),"\r\nThis guide covers ",(0,t.jsx)(r.strong,{children:"resilience capabilities"})," - the wrapper strategy that adds error handling, retries, and node restart functionality. For information about ",(0,t.jsx)(r.strong,{children:"all execution strategies"})," (sequential, parallel, and how they work), see ",(0,t.jsx)(r.a,{href:"/docs/core-concepts/pipeline-execution/execution-strategies",children:"Execution Strategies"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.a,{href:"../../../src/NPipeline/Execution/Strategies/ResilientExecutionStrategy.cs",children:(0,t.jsx)(r.code,{children:"ResilientExecutionStrategy"})})," is a wrapper strategy that enables resilience capabilities for your pipeline nodes. It doesn't execute nodes directly but instead wraps another execution strategy (like ",(0,t.jsx)(r.code,{children:"SequentialExecutionStrategy"})," or ",(0,t.jsx)(r.code,{children:"ParallelExecutionStrategy"}),") to add error handling, retry logic, and recovery mechanisms."]}),"\n",(0,t.jsx)(r.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"ResilientExecutionStrategy"})," acts as a middleware layer between the pipeline executor and the actual execution strategy:"]}),"\n",(0,t.jsx)(r.mermaid,{value:'graph TD\r\n    A[Pipeline Executor] --\x3e B[ResilientExecutionStrategy]\r\n    B --\x3e C["Inner Strategy\r\n(Sequential/Parallel)"]\r\n    C --\x3e D[Node Processing]\r\n    D --\x3e E{Success?}\r\n    E --\x3e|Yes| F[Output Stream]\r\n    E --\x3e|No| G[Error Handler]\r\n    G --\x3e H{PipelineErrorDecision}\r\n    H --\x3e|RestartNode| I[Restart Stream]\r\n    H --\x3e|ContinueWithoutNode| J[Bypass Node]\r\n    H --\x3e|FailPipeline| K[Pipeline Failure]\r\n    I --\x3e C\r\n\r\n    style B fill:#e1f5fe\r\n    style G fill:#fff3e0\r\n    style H fill:#ffecb3'}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.em,{children:"Figure: ResilientExecutionStrategy wraps inner strategies to add resilience capabilities."})}),"\n",(0,t.jsx)(r.h2,{id:"key-responsibilities",children:"Key Responsibilities"}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"ResilientExecutionStrategy"})," handles several critical responsibilities:"]}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Stream Materialization"}),": Automatically materializes streaming inputs to enable replay during restarts"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Error Interception"}),": Catches exceptions from node execution and routes them to the error handler"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Decision Execution"}),": Implements the ",(0,t.jsx)(r.code,{children:"PipelineErrorDecision"})," returned by the error handler"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Circuit Breaking"}),": Prevents cascading failures when consecutive failures exceed thresholds"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Retry Limit Enforcement"}),": Respects configured retry limits for both items and node restarts"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"wrapper-pattern",children:"Wrapper Pattern"}),"\n",(0,t.jsx)(r.p,{children:"The strategy follows a wrapper pattern where it enhances any inner strategy with resilience capabilities:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'// Wrap a sequential strategy\r\nvar resilientSequential = new ResilientExecutionStrategy(\r\n    new SequentialExecutionStrategy()\r\n);\r\n\r\n// Wrap a parallel strategy\r\nvar resilientParallel = new ResilientExecutionStrategy(\r\n    new ParallelExecutionStrategy(maxDegreeOfParallelism: 4)\r\n);\r\n\r\n// Apply to a node\r\nvar nodeHandle = builder\r\n    .AddTransform<MyTransform, Input, Output>("myNode")\r\n    .WithExecutionStrategy(builder, resilientParallel);\n'})}),"\n",(0,t.jsx)(r.h2,{id:"materialization-behavior",children:"Materialization Behavior"}),"\n",(0,t.jsxs)(r.p,{children:["When the ",(0,t.jsx)(r.code,{children:"ResilientExecutionStrategy"})," detects a streaming input, it automatically materializes the stream to enable replay functionality:"]}),"\n",(0,t.jsx)(r.mermaid,{value:"graph TD\r\n    A[Streaming Input] --\x3e B{ResilientExecutionStrategy Applied?}\r\n    B --\x3e|No| C[Direct Processing]\r\n    B --\x3e|Yes| D[Materialize via CappedReplayableDataPipe]\r\n    D --\x3e E[Buffer Items]\r\n    E --\x3e F[Process Items]\r\n    F --\x3e G{Failure?}\r\n    G --\x3e|No| H[Continue]\r\n    G --\x3e|Yes| I[Replay from Buffer]\r\n    I --\x3e F\r\n\r\n    style B fill:#e1f5fe\r\n    style D fill:#f3e5f5\r\n    style E fill:#e8f5e9\r\n    style I fill:#fff3e0"}),"\n",(0,t.jsxs)(r.p,{children:["The materialization process is controlled by the ",(0,t.jsx)(r.code,{children:"MaxMaterializedItems"})," parameter in ",(0,t.jsx)(r.code,{children:"PipelineRetryOptions"}),":"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsxs)(r.strong,{children:["When ",(0,t.jsx)(r.code,{children:"MaxMaterializedItems"})," is null"]})," (default): Unbounded materialization - all items are buffered"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsxs)(r.strong,{children:["When ",(0,t.jsx)(r.code,{children:"MaxMaterializedItems"})," has a value"]}),": Limited materialization - only the specified number of items are buffered"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,t.jsx)(r.h3,{id:"basic-resilient-sequential-execution",children:"Basic Resilient Sequential Execution"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Execution.Strategies;\r\nusing NPipeline.ErrorHandling;\r\n\r\n// Create a resilient sequential strategy\r\nvar resilientStrategy = new ResilientExecutionStrategy(\r\n    new SequentialExecutionStrategy()\r\n);\r\n\r\n// Apply to a transform node\r\nvar resilientStrategy = new ResilientExecutionStrategy(\r\n    new SequentialExecutionStrategy()\r\n);\r\n\r\nvar builder = new PipelineBuilder();\r\nvar sourceHandle = builder.AddSource<DataSource, object>("source");\r\nvar transformHandle = builder\r\n    .AddTransform<DataTransform, object, object>("transform")\r\n    .WithExecutionStrategy(builder, resilientStrategy);\r\nvar sinkHandle = builder.AddSink<DataSink, object>("sink");\r\n\r\nbuilder.Connect(sourceHandle, transformHandle);\r\nbuilder.Connect(transformHandle, sinkHandle);\r\nbuilder.WithRetryOptions(new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5\r\n));\r\n\r\nvar pipeline = builder.Build();\n'})}),"\n",(0,t.jsx)(r.h3,{id:"resilient-parallel-execution",children:"Resilient Parallel Execution"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'using NPipeline.Extensions.Parallelism;\r\n\r\n// Wrap a parallel strategy with resilience\r\nvar resilientParallel = new ResilientExecutionStrategy(\r\n    new ParallelExecutionStrategy(maxDegreeOfParallelism: 4)\r\n);\r\n\r\n// Configure with parallel options and resilience\r\nvar builder = new PipelineBuilder();\r\nvar sourceHandle = builder.AddSource<DataSource, object>("source");\r\nvar transformHandle = builder\r\n    .AddTransform<DataTransform, object, object>("transform")\r\n    .WithExecutionStrategy(builder, resilientParallel);\r\nvar sinkHandle = builder.AddSink<DataSink, object>("sink");\r\n\r\nbuilder.Connect(sourceHandle, transformHandle);\r\nbuilder.Connect(transformHandle, sinkHandle);\r\nbuilder.SetNodeExecutionOption(transformHandle.Id, new ParallelOptions\r\n{\r\n    MaxDegreeOfParallelism = 4,\r\n    MaxQueueLength = 10,\r\n    QueuePolicy = BoundedQueuePolicy.Block,\r\n    PreserveOrdering = true\r\n});\r\n\r\nbuilder.WithRetryOptions(new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5\r\n));\r\n\r\nvar pipeline = builder.Build();\n'})}),"\n",(0,t.jsx)(r.h3,{id:"per-node-retry-options",children:"Per-Node Retry Options"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'var builder = new PipelineBuilder();\r\nvar sourceHandle = builder.AddSource<DataSource, object>("source");\r\nvar criticalHandle = builder\r\n    .AddTransform<CriticalTransform, object, object>("criticalNode")\r\n    .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n        new SequentialExecutionStrategy()\r\n    ));\r\nvar regularHandle = builder\r\n    .AddTransform<RegularTransform, object, object>("regularNode")\r\n    .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n        new SequentialExecutionStrategy()\r\n    ));\r\nvar sinkHandle = builder.AddSink<DataSink, object>("sink");\r\n\r\nbuilder.Connect(sourceHandle, criticalHandle);\r\nbuilder.Connect(criticalHandle, regularHandle);\r\nbuilder.Connect(regularHandle, sinkHandle);\r\n\r\n// Configure different retry options for each node\r\nbuilder.WithRetryOptions(criticalHandle, new PipelineRetryOptions(\r\n    MaxItemRetries: 5,\r\n    MaxNodeRestartAttempts: 5,\r\n    MaxSequentialNodeAttempts: 10\r\n));\r\nbuilder.WithRetryOptions(regularHandle, new PipelineRetryOptions(\r\n    MaxItemRetries: 2,\r\n    MaxNodeRestartAttempts: 1,\r\n    MaxSequentialNodeAttempts: 3\r\n));\r\n\r\nvar pipeline = builder.Build();\n'})}),"\n",(0,t.jsx)(r.h2,{id:"prerequisite-relationship",children:"Prerequisite Relationship"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"ResilientExecutionStrategy"})," is the ",(0,t.jsx)(r.strong,{children:"mandatory starting point"})," for all resilience features in NPipeline. Without this strategy:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"PipelineErrorDecision.RestartNode"})," will not work"]}),"\n",(0,t.jsx)(r.li,{children:"Materialization will not be automatically applied"}),"\n",(0,t.jsx)(r.li,{children:"Circuit breaker functionality will not be available"}),"\n",(0,t.jsx)(r.li,{children:"Node restart capabilities will be disabled"}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Always apply ",(0,t.jsx)(r.code,{children:"ResilientExecutionStrategy"})," to nodes that require any form of resilience."]}),"\n",(0,t.jsx)(r.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsx)(r.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,t.jsx)(r.p,{children:"Materialization for resilience comes with memory trade-offs:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// High memory usage - unlimited buffering\r\nvar unlimitedBuffering = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: null // No limit\r\n);\r\n\r\n// Controlled memory usage - limited buffering\r\nvar limitedBuffering = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: 1000 // Limit to 1000 items\r\n);\n"})}),"\n",(0,t.jsx)(r.h3,{id:"latency-impact",children:"Latency Impact"}),"\n",(0,t.jsx)(r.p,{children:"The resilience wrapper adds minimal latency to successful operations:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Error-free execution"}),": ~1-2% overhead for wrapper logic"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"During failures"}),": Additional latency for error handling and restarts"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Memory pressure"}),": Potential GC impact from buffered items"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"throughput-considerations",children:"Throughput Considerations"}),"\n",(0,t.jsxs)(r.p,{children:["When using ",(0,t.jsx)(r.code,{children:"ResilientExecutionStrategy"})," with ",(0,t.jsx)(r.code,{children:"ParallelExecutionStrategy"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Optimal configuration for high throughput\r\nvar highThroughputConfig = new ParallelOptions\r\n{\r\n    MaxDegreeOfParallelism = Environment.ProcessorCount,\r\n    MaxQueueLength = 100,\r\n    QueuePolicy = BoundedQueuePolicy.Block,\r\n    PreserveOrdering = false // Disable ordering for maximum throughput\r\n};\r\n\r\nvar resilientHighThroughput = new ResilientExecutionStrategy(\r\n    new ParallelExecutionStrategy()\r\n);\n"})}),"\n",(0,t.jsx)(r.h2,{id:"integration-with-error-handling",children:"Integration with Error Handling"}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"ResilientExecutionStrategy"})," works in tandem with NPipeline's error handling system:"]}),"\n",(0,t.jsx)(r.mermaid,{value:"sequenceDiagram\r\n    participant PE as Pipeline Executor\r\n    participant RES as ResilientExecutionStrategy\r\n    participant ES as Inner Execution Strategy\r\n    participant N as Node\r\n    participant EH as Error Handler\r\n\r\n    PE->>RES: Execute node\r\n    RES->>ES: Execute with resilience\r\n    ES->>N: Process item\r\n    N--\x3e>ES: Exception\r\n    ES--\x3e>RES: Exception\r\n    RES->>EH: Handle error\r\n    EH--\x3e>RES: PipelineErrorDecision\r\n    RES->>RES: Execute decision\r\n\r\n    alt RestartNode\r\n        RES->>ES: Restart execution\r\n    else ContinueWithoutNode\r\n        RES->>PE: Skip node\r\n    else FailPipeline\r\n        RES->>PE: Fail pipeline\r\n    end"}),"\n",(0,t.jsx)(r.h2,{id:"common-configuration-patterns",children:"Common Configuration Patterns"}),"\n",(0,t.jsx)(r.p,{children:"Real-world resilience configurations depend on your specific use case. Here are practical patterns for common scenarios:"}),"\n",(0,t.jsx)(r.h3,{id:"e-commerce-order-processing",children:"E-commerce Order Processing"}),"\n",(0,t.jsx)(r.p,{children:"For critical financial operations where order reliability is paramount:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public class EcommercePipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var orderSourceHandle = builder.AddSource<OrderSource, Order>("orderSource");\r\n        var validatorHandle = builder\r\n            .AddTransform<OrderValidator, Order, ValidatedOrder>("validator")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new SequentialExecutionStrategy()\r\n            ));\r\n        var paymentHandle = builder\r\n            .AddTransform<PaymentProcessor, ValidatedOrder, PaidOrder>("paymentProcessor")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new SequentialExecutionStrategy()\r\n            ));\r\n        var inventoryHandle = builder\r\n            .AddTransform<InventoryUpdater, PaidOrder, UpdatedOrder>("inventoryUpdater")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new ParallelExecutionStrategy()\r\n            ));\r\n        var shippingHandle = builder\r\n            .AddTransform<ShippingScheduler, UpdatedOrder, ScheduledOrder>("shippingScheduler")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new SequentialExecutionStrategy()\r\n            ));\r\n        var sinkHandle = builder.AddSink<OrderSink, ScheduledOrder>("orderSink");\r\n\r\n        builder.Connect(orderSourceHandle, validatorHandle);\r\n        builder.Connect(validatorHandle, paymentHandle);\r\n        builder.Connect(paymentHandle, inventoryHandle);\r\n        builder.Connect(inventoryHandle, shippingHandle);\r\n        builder.Connect(shippingHandle, sinkHandle);\r\n    }\r\n}\r\n\r\npublic static class EcommercePipeline\r\n{\r\n    public static async Task RunAsync()\r\n    {\r\n        var retryOptions = new PipelineRetryOptions(\r\n            MaxItemRetries: 3,\r\n            MaxNodeRestartAttempts: 2,\r\n            MaxSequentialNodeAttempts: 5\r\n        );\r\n\r\n        var config = new PipelineContextConfiguration(\r\n            RetryOptions: retryOptions,\r\n            PipelineErrorHandler: new EcommerceErrorHandler()\r\n        );\r\n        var context = new PipelineContext(config);\r\n\r\n        var runner = new PipelineRunner();\r\n        await runner.RunAsync<EcommercePipelineDefinition>(context);\r\n    }\r\n}\r\n\r\npublic class EcommerceErrorHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        return nodeId switch\r\n        {\r\n            "paymentProcessor" when error is PaymentException =>\r\n                Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            "inventoryUpdater" when error is DatabaseException =>\r\n                Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            "validator" when error is ValidationException =>\r\n                Task.FromResult(PipelineErrorDecision.ContinueWithoutNode),\r\n            _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\r\n        };\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"high-volume-data-analytics",children:"High-Volume Data Analytics"}),"\n",(0,t.jsx)(r.p,{children:"For high-throughput scenarios where some data loss is acceptable:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public class AnalyticsPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<EventStreamSource, EventData>("eventSource");\r\n        var parserHandle = builder\r\n            .AddTransform<EventParser, EventData, ParsedEvent>("parser")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new ParallelExecutionStrategy()\r\n            ));\r\n        var aggregatorHandle = builder\r\n            .AddTransform<Aggregator, ParsedEvent, AggregatedData>("aggregator")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new ParallelExecutionStrategy()\r\n            ));\r\n        var calculatorHandle = builder\r\n            .AddTransform<MetricsCalculator, AggregatedData, Metrics>("calculator")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new SequentialExecutionStrategy()\r\n            ));\r\n        var sinkHandle = builder.AddSink<MetricsSink, Metrics>("metricsSink");\r\n\r\n        builder.Connect(sourceHandle, parserHandle);\r\n        builder.Connect(parserHandle, aggregatorHandle);\r\n        builder.Connect(aggregatorHandle, calculatorHandle);\r\n        builder.Connect(calculatorHandle, sinkHandle);\r\n\r\n        // Configure execution options for parallel nodes\r\n        builder.SetNodeExecutionOption(parserHandle.Id, new ParallelOptions\r\n        {\r\n            MaxDegreeOfParallelism = 8,\r\n            MaxQueueLength = 100,\r\n            QueuePolicy = BoundedQueuePolicy.Block,\r\n            PreserveOrdering = false // Disable ordering for maximum throughput\r\n        });\r\n        builder.SetNodeExecutionOption(aggregatorHandle.Id, new ParallelOptions\r\n        {\r\n            MaxDegreeOfParallelism = 4,\r\n            MaxQueueLength = 50,\r\n            QueuePolicy = BoundedQueuePolicy.Block,\r\n            PreserveOrdering = false\r\n        });\r\n    }\r\n}\r\n\r\npublic static class AnalyticsPipeline\r\n{\r\n    public static async Task RunAsync()\r\n    {\r\n        var retryOptions = new PipelineRetryOptions(\r\n            MaxItemRetries: 1,\r\n            MaxNodeRestartAttempts: 2,\r\n            MaxSequentialNodeAttempts: 4,\r\n            MaxMaterializedItems: 10000 // Large buffer for high volume\r\n        );\r\n\r\n        var context = PipelineContext.WithRetry(retryOptions);\r\n        context.AddPipelineErrorHandler<AnalyticsErrorHandler>();\r\n\r\n        var runner = new PipelineRunner();\r\n        await runner.RunAsync<AnalyticsPipelineDefinition>(context);\r\n    }\r\n}\r\n\r\npublic class AnalyticsErrorHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        return error switch\r\n        {\r\n            TimeoutException => Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            IOException => Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\r\n        };\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"microservice-integration",children:"Microservice Integration"}),"\n",(0,t.jsx)(r.p,{children:"For distributed systems calling external services:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public class MicroservicePipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<MessageQueueSource, ServiceRequest>("messageSource");\r\n        var requestBuilderHandle = builder\r\n            .AddTransform<RequestBuilder, ServiceRequest, HttpRequestMessage>("requestBuilder")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new SequentialExecutionStrategy()\r\n            ));\r\n        var serviceCallerHandle = builder\r\n            .AddTransform<ExternalServiceCaller, HttpRequestMessage, HttpResponseMessage>("serviceCaller")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new ParallelExecutionStrategy()\r\n            ));\r\n        var responseProcessorHandle = builder\r\n            .AddTransform<ResponseProcessor, HttpResponseMessage, ServiceResponse>("responseProcessor")\r\n            .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n                new SequentialExecutionStrategy()\r\n            ));\r\n        var sinkHandle = builder.AddSink<ResultPublisher, ServiceResponse>("resultPublisher");\r\n\r\n        builder.Connect(sourceHandle, requestBuilderHandle);\r\n        builder.Connect(requestBuilderHandle, serviceCallerHandle);\r\n        builder.Connect(serviceCallerHandle, responseProcessorHandle);\r\n        builder.Connect(responseProcessorHandle, sinkHandle);\r\n\r\n        // Configure high parallelism for external service calls\r\n        builder.SetNodeExecutionOption(serviceCallerHandle.Id, new ParallelOptions\r\n        {\r\n            MaxDegreeOfParallelism = 10, // High parallelism for external calls\r\n            MaxQueueLength = 200,\r\n            QueuePolicy = BoundedQueuePolicy.Block,\r\n            PreserveOrdering = false\r\n        });\r\n    }\r\n}\r\n\r\npublic static class MicroservicePipeline\r\n{\r\n    public static async Task RunAsync()\r\n    {\r\n        var retryOptions = new PipelineRetryOptions(\r\n            MaxItemRetries: 5, // High retry count for external services\r\n            MaxNodeRestartAttempts: 3,\r\n            MaxSequentialNodeAttempts: 8,\r\n            MaxMaterializedItems: 2000\r\n        );\r\n\r\n        var context = PipelineContext.WithRetry(retryOptions);\r\n\r\n        context.AddPipelineErrorHandler<MicroserviceErrorHandler>();\r\n\r\n        var runner = new PipelineRunner();\r\n        await runner.RunAsync<MicroservicePipelineDefinition>(context);\r\n    }\r\n}\r\n\r\npublic class MicroserviceErrorHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        return nodeId switch\r\n        {\r\n            "serviceCaller" when IsTransientHttpError(error) =>\r\n                Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            "serviceCaller" when IsPermanentHttpError(error) =>\r\n                Task.FromResult(PipelineErrorDecision.ContinueWithoutNode),\r\n            _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\r\n        };\r\n    }\r\n\r\n    private bool IsTransientHttpError(Exception ex)\r\n    {\r\n        return ex is HttpRequestException httpEx &&\r\n               (httpEx.StatusCode is HttpStatusCode.ServiceUnavailable or\r\n                HttpStatusCode.RequestTimeout or\r\n                HttpStatusCode.TooManyRequests);\r\n    }\r\n\r\n    private bool IsPermanentHttpError(Exception ex)\r\n    {\r\n        return ex is HttpRequestException httpEx &&\r\n               (httpEx.StatusCode is HttpStatusCode.NotFound or\r\n                HttpStatusCode.Unauthorized or\r\n                HttpStatusCode.Forbidden);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"configuration-decision-matrix",children:"Configuration Decision Matrix"}),"\n",(0,t.jsx)(r.p,{children:"When choosing retry configuration, consider this matrix:"}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Scenario"}),(0,t.jsx)(r.th,{children:"MaxItemRetries"}),(0,t.jsx)(r.th,{children:"MaxNodeRestartAttempts"}),(0,t.jsx)(r.th,{children:"MaxSequentialNodeAttempts"}),(0,t.jsx)(r.th,{children:"MaxMaterializedItems"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.strong,{children:"Stable internal services"})}),(0,t.jsx)(r.td,{children:"1-2"}),(0,t.jsx)(r.td,{children:"1"}),(0,t.jsx)(r.td,{children:"3"}),(0,t.jsx)(r.td,{children:"500-1000"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.strong,{children:"Unstable external APIs"})}),(0,t.jsx)(r.td,{children:"3-5"}),(0,t.jsx)(r.td,{children:"3-5"}),(0,t.jsx)(r.td,{children:"8-10"}),(0,t.jsx)(r.td,{children:"1000-2000"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.strong,{children:"High-volume streaming"})}),(0,t.jsx)(r.td,{children:"1"}),(0,t.jsx)(r.td,{children:"2"}),(0,t.jsx)(r.td,{children:"4"}),(0,t.jsx)(r.td,{children:"5000-10000"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.strong,{children:"Critical business logic"})}),(0,t.jsx)(r.td,{children:"3-5"}),(0,t.jsx)(r.td,{children:"5"}),(0,t.jsx)(r.td,{children:"10"}),(0,t.jsx)(r.td,{children:"2000-5000"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.strong,{children:"Memory-constrained"})}),(0,t.jsx)(r.td,{children:"1-2"}),(0,t.jsx)(r.td,{children:"1"}),(0,t.jsx)(r.td,{children:"3"}),(0,t.jsx)(r.td,{children:"100-500"})]})]})]}),"\n",(0,t.jsx)(r.h3,{id:"common-configuration-mistakes-to-avoid",children:"Common Configuration Mistakes to Avoid"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Mistake 1: Forgetting ResilientExecutionStrategy"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'var nodeHandle = builder.AddTransform<MyTransform, Input, Output>("node");\r\n\r\n// \u274c WRONG: Missing resilience wrapper\r\nvar nodeHandle = builder\r\n    .AddTransform<MyTransform, Input, Output>("node")\r\n    .WithExecutionStrategy(builder, new ParallelExecutionStrategy());\r\n\r\n// \u2713 CORRECT: With resilience wrapper\r\nvar nodeHandle = builder\r\n    .AddTransform<MyTransform, Input, Output>("node")\r\n    .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n        new ParallelExecutionStrategy()\r\n    ));\n'})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Mistake 2: No Materialization for Streaming Inputs"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// \u274c WRONG: No materialization\r\nvar options = new PipelineRetryOptions(\r\n    MaxMaterializedItems: null // No buffering\r\n);\r\n\r\n// \u2713 CORRECT: Enable materialization\r\nvar options = new PipelineRetryOptions(\r\n    MaxMaterializedItems: 1000 // Buffer items for replay\r\n);\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Mistake 3: Always Restarting on All Errors"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// \u274c WRONG: Restarts forever on all errors\r\npublic class BadErrorHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(...)\r\n    {\r\n        return Task.FromResult(PipelineErrorDecision.RestartNode); // Always!\r\n    }\r\n}\r\n\r\n// \u2713 CORRECT: Distinguish transient from permanent failures\r\npublic class GoodErrorHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId, Exception error, ...)\r\n    {\r\n        return error switch\r\n        {\r\n            TimeoutException => Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            ValidationException => Task.FromResult(PipelineErrorDecision.ContinueWithoutNode),\r\n            _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\r\n        };\r\n    }\r\n}\n"})}),"\n",(0,t.jsxs)(r.h2,{id:"arrow_right-next-steps",children:["\u27a1\ufe0f"," Next Steps"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/configuration-guide",children:"Configuration Guide"})}),": Get step-by-step configuration guidance"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/materialization-and-buffering",children:"Materialization and Buffering"})}),": Learn how buffering enables replay functionality"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/dependency-chains",children:"Dependency Chains"})}),": Understand the critical prerequisite relationships"]}),"\n"]})]})}function u(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>s});var i=n(6540);const t={},a=i.createContext(t);function l(e){const r=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(a.Provider,{value:r},e.children)}}}]);