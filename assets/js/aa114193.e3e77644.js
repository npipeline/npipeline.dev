"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[4610],{7732:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"architecture/retry-delay-architecture","title":"Retry Delay Strategies Architecture","description":"How NPipeline\'s retry delay system works internally, including design patterns, components, and architectural decisions.","source":"@site/docs/architecture/retry-delay-architecture.md","sourceDirName":"architecture","slug":"/architecture/retry-delay-architecture","permalink":"/docs/architecture/retry-delay-architecture","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"Retry Delay Strategies Architecture","description":"How NPipeline\'s retry delay system works internally, including design patterns, components, and architectural decisions.","sidebar_position":8},"sidebar":"docsSidebar","previous":{"title":"Performance Characteristics","permalink":"/docs/architecture/performance-characteristics"},"next":{"title":"Extension Points","permalink":"/docs/architecture/extension-points"}}');var r=n(4848),a=n(8453);const l={title:"Retry Delay Strategies Architecture",description:"How NPipeline's retry delay system works internally, including design patterns, components, and architectural decisions.",sidebar_position:8},s="Retry Delay Strategies Architecture",c={},o=[{value:"Overview",id:"overview",level:2},{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Architecture Components",id:"architecture-components",level:2},{value:"1. Backoff Strategies",id:"1-backoff-strategies",level:3},{value:"2. Jitter Strategies",id:"2-jitter-strategies",level:3},{value:"3. Strategy Implementation",id:"3-strategy-implementation",level:3},{value:"4. Composite Strategy",id:"4-composite-strategy",level:3},{value:"5. Factory",id:"5-factory",level:3},{value:"6. PipelineContext Integration",id:"6-pipelinecontext-integration",level:3},{value:"Design Patterns Used",id:"design-patterns-used",level:2},{value:"Strategy Pattern",id:"strategy-pattern",level:3},{value:"Composite Pattern",id:"composite-pattern",level:3},{value:"Factory Pattern",id:"factory-pattern",level:3},{value:"Configuration Pattern",id:"configuration-pattern",level:3},{value:"Data Flow",id:"data-flow",level:2},{value:"Configuration to Execution",id:"configuration-to-execution",level:3},{value:"Async Execution Flow",id:"async-execution-flow",level:3},{value:"Validation Architecture",id:"validation-architecture",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Memory Usage",id:"memory-usage",level:3},{value:"CPU Usage",id:"cpu-usage",level:3},{value:"Thread Safety",id:"thread-safety",level:3},{value:"Extensibility",id:"extensibility",level:2},{value:"Adding Custom Backoff Strategy",id:"adding-custom-backoff-strategy",level:3},{value:"Adding Custom Jitter Strategy",id:"adding-custom-jitter-strategy",level:3},{value:"Integration Points",id:"integration-points",level:2},{value:"With ResilientExecutionStrategy",id:"with-resilientexecutionstrategy",level:3},{value:"With PipelineContext",id:"with-pipelinecontext",level:3},{value:"Testing Architecture",id:"testing-architecture",level:2},{value:"Unit Testing Strategies",id:"unit-testing-strategies",level:3},{value:"Integration Testing",id:"integration-testing",level:3},{value:"Factory Testing",id:"factory-testing",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"See Also",id:"see-also",level:2},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"retry-delay-strategies-architecture",children:"Retry Delay Strategies Architecture"})}),"\n",(0,r.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(t.p,{children:"NPipeline's retry delay system is built on a modular architecture that separates concerns into distinct components. This guide explains the design, components, and how they work together."}),"\n",(0,r.jsx)(t.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#architecture-components",children:"Architecture Components"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#design-patterns-used",children:"Design Patterns Used"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#data-flow",children:"Data Flow"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#validation-architecture",children:"Validation Architecture"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#performance-considerations",children:"Performance Considerations"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#extensibility",children:"Extensibility"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#integration-points",children:"Integration Points"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#testing-architecture",children:"Testing Architecture"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"architecture-components",children:"Architecture Components"}),"\n",(0,r.jsx)(t.h3,{id:"1-backoff-strategies",children:"1. Backoff Strategies"}),"\n",(0,r.jsx)(t.p,{children:"Backoff strategies determine how delays increase between retry attempts."}),"\n",(0,r.jsx)(t.mermaid,{value:'graph TD\n    subgraph "Backoff Strategy Configuration"\n        A[BackoffStrategyConfiguration<br>Interface] --\x3e B[ExponentialBackoffConfiguration]\n        A --\x3e C[LinearBackoffConfiguration]\n        A --\x3e D[FixedDelayConfiguration]\n    end\n    \n    subgraph "Backoff Strategy Implementation"\n        E[IBackoffStrategy<br>Interface] --\x3e F[ExponentialBackoffStrategy]\n        E --\x3e G[LinearBackoffStrategy]\n        E --\x3e H[FixedDelayStrategy]\n    end\n    \n    B --\x3e I[Validates parameters<br>Creates immutable config]\n    C --\x3e I\n    D --\x3e I\n    \n    F --\x3e J[Calculates: baseDelay \xd7 multiplier^attempt<br>Capped at maxDelay]\n    G --\x3e K[Calculates: baseDelay + (increment \xd7 attempt)<br>Capped at maxDelay]\n    H --\x3e L[Returns: constant delay for all attempts]\n    \n    style A fill:#e1f5fe\n    style E fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#f3e5f5\n    style D fill:#f3e5f5\n    style F fill:#e8f5e9\n    style G fill:#e8f5e9\n    style H fill:#e8f5e9\n    style I fill:#fff3e0\n    style J fill:#e3f2fd\n    style K fill:#e3f2fd\n    style L fill:#e3f2fd'}),"\n",(0,r.jsx)(t.p,{children:"Each configuration:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Defines parameters for delay calculation"}),"\n",(0,r.jsx)(t.li,{children:"Implements validation to ensure valid parameters"}),"\n",(0,r.jsx)(t.li,{children:"Can be serialized/deserialized for persistence"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Key Characteristics:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Immutable (uses ",(0,r.jsx)(t.code,{children:"init"})," properties)"]}),"\n",(0,r.jsx)(t.li,{children:"Validated on creation"}),"\n",(0,r.jsx)(t.li,{children:"Deterministic (same input produces same output)"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"2-jitter-strategies",children:"2. Jitter Strategies"}),"\n",(0,r.jsx)(t.p,{children:"Jitter strategies add randomness to backoff delays to prevent synchronized retries."}),"\n",(0,r.jsx)(t.mermaid,{value:'graph TD\n    subgraph "Jitter Strategy Configuration"\n        A[JitterStrategyConfiguration<br>Interface] --\x3e B[FullJitterConfiguration]\n        A --\x3e C[EqualJitterConfiguration]\n        A --\x3e D[DecorrelatedJitterConfiguration]\n        A --\x3e E[NoJitterConfiguration]\n    end\n    \n    subgraph "Jitter Strategy Implementation"\n        F[IJitterStrategy<br>Interface] --\x3e G[FullJitterStrategy]\n        F --\x3e H[EqualJitterStrategy]\n        F --\x3e I[DecorrelatedJitterStrategy]\n        F --\x3e J[NoJitterStrategy]\n    end\n    \n    subgraph "Jitter Application"\n        K[Base Delay from Backoff] --\x3e L{Jitter Strategy}\n        L --\x3e|Full Jitter|M[random(0, baseDelay)]\n        L --\x3e|Equal Jitter|N[baseDelay/2 + random(0, baseDelay/2)]\n        L --\x3e|Decorrelated Jitter|O[random(baseDelay, min(maxDelay, previousDelay \xd7 multiplier))]\n        L --\x3e|No Jitter|P[Return baseDelay unchanged]\n    end\n    \n    style A fill:#e1f5fe\n    style F fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#f3e5f5\n    style D fill:#f3e5f5\n    style E fill:#f3e5f5\n    style G fill:#e8f5e9\n    style H fill:#e8f5e9\n    style I fill:#e8f5e9\n    style J fill:#e8f5e9\n    style K fill:#fff3e0\n    style L fill:#ffecb3\n    style M fill:#e3f2fd\n    style N fill:#e3f2fd\n    style O fill:#e3f2fd\n    style P fill:#e3f2fd'}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Benefits of Jitter:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:'Prevents "thundering herd" problem'}),"\n",(0,r.jsx)(t.li,{children:"Spreads retry load over time"}),"\n",(0,r.jsx)(t.li,{children:"Improves system stability"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"3-strategy-implementation",children:"3. Strategy Implementation"}),"\n",(0,r.jsx)(t.p,{children:"The actual retry delay calculation is performed by strategy implementations:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"IBackoffStrategy\n\u251c\u2500\u2500 ExponentialBackoffStrategy\n\u251c\u2500\u2500 LinearBackoffStrategy\n\u2514\u2500\u2500 FixedDelayStrategy\n\nIJitterStrategy\n\u251c\u2500\u2500 FullJitterStrategy\n\u251c\u2500\u2500 EqualJitterStrategy\n\u251c\u2500\u2500 DecorrelatedJitterStrategy\n\u2514\u2500\u2500 NoJitterStrategy\n"})}),"\n",(0,r.jsx)(t.p,{children:"These implement the mathematical formulas for delay calculation."}),"\n",(0,r.jsx)(t.h3,{id:"4-composite-strategy",children:"4. Composite Strategy"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"IRetryDelayStrategy\n\u2514\u2500\u2500 CompositeRetryDelayStrategy\n    \u251c\u2500\u2500 Combines: IBackoffStrategy\n    \u251c\u2500\u2500 Combines: IJitterStrategy (optional)\n    \u2514\u2500\u2500 Handles: Cancellation, async execution\n"})}),"\n",(0,r.jsx)(t.p,{children:"The composite strategy:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Orchestrates backoff and jitter"}),"\n",(0,r.jsxs)(t.li,{children:["Manages async execution with ",(0,r.jsx)(t.code,{children:"ValueTask"})]}),"\n",(0,r.jsx)(t.li,{children:"Respects cancellation tokens"}),"\n",(0,r.jsx)(t.li,{children:"Caches state for stateful jitter (e.g., decorrelated)"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"5-factory",children:"5. Factory"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"DefaultRetryDelayStrategyFactory\n\u251c\u2500\u2500 Creates individual strategies\n\u251c\u2500\u2500 Validates configurations\n\u2514\u2500\u2500 Combines strategies appropriately\n"})}),"\n",(0,r.jsx)(t.p,{children:"The factory:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Handles configuration validation"}),"\n",(0,r.jsx)(t.li,{children:"Creates appropriate strategy instances"}),"\n",(0,r.jsx)(t.li,{children:"Manages strategy lifecycle"}),"\n",(0,r.jsx)(t.li,{children:"Provides centralized creation logic"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"6-pipelinecontext-integration",children:"6. PipelineContext Integration"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"PipelineContextRetryDelayExtensions\n\u251c\u2500\u2500 GetRetryDelayStrategy() - retrieves/caches strategy\n\u251c\u2500\u2500 GetRetryDelayAsync() - gets delay for attempt\n\u251c\u2500\u2500 UseExponentialBackoffDelay() - runtime config\n\u251c\u2500\u2500 UseLinearBackoffDelay() - runtime config\n\u2514\u2500\u2500 UseExponentialBackoffWithJitter() - runtime config\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Integration Features:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Caches strategies to avoid recreation"}),"\n",(0,r.jsx)(t.li,{children:"Supports runtime configuration"}),"\n",(0,r.jsx)(t.li,{children:"Integrates with resilient execution strategy"}),"\n",(0,r.jsx)(t.li,{children:"Provides convenient API for common patterns"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"design-patterns-used",children:"Design Patterns Used"}),"\n",(0,r.jsx)(t.h3,{id:"strategy-pattern",children:"Strategy Pattern"}),"\n",(0,r.jsx)(t.p,{children:"Each backoff/jitter type implements a different strategy:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"// Strategy interface\npublic interface IBackoffStrategy\n{\n    TimeSpan CalculateDelay(int attemptNumber);\n}\n\n// Different implementations\npublic class ExponentialBackoffStrategy : IBackoffStrategy { }\npublic class LinearBackoffStrategy : IBackoffStrategy { }\npublic class FixedDelayStrategy : IBackoffStrategy { }\n"})}),"\n",(0,r.jsx)(t.h3,{id:"composite-pattern",children:"Composite Pattern"}),"\n",(0,r.jsx)(t.p,{children:"Combines backoff and jitter into a single strategy:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class CompositeRetryDelayStrategy : IRetryDelayStrategy\n{\n    private readonly IBackoffStrategy _backoff;\n    private readonly IJitterStrategy _jitter;\n    \n    public async ValueTask<TimeSpan> GetDelayAsync(int attemptNumber)\n    {\n        // Get base delay from backoff strategy\n        var baseDelay = _backoff.CalculateDelay(attemptNumber);\n        \n        // Apply jitter if present\n        if (_jitter != null)\n            return _jitter.ApplyJitter(baseDelay, _random);\n        \n        return baseDelay;\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"factory-pattern",children:"Factory Pattern"}),"\n",(0,r.jsx)(t.p,{children:"Creates strategies from configurations:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class DefaultRetryDelayStrategyFactory\n{\n    public IRetryDelayStrategy CreateExponentialBackoff(\n        ExponentialBackoffConfiguration config,\n        IJitterStrategy jitterStrategy = null)\n    {\n        config.Validate();\n        var backoff = new ExponentialBackoffStrategy(config);\n        return new CompositeRetryDelayStrategy(backoff, jitterStrategy);\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"configuration-pattern",children:"Configuration Pattern"}),"\n",(0,r.jsx)(t.p,{children:"Separates configuration from implementation:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"// Configuration - data only\npublic class ExponentialBackoffConfiguration\n{\n    public TimeSpan BaseDelay { get; init; }\n    public double Multiplier { get; init; }\n    public TimeSpan MaxDelay { get; init; }\n}\n\n// Implementation - uses configuration\npublic class ExponentialBackoffStrategy\n{\n    private readonly ExponentialBackoffConfiguration _config;\n    \n    public TimeSpan CalculateDelay(int attempt)\n    {\n        return TimeSpan.FromMilliseconds(\n            Math.Min(\n                _config.BaseDelay.TotalMilliseconds * \n                Math.Pow(_config.Multiplier, attempt),\n                _config.MaxDelay.TotalMilliseconds));\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"data-flow",children:"Data Flow"}),"\n",(0,r.jsx)(t.h3,{id:"configuration-to-execution",children:"Configuration to Execution"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"1. PipelineRetryOptions\n   \u2514\u2500\u2500 RetryDelayStrategyConfiguration\n       \u251c\u2500\u2500 BackoffStrategyConfiguration\n       \u2514\u2500\u2500 JitterStrategyConfiguration\n\n2. Factory.CreateStrategy(configuration)\n   \u251c\u2500\u2500 Validate configurations\n   \u251c\u2500\u2500 Create backoff strategy\n   \u251c\u2500\u2500 Create jitter strategy\n   \u2514\u2500\u2500 Return composite strategy\n\n3. PipelineContext.GetRetryDelayStrategy()\n   \u251c\u2500\u2500 Check cache\n   \u251c\u2500\u2500 If not cached:\n   \u2502   \u2514\u2500\u2500 factory.CreateStrategy()\n   \u2514\u2500\u2500 Return strategy\n\n4. ResilientExecutionStrategy\n   \u2514\u2500\u2500 On failure:\n       \u251c\u2500\u2500 Get strategy from context\n       \u251c\u2500\u2500 Calculate delay for attempt\n       \u251c\u2500\u2500 Wait for delay\n       \u2514\u2500\u2500 Retry operation\n"})}),"\n",(0,r.jsx)(t.h3,{id:"async-execution-flow",children:"Async Execution Flow"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"async Task<TimeSpan> GetDelayAsync(attemptNumber)\n\u2502\n\u251c\u2500 BackoffStrategy.CalculateDelay(synchronous)\n\u2502  \u2514\u2500 Returns base delay\n\u2502\n\u251c\u2500 JitterStrategy.ApplyJitter (may be async)\n\u2502  \u2514\u2500 Adds randomness\n\u2502\n\u2514\u2500 Return combined delay\n"})}),"\n",(0,r.jsx)(t.h2,{id:"validation-architecture",children:"Validation Architecture"}),"\n",(0,r.jsx)(t.p,{children:"Each configuration component validates independently:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"RetryDelayStrategyConfiguration\n\u251c\u2500\u2500 Validates self\n\u251c\u2500\u2500 BackoffStrategyConfiguration.Validate()\n\u2502  \u2514\u2500\u2500 Specific validation rules\n\u2514\u2500\u2500 JitterStrategyConfiguration.Validate()\n   \u2514\u2500\u2500 Specific validation rules\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Validation Timing:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Configuration creation: Optional (deferred)"}),"\n",(0,r.jsx)(t.li,{children:"Factory creation: Mandatory (immediate)"}),"\n",(0,r.jsx)(t.li,{children:"Strategy usage: Pre-validated"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(t.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Configurations"}),": Immutable, small (few properties)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Strategies"}),": Stateless except decorrelated jitter (previous delay)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Factory"}),": Singleton pattern recommended"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"PipelineContext"}),": Caches single strategy per context"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"cpu-usage",children:"CPU Usage"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Delay calculation"}),": O(1) - simple arithmetic"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Validation"}),": One-time cost at factory creation"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Random generation"}),": Minimal overhead, only if jitter enabled"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Async overhead"}),": Minimal for synchronous paths with ValueTask"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Configurations"}),": Immutable - fully thread-safe"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Strategies"}),": Stateless - thread-safe"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Decorrelated Jitter"}),": Thread-safe with proper locking"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Factory"}),": Thread-safe (pure function pattern)"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"extensibility",children:"Extensibility"}),"\n",(0,r.jsx)(t.h3,{id:"adding-custom-backoff-strategy",children:"Adding Custom Backoff Strategy"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class CustomBackoffConfiguration : BackoffStrategyConfiguration\n{\n    public override void Validate()\n    {\n        // Your validation logic\n    }\n}\n\npublic class CustomBackoffStrategy : IBackoffStrategy\n{\n    public TimeSpan CalculateDelay(int attemptNumber)\n    {\n        // Your delay calculation logic\n    }\n}\n\n// Extend factory\npublic class ExtendedFactory : DefaultRetryDelayStrategyFactory\n{\n    public IRetryDelayStrategy CreateCustomBackoff(\n        CustomBackoffConfiguration config)\n    {\n        config.Validate();\n        var backoff = new CustomBackoffStrategy(config);\n        return new CompositeRetryDelayStrategy(backoff, null);\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"adding-custom-jitter-strategy",children:"Adding Custom Jitter Strategy"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class CustomJitterConfiguration : JitterStrategyConfiguration\n{\n    public override void Validate() { }\n}\n\npublic class CustomJitterStrategy : IJitterStrategy\n{\n    public TimeSpan ApplyJitter(TimeSpan baseDelay, Random random)\n    {\n        // Your jitter calculation logic\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,r.jsx)(t.h3,{id:"with-resilientexecutionstrategy",children:"With ResilientExecutionStrategy"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class ResilientExecutionStrategy\n{\n    public async Task ExecuteAsync(/* ... */)\n    {\n        for (int attempt = 0; attempt <= maxRetries; attempt++)\n        {\n            try\n            {\n                return await Execute();\n            }\n            catch when (attempt < maxRetries)\n            {\n                // Integration point: Get delay from context\n                var strategy = context.GetRetryDelayStrategy();\n                var delay = await strategy.GetDelayAsync(attempt);\n                \n                // Wait respecting cancellation\n                await Task.Delay(delay, cancellationToken);\n            }\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"with-pipelinecontext",children:"With PipelineContext"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public class PipelineContext\n{\n    private Dictionary<string, object> _items;\n    \n    public IRetryDelayStrategy GetRetryDelayStrategy()\n    {\n        // Cache key: "NPipeline.RetryDelayStrategy"\n        if (!_items.TryGetValue(key, out var cached))\n        {\n            var factory = new DefaultRetryDelayStrategyFactory();\n            cached = factory.CreateStrategy(\n                RetryOptions.DelayStrategyConfiguration);\n            _items[key] = cached;\n        }\n        \n        return (IRetryDelayStrategy)cached;\n    }\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"testing-architecture",children:"Testing Architecture"}),"\n",(0,r.jsx)(t.h3,{id:"unit-testing-strategies",children:"Unit Testing Strategies"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"[Fact]\npublic void ExponentialBackoff_WithValidConfig_CalculatesCorrectly()\n{\n    var config = new ExponentialBackoffConfiguration(...);\n    var strategy = new ExponentialBackoffStrategy(config);\n    \n    Assert.Equal(TimeSpan.FromSeconds(1), strategy.CalculateDelay(0));\n    Assert.Equal(TimeSpan.FromSeconds(2), strategy.CalculateDelay(1));\n    Assert.Equal(TimeSpan.FromSeconds(4), strategy.CalculateDelay(2));\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"[Fact]\npublic async Task CompositeStrategy_WithBackoffAndJitter_WorksTogether()\n{\n    var backoff = new ExponentialBackoffStrategy(...);\n    var jitter = new FullJitterStrategy(...);\n    var composite = new CompositeRetryDelayStrategy(backoff, jitter);\n    \n    var delay = await composite.GetDelayAsync(1);\n    \n    Assert.InRange(delay, TimeSpan.Zero, TimeSpan.FromSeconds(2));\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"factory-testing",children:"Factory Testing"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"[Fact]\npublic void Factory_CreatesCorrectStrategies()\n{\n    var factory = new DefaultRetryDelayStrategyFactory();\n    \n    var strategy = factory.CreateExponentialBackoff(\n        new ExponentialBackoffConfiguration(),\n        new FullJitterConfiguration());\n    \n    Assert.IsType<CompositeRetryDelayStrategy>(strategy);\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(t.p,{children:"NPipeline's retry delay architecture provides:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Separation of Concerns"}),": Backoff and jitter are independent"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Flexibility"}),": Easy to add new strategies"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Performance"}),": Minimal overhead with caching"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Testability"}),": Each component can be tested independently"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Observability"}),": Clear design makes debugging easier"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Extensibility"}),": Custom strategies can be added"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"This architecture enables robust, configurable retry behavior for resilient data pipelines."}),"\n",(0,r.jsx)(t.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/advanced-topics/retry-delay-advanced",children:"Advanced Retry Delay Strategies"})}),": Advanced patterns and scenarios for using retry delay strategies in production environments"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/core-concepts/resilience/retry-configuration",children:"Retry Configuration"})}),": Basic retry configuration options and built-in strategies"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/core-concepts/resilience/",children:"Resilience Overview"})}),": Comprehensive guide to building fault-tolerant pipelines"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/component-architecture",children:"Component Architecture"})}),": Overview of major NPipeline system components and their interactions"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/execution-flow",children:"Execution Flow"})}),": How pipelines execute data and flow through the system"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/error-handling-architecture",children:"Error Handling Architecture"})}),": Error propagation and handling mechanisms in NPipeline"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/design-principles",children:"Design Principles"})}),": Core philosophy behind NPipeline's design including separation of concerns and composability"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/performance-characteristics",children:"Performance Characteristics"})}),": Understanding performance implications of retry strategies and other architectural decisions"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/extension-points",children:"Extension Points"})}),": How to extend NPipeline functionality including custom retry strategies"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"/docs/architecture/optimization-principles",children:"Optimization Principles"})}),": Performance optimizations that influence retry delay system design"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>s});var i=n(6540);const r={},a=i.createContext(r);function l(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);