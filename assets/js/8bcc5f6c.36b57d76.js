"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[2311],{8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var a=r(6540);const s={},t=a.createContext(s);function i(e){const n=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(t.Provider,{value:n},e.children)}},9916:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"advanced-topics/synchronous-fast-paths","title":"Synchronous Fast Paths and ValueTask Optimization","description":"Deep-dive guide on optimizing transformer nodes for high-throughput scenarios using ValueTask to eliminate GC pressure.","source":"@site/docs/advanced-topics/synchronous-fast-paths.md","sourceDirName":"advanced-topics","slug":"/advanced-topics/synchronous-fast-paths","permalink":"/docs/advanced-topics/synchronous-fast-paths","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Synchronous Fast Paths and ValueTask Optimization","description":"Deep-dive guide on optimizing transformer nodes for high-throughput scenarios using ValueTask to eliminate GC pressure.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Performance Hygiene","permalink":"/docs/advanced-topics/performance-hygiene"},"next":{"title":"Advanced Testing","permalink":"/docs/advanced-topics/testing-pipelines"}}');var s=r(4848),t=r(8453);const i={title:"Synchronous Fast Paths and ValueTask Optimization",description:"Deep-dive guide on optimizing transformer nodes for high-throughput scenarios using ValueTask to eliminate GC pressure.",sidebar_position:2},o="Synchronous Fast Paths and ValueTask Optimization",l={},c=[{value:"The Performance Paradox",id:"the-performance-paradox",level:2},{value:"The Solution: ValueTask",id:"the-solution-valuetask",level:2},{value:"The Pattern: Synchronous Fast Path + Asynchronous Slow Path",id:"the-pattern-synchronous-fast-path--asynchronous-slow-path",level:2},{value:"Real-World Example: Cached Data Enrichment",id:"real-world-example-cached-data-enrichment",level:2},{value:"Performance Impact",id:"performance-impact",level:2},{value:"Practical Guidelines",id:"practical-guidelines",level:2},{value:"When to Use <code>ValueTask</code> for Transforms",id:"when-to-use-valuetask-for-transforms",level:3},{value:"Implementation Checklist",id:"implementation-checklist",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Example 1: Simple Transformation (Always Synchronous)",id:"example-1-simple-transformation-always-synchronous",level:3},{value:"Example 2: Format Transformation with Optional Fallback",id:"example-2-format-transformation-with-optional-fallback",level:3},{value:"Critical Constraints: When NOT to Use ValueTask",id:"critical-constraints-when-not-to-use-valuetask",level:2},{value:"Never Await More Than Once",id:"never-await-more-than-once",level:3},{value:"Avoid When Always Asynchronous",id:"avoid-when-always-asynchronous",level:3},{value:"Consider Public APIs Carefully",id:"consider-public-apis-carefully",level:3},{value:"ConfigureAwait Not Supported",id:"configureawait-not-supported",level:3},{value:"See Also",id:"see-also",level:2},{value:"Benchmarking Template",id:"benchmarking-template",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"synchronous-fast-paths-and-valuetask-optimization",children:"Synchronous Fast Paths and ValueTask Optimization"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["\u2139\ufe0f"," For general performance best practices, see ",(0,s.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Hygiene"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This is the ",(0,s.jsx)(n.strong,{children:"definitive guide"})," for understanding and implementing the ",(0,s.jsx)(n.code,{children:"ValueTask<T>"})," pattern in transformer nodes. For a quick introduction, see ",(0,s.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene#use-valuetaskt-for-fast-path-scenarios",children:"Performance Hygiene: Use ValueTask<T> for Fast Path Scenarios"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"the-performance-paradox",children:"The Performance Paradox"}),"\n",(0,s.jsx)(n.p,{children:"A common performance pitfall in high-throughput ETL pipelines is the contradiction between advice and implementation:"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"The advice says:"}),' "Minimize memory allocations to reduce GC pressure"\r\n',(0,s.jsx)(n.strong,{children:"The code does:"})," Return ",(0,s.jsx)(n.code,{children:"Task<T>"})," for all transformer nodes"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This creates a subtle but critical performance problem: even when your transform work is ",(0,s.jsx)(n.strong,{children:"completely synchronous"})," (a cache hit, a simple calculation), you're still creating a heap-allocated ",(0,s.jsx)(n.code,{children:"Task<T>"})," object to wrap the result."]}),"\n",(0,s.jsxs)(n.p,{children:["In a pipeline processing ",(0,s.jsx)(n.strong,{children:"millions of items per second"}),", where many transforms are synchronous or have high synchronous fast-path rates, you can easily be creating ",(0,s.jsx)(n.strong,{children:"millions of tiny heap allocations per second"}),". This creates constant pressure on the garbage collector, causing pauses that directly undermine your throughput goals."]}),"\n",(0,s.jsx)(n.h2,{id:"the-solution-valuetask",children:"The Solution: ValueTask"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ValueTask<T>"})," is a struct-based alternative to ",(0,s.jsx)(n.code,{children:"Task<T>"})," that:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Allocates on the stack"})," (not the heap) when the result is available synchronously"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Zero allocations"})," for the common case in cache-hit or synchronous scenarios"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Seamlessly transitions"})," to true async work when needed"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The tradeoff: You need to implement a two-path pattern\u2014checking for the synchronous case first."}),"\n",(0,s.jsx)(n.h2,{id:"the-pattern-synchronous-fast-path--asynchronous-slow-path",children:"The Pattern: Synchronous Fast Path + Asynchronous Slow Path"}),"\n",(0,s.jsx)(n.p,{children:"Here's the pattern that balances performance with practicality:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public sealed class OptimizedTransform : ITransformNode<InputType, OutputType>\r\n{\r\n    private readonly ConcurrentDictionary<KeyType, OutputType> _cache = new();\r\n\r\n    /// <summary>\r\n    /// ValueTask enables zero-allocation returns when work is synchronous.\r\n    /// </summary>\r\n    public ValueTask<OutputType> ExecuteAsync(\r\n        InputType item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Fast path: Synchronous work (e.g., cache lookup, simple calculation)\r\n        if (TryGetSynchronousResult(item, out var result))\r\n        {\r\n            // Return via ValueTask - no heap allocation!\r\n            return new ValueTask<OutputType>(result);\r\n        }\r\n\r\n        // Slow path: Asynchronous work falls back to true async\r\n        return new ValueTask<OutputType>(TransformAsync(item, context, cancellationToken));\r\n    }\r\n\r\n    private bool TryGetSynchronousResult(InputType item, out OutputType result)\r\n    {\r\n        // Example: Check cache\r\n        return _cache.TryGetValue(ExtractKey(item), out result!);\r\n    }\r\n\r\n    private async Task<OutputType> TransformAsync(\r\n        InputType item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        var result = await ExpensiveOperationAsync(item, cancellationToken);\r\n        return result;\r\n    }\r\n\r\n    private KeyType ExtractKey(InputType item) => /* ... */;\r\n    private async Task<OutputType> ExpensiveOperationAsync(InputType item, CancellationToken ct) => /* ... */;\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"real-world-example-cached-data-enrichment",children:"Real-World Example: Cached Data Enrichment"}),"\n",(0,s.jsx)(n.p,{children:"Consider a typical ETL scenario where you enrich data by looking up additional information:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public sealed class UserEnrichmentTransform : ITransformNode<UserId, EnrichedUser>\r\n{\r\n    private readonly ConcurrentDictionary<string, UserProfile> _profileCache = new();\r\n    private readonly IUserDatabase _userDatabase;\r\n\r\n    public UserEnrichmentTransform(IUserDatabase userDatabase)\r\n    {\r\n        _userDatabase = userDatabase;\r\n    }\r\n\r\n    /// <summary>\r\n    /// For a pipeline processing 1 million user IDs per second with 90% cache hits,\r\n    /// this eliminates 900,000 Task allocations per second.\r\n    /// </summary>\r\n    public ValueTask<EnrichedUser> ExecuteAsync(\r\n        UserId userId,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Check cache first (usually succeeds)\r\n        if (_profileCache.TryGetValue(userId.Value, out var cachedProfile))\r\n        {\r\n            // Fast path: Return immediately, zero heap allocation\r\n            return new ValueTask<EnrichedUser>(\r\n                new EnrichedUser(userId, cachedProfile)\r\n            );\r\n        }\r\n\r\n        // Cache miss: Fall back to database lookup\r\n        return new ValueTask<EnrichedUser>(\r\n            FetchAndEnrichAsync(userId, context, cancellationToken)\r\n        );\r\n    }\r\n\r\n    private async Task<EnrichedUser> FetchAndEnrichAsync(\r\n        UserId userId,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        var profile = await _userDatabase.GetProfileAsync(userId.Value, cancellationToken);\r\n        _profileCache.TryAdd(userId.Value, profile);\r\n        return new EnrichedUser(userId, profile);\r\n    }\r\n}\r\n\r\npublic record UserId(string Value);\r\npublic record UserProfile(string Name, string Email, DateTime CreatedAt);\r\npublic record EnrichedUser(UserId Id, UserProfile Profile);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-impact",children:"Performance Impact"}),"\n",(0,s.jsx)(n.p,{children:"In a realistic high-volume ETL pipeline:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Scenario"}),(0,s.jsx)(n.th,{children:"Items/Sec"}),(0,s.jsx)(n.th,{children:"Cache Hit Rate"}),(0,s.jsx)(n.th,{children:"Task Allocations/Sec"}),(0,s.jsx)(n.th,{children:"ValueTask Allocations/Sec"}),(0,s.jsx)(n.th,{children:"GC Pressure Reduction"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Simple enrichment"}),(0,s.jsx)(n.td,{children:"1,000,000"}),(0,s.jsx)(n.td,{children:"90%"}),(0,s.jsx)(n.td,{children:"1,000,000"}),(0,s.jsx)(n.td,{children:"100,000"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"90%"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Lookup pipeline"}),(0,s.jsx)(n.td,{children:"5,000,000"}),(0,s.jsx)(n.td,{children:"85%"}),(0,s.jsx)(n.td,{children:"5,000,000"}),(0,s.jsx)(n.td,{children:"750,000"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"85%"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Stream transformation"}),(0,s.jsx)(n.td,{children:"10,000,000"}),(0,s.jsx)(n.td,{children:"95%"}),(0,s.jsx)(n.td,{children:"10,000,000"}),(0,s.jsx)(n.td,{children:"500,000"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"95%"})})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"The compounding effect:"})," Reduced allocations \u2192 Less GC pressure \u2192 Fewer GC pauses \u2192 More throughput \u2192 Lower latency"]}),"\n",(0,s.jsx)(n.h2,{id:"practical-guidelines",children:"Practical Guidelines"}),"\n",(0,s.jsxs)(n.h3,{id:"when-to-use-valuetask-for-transforms",children:["When to Use ",(0,s.jsx)(n.code,{children:"ValueTask"})," for Transforms"]}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsxs)(n.strong,{children:["Use ",(0,s.jsx)(n.code,{children:"ValueTask"})," when:"]})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The transform can complete synchronously in the common case"}),"\n",(0,s.jsx)(n.li,{children:"You have a cache, in-memory lookup, or fast path"}),"\n",(0,s.jsx)(n.li,{children:"The synchronous case is likely to happen frequently"}),"\n",(0,s.jsx)(n.li,{children:"You're optimizing for throughput in high-volume scenarios"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["\u274c ",(0,s.jsxs)(n.strong,{children:["Use ",(0,s.jsx)(n.code,{children:"Task"})," when:"]})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The transform is almost always asynchronous (database queries, network calls every time)"}),"\n",(0,s.jsx)(n.li,{children:"You want simpler code and the performance benefit is marginal"}),"\n",(0,s.jsx)(n.li,{children:"You're building a library and want to keep the interface simple"}),"\n",(0,s.jsx)(n.li,{children:"The pipeline volume is low enough that allocations don't matter"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-checklist",children:"Implementation Checklist"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(n.strong,{children:"Identify the fast path:"})," Where can the transform return synchronously?"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(n.strong,{children:"Measure the fast-path hit rate:"})," Is it worth optimizing? (Usually yes if > 50%)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,s.jsxs)(n.strong,{children:["Implement ",(0,s.jsx)(n.code,{children:"TryGetSynchronousResult()"}),":"]})," Extract the synchronous case"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(n.strong,{children:"Benchmark it:"})," Use BenchmarkDotNet to measure allocation reduction"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(n.strong,{children:"Document it:"})," Explain why ",(0,s.jsx)(n.code,{children:"ValueTask<T>"})," is used and what the fast path is"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(n.strong,{children:"Test both paths:"})," Ensure your code works when fast path returns and when it doesn't"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,s.jsx)(n.h3,{id:"example-1-simple-transformation-always-synchronous",children:"Example 1: Simple Transformation (Always Synchronous)"}),"\n",(0,s.jsxs)(n.p,{children:["If your transform is ",(0,s.jsx)(n.strong,{children:"always"})," synchronous, even simpler:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public sealed class SimpleCalculationTransform : ITransformNode<int, int>\r\n{\r\n    /// <summary>\r\n    /// Pure synchronous work: square each number.\r\n    /// Using ValueTask eliminates Task allocation overhead.\r\n    /// </summary>\r\n    public ValueTask<int> ExecuteAsync(\r\n        int item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // No async work at all\r\n        return new ValueTask<int>(item * item);\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"example-2-format-transformation-with-optional-fallback",children:"Example 2: Format Transformation with Optional Fallback"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public sealed class DataFormatTransform : ITransformNode<RawData, FormattedData>\r\n{\r\n    private readonly IFormatterCache _formatterCache;\r\n    private readonly INetworkFormatterService _networkFormatter;\r\n\r\n    public ValueTask<FormattedData> ExecuteAsync(\r\n        RawData item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Try local cache (fast synchronous path)\r\n        if (_formatterCache.TryFormat(item, out var formatted))\r\n        {\r\n            return new ValueTask<FormattedData>(formatted);\r\n        }\r\n\r\n        // Fall back to network service if needed (slow async path)\r\n        return new ValueTask<FormattedData>(\r\n            _networkFormatter.FormatAsync(item, cancellationToken)\r\n        );\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"critical-constraints-when-not-to-use-valuetask",children:"Critical Constraints: When NOT to Use ValueTask"}),"\n",(0,s.jsx)(n.p,{children:"While ValueTask is powerful, it comes with strict constraints. Understanding these is essential for correctness."}),"\n",(0,s.jsx)(n.h3,{id:"never-await-more-than-once",children:"Never Await More Than Once"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"The Rule:"})," You can only ",(0,s.jsx)(n.code,{children:"await"})," a ",(0,s.jsx)(n.code,{children:"ValueTask<T>"})," exactly once. Multiple awaits on the same ",(0,s.jsx)(n.code,{children:"ValueTask<T>"})," are undefined behavior and will cause exceptions or incorrect results."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// INCORRECT - DO NOT DO THIS\r\nvar valueTask = GetValueAsync("key");\r\nvar result1 = await valueTask;  // First await - OK\r\nvar result2 = await valueTask;  // Second await - UNDEFINED BEHAVIOR (exception or wrong result)\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Why?"})," The struct-based nature of ",(0,s.jsx)(n.code,{children:"ValueTask<T>"})," means its state is mutable. After the first await completes, the internal state is consumed. A second await has nowhere to go."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Correct usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// CORRECT\r\nvar result1 = await GetValueAsync("key");\r\nvar result2 = await GetValueAsync("key"); // Call the method again\n'})}),"\n",(0,s.jsx)(n.h3,{id:"avoid-when-always-asynchronous",children:"Avoid When Always Asynchronous"}),"\n",(0,s.jsxs)(n.p,{children:["If your method ",(0,s.jsx)(n.strong,{children:"always"})," performs async work\u2014never returns synchronously\u2014there's no benefit to ",(0,s.jsx)(n.code,{children:"ValueTask<T>"}),". The wrapper adds complexity without any allocation savings."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// WRONG - Always async, so no benefit\r\npublic ValueTask<int> ComputeExpensiveAsync()\r\n{\r\n    return new ValueTask<int>(ExpensiveComputationAsync());\r\n}\r\n\r\n// CORRECT - Use Task for always async operations\r\npublic Task<int> ComputeExpensiveAsync()\r\n{\r\n    return ExpensiveComputationAsync();\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this case, the synchronous fast path never exists, so you're just adding complexity."}),"\n",(0,s.jsx)(n.h3,{id:"consider-public-apis-carefully",children:"Consider Public APIs Carefully"}),"\n",(0,s.jsxs)(n.p,{children:["If this is a public API that external callers will use, consider using ",(0,s.jsx)(n.code,{children:"Task<T>"})," instead. Your callers need to understand the constraints of ",(0,s.jsx)(n.code,{children:"ValueTask<T>"})," (single await, no ConfigureAwait) to use it correctly. If those constraints aren't explicitly documented and understood, you may create subtle bugs in calling code."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// If this is internal or well-documented, ValueTask is fine\r\ninternal ValueTask<int> GetItemAsync(string key)\r\n{\r\n    // ...\r\n}\r\n\r\n// If this is public, consider whether ValueTask constraints are worth the performance gain\r\n// or whether Task is the safer choice for API stability\r\npublic Task<int> GetItemAsync(string key)\r\n{\r\n    // Simpler contract, no surprise constraints\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"configureawait-not-supported",children:"ConfigureAwait Not Supported"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ValueTask<T>"})," does not support ",(0,s.jsx)(n.code,{children:"ConfigureAwait()"}),". If your code requires ",(0,s.jsx)(n.code,{children:"ConfigureAwait(false)"})," for library code or UI synchronization context handling, you cannot use ",(0,s.jsx)(n.code,{children:"ValueTask<T>"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// WRONG - ConfigureAwait not supported on ValueTask\r\nvar result = await GetValueAsync().ConfigureAwait(false);\r\n\r\n// CORRECT if you need ConfigureAwait\r\npublic Task<string> GetValueAsync()\r\n{\r\n    return FetchAsync().ConfigureAwait(false);\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Hygiene"})," - Comprehensive performance best practices"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/nodes/transform-nodes",children:"Transform Nodes"})," - Node implementation details and ValueTask optimization patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../../samples/Sample_02_HighPerformanceTransform/",children:"Sample: High-Performance Transforms"})," - Complete working example"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"benchmarking-template",children:"Benchmarking Template"}),"\n",(0,s.jsx)(n.p,{children:"Use BenchmarkDotNet to measure the impact:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"[MemoryDiagnoser]\r\npublic class TransformNodeBenchmarks\r\n{\r\n    private ITransformNode<InputType, OutputType> _taskVersion;\r\n    private ITransformNode<InputType, OutputType> _valuetaskVersion;\r\n    private InputType[] _testData;\r\n\r\n    [GlobalSetup]\r\n    public void Setup()\r\n    {\r\n        _testData = GenerateTestData(10000);\r\n        // Initialize both implementations\r\n    }\r\n\r\n    [Benchmark]\r\n    public async Task TaskVersion()\r\n    {\r\n        foreach (var item in _testData)\r\n        {\r\n            await _taskVersion.ExecuteAsync(item, null!, default);\r\n        }\r\n    }\r\n\r\n    [Benchmark]\r\n    public async Task ValueTaskVersion()\r\n    {\r\n        foreach (var item in _testData)\r\n        {\r\n            await _valuetaskVersion.ExecuteAsync(item, null!, default);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"[MemoryDiagnoser]"})," attribute will show you the allocation difference between ",(0,s.jsx)(n.code,{children:"Task<T>"})," and ",(0,s.jsx)(n.code,{children:"ValueTask<T>"})," approaches."]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);