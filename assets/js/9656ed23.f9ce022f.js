"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[9305],{8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},9775:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"extensions/testing/advanced-testing","title":"Advanced Testing","description":"Learn how to test complex pipeline scenarios, including nodes with dependencies, error handling, and more.","source":"@site/docs/extensions/testing/advanced-testing.md","sourceDirName":"extensions/testing","slug":"/extensions/testing/advanced-testing","permalink":"/docs/extensions/testing/advanced-testing","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Advanced Testing","description":"Learn how to test complex pipeline scenarios, including nodes with dependencies, error handling, and more.","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"FluentAssertions","permalink":"/docs/extensions/testing/fluent-assertions"},"next":{"title":"Connectors Overview","permalink":"/docs/connectors"}}');var t=i(4848),r=i(8453);const o={title:"Advanced Testing",description:"Learn how to test complex pipeline scenarios, including nodes with dependencies, error handling, and more.",sidebar_position:4},a="Advanced Pipeline Testing",c={},l=[{value:"Testing Nodes with Dependencies",id:"testing-nodes-with-dependencies",level:2},{value:"Example: Mocking a Service with Moq",id:"example-mocking-a-service-with-moq",level:3},{value:"Testing Error Handling",id:"testing-error-handling",level:2},{value:"Example: Testing Error Handling in a Transform",id:"example-testing-error-handling-in-a-transform",level:3},{value:"Best Practices for Advanced Testing",id:"best-practices-for-advanced-testing",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"advanced-pipeline-testing",children:"Advanced Pipeline Testing"})}),"\n",(0,t.jsxs)(n.p,{children:["While the ",(0,t.jsx)(n.a,{href:"/docs/extensions/testing",children:"basic testing utilities"})," are great for simple, stateless pipelines, real-world scenarios are often more complex. Your nodes may have dependencies on external services, implement complex error handling, or manage internal state."]}),"\n",(0,t.jsx)(n.p,{children:"This guide covers strategies for testing these advanced scenarios effectively."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Getting started with testing?"})," Start with the ",(0,t.jsx)(n.a,{href:"/docs/extensions/testing",children:"Testing Extensions"})," overview for basic patterns."]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"This guide"})," focuses on: ",(0,t.jsx)(n.strong,{children:"Dependencies, mocking, error handling, state management, and integration tests"}),(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Testing Extensions"})," covers: ",(0,t.jsx)(n.strong,{children:"Installation, quick start, available packages, and basic patterns"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"testing-nodes-with-dependencies",children:"Testing Nodes with Dependencies"}),"\n",(0,t.jsx)(n.p,{children:"When your nodes rely on external services (like a database repository or a web API client), you'll want to replace those dependencies with mock or fake implementations during tests. This isolates your node's logic and makes your tests fast and reliable."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"NPipeline.Extensions.DependencyInjection"})," package is invaluable here."]}),"\n",(0,t.jsx)(n.h3,{id:"example-mocking-a-service-with-moq",children:"Example: Mocking a Service with Moq"}),"\n",(0,t.jsxs)(n.p,{children:["Let's expand on the ",(0,t.jsx)(n.code,{children:"NotificationTransform"})," example from the ",(0,t.jsx)(n.a,{href:"/docs/extensions/dependency-injection",children:"Dependency Injection"})," page. We want to test the transform without actually sending an email. We can use a mocking library like ",(0,t.jsx)(n.a,{href:"https://github.com/moq/moq4",children:"Moq"})," to provide a mock ",(0,t.jsx)(n.code,{children:"IEmailService"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"1. Install required packages:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"dotnet add package Moq\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"2. The Test:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Moq;\nusing NPipeline.Execution;\nusing NPipeline.Extensions.DependencyInjection;\nusing NPipeline.Extensions.Testing;\nusing Microsoft.Extensions.DependencyInjection;\nusing NPipeline.Nodes;\nusing NPipeline.Pipeline;\nusing Xunit;\n\npublic interface IEmailService\n{\n    Task SendEmailAsync(string to, string subject, string body);\n}\n\npublic sealed class NotificationTransform : TransformNode<string, string>\n{\n    private readonly IEmailService _emailService;\n\n    public NotificationTransform(IEmailService emailService)\n    {\n        _emailService = emailService;\n    }\n\n    public override async Task<string> ExecuteAsync(\n        string item,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        await _emailService.SendEmailAsync(\n            "admin@example.com",\n            "Processing Item",\n            $"Item \'{item}\' was processed.");\n        return $"Notified for {item}";\n    }\n}\n\npublic sealed class NotificationPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<InMemorySourceNode<string>, string>();\n        var transform = builder.AddTransform<NotificationTransform, string, string>();\n        var sink = builder.AddSink<InMemorySinkNode<string>, string>();\n\n        builder.Connect(source, transform);\n        builder.Connect(transform, sink);\n    }\n}\n\npublic class NotificationTransformTests\n{\n    [Fact]\n    public async Task Transform_Should_Call_Email_Service_For_Each_Item()\n    {\n        // Arrange\n        var mockEmailService = new Mock<IEmailService>();\n\n        var services = new ServiceCollection();\n        \n        // Approach 1: Assembly scanning (automatic discovery)\n        services.AddNPipeline(typeof(NotificationTransformTests).Assembly);\n\n        // Approach 2: Fluent configuration (explicit registration)\n        // services.AddNPipeline(builder => builder\n        //     .AddNode<InMemorySourceNode<string>>()\n        //     .AddNode<NotificationTransform>()\n        //     .AddNode<InMemorySinkNode<string>>()\n        //     .AddPipeline<NotificationPipeline>()\n        // );\n\n        // Register the mock service BEFORE building the provider\n        services.AddSingleton(mockEmailService.Object);\n\n        var serviceProvider = services.BuildServiceProvider();\n\n        var inputData = new[] { "item1", "item2" };\n        var context = new PipelineContext();\n        context.SetSourceData(inputData);\n\n        // Note: IPipelineRunner is registered by AddNPipeline() in the DI container\n        var runner = serviceProvider.GetRequiredService<IPipelineRunner>();\n\n        // Act\n        await runner.RunAsync<NotificationPipeline>(context);\n\n        // Assert\n        // Verify that the SendEmailAsync method was called twice\n        mockEmailService.Verify(\n            x => x.SendEmailAsync(\n                It.IsAny<string>(),\n                It.IsAny<string>(),\n                It.IsAny<string>()),\n            Times.Exactly(2));\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"In this test, we:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Create a mock ",(0,t.jsx)(n.code,{children:"IEmailService"})," using ",(0,t.jsx)(n.code,{children:"new Mock<IEmailService>()"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Register this mock service with the ",(0,t.jsx)(n.code,{children:"ServiceCollection"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Set up the test data in the ",(0,t.jsx)(n.code,{children:"PipelineContext"})," for the ",(0,t.jsx)(n.code,{children:"InMemorySourceNode"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["When the pipeline runs, the ",(0,t.jsx)(n.code,{children:"NotificationTransform"})," receives the mock service."]}),"\n",(0,t.jsxs)(n.li,{children:["Finally, we use Moq's verification API (",(0,t.jsx)(n.code,{children:"Verify()"}),") to confirm the service's method was called as expected."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"testing-error-handling",children:"Testing Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"Testing your pipeline's resilience is important. You should verify that your nodes handle errors gracefully."}),"\n",(0,t.jsx)(n.h3,{id:"example-testing-error-handling-in-a-transform",children:"Example: Testing Error Handling in a Transform"}),"\n",(0,t.jsx)(n.p,{children:"Let's test a transform that handles parsing errors:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.Execution;\nusing NPipeline.Extensions.Testing;\nusing NPipeline.Nodes;\nusing NPipeline.Pipeline;\nusing Xunit;\n\npublic sealed class ParsingTransform : TransformNode<string, int>\n{\n    public override Task<int> ExecuteAsync(\n        string item,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        if (!int.TryParse(item, out var result))\n        {\n            throw new FormatException($"Cannot parse \'{item}\' as an integer");\n        }\n        return Task.FromResult(result);\n    }\n}\n\npublic sealed class ParsingPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<InMemorySourceNode<string>, string>();\n        var transform = builder.AddTransform<ParsingTransform, string, int>();\n        var sink = builder.AddSink<InMemorySinkNode<int>, int>();\n\n        builder.Connect(source, transform);\n        builder.Connect(transform, sink);\n    }\n}\n\npublic class ParsingTransformTests\n{\n    [Fact]\n    public async Task Should_Throw_On_Invalid_Input()\n    {\n        // Arrange\n        var inputData = new[] { "1", "two", "3" };\n        var context = new PipelineContext();\n        context.SetSourceData(inputData);\n\n        var runner = PipelineRunner.Create();\n\n        // Act & Assert\n        var exception = await Assert.ThrowsAsync<FormatException>(\n            async () => await runner.RunAsync<ParsingPipeline>(context));\n\n        Assert.Contains("Cannot parse", exception.Message);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices-for-advanced-testing",children:"Best Practices for Advanced Testing"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Isolate What You're Testing:"})," Use mocks and fakes to ensure your test focuses on a single unit of logic (e.g., one node's ",(0,t.jsx)(n.code,{children:"ExecuteAsync"})," method)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test Both Success and Failure:"})," Don't just test the happy path. Write tests for invalid input, exceptions, cancellations, and other failure modes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Use ",(0,t.jsx)(n.code,{children:"[Theory]"})," for Parameterized Tests:"]})," For nodes with complex conditional logic, use xUnit's ",(0,t.jsx)(n.code,{children:"[Theory]"})," attribute to test many different inputs and expected outputs concisely."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Keep Tests Fast:"})," Avoid ",(0,t.jsx)(n.code,{children:"Task.Delay"}),", network calls, or file system access in your unit tests. Rely on mocks to simulate these operations."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);