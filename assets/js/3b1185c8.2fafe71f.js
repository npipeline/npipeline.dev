"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[4738],{1441:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"core-concepts/nodes/branch","title":"Branch Nodes","description":"Duplicate data streams to multiple downstream paths for branching logic or monitoring using NPipeline\'s Branch Nodes.","source":"@site/docs/core-concepts/nodes/branch.md","sourceDirName":"core-concepts/nodes","slug":"/core-concepts/nodes/branch","permalink":"/docs/core-concepts/nodes/branch","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Branch Nodes","description":"Duplicate data streams to multiple downstream paths for branching logic or monitoring using NPipeline\'s Branch Nodes.","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Lookup Nodes","permalink":"/docs/core-concepts/nodes/lookup"},"next":{"title":"Tap Nodes","permalink":"/docs/core-concepts/nodes/tap"}}');var a=r(4848),s=r(8453);const o={title:"Branch Nodes",description:"Duplicate data streams to multiple downstream paths for branching logic or monitoring using NPipeline's Branch Nodes.",sidebar_position:5},t="Branch Nodes",c={},l=[{value:"<code>BranchNode&lt;T&gt;</code>: Duplicating Streams",id:"branchnodet-duplicating-streams",level:2},{value:"Example: Processing Data in Multiple Ways",id:"example-processing-data-in-multiple-ways",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Considerations for Branch Nodes",id:"considerations-for-branch-nodes",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"branch-nodes",children:"Branch Nodes"})}),"\n",(0,a.jsx)(n.p,{children:"Branch nodes allow you to duplicate (fan-out) an incoming data stream and send identical copies of each item to multiple downstream paths. This is incredibly useful for scenarios where you need to process the same data in different ways concurrently, or for parallel processing of the same data across multiple independent branches."}),"\n",(0,a.jsx)(n.mermaid,{value:"graph TD\r\n    A[Source Data Stream] --\x3e B[BranchNode]\r\n    B --\x3e C[Branch 1: Main Processing]\r\n    B --\x3e D[Branch 2: Processing]\r\n    B --\x3e E[Branch 3: Processing]\r\n\r\n    C --\x3e F[Sink]\r\n    D --\x3e G[Sink]\r\n    E --\x3e H[Sink]\r\n\r\n    style B fill:#e1f5fe,stroke:#01579b,stroke-width:2px\r\n    style C fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\r\n    style D fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\r\n    style E fill:#f3e5f5,stroke:#4a148c,stroke-width:2px"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Figure: BranchNode fan-out pattern showing how a single input stream is duplicated to multiple independent processing branches."})}),"\n",(0,a.jsxs)(n.p,{children:["NPipeline provides the ",(0,a.jsx)(n.a,{href:"src/NPipeline/Nodes/BranchNode.cs",children:(0,a.jsx)(n.code,{children:"BranchNode<T>"})})," for general-purpose stream duplication. For non-intrusive monitoring and side-channel processing, see ",(0,a.jsx)(n.a,{href:"/docs/core-concepts/nodes/tap",children:"Tap Nodes"}),"."]}),"\n",(0,a.jsxs)(n.h2,{id:"branchnodet-duplicating-streams",children:[(0,a.jsx)(n.a,{href:"src/NPipeline/Nodes/BranchNode.cs",children:(0,a.jsx)(n.code,{children:"BranchNode<T>"})}),": Duplicating Streams"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"src/NPipeline/Nodes/BranchNode.cs",children:(0,a.jsx)(n.code,{children:"BranchNode<T>"})})," takes a single input stream of type ",(0,a.jsx)(n.code,{children:"T"})," and produces multiple output streams of the same type ",(0,a.jsx)(n.code,{children:"T"}),". Each item that enters the ",(0,a.jsx)(n.code,{children:"BranchNode"})," is sent to all connected downstream nodes."]}),"\n",(0,a.jsx)(n.h3,{id:"example-processing-data-in-multiple-ways",children:"Example: Processing Data in Multiple Ways"}),"\n",(0,a.jsx)(n.p,{children:"Imagine a scenario where you receive a stream of sensor readings. You might want to:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Store the raw readings in a database."}),"\n",(0,a.jsx)(n.li,{children:"Analyze the readings for anomalies in real-time."}),"\n",(0,a.jsx)(n.li,{children:"Aggregate the readings for hourly reports."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"BranchNode"})," allows you to achieve this by fanning out the raw readings to three different processing branches."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\n\r\npublic sealed record SensorReading(DateTime Timestamp, double Value);\r\n\r\npublic sealed class SensorReadingSource : SourceNode<SensorReading>\r\n{\r\n    public async IAsyncEnumerable<SensorReading> ExecuteAsync(CancellationToken cancellationToken = default)\r\n    {\r\n        for (int i = 0; i < 5; i++)\r\n        {\r\n            if (cancellationToken.IsCancellationRequested) yield break;\r\n            var reading = new SensorReading(DateTime.UtcNow.AddSeconds(i), i * 10.0);\r\n            Console.WriteLine($"Source: Producing {reading}");\r\n            yield return reading;\r\n            await Task.Delay(100, cancellationToken);\r\n        }\r\n    }\r\n}\r\n\r\npublic sealed class RawDataSink : SinkNode<SensorReading>\r\n{\r\n    public async Task ExecuteAsync(IAsyncEnumerable<SensorReading> input, CancellationToken cancellationToken = default)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            Console.WriteLine($"RawDataSink: Stored {item}");\r\n        }\r\n    }\r\n}\r\n\r\npublic sealed class AnomalyDetector : ITransformNode<SensorReading, string>\r\n{\r\n    public async IAsyncEnumerable<string> ExecuteAsync(IAsyncEnumerable<SensorReading> input, CancellationToken cancellationToken = default)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            if (cancellationToken.IsCancellationRequested) yield break;\r\n            if (item.Value > 30.0 && item.Value < 60.0) // Simple anomaly detection\r\n            {\r\n                yield return $"Anomaly Detected: Reading {item.Value} at {item.Timestamp}";\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var context = PipelineContext.Default;\r\n        var runner = PipelineRunner.Create();\r\n        \r\n        Console.WriteLine("Starting branching pipeline...");\r\n        await runner.RunAsync<BranchingPipelineDefinition>(context);\r\n        Console.WriteLine("Branching pipeline finished.");\r\n    }\r\n}\r\n\r\npublic sealed class BranchingPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<SensorReadingSource, SensorReading>("source");\r\n        var branchHandle = builder.AddBranch<BranchNode<SensorReading>>("branch");\r\n        var rawDataSinkHandle = builder.AddSink<RawDataSink, SensorReading>("rawSink");\r\n        var anomalyDetectorHandle = builder.AddTransform<AnomalyDetector, SensorReading, string>("anomaly");\r\n        var consoleSinkHandle = builder.AddSink<ConsoleSink<string>, string>("consoleSink");\r\n\r\n        // First branch: direct to raw data sink\r\n        builder.Connect(sourceHandle, branchHandle);\r\n        builder.Connect(branchHandle, rawDataSinkHandle);\r\n        \r\n        // Second branch: through anomaly detector\r\n        builder.Connect(branchHandle, anomalyDetectorHandle);\r\n        builder.Connect(anomalyDetectorHandle, consoleSinkHandle);\r\n    }\r\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In this example, the ",(0,a.jsx)(n.code,{children:"BranchNode"})," duplicates the input stream, sending copies to multiple downstream paths. One copy goes to ",(0,a.jsx)(n.code,{children:"RawDataSink"})," for storage, and another copy goes through ",(0,a.jsx)(n.code,{children:"AnomalyDetector"})," for real-time anomaly alerts."]}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory Usage"}),": For large-scale fan-out scenarios, be mindful of memory consumption. Each branch maintains its own processing queue and buffers, which can multiply memory usage with multiple branches."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Backpressure"}),": If one branch of a ",(0,a.jsx)(n.code,{children:"BranchNode"})," becomes slow, it can create backpressure that affects other branches. Consider using appropriate buffering strategies or async processing in sink implementations."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Throughput Impact"}),": Duplicating streams incurs overhead. For high-throughput scenarios, profile your pipeline to ensure the fan-out doesn't become a bottleneck."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Resource Management"}),": Ensure all branches properly dispose of resources, especially when using sinks that maintain connections or file handles."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"considerations-for-branch-nodes",children:"Considerations for Branch Nodes"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Order of Processing:"})," While ",(0,a.jsx)(n.code,{children:"BranchNode"})," duplicates items, the order in which items are processed in parallel branches is not guaranteed unless explicitly managed (e.g., by subsequent synchronization points)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance Impact:"})," Duplicating streams and processing them in parallel can increase resource consumption (CPU, memory) if not managed carefully."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Error Handling:"})," Errors in one branch of a ",(0,a.jsx)(n.code,{children:"BranchNode"})," will typically not affect other branches, allowing for isolated fault tolerance."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/core-concepts/nodes/tap",children:"Tap Nodes"})}),": Learn about non-intrusive monitoring and side-channel processing."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling-guide#advanced-patterns",children:"Advanced Error Handling Patterns"})}),": Learn more about handling errors in complex pipeline structures."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>t});var i=r(6540);const a={},s=i.createContext(a);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);