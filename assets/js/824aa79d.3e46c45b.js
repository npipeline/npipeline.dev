"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[2531],{7169:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-concepts/resilience/troubleshooting","title":"Troubleshooting","description":"Diagnose and resolve common resilience issues in NPipeline with symptom-based troubleshooting and debugging guidance.","source":"@site/docs/core-concepts/resilience/troubleshooting.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/troubleshooting","permalink":"/docs/core-concepts/resilience/troubleshooting","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Troubleshooting","description":"Diagnose and resolve common resilience issues in NPipeline with symptom-based troubleshooting and debugging guidance.","sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Materialization and Buffering","permalink":"/docs/core-concepts/resilience/materialization"},"next":{"title":"Retry Configuration","permalink":"/docs/core-concepts/resilience/retries"}}');var t=n(4848),o=n(8453);const s={title:"Troubleshooting",description:"Diagnose and resolve common resilience issues in NPipeline with symptom-based troubleshooting and debugging guidance.",sidebar_position:6},a="Troubleshooting",l={},c=[{value:"Symptom-Based Troubleshooting",id:"symptom-based-troubleshooting",level:2},{value:"Symptom: Node Doesn&#39;t Restart Despite Failures",id:"symptom-node-doesnt-restart-despite-failures",level:3},{value:"Symptom: OutOfMemoryException with Resilient Nodes",id:"symptom-outofmemoryexception-with-resilient-nodes",level:3},{value:"Symptom: Buffer Overflow Exceptions",id:"symptom-buffer-overflow-exceptions",level:3},{value:"Symptom: Circuit Breaker Tripping Too Frequently",id:"symptom-circuit-breaker-tripping-too-frequently",level:3},{value:"Debugging Techniques",id:"debugging-techniques",level:2},{value:"1. Enable Detailed Logging",id:"1-enable-detailed-logging",level:3},{value:"2. Add Custom Observability",id:"2-add-custom-observability",level:3},{value:"3. Create Test Scenarios",id:"3-create-test-scenarios",level:3},{value:"Common Anti-Patterns and Solutions",id:"common-anti-patterns-and-solutions",level:2},{value:"Anti-Pattern 1: Blind Retry Everything",id:"anti-pattern-1-blind-retry-everything",level:3},{value:"Anti-Pattern 2: Unbounded Buffering",id:"anti-pattern-2-unbounded-buffering",level:3},{value:"Anti-Pattern 3: Ignoring Memory Pressure",id:"anti-pattern-3-ignoring-memory-pressure",level:3},{value:"Anti-Pattern 4: One-Size-Fits-All Configuration",id:"anti-pattern-4-one-size-fits-all-configuration",level:3},{value:"Monitoring and Alerting",id:"monitoring-and-alerting",level:2},{value:"1. Key Metrics to Monitor",id:"1-key-metrics-to-monitor",level:3},{value:"2. Alert Thresholds",id:"2-alert-thresholds",level:3},{value:"3. Health Checks",id:"3-health-checks",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const r={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"troubleshooting",children:"Troubleshooting"})}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Related Documentation"}),"\r\nThis guide covers ",(0,t.jsx)(r.strong,{children:"resilience-specific issues"})," (retries, node restarts, materialization). For general pipeline execution issues, see ",(0,t.jsx)(r.a,{href:"/docs/reference/troubleshooting",children:"General Troubleshooting"}),"."]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"This guide helps you diagnose and resolve common issues with resilience configuration in NPipeline. It provides symptom-based troubleshooting, debugging techniques, and solutions for common anti-patterns."}),"\n",(0,t.jsx)(r.h2,{id:"symptom-based-troubleshooting",children:"Symptom-Based Troubleshooting"}),"\n",(0,t.jsx)(r.h3,{id:"symptom-node-doesnt-restart-despite-failures",children:"Symptom: Node Doesn't Restart Despite Failures"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Possible Causes:"})}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["Missing ",(0,t.jsx)(r.code,{children:"ResilientExecutionStrategy"})]}),"\n",(0,t.jsx)(r.li,{children:"No materialization configured for streaming inputs"}),"\n",(0,t.jsxs)(r.li,{children:["Error handler not returning ",(0,t.jsx)(r.code,{children:"RestartNode"})]}),"\n",(0,t.jsx)(r.li,{children:"Retry limits exhausted"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Diagnostic Steps:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'// 1. Check if ResilientExecutionStrategy is applied\r\nvar nodeDefinition = pipeline.GetNodeDefinition("problematicNode");\r\nvar hasResilientStrategy = nodeDefinition.ExecutionStrategy is ResilientExecutionStrategy;\r\nConsole.WriteLine($"Has ResilientExecutionStrategy: {hasResilientStrategy}");\r\n\r\n// 2. Check materialization configuration\r\nvar retryOptions = context.RetryOptions;\r\nConsole.WriteLine($"MaxMaterializedItems: {retryOptions.MaxMaterializedItems}");\r\nif (retryOptions.MaxMaterializedItems == null)\r\n{\r\n    Console.WriteLine("ERROR: No materialization configured for streaming inputs");\r\n}\r\n\r\n// 3. Add logging to error handler\r\npublic class DebuggingErrorHandler : IPipelineErrorHandler\r\n{\r\n    public async Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId, Exception error, PipelineContext context, CancellationToken ct)\r\n    {\r\n        Console.WriteLine($"Error handler called for node: {nodeId}");\r\n        Console.WriteLine($"Exception type: {error.GetType().Name}");\r\n        Console.WriteLine($"Exception message: {error.Message}");\r\n        \r\n        var decision = await HandleError(nodeId, error, context, ct);\r\n        Console.WriteLine($"Decision: {decision}");\r\n        \r\n        return decision;\r\n    }\r\n}\r\n\r\n// 4. Check retry counts\r\nConsole.WriteLine($"MaxItemRetries: {retryOptions.MaxItemRetries}");\r\nConsole.WriteLine($"MaxNodeRestartAttempts: {retryOptions.MaxNodeRestartAttempts}");\r\nConsole.WriteLine($"MaxSequentialNodeAttempts: {retryOptions.MaxSequentialNodeAttempts}");\n'})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Solutions:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'// Solution 1: Apply ResilientExecutionStrategy\r\nvar problematicHandle = builder\r\n    .AddTransform<ProblematicTransform, Input, Output>("problematicNode")\r\n    .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n        new SequentialExecutionStrategy()\r\n    ));\r\n\r\n// Solution 2: Configure materialization\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5\r\n);\r\n\r\n// Solution 3: Fix error handler\r\npublic class FixedErrorHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId, Exception error, PipelineContext context, CancellationToken ct)\r\n    {\r\n        return error switch\r\n        {\r\n            TimeoutException => Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            NetworkException => Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\r\n        };\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"symptom-outofmemoryexception-with-resilient-nodes",children:"Symptom: OutOfMemoryException with Resilient Nodes"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Possible Causes:"})}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["Unbounded materialization (",(0,t.jsx)(r.code,{children:"MaxMaterializedItems = null"}),")"]}),"\n",(0,t.jsx)(r.li,{children:"Buffer size too large for available memory"}),"\n",(0,t.jsx)(r.li,{children:"Large items being buffered"}),"\n",(0,t.jsx)(r.li,{children:"Memory leaks in custom components"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Diagnostic Steps:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'// 1. Monitor memory usage\r\npublic class MemoryMonitor : IExecutionObserver\r\n{\r\n    public void OnBufferUsage(string nodeId, int currentItems, int maxItems)\r\n    {\r\n        var memoryMB = GC.GetTotalMemory(false) / (1024 * 1024);\r\n        Console.WriteLine($"Node {nodeId}: {currentItems}/{maxItems} items, Memory: {memoryMB}MB");\r\n        \r\n        if (memoryMB > 1000) // 1GB threshold\r\n        {\r\n            Console.WriteLine($"WARNING: High memory usage: {memoryMB}MB");\r\n        }\r\n    }\r\n}\r\n\r\n// 2. Check buffer configuration\r\nvar retryOptions = context.RetryOptions;\r\nif (retryOptions.MaxMaterializedItems == null)\r\n{\r\n    Console.WriteLine("WARNING: Unbounded materialization may cause memory issues");\r\n}\r\n\r\n// 3. Estimate memory requirements\r\npublic static long EstimateMemoryUsage(int itemCount, long itemSizeBytes)\r\n{\r\n    return itemCount * itemSizeBytes * 2; // Factor in overhead\r\n}\r\n\r\nvar estimatedMemory = EstimateMemoryUsage(\r\n    retryOptions.MaxMaterializedItems ?? 0,\r\n    estimatedItemSizeBytes\r\n);\r\nConsole.WriteLine($"Estimated memory usage: {estimatedMemory / (1024 * 1024)}MB");\n'})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Solutions:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'// Solution 1: Set appropriate buffer limits\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: CalculateOptimalBufferSize()\r\n);\r\n\r\nprivate static int CalculateOptimalBufferSize()\r\n{\r\n    var availableMemoryMB = GetAvailableMemoryMB();\r\n    var estimatedItemSizeKB = EstimateItemSize();\r\n    var memoryBudgetMB = availableMemoryMB / 4; // Use 25% of available memory\r\n    return (memoryBudgetMB * 1024) / estimatedItemSizeKB;\r\n}\r\n\r\n// Solution 2: Implement memory-aware error handling\r\npublic class MemoryAwareErrorHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId, Exception error, PipelineContext context, CancellationToken ct)\r\n    {\r\n        // Check memory pressure\r\n        var memoryMB = GC.GetTotalMemory(false) / (1024 * 1024);\r\n        if (memoryMB > 2000) // 2GB threshold\r\n        {\r\n            Console.WriteLine("High memory pressure - avoiding restart");\r\n            return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\r\n        }\r\n        \r\n        return Task.FromResult(PipelineErrorDecision.RestartNode);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"symptom-buffer-overflow-exceptions",children:"Symptom: Buffer Overflow Exceptions"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Possible Causes:"})}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"MaxMaterializedItems"})," set too low"]}),"\n",(0,t.jsx)(r.li,{children:"High throughput with small buffer"}),"\n",(0,t.jsx)(r.li,{children:"Processing bottlenecks downstream"}),"\n",(0,t.jsx)(r.li,{children:"Infinite loops in processing logic"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Diagnostic Steps:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'// 1. Monitor buffer utilization\r\npublic class BufferMonitor : IExecutionObserver\r\n{\r\n    public void OnBufferUsage(string nodeId, int currentItems, int maxItems)\r\n    {\r\n        var usagePercent = (currentItems * 100) / maxItems;\r\n        if (usagePercent > 80)\r\n        {\r\n            Console.WriteLine($"WARNING: Node {nodeId} buffer at {usagePercent}% capacity");\r\n        }\r\n    }\r\n}\r\n\r\n// 2. Check throughput vs. processing rate\r\npublic class ThroughputMonitor\r\n{\r\n    private readonly Dictionary<string, (int Input, int Output)> _counters = new();\r\n    \r\n    public void RecordInput(string nodeId)\r\n    {\r\n        _counters.TryGetValue(nodeId, out var counter);\r\n        _counters[nodeId] = (counter.Input + 1, counter.Output);\r\n    }\r\n    \r\n    public void RecordOutput(string nodeId)\r\n    {\r\n        _counters.TryGetValue(nodeId, out var counter);\r\n        _counters[nodeId] = (counter.Input, counter.Output + 1);\r\n    }\r\n    \r\n    public void AnalyzeBackpressure()\r\n    {\r\n        foreach (var (nodeId, (input, output)) in _counters)\r\n        {\r\n            var backlog = input - output;\r\n            if (backlog > 1000)\r\n            {\r\n                Console.WriteLine($"WARNING: Node {nodeId} has backlog of {backlog} items");\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Solutions:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'// Solution 1: Increase buffer size\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: 5000 // Increased buffer size\r\n);\r\n\r\n// Solution 2: Implement adaptive buffering\r\npublic class AdaptiveRetryOptions : PipelineRetryOptions\r\n{\r\n    private int _currentMaxItems;\r\n    \r\n    public AdaptiveRetryOptions() : base(3, 2, 5, 1000)\r\n    {\r\n        _currentMaxItems = MaxMaterializedItems ?? 1000;\r\n    }\r\n    \r\n    public void AdjustBufferSize(int currentUsage, int maxCapacity)\r\n    {\r\n        var usagePercent = (currentUsage * 100) / maxCapacity;\r\n        if (usagePercent > 90)\r\n        {\r\n            _currentMaxItems = (int)(_currentMaxItems * 1.5); // Increase by 50%\r\n            Console.WriteLine($"Increased buffer size to {_currentMaxItems}");\r\n        }\r\n    }\r\n}\r\n\r\n// Solution 3: Add circuit breaker for buffer overflow\r\npublic class BufferOverflowAwareErrorHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId, Exception error, PipelineContext context, CancellationToken ct)\r\n    {\r\n        if (error.Message.Contains("Resilience materialization exceeded MaxMaterializedItems"))\r\n        {\r\n            Console.WriteLine($"Buffer overflow for node {nodeId} - skipping restart");\r\n            return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\r\n        }\r\n        \r\n        return Task.FromResult(PipelineErrorDecision.RestartNode);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"symptom-circuit-breaker-tripping-too-frequently",children:"Symptom: Circuit Breaker Tripping Too Frequently"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Possible Causes:"})}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"Failure threshold set too low"}),"\n",(0,t.jsx)(r.li,{children:"Persistent infrastructure issues"}),"\n",(0,t.jsx)(r.li,{children:"Incorrect error classification"}),"\n",(0,t.jsx)(r.li,{children:"Resource contention"}),"\n",(0,t.jsx)(r.li,{children:"Wrong threshold type for your scenario (e.g., using ConsecutiveFailures when rate-based would be better)"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Diagnostic Steps:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'// 1. Monitor circuit breaker state\r\npublic class CircuitBreakerMonitor : IExecutionObserver\r\n{\r\n    public void OnRetry(NodeRetryEvent retryEvent)\r\n    {\r\n        if (retryEvent.RetryKind == RetryKind.NodeRestart)\r\n        {\r\n            Console.WriteLine($"Node restart: {retryEvent.NodeId}, Attempt: {retryEvent.Attempt}");\r\n        }\r\n    }\r\n}\r\n\r\n// 2. Check circuit breaker statistics\r\nif (context.Items.TryGetValue(PipelineContextKeys.CircuitBreakerManager, out var managerObj) &&\r\n    managerObj is ICircuitBreakerManager manager)\r\n{\r\n    var circuitBreaker = manager.GetCircuitBreaker(nodeId, circuitBreakerOptions);\r\n    var stats = circuitBreaker.GetStatistics();\r\n    Console.WriteLine($"Circuit breaker stats: {stats.TotalOperations} total, " +\r\n                     $"{stats.FailureCount} failures, {stats.FailureRate:P2} failure rate");\r\n}\r\n\r\n// 3. Analyze failure patterns\r\npublic class FailureAnalyzer\r\n{\r\n    private readonly Dictionary<string, List<Exception>> _failures = new();\r\n    \r\n    public void RecordFailure(string nodeId, Exception error)\r\n    {\r\n        if (!_failures.ContainsKey(nodeId))\r\n            _failures[nodeId] = new List<Exception>();\r\n        \r\n        _failures[nodeId].Add(error);\r\n        \r\n        // Analyze pattern after 10 failures\r\n        if (_failures[nodeId].Count >= 10)\r\n        {\r\n            AnalyzeFailurePattern(nodeId);\r\n        }\r\n    }\r\n    \r\n    private void AnalyzeFailurePattern(string nodeId)\r\n    {\r\n        var failures = _failures[nodeId];\r\n        var errorTypes = failures.GroupBy(e => e.GetType().Name)\r\n                              .ToDictionary(g => g.Key, g => g.Count());\r\n        \r\n        Console.WriteLine($"Failure pattern for {nodeId}:");\r\n        foreach (var (errorType, count) in errorTypes)\r\n        {\r\n            Console.WriteLine($"  {errorType}: {count} occurrences");\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Solutions:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Solution 1: Adjust circuit breaker options\r\nvar circuitBreakerOptions = new PipelineCircuitBreakerOptions\r\n{\r\n    Enabled: true,\r\n    FailureThreshold: 10, // Increased from default\r\n    OpenDuration: TimeSpan.FromMinutes(2),\r\n    SamplingWindow: TimeSpan.FromMinutes(5),\r\n    ThresholdType: CircuitBreakerThresholdType.RollingWindowRate, // Try rate-based\r\n    FailureRateThreshold: 0.2 // 20% failure rate\r\n};\r\n\r\n// Solution 2: Implement smart error classification\r\npublic class SmartErrorHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId, Exception error, PipelineContext context, CancellationToken ct)\r\n    {\r\n        // Don't restart for permanent failures\r\n        if (IsPermanentFailure(error))\r\n        {\r\n            return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\r\n        }\r\n        \r\n        // Only restart for transient failures\r\n        if (IsTransientFailure(error))\r\n        {\r\n            return Task.FromResult(PipelineErrorDecision.RestartNode);\r\n        }\r\n        \r\n        return Task.FromResult(PipelineErrorDecision.FailPipeline);\r\n    }\r\n    \r\n    private bool IsPermanentFailure(Exception ex)\r\n    {\r\n        return ex is AuthenticationException or \r\n               AuthorizationException or \r\n               NotFoundException;\r\n    }\r\n    \r\n    private bool IsTransientFailure(Exception ex)\r\n    {\r\n        return ex is TimeoutException or \r\n               NetworkException or \r\n               TemporaryServiceException;\r\n    }\r\n}\r\n\r\n// Solution 3: Try different threshold types based on your scenario\r\n// For high-volume, rate-sensitive scenarios:\r\nvar rateBasedOptions = new PipelineCircuitBreakerOptions\r\n{\r\n    FailureThreshold: 100,\r\n    OpenDuration: TimeSpan.FromMinutes(2),\r\n    SamplingWindow: TimeSpan.FromMinutes(5),\r\n    ThresholdType: CircuitBreakerThresholdType.RollingWindowRate,\r\n    FailureRateThreshold: 0.05 // 5% failure rate\r\n};\r\n\r\n// For scenarios where both count and rate matter:\r\nvar hybridOptions = new PipelineCircuitBreakerOptions\r\n{\r\n    FailureThreshold: 5,\r\n    OpenDuration: TimeSpan.FromMinutes(1),\r\n    SamplingWindow: TimeSpan.FromMinutes(5),\r\n    ThresholdType: CircuitBreakerThresholdType.Hybrid,\r\n    FailureRateThreshold: 0.3 // 30% failure rate\r\n};\n"})}),"\n",(0,t.jsx)(r.h2,{id:"debugging-techniques",children:"Debugging Techniques"}),"\n",(0,t.jsx)(r.h3,{id:"1-enable-detailed-logging",children:"1. Enable Detailed Logging"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public class ResilienceLogger : IPipelineLogger\r\n{\r\n    private readonly ILogger _logger;\r\n    \r\n    public ResilienceLogger(ILogger logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n    \r\n    public void LogDebug(string message, params object[] args)\r\n    {\r\n        _logger.LogDebug(message, args);\r\n    }\r\n    \r\n    public void LogInformation(string message, params object[] args)\r\n    {\r\n        _logger.LogInformation(message, args);\r\n    }\r\n    \r\n    public void LogWarning(string message, params object[] args)\r\n    {\r\n        _logger.LogWarning(message, args);\r\n    }\r\n    \r\n    public void LogError(Exception exception, string message, params object[] args)\r\n    {\r\n        _logger.LogError(exception, message, args);\r\n    }\r\n}\r\n\r\n// Configure in context\r\nvar context = PipelineContext.WithObservability(\r\n    loggerFactory: new ResilienceLoggerFactory()\r\n);\n"})}),"\n",(0,t.jsx)(r.h3,{id:"2-add-custom-observability",children:"2. Add Custom Observability"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public class ResilienceObserver : IExecutionObserver\r\n{\r\n    public void OnRetry(NodeRetryEvent retryEvent)\r\n    {\r\n        Console.WriteLine($"[{DateTime.UtcNow:O}] Retry: {retryEvent.NodeId}, " +\r\n                         $"Kind: {retryEvent.RetryKind}, " +\r\n                         $"Attempt: {retryEvent.Attempt}, " +\r\n                         $"Error: {retryEvent.Error?.Message}");\r\n    }\r\n    \r\n    public void OnBufferUsage(string nodeId, int currentItems, int maxItems)\r\n    {\r\n        var usagePercent = (currentItems * 100) / maxItems;\r\n        Console.WriteLine($"[{DateTime.UtcNow:O}] Buffer: {nodeId}, " +\r\n                         $"{currentItems}/{maxItems} ({usagePercent}%)");\r\n    }\r\n}\r\n\r\n// Register observer\r\nvar context = PipelineContext.Default;\r\ncontext.ExecutionObserver = new ResilienceObserver();\n'})}),"\n",(0,t.jsx)(r.h3,{id:"3-create-test-scenarios",children:"3. Create Test Scenarios"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public class ResilienceTestHarness\r\n{\r\n    public async Task TestRestartScenario()\r\n    {\r\n        var flakySource = new FlakyDataSource(failureRate: 0.3);\r\n        var pipeline = CreateResilientPipeline(flakySource);\r\n        \r\n        var context = PipelineContext.WithRetry(new PipelineRetryOptions(\r\n            MaxItemRetries: 3,\r\n            MaxNodeRestartAttempts: 2,\r\n            MaxSequentialNodeAttempts: 5,\r\n            MaxMaterializedItems: 1000\r\n        ));\r\n        \r\n        var result = await pipeline.RunAsync(context);\r\n        \r\n        Assert.IsTrue(result.IsSuccess);\r\n        Assert.Greater(flakySource.ProcessedItems, 0);\r\n    }\r\n    \r\n    public async Task TestBufferOverflowScenario()\r\n    {\r\n        var highVolumeSource = new HighVolumeSource(itemsPerSecond: 1000);\r\n        var pipeline = CreateResilientPipeline(highVolumeSource);\r\n        \r\n        var context = PipelineContext.WithRetry(new PipelineRetryOptions(\r\n            MaxMaterializedItems: 100 // Small buffer to trigger overflow\r\n        ));\r\n        \r\n        try\r\n        {\r\n            await pipeline.RunAsync(context);\r\n            Assert.Fail("Expected buffer overflow exception");\r\n        }\r\n        catch (InvalidOperationException ex) when ex.Message.Contains("MaxMaterializedItems")\r\n        {\r\n            // Expected exception\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"common-anti-patterns-and-solutions",children:"Common Anti-Patterns and Solutions"}),"\n",(0,t.jsx)(r.h3,{id:"anti-pattern-1-blind-retry-everything",children:"Anti-Pattern 1: Blind Retry Everything"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// WRONG: Retry everything, including permanent failures\r\npublic class BlindRetryHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId, Exception error, PipelineContext context, CancellationToken ct)\r\n    {\r\n        return Task.FromResult(PipelineErrorDecision.RestartNode); // Always restarts!\r\n    }\r\n}\r\n\r\n// CORRECT: Smart error classification\r\npublic class SmartRetryHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId, Exception error, PipelineContext context, CancellationToken ct)\r\n    {\r\n        return error switch\r\n        {\r\n            // Transient failures - retry\r\n            TimeoutException => Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            NetworkException => Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            HttpRequestException http when IsTransientHttpError(http) => \r\n                Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            \r\n            // Permanent failures - don't retry\r\n            AuthenticationException => Task.FromResult(PipelineErrorDecision.FailPipeline),\r\n            ValidationException => Task.FromResult(PipelineErrorDecision.Skip),\r\n            NotFoundException => Task.FromResult(PipelineErrorDecision.ContinueWithoutNode),\r\n            \r\n            // Unknown failures - fail safe\r\n            _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\r\n        };\r\n    }\r\n    \r\n    private bool IsTransientHttpError(HttpRequestException ex)\r\n    {\r\n        return ex.StatusCode is HttpStatusCode.ServiceUnavailable or \r\n               HttpStatusCode.RequestTimeout or \r\n               HttpStatusCode.TooManyRequests;\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"anti-pattern-2-unbounded-buffering",children:"Anti-Pattern 2: Unbounded Buffering"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// WRONG: Unbounded materialization\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: null // No limit - potential OOM\r\n);\r\n\r\n// CORRECT: Calculated buffer limits\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: CalculateSafeBufferLimit()\r\n);\r\n\r\nprivate static int CalculateSafeBufferLimit()\r\n{\r\n    var availableMemoryMB = GC.GetTotalMemory(false) / (1024 * 1024);\r\n    var estimatedItemSizeKB = 10; // Estimate based on your data\r\n    var memoryBudgetMB = Math.Min(availableMemoryMB / 4, 1000); // Max 1GB\r\n    return (memoryBudgetMB * 1024) / estimatedItemSizeKB;\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"anti-pattern-3-ignoring-memory-pressure",children:"Anti-Pattern 3: Ignoring Memory Pressure"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'// WRONG: No memory awareness\r\npublic class MemoryObliviousHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId, Exception error, PipelineContext context, CancellationToken ct)\r\n    {\r\n        return Task.FromResult(PipelineErrorDecision.RestartNode); // Always restarts\r\n    }\r\n}\r\n\r\n// CORRECT: Memory-aware error handling\r\npublic class MemoryAwareHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId, Exception error, PipelineContext context, CancellationToken ct)\r\n    {\r\n        // Check memory pressure\r\n        var memoryMB = GC.GetTotalMemory(false) / (1024 * 1024);\r\n        if (memoryMB > 2000) // 2GB threshold\r\n        {\r\n            Console.WriteLine($"High memory usage ({memoryMB}MB) - avoiding restart");\r\n            return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\r\n        }\r\n        \r\n        return error switch\r\n        {\r\n            TimeoutException => Task.FromResult(PipelineErrorDecision.RestartNode),\r\n            _ => Task.FromResult(PipelineErrorDecision.FailPipeline)\r\n        };\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"anti-pattern-4-one-size-fits-all-configuration",children:"Anti-Pattern 4: One-Size-Fits-All Configuration"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'// WRONG: Same configuration for all nodes\r\nvar defaultOptions = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: 1000\r\n);\r\nvar context = PipelineContext.WithRetry(defaultOptions);\r\n\r\n// CORRECT: Node-specific configuration using per-node retry options\r\nvar betterDefaultOptions = new PipelineRetryOptions(\r\n    MaxItemRetries: 2,\r\n    MaxNodeRestartAttempts: 1,\r\n    MaxSequentialNodeAttempts: 3,\r\n    MaxMaterializedItems: 500\r\n);\r\nvar betterContext = PipelineContext.WithRetry(betterDefaultOptions);\r\n\r\nvar criticalNodeHandle = builder\r\n    .AddTransform<CriticalTransform, Input, Output>("criticalNode");\r\nvar highVolumeHandle = builder\r\n    .AddTransform<HighVolumeTransform, Input, Output>("highVolumeNode");\r\n\r\nbuilder\r\n    .WithRetryOptions(criticalNodeHandle, new PipelineRetryOptions(\r\n        MaxItemRetries: 5,\r\n        MaxNodeRestartAttempts: 5,\r\n        MaxSequentialNodeAttempts: 10,\r\n        MaxMaterializedItems: 2000\r\n    ))\r\n    .WithRetryOptions(highVolumeHandle, new PipelineRetryOptions(\r\n        MaxItemRetries: 1,\r\n        MaxNodeRestartAttempts: 2,\r\n        MaxSequentialNodeAttempts: 4,\r\n        MaxMaterializedItems: 10000\r\n    ));\n'})}),"\n",(0,t.jsx)(r.h2,{id:"monitoring-and-alerting",children:"Monitoring and Alerting"}),"\n",(0,t.jsx)(r.h3,{id:"1-key-metrics-to-monitor",children:"1. Key Metrics to Monitor"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public class ResilienceMetrics\r\n{\r\n    private readonly IMetrics _metrics;\r\n    \r\n    public ResilienceMetrics(IMetrics metrics)\r\n    {\r\n        _metrics = metrics;\r\n    }\r\n    \r\n    public void RecordNodeRestart(string nodeId)\r\n    {\r\n        _metrics.Counter("node_restarts", new[] { ("node_id", nodeId) }).Increment();\r\n    }\r\n    \r\n    public void RecordBufferUsage(string nodeId, int current, int max)\r\n    {\r\n        var usagePercent = (current * 100) / max;\r\n        _metrics.Gauge("buffer_usage_percent", usagePercent, new[] { ("node_id", nodeId) });\r\n    }\r\n    \r\n    public void RecordMemoryUsage(long bytes)\r\n    {\r\n        _metrics.Gauge("memory_usage_bytes", bytes);\r\n    }\r\n    \r\n    public void RecordCircuitBreakerTrip(string nodeId)\r\n    {\r\n        _metrics.Counter("circuit_breaker_trips", new[] { ("node_id", nodeId) }).Increment();\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"2-alert-thresholds",children:"2. Alert Thresholds"}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Metric"}),(0,t.jsx)(r.th,{children:"Warning Threshold"}),(0,t.jsx)(r.th,{children:"Critical Threshold"}),(0,t.jsx)(r.th,{children:"Action"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Node restarts per minute"}),(0,t.jsx)(r.td,{children:">5"}),(0,t.jsx)(r.td,{children:">10"}),(0,t.jsx)(r.td,{children:"Investigate infrastructure"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Buffer usage percent"}),(0,t.jsx)(r.td,{children:">80%"}),(0,t.jsx)(r.td,{children:">95%"}),(0,t.jsx)(r.td,{children:"Increase buffer size"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Memory usage"}),(0,t.jsx)(r.td,{children:">1GB"}),(0,t.jsx)(r.td,{children:">2GB"}),(0,t.jsx)(r.td,{children:"Scale horizontally"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Circuit breaker trips per hour"}),(0,t.jsx)(r.td,{children:">2"}),(0,t.jsx)(r.td,{children:">5"}),(0,t.jsx)(r.td,{children:"Review error classification"})]})]})]}),"\n",(0,t.jsx)(r.h3,{id:"3-health-checks",children:"3. Health Checks"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public class ResilienceHealthCheck : IHealthCheck\r\n{\r\n    public async Task<HealthCheckResult> CheckHealthAsync(\r\n        HealthCheckContext context, CancellationToken cancellationToken = default)\r\n    {\r\n        var memoryMB = GC.GetTotalMemory(false) / (1024 * 1024);\r\n        var issues = new List<string>();\r\n        \r\n        if (memoryMB > 2000)\r\n            issues.Add($"High memory usage: {memoryMB}MB");\r\n        \r\n        if (GetFailedNodeCount() > 5)\r\n            issues.Add($"High failure rate: {GetFailedNodeCount()} nodes");\r\n        \r\n        return issues.Count == 0\r\n            ? HealthCheckResult.Healthy()\r\n            : HealthCheckResult.Degraded(string.Join(", ", issues));\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling Guide"})}),": Review proper configuration patterns"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/getting-started",children:"Getting Started with Resilience"})}),": Understand critical prerequisite relationships"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/reference/error-codes",children:"Error Codes Reference"})}),": Look up specific NPipeline error codes (NP01xx-NP05xx)"]}),"\n"]})]})}function u(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>a});var i=n(6540);const t={},o=i.createContext(t);function s(e){const r=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(o.Provider,{value:r},e.children)}}}]);