"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[7589],{21297:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>g,frontMatter:()=>o,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"extensions/observability/configuration","title":"Observability Configuration","description":"Detailed guide to configuring NPipeline observability with dependency injection, custom sinks, and advanced scenarios.","source":"@site/docs/extensions/observability/configuration.md","sourceDirName":"extensions/observability","slug":"/extensions/observability/configuration","permalink":"/docs/extensions/observability/configuration","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Observability Configuration","description":"Detailed guide to configuring NPipeline observability with dependency injection, custom sinks, and advanced scenarios."},"sidebar":"docsSidebar","previous":{"title":"Advanced Observability Patterns","permalink":"/docs/extensions/observability/advanced-patterns"},"next":{"title":"Observability Usage Examples","permalink":"/docs/extensions/observability/examples"}}');var s=i(74848),t=i(28453);const o={title:"Observability Configuration",description:"Detailed guide to configuring NPipeline observability with dependency injection, custom sinks, and advanced scenarios."},l="Observability Configuration",c={},a=[{value:"Quick Start: Automatic Metrics Collection",id:"quick-start-automatic-metrics-collection",level:2},{value:"Registration Methods",id:"registration-methods",level:2},{value:"1. Default Registration with Logging Sinks",id:"1-default-registration-with-logging-sinks",level:3},{value:"2. Custom Metrics Sinks",id:"2-custom-metrics-sinks",level:3},{value:"3. Factory Delegate Registration",id:"3-factory-delegate-registration",level:3},{value:"4. Custom Collector Implementation",id:"4-custom-collector-implementation",level:3},{value:"5. Custom Collector with Factory Delegate",id:"5-custom-collector-with-factory-delegate",level:3},{value:"Service Lifetimes",id:"service-lifetimes",level:2},{value:"Why Scoped Collector?",id:"why-scoped-collector",level:3},{value:"Why Scoped Sinks?",id:"why-scoped-sinks",level:3},{value:"Configuration Options",id:"configuration-options",level:2},{value:"ObservabilityExtensionOptions",id:"observabilityextensionoptions",level:3},{value:"Default Configuration (Logging Sinks)",id:"default-configuration-logging-sinks",level:3},{value:"Conditional Registration",id:"conditional-registration",level:3},{value:"Multiple Sinks",id:"multiple-sinks",level:3},{value:"Configuration-Based Sink Selection",id:"configuration-based-sink-selection",level:3},{value:"Integration with Existing Logging Infrastructure",id:"integration-with-existing-logging-infrastructure",level:2},{value:"Structured Logging with Serilog",id:"structured-logging-with-serilog",level:3},{value:"Enriching Logs with Context",id:"enriching-logs-with-context",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Appropriate Service Lifetimes",id:"1-use-appropriate-service-lifetimes",level:3},{value:"2. Handle Cancellation",id:"2-handle-cancellation",level:3},{value:"3. Implement Retry Logic for External Systems",id:"3-implement-retry-logic-for-external-systems",level:3},{value:"4. Filter Metrics in Development",id:"4-filter-metrics-in-development",level:3},{value:"5. Aggregate Metrics for High-Volume Scenarios",id:"5-aggregate-metrics-for-high-volume-scenarios",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Metrics Not Appearing",id:"metrics-not-appearing",level:3},{value:"Memory Leaks",id:"memory-leaks",level:3},{value:"Performance Degradation",id:"performance-degradation",level:3},{value:"Architecture and Design",id:"architecture-and-design",level:2},{value:"System Architecture",id:"system-architecture",level:3},{value:"Key Components",id:"key-components",level:3},{value:"Thread-Safety Guarantees",id:"thread-safety-guarantees",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Minimal Overhead",id:"minimal-overhead",level:3},{value:"Memory Usage",id:"memory-usage",level:3},{value:"CPU Impact",id:"cpu-impact",level:3},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"observability-configuration",children:"Observability Configuration"})}),"\n",(0,s.jsx)(n.p,{children:"This guide covers all configuration options for the NPipeline Observability extension, including dependency injection registration, custom metrics sinks, and integration patterns."}),"\n",(0,s.jsx)(n.h2,{id:"quick-start-automatic-metrics-collection",children:"Quick Start: Automatic Metrics Collection"}),"\n",(0,s.jsxs)(n.p,{children:["The simplest way to enable observability is to use the ",(0,s.jsx)(n.code,{children:"IObservablePipelineContextFactory"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing NPipeline.Observability;\nusing NPipeline.Observability.DependencyInjection;\nusing NPipeline.Extensions.DependencyInjection;\n\nvar host = Host.CreateDefaultBuilder()\n    .ConfigureServices((context, services) =>\n    {\n        services.AddNPipelineObservability(); // Registers everything automatically\n        services.AddNPipeline(Assembly.GetExecutingAssembly());\n    })\n    .Build();\n\n// Create context with observability pre-configured\nawait using var scope = host.Services.CreateAsyncScope();\nvar contextFactory = scope.ServiceProvider.GetRequiredService<IObservablePipelineContextFactory>();\nawait using var context = contextFactory.Create(); // ExecutionObserver is already set!\n\nvar runner = scope.ServiceProvider.GetRequiredService<IPipelineRunner>();\nawait runner.RunAsync<MyPipeline>(context);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["No need to manually create or wire up ",(0,s.jsx)(n.code,{children:"MetricsCollectingExecutionObserver"})," - it's all handled automatically!"]}),"\n",(0,s.jsx)(n.h2,{id:"registration-methods",children:"Registration Methods"}),"\n",(0,s.jsx)(n.p,{children:"The extension provides multiple registration methods to accommodate different scenarios and requirements."}),"\n",(0,s.jsx)(n.h3,{id:"1-default-registration-with-logging-sinks",children:"1. Default Registration with Logging Sinks"}),"\n",(0,s.jsxs)(n.p,{children:["The simplest approach uses built-in logging sinks that output metrics to ",(0,s.jsx)(n.code,{children:"ILogger"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using Microsoft.Extensions.DependencyInjection;\nusing NPipeline.Observability.DependencyInjection;\n\nvar services = new ServiceCollection();\n\n// Register with default logging sinks\nservices.AddNPipelineObservability();\n\n// Register NPipeline core services\nservices.AddNPipeline(Assembly.GetExecutingAssembly());\n\nvar serviceProvider = services.BuildServiceProvider();\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What gets registered:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IObservabilityCollector"})," (scoped) - collects metrics during execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IExecutionObserver"})," (scoped) - automatically wired to observer pipeline events"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IObservablePipelineContextFactory"})," (scoped) - creates contexts with observability enabled"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IMetricsSink"})," \u2192 ",(0,s.jsx)(n.code,{children:"LoggingMetricsSink"})," (transient) - outputs metrics via ILogger"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IPipelineMetricsSink"})," \u2192 ",(0,s.jsx)(n.code,{children:"LoggingPipelineMetricsSink"})," (transient) - outputs pipeline-level metrics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IObservabilityFactory"})," \u2192 ",(0,s.jsx)(n.code,{children:"DiObservabilityFactory"})," (scoped) - factory for sink resolution"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use when:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You want quick observability without additional infrastructure"}),"\n",(0,s.jsx)(n.li,{children:"You're already using structured logging (Serilog, NLog, etc.)"}),"\n",(0,s.jsx)(n.li,{children:"You need metrics for local development or debugging"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-custom-metrics-sinks",children:"2. Custom Metrics Sinks"}),"\n",(0,s.jsx)(n.p,{children:"Register your own implementations of metrics sinks:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using Microsoft.Extensions.DependencyInjection;\nusing NPipeline.Observability.DependencyInjection;\nusing NPipeline.Observability.Metrics;\n\nvar services = new ServiceCollection();\n\n// Register with custom sinks\nservices.AddNPipelineObservability<CustomMetricsSink, CustomPipelineMetricsSink>();\n\n// Register your custom sinks if they have dependencies\nservices.AddSingleton<ITelemetryClient, TelemetryClient>();\nservices.AddTransient<CustomMetricsSink>();\nservices.AddTransient<CustomPipelineMetricsSink>();\n\nvar serviceProvider = services.BuildServiceProvider();\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Custom sink implementations:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public sealed class CustomMetricsSink : IMetricsSink\n{\n    private readonly ITelemetryClient _telemetryClient;\n\n    public CustomMetricsSink(ITelemetryClient telemetryClient)\n    {\n        _telemetryClient = telemetryClient;\n    }\n\n    public Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        // Emit metrics to your monitoring system\n        var properties = new Dictionary<string, string>\n        {\n            ["NodeId"] = nodeMetrics.NodeId,\n            ["Success"] = nodeMetrics.Success.ToString()\n        };\n\n        var metrics = new Dictionary<string, double>\n        {\n            ["DurationMs"] = nodeMetrics.DurationMs ?? 0,\n            ["ItemsProcessed"] = nodeMetrics.ItemsProcessed,\n            ["Throughput"] = nodeMetrics.ThroughputItemsPerSec ?? 0\n        };\n\n        _telemetryClient.TrackEvent("NodeCompleted", properties, metrics);\n        return Task.CompletedTask;\n    }\n}\n\npublic sealed class CustomPipelineMetricsSink : IPipelineMetricsSink\n{\n    private readonly ITelemetryClient _telemetryClient;\n\n    public CustomPipelineMetricsSink(ITelemetryClient telemetryClient)\n    {\n        _telemetryClient = telemetryClient;\n    }\n\n    public Task RecordAsync(IPipelineMetrics pipelineMetrics, CancellationToken cancellationToken)\n    {\n        var properties = new Dictionary<string, string>\n        {\n            ["PipelineName"] = pipelineMetrics.PipelineName,\n            ["RunId"] = pipelineMetrics.RunId.ToString(),\n            ["Success"] = pipelineMetrics.Success.ToString()\n        };\n\n        var metrics = new Dictionary<string, double>\n        {\n            ["DurationMs"] = pipelineMetrics.DurationMs ?? 0,\n            ["TotalItemsProcessed"] = pipelineMetrics.TotalItemsProcessed\n        };\n\n        _telemetryClient.TrackEvent("PipelineCompleted", properties, metrics);\n        return Task.CompletedTask;\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use when:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You need to integrate with Application Insights, Prometheus, OpenTelemetry, or other monitoring systems"}),"\n",(0,s.jsx)(n.li,{children:"You want to transform or enrich metrics before emission"}),"\n",(0,s.jsx)(n.li,{children:"You need to send metrics to multiple destinations"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-factory-delegate-registration",children:"3. Factory Delegate Registration"}),"\n",(0,s.jsx)(n.p,{children:"Use factory delegates for complex initialization scenarios:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using Microsoft.Extensions.DependencyInjection;\nusing NPipeline.Observability.DependencyInjection;\nusing NPipeline.Observability.Metrics;\n\nvar services = new ServiceCollection();\n\n// Register with factory delegates\nservices.AddNPipelineObservability(\n    metricsSinkFactory: serviceProvider =>\n    {\n        var logger = serviceProvider.GetRequiredService<ILogger<CustomMetricsSink>>();\n        var config = serviceProvider.GetRequiredService<IConfiguration>();\n        var endpoint = config["Metrics:Endpoint"];\n        return new CustomMetricsSink(logger, endpoint);\n    },\n    pipelineMetricsSinkFactory: serviceProvider =>\n    {\n        var logger = serviceProvider.GetRequiredService<ILogger<CustomPipelineMetricsSink>>();\n        var config = serviceProvider.GetRequiredService<IConfiguration>();\n        var endpoint = config["Metrics:PipelineEndpoint"];\n        return new CustomPipelineMetricsSink(logger, endpoint);\n    }\n);\n\nvar serviceProvider = services.BuildServiceProvider();\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use when:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Your sinks require complex initialization logic"}),"\n",(0,s.jsx)(n.li,{children:"You need to resolve multiple dependencies from the service provider"}),"\n",(0,s.jsx)(n.li,{children:"You want to conditionally create sinks based on configuration"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"4-custom-collector-implementation",children:"4. Custom Collector Implementation"}),"\n",(0,s.jsx)(n.p,{children:"For specialized metrics collection scenarios, provide your own collector:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using Microsoft.Extensions.DependencyInjection;\nusing NPipeline.Observability.DependencyInjection;\nusing NPipeline.Observability.Metrics;\n\n// Custom collector implementation\npublic sealed class CustomObservabilityCollector : IObservabilityCollector\n{\n    private readonly ObservabilityCollector _baseCollector;\n    private readonly ILogger _logger;\n\n    public CustomObservabilityCollector(ILogger<CustomObservabilityCollector> logger)\n    {\n        _baseCollector = new ObservabilityCollector();\n        _logger = logger;\n    }\n\n    public void RecordNodeStart(string nodeId, DateTimeOffset timestamp, int? threadId = null, long? initialMemoryMb = null)\n    {\n        _logger.LogInformation("Node {NodeId} started at {Timestamp}", nodeId, timestamp);\n        _baseCollector.RecordNodeStart(nodeId, timestamp, threadId, initialMemoryMb);\n    }\n\n    public void RecordNodeEnd(string nodeId, DateTimeOffset timestamp, bool success, Exception? exception = null, \n        long? peakMemoryMb = null, long? processorTimeMs = null)\n    {\n        _baseCollector.RecordNodeEnd(nodeId, timestamp, success, exception, peakMemoryMb, processorTimeMs);\n        \n        if (!success)\n        {\n            _logger.LogError(exception, "Node {NodeId} failed", nodeId);\n        }\n    }\n\n    public void RecordItemMetrics(string nodeId, long itemsProcessed, long itemsEmitted)\n    {\n        _baseCollector.RecordItemMetrics(nodeId, itemsProcessed, itemsEmitted);\n    }\n\n    public void RecordRetry(string nodeId, int retryCount, string? reason = null)\n    {\n        _logger.LogWarning("Node {NodeId} retry attempt {RetryCount}. Reason: {Reason}", nodeId, retryCount, reason);\n        _baseCollector.RecordRetry(nodeId, retryCount, reason);\n    }\n\n    public void RecordPerformanceMetrics(string nodeId, double throughputItemsPerSec, double averageItemProcessingMs)\n    {\n        _baseCollector.RecordPerformanceMetrics(nodeId, throughputItemsPerSec, averageItemProcessingMs);\n    }\n\n    public IReadOnlyList<INodeMetrics> GetNodeMetrics()\n    {\n        return _baseCollector.GetNodeMetrics();\n    }\n\n    public INodeMetrics? GetNodeMetrics(string nodeId)\n    {\n        return _baseCollector.GetNodeMetrics(nodeId);\n    }\n\n    public IPipelineMetrics CreatePipelineMetrics(string pipelineName, Guid runId, DateTimeOffset startTime, \n        DateTimeOffset? endTime, bool success, Exception? exception = null)\n    {\n        return _baseCollector.CreatePipelineMetrics(pipelineName, runId, startTime, endTime, success, exception);\n    }\n}\n\n// Registration\nvar services = new ServiceCollection();\n\nservices.AddNPipelineObservability<CustomObservabilityCollector, LoggingMetricsSink, LoggingPipelineMetricsSink>();\n\nvar serviceProvider = services.BuildServiceProvider();\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use when:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You need to add custom logging or side effects during metrics collection"}),"\n",(0,s.jsx)(n.li,{children:"You want to transform or filter metrics before they're stored"}),"\n",(0,s.jsx)(n.li,{children:"You need to integrate with custom observability infrastructure"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"5-custom-collector-with-factory-delegate",children:"5. Custom Collector with Factory Delegate"}),"\n",(0,s.jsx)(n.p,{children:"Combine custom collector with factory delegate initialization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'services.AddNPipelineObservability<LoggingMetricsSink, LoggingPipelineMetricsSink>(\n    collectorFactory: serviceProvider =>\n    {\n        var logger = serviceProvider.GetRequiredService<ILogger<CustomObservabilityCollector>>();\n        var config = serviceProvider.GetRequiredService<IConfiguration>();\n        var enableDetailedMetrics = config.GetValue<bool>("Observability:DetailedMetrics");\n        return new CustomObservabilityCollector(logger, enableDetailedMetrics);\n    }\n);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"service-lifetimes",children:"Service Lifetimes"}),"\n",(0,s.jsx)(n.p,{children:"Understanding service lifetimes is crucial for proper configuration:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Service"}),(0,s.jsx)(n.th,{children:"Default Lifetime"}),(0,s.jsx)(n.th,{children:"Rationale"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"IObservabilityCollector"})}),(0,s.jsx)(n.td,{children:"Scoped"}),(0,s.jsx)(n.td,{children:"One instance per pipeline run for isolation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"IMetricsSink"})}),(0,s.jsx)(n.td,{children:"Scoped"}),(0,s.jsx)(n.td,{children:"New instance per pipeline run to avoid state sharing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"IPipelineMetricsSink"})}),(0,s.jsx)(n.td,{children:"Scoped"}),(0,s.jsx)(n.td,{children:"New instance per pipeline run to avoid state sharing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"IObservabilityFactory"})}),(0,s.jsx)(n.td,{children:"Scoped"}),(0,s.jsx)(n.td,{children:"Resolves scoped collector instances"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"why-scoped-collector",children:"Why Scoped Collector?"}),"\n",(0,s.jsx)(n.p,{children:"The collector is scoped to ensure:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Isolation"}),": Each pipeline run gets its own metrics, preventing cross-contamination"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory management"}),": Metrics are automatically disposed when the scope ends"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Thread safety"}),": Concurrent pipeline runs don't interfere with each other"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"why-scoped-sinks",children:"Why Scoped Sinks?"}),"\n",(0,s.jsx)(n.p,{children:"Sinks are scoped because:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stateless operation"}),": Most sinks don't maintain state between uses"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dependency resolution"}),": Allows sinks to receive scoped dependencies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flexibility"}),": Enables different sink instances for different pipeline runs"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,s.jsx)(n.h3,{id:"observabilityextensionoptions",children:"ObservabilityExtensionOptions"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"../../src/NPipeline.Extensions.Observability/DependencyInjection/ObservabilityExtensionOptions.cs:10",children:(0,s.jsx)(n.code,{children:"ObservabilityExtensionOptions"})})," class controls global behavior of the observability extension:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public sealed record ObservabilityExtensionOptions\n{\n    /// Whether to automatically collect memory metrics (peak memory usage) for each node\n    bool EnableMemoryMetrics { get; init; }\n\n    /// Default observability extension options with memory metrics disabled\n    public static ObservabilityExtensionOptions Default => new() { EnableMemoryMetrics = false };\n\n    /// Observability extension options with memory metrics enabled\n    public static ObservabilityExtensionOptions WithMemoryMetrics => new() { EnableMemoryMetrics = true };\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Default"}),": ",(0,s.jsx)(n.code,{children:"EnableMemoryMetrics = false"})," (memory metrics disabled by default)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important"}),": Memory metrics require BOTH:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Extension-level configuration: ",(0,s.jsx)(n.code,{children:"services.AddNPipelineObservability(ObservabilityExtensionOptions.WithMemoryMetrics)"})]}),"\n",(0,s.jsxs)(n.li,{children:["Node-level configuration: ",(0,s.jsx)(n.code,{children:".WithObservability(builder, ObservabilityOptions.Full)"})," or set ",(0,s.jsx)(n.code,{children:"RecordMemoryUsage = true"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If either level is disabled, memory metrics will not be collected."}),"\n",(0,s.jsx)(n.h3,{id:"default-configuration-logging-sinks",children:"Default Configuration (Logging Sinks)"}),"\n",(0,s.jsx)(n.h3,{id:"conditional-registration",children:"Conditional Registration"}),"\n",(0,s.jsx)(n.p,{children:"Enable observability based on configuration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'var services = new ServiceCollection();\nvar configuration = new ConfigurationBuilder()\n    .AddJsonFile("appsettings.json")\n    .Build();\n\nvar enableObservability = configuration.GetValue<bool>("Observability:Enabled", true);\n\nif (enableObservability)\n{\n    services.AddNPipelineObservability();\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"multiple-sinks",children:"Multiple Sinks"}),"\n",(0,s.jsx)(n.p,{children:"Send metrics to multiple destinations by implementing composite sinks:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public sealed class CompositeMetricsSink : IMetricsSink\n{\n    private readonly IEnumerable<IMetricsSink> _sinks;\n\n    public CompositeMetricsSink(IEnumerable<IMetricsSink> sinks)\n    {\n        _sinks = sinks;\n    }\n\n    public async Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        var tasks = _sinks.Select(sink => sink.RecordAsync(nodeMetrics, cancellationToken));\n        await Task.WhenAll(tasks);\n    }\n}\n\n// Register multiple sinks\nservices.AddSingleton<IMetricsSink, LoggingMetricsSink>();\nservices.AddSingleton<IMetricsSink, ApplicationInsightsSink>();\nservices.AddSingleton<IMetricsSink, PrometheusSink>();\n\n// Register composite sink\nservices.AddNPipelineObservability<CompositeMetricsSink, LoggingPipelineMetricsSink>();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"configuration-based-sink-selection",children:"Configuration-Based Sink Selection"}),"\n",(0,s.jsx)(n.p,{children:"Choose sinks based on configuration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'services.AddNPipelineObservability(\n    metricsSinkFactory: serviceProvider =>\n    {\n        var config = serviceProvider.GetRequiredService<IConfiguration>();\n        var sinkType = config["Observability:SinkType"];\n\n        return sinkType switch\n        {\n            "Logging" => new LoggingMetricsSink(),\n            "ApplicationInsights" => new ApplicationInsightsSink(/* ... */),\n            "Prometheus" => new PrometheusSink(/* ... */),\n            _ => throw new InvalidOperationException($"Unknown sink type: {sinkType}")\n        };\n    },\n    pipelineMetricsSinkFactory: serviceProvider =>\n    {\n        var config = serviceProvider.GetRequiredService<IConfiguration>();\n        var sinkType = config["Observability:PipelineSinkType"];\n\n        return sinkType switch\n        {\n            "Logging" => new LoggingPipelineMetricsSink(),\n            "ApplicationInsights" => new ApplicationInsightsPipelineSink(/* ... */),\n            _ => throw new InvalidOperationException($"Unknown sink type: {sinkType}")\n        };\n    }\n);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-existing-logging-infrastructure",children:"Integration with Existing Logging Infrastructure"}),"\n",(0,s.jsx)(n.p,{children:"The extension integrates seamlessly with Microsoft.Extensions.Logging:"}),"\n",(0,s.jsx)(n.h3,{id:"structured-logging-with-serilog",children:"Structured Logging with Serilog"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using Serilog;\n\nLog.Logger = new LoggerConfiguration()\n    .WriteTo.Console()\n    .WriteTo.File("logs/pipeline-.txt", rollingInterval: RollingInterval.Day)\n    .CreateLogger();\n\nvar services = new ServiceCollection();\nservices.AddLogging(loggingBuilder => loggingBuilder.AddSerilog());\n\nservices.AddNPipelineObservability();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"enriching-logs-with-context",children:"Enriching Logs with Context"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public sealed class EnrichedLoggingMetricsSink : IMetricsSink\n{\n    private readonly ILogger _logger;\n    private readonly IHttpContextAccessor _httpContextAccessor;\n\n    public EnrichedLoggingMetricsSink(\n        ILogger<EnrichedLoggingMetricsSink> logger,\n        IHttpContextAccessor httpContextAccessor)\n    {\n        _logger = logger;\n        _httpContextAccessor = httpContextAccessor;\n    }\n\n    public Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        var correlationId = _httpContextAccessor.HttpContext?.TraceIdentifier;\n        \n        using (_logger.BeginScope(new Dictionary<string, object?>\n        {\n            ["NodeId"] = nodeMetrics.NodeId,\n            ["Success"] = nodeMetrics.Success,\n            ["CorrelationId"] = correlationId\n        }))\n        {\n            _logger.LogInformation(\n                "Node {NodeId} completed. Processed {ItemsProcessed} items in {DurationMs}ms",\n                nodeMetrics.NodeId,\n                nodeMetrics.ItemsProcessed,\n                nodeMetrics.DurationMs);\n        }\n\n        return Task.CompletedTask;\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-use-appropriate-service-lifetimes",children:"1. Use Appropriate Service Lifetimes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Keep collectors scoped for pipeline isolation"}),"\n",(0,s.jsx)(n.li,{children:"Use transient sinks to avoid state sharing"}),"\n",(0,s.jsx)(n.li,{children:"Register singleton sinks only if they're truly stateless"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-handle-cancellation",children:"2. Handle Cancellation"}),"\n",(0,s.jsx)(n.p,{children:"Always respect cancellation tokens in async sink implementations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public async Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n{\n    try\n    {\n        await _telemetryClient.TrackEventAsync(\n            "NodeCompleted",\n            properties,\n            metrics,\n            cancellationToken);\n    }\n    catch (OperationCanceledException)\n    {\n        // Log cancellation and exit gracefully\n        _logger.LogWarning("Metrics recording cancelled");\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-implement-retry-logic-for-external-systems",children:"3. Implement Retry Logic for External Systems"}),"\n",(0,s.jsx)(n.p,{children:"When sending metrics to external systems, implement retry logic:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public sealed class ResilientMetricsSink : IMetricsSink\n{\n    private readonly ITelemetryClient _telemetryClient;\n    private readonly ILogger _logger;\n    private readonly AsyncRetryPolicy _retryPolicy;\n\n    public ResilientMetricsSink(ITelemetryClient telemetryClient, ILogger<ResilientMetricsSink> logger)\n    {\n        _telemetryClient = telemetryClient;\n        _logger = logger;\n        \n        _retryPolicy = Policy\n            .Handle<Exception>()\n            .WaitAndRetryAsync(\n                retryCount: 3,\n                sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),\n                onRetry: (exception, timeSpan, retryCount, context) =>\n                {\n                    _logger.LogWarning(\n                        exception,\n                        "Retry {RetryCount} after {Delay}s for metrics recording",\n                        retryCount,\n                        timeSpan.TotalSeconds);\n                });\n    }\n\n    public async Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        await _retryPolicy.ExecuteAsync(async () =>\n        {\n            await _telemetryClient.TrackEventAsync(\n                "NodeCompleted",\n                CreateProperties(nodeMetrics),\n                CreateMetrics(nodeMetrics),\n                cancellationToken);\n        });\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"4-filter-metrics-in-development",children:"4. Filter Metrics in Development"}),"\n",(0,s.jsx)(n.p,{children:"Reduce noise in development environments:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public sealed class DevelopmentMetricsSink : IMetricsSink\n{\n    private readonly IMetricsSink _innerSink;\n    private readonly bool _isDevelopment;\n\n    public DevelopmentMetricsSink(IMetricsSink innerSink, IHostEnvironment environment)\n    {\n        _innerSink = innerSink;\n        _isDevelopment = environment.IsDevelopment();\n    }\n\n    public async Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        if (_isDevelopment)\n        {\n            // Only log errors and warnings in development\n            if (!nodeMetrics.Success || nodeMetrics.RetryCount > 0)\n            {\n                await _innerSink.RecordAsync(nodeMetrics, cancellationToken);\n            }\n        }\n        else\n        {\n            // Log everything in production\n            await _innerSink.RecordAsync(nodeMetrics, cancellationToken);\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-aggregate-metrics-for-high-volume-scenarios",children:"5. Aggregate Metrics for High-Volume Scenarios"}),"\n",(0,s.jsx)(n.p,{children:"For high-throughput pipelines, aggregate metrics before emission:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public sealed class AggregatingMetricsSink : IMetricsSink\n{\n    private readonly ConcurrentDictionary<string, AggregatedMetrics> _aggregates = new();\n    private readonly Timer _flushTimer;\n    private readonly IMetricsSink _innerSink;\n\n    public AggregatingMetricsSink(IMetricsSink innerSink)\n    {\n        _innerSink = innerSink;\n        _flushTimer = new Timer(FlushAggregates, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));\n    }\n\n    public Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        var aggregate = _aggregates.GetOrAdd(nodeMetrics.NodeId, _ => new AggregatedMetrics());\n        aggregate.Add(nodeMetrics);\n        return Task.CompletedTask;\n    }\n\n    private async void FlushAggregates(object? state)\n    {\n        foreach (var kvp in _aggregates)\n        {\n            var aggregatedMetrics = kvp.Value.Build();\n            await _innerSink.RecordAsync(aggregatedMetrics, CancellationToken.None);\n            _aggregates.TryRemove(kvp.Key, out _);\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(n.h3,{id:"metrics-not-appearing",children:"Metrics Not Appearing"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": Metrics are not being logged or sent to external systems."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Verify observability is registered: ",(0,s.jsx)(n.code,{children:"services.AddNPipelineObservability()"})]}),"\n",(0,s.jsxs)(n.li,{children:["Check that the pipeline is using DI: ",(0,s.jsx)(n.code,{children:"await serviceProvider.RunPipelineAsync<T>()"})]}),"\n",(0,s.jsx)(n.li,{children:"Ensure logging is configured properly"}),"\n",(0,s.jsx)(n.li,{children:"Verify sink implementations are not throwing exceptions"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"memory-leaks",children:"Memory Leaks"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": Memory usage increases over time with long-running pipelines."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Ensure collectors are scoped, not singleton"}),"\n",(0,s.jsx)(n.li,{children:"Verify sinks are transient and don't retain references"}),"\n",(0,s.jsx)(n.li,{children:"Check for circular dependencies in sink implementations"}),"\n",(0,s.jsx)(n.li,{children:"Review custom collector implementations for proper disposal"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"performance-degradation",children:"Performance Degradation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": Pipeline execution slows down when observability is enabled."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Use async sink implementations"}),"\n",(0,s.jsx)(n.li,{children:"Implement batching or aggregation for external calls"}),"\n",(0,s.jsx)(n.li,{children:"Consider disabling expensive metrics (memory, processor time) in production"}),"\n",(0,s.jsx)(n.li,{children:"Use sampling for high-volume scenarios"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"architecture-and-design",children:"Architecture and Design"}),"\n",(0,s.jsx)(n.h3,{id:"system-architecture",children:"System Architecture"}),"\n",(0,s.jsx)(n.p,{children:"The extension follows a layered architecture for separation of concerns:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"Pipeline Execution\n        \u2193\nIExecutionObserver\n        \u2193\nMetricsCollectingExecutionObserver\n        \u2193\nIObservabilityCollector (Thread-safe)\n        \u251c\u2192 Node Metrics\n        \u2514\u2192 Pipeline Metrics\n        \u2193\nIMetricsSink / IPipelineMetricsSink\n        \u251c\u2192 LoggingMetricsSink\n        \u251c\u2192 Custom Sinks\n        \u2514\u2192 Composite Sinks\n"})}),"\n",(0,s.jsx)(n.h3,{id:"key-components",children:"Key Components"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"MetricsCollectingExecutionObserver"})}),": Hooks into pipeline execution lifecycle to capture node start/end events and delegate to the collector"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"IObservabilityCollector"})}),": Thread-safe collector that aggregates metrics from all nodes and provides query interfaces"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"IMetricsSink"})," / ",(0,s.jsx)(n.code,{children:"IPipelineMetricsSink"})]}),": Abstractions for emitting metrics to various destinations (logging, monitoring systems, etc.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"IObservabilityFactory"})}),": DI-aware factory for resolving and configuring observability components"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"thread-safety-guarantees",children:"Thread-Safety Guarantees"}),"\n",(0,s.jsx)(n.p,{children:"The extension provides strong thread-safety guarantees for production environments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Concurrent metrics collection"}),": Multiple nodes can record metrics simultaneously without race conditions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Atomic counter updates"}),": Item counts use ",(0,s.jsx)(n.code,{children:"Interlocked.Add"})," for thread-safe increments"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Immutable metric records"}),": Once built, metric records are immutable and safe to share across threads"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scoped isolation"}),": Each pipeline run gets its own collector instance, preventing cross-contamination between runs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ConcurrentDictionary"}),": Internal metrics storage uses ",(0,s.jsx)(n.code,{children:"ConcurrentDictionary"})," for lock-free operations"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,s.jsx)(n.h3,{id:"minimal-overhead",children:"Minimal Overhead"}),"\n",(0,s.jsx)(n.p,{children:"The extension is designed for production use with minimal performance impact:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Non-blocking metrics collection"}),": Metrics are recorded asynchronously without blocking pipeline execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient data structures"}),": Uses optimized collections (ConcurrentDictionary) for metrics aggregation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optional observability"}),": Can be disabled entirely by not registering the services"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scoped lifetime"}),": Metrics are isolated per pipeline run, preventing memory leaks"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Per-pipeline overhead"}),": Approximately 1-2 KB per node for metrics storage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transient sinks"}),": Metrics sinks are created per pipeline run and disposed after use"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No persistent storage"}),": Metrics are not retained in memory beyond the pipeline execution scope"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"cpu-impact",children:"CPU Impact"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lightweight timing"}),": Uses high-resolution ",(0,s.jsx)(n.code,{children:"Stopwatch"})," timers with minimal CPU overhead"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optional performance counters"}),": Memory and processor time collection can be disabled if not needed via ",(0,s.jsx)(n.code,{children:"ObservabilityOptions.Minimal"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Batch-friendly"}),": Metrics collection scales efficiently with large batch sizes and doesn't degrade with parallelism"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/extensions/observability/",children:"Getting Started"})}),": Quick start and basic usage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/extensions/observability/metrics",children:"Metrics Reference"})}),": Detailed metrics documentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/extensions/observability/examples",children:"Usage Examples"})}),": Complete code examples"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/extensions/observability/advanced-patterns",children:"Advanced Patterns"})}),": Advanced scenarios and custom implementations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/extensions/observability/tracing",children:"Distributed Tracing"})}),": Core tracing abstraction"]}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var r=i(96540);const s={},t=r.createContext(s);function o(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);