"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[8283],{28453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>o});var t=i(96540);const r={},s=t.createContext(r);function c(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),t.createElement(s.Provider,{value:n},e.children)}},48994:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>p,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"analyzers/best-practices","title":"Best Practice Analyzers","description":"Validate dependency injection, resource management, and framework contract compliance.","source":"@site/docs/analyzers/best-practices.md","sourceDirName":"analyzers","slug":"/analyzers/best-practices","permalink":"/docs/analyzers/best-practices","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Best Practice Analyzers","description":"Validate dependency injection, resource management, and framework contract compliance.","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Data Processing Analyzers","permalink":"/docs/analyzers/data-processing"},"next":{"title":"Configuration Analyzers","permalink":"/docs/analyzers/configuration"}}');var r=i(74848),s=i(28453);const c={title:"Best Practice Analyzers",description:"Validate dependency injection, resource management, and framework contract compliance.",sidebar_position:5},o=void 0,a={},l=[{value:"Best Practice Analyzers",id:"best-practice-analyzers",level:2},{value:"NP9303: Unsafe PipelineContext Access",id:"np9303-unsafe-pipelinecontext-access",level:3},{value:"Problematic Patterns",id:"problematic-patterns",level:4},{value:"Solution: Use Safe Access Patterns",id:"solution-use-safe-access-patterns",level:4},{value:"Safe Access Patterns Reference",id:"safe-access-patterns-reference",level:4},{value:"Why Safe Access Matters",id:"why-safe-access-matters",level:4},{value:"NP9401: Missing Dependency Injection for Services",id:"np9401-missing-dependency-injection-for-services",level:3},{value:"The Problem",id:"the-problem",level:4},{value:"Solution: Use Constructor Injection",id:"solution-use-constructor-injection",level:4},{value:"Best Practices",id:"best-practices",level:4},{value:"Configuration",id:"configuration",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"best-practice-analyzers",children:"Best Practice Analyzers"}),"\n",(0,r.jsx)(n.p,{children:"Best practice analyzers enforce architectural patterns that ensure your code is testable, maintainable, and follows the framework's design principles."}),"\n",(0,r.jsx)(n.h3,{id:"np9303-unsafe-pipelinecontext-access",children:"NP9303: Unsafe PipelineContext Access"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ID:"})," ",(0,r.jsx)(n.code,{children:"NP9303"}),"\n",(0,r.jsx)(n.strong,{children:"Severity:"})," Warning",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Category:"})," Best Practice"]}),"\n",(0,r.jsx)(n.p,{children:"This analyzer detects unsafe access patterns to nullable properties on PipelineContext. Accessing potentially null properties without null-safety checks can cause null reference exceptions at runtime."}),"\n",(0,r.jsx)(n.h4,{id:"problematic-patterns",children:"Problematic Patterns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// PROBLEM: Direct access to potentially null property\npublic async Task HandleErrorAsync(PipelineContext context, Exception error)\n{\n    // NP9303: PipelineErrorHandler might be null\n    await context.PipelineErrorHandler.HandleNodeFailureAsync(\n        "nodeId", error, context, cancellationToken);\n}\n\n// PROBLEM: Direct dictionary access without existence check\npublic string GetParameter(PipelineContext context, string key)\n{\n    // NP9303: Dictionary might not contain key, and Parameters might be null\n    return context.Parameters[key].ToString();\n}\n\n// PROBLEM: Unsafe cast\npublic void ProcessConfig(PipelineContext context)\n{\n    // NP9303: Configuration might be null or wrong type\n    var config = (MyConfig)context.Configuration;\n    ProcessConfig(config);\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"solution-use-safe-access-patterns",children:"Solution: Use Safe Access Patterns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// CORRECT: Use null-conditional operator\npublic async Task HandleErrorAsync(PipelineContext context, Exception error, CancellationToken cancellationToken)\n{\n    // Safe access - operation only occurs if PipelineErrorHandler is not null\n    await context.PipelineErrorHandler?.HandleNodeFailureAsync(\n        "nodeId", error, context, cancellationToken);\n}\n\n// CORRECT: Explicit null check with comment\npublic async Task HandleErrorAsync(PipelineContext context, Exception error, CancellationToken cancellationToken)\n{\n    if (context.PipelineErrorHandler == null)\n    {\n        throw new InvalidOperationException("PipelineErrorHandler must be configured for this operation");\n    }\n    \n    await context.PipelineErrorHandler.HandleNodeFailureAsync(\n        "nodeId", error, context, cancellationToken);\n}\n\n// CORRECT: Use TryGetValue pattern for dictionary access\npublic bool TryGetParameter(PipelineContext context, string key, out object value)\n{\n    value = null;\n    return context.Parameters?.TryGetValue(key, out value) == true;\n}\n\n// CORRECT: Use pattern matching for type-safe access\npublic void ProcessConfig(PipelineContext context)\n{\n    if (context.Configuration is MyConfig config)\n    {\n        ProcessConfig(config);\n    }\n}\n\n// CORRECT: Use pattern matching with property access\npublic string GetValue(PipelineContext context)\n{\n    if (context.PipelineErrorHandler is { } handler)\n    {\n        return handler.GetType().Name;\n    }\n    \n    return "No error handler configured";\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"safe-access-patterns-reference",children:"Safe Access Patterns Reference"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Pattern"}),(0,r.jsx)(n.th,{children:"Example"}),(0,r.jsx)(n.th,{children:"When to Use"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Null-conditional operator"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"context.Property?.Method()"})}),(0,r.jsx)(n.td,{children:"When you can safely continue if the property is null"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Explicit null check"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"if (context.Property != null)"})}),(0,r.jsx)(n.td,{children:"When you need to handle the null case explicitly"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"TryGetValue pattern"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:'context.Parameters?.TryGetValue("key", out var value)'})}),(0,r.jsx)(n.td,{children:"For dictionary access with null safety"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Pattern matching"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"if (context.Property is { } value)"})}),(0,r.jsx)(n.td,{children:"For type-safe access with null checking"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Combined null and key check"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:'context.Parameters?.ContainsKey("key") == true'})}),(0,r.jsx)(n.td,{children:"When you need to verify both container and key existence"})]})]})]}),"\n",(0,r.jsx)(n.h4,{id:"why-safe-access-matters",children:"Why Safe Access Matters"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime Safety"}),": Prevents null reference exceptions from reaching production"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Graceful Degradation"}),": Code continues functioning with missing optional properties"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Explicit Intent"}),": Null checks make it clear which properties are optional"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Testability"}),": Easier to test code that handles null cases explicitly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Maintainability"}),": Future developers understand property optionality"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"np9401-missing-dependency-injection-for-services",children:"NP9401: Missing Dependency Injection for Services"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ID:"})," ",(0,r.jsx)(n.code,{children:"NP9401"}),"\n",(0,r.jsx)(n.strong,{children:"Severity:"})," Warning",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Category:"})," Best Practice"]}),"\n",(0,r.jsx)(n.p,{children:"This analyzer detects dependency injection anti-patterns in node implementations that can lead to tightly coupled code that is difficult to test and maintain. The analyzer identifies the following problematic patterns:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Direct service instantiation"})," using the ",(0,r.jsx)(n.code,{children:"new"})," keyword"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Static singleton field assignments"})," that create tightly coupled dependencies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service locator pattern usage"})," through GetService or GetRequiredService calls"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"the-problem",children:"The Problem"}),"\n",(0,r.jsx)(n.p,{children:"When node implementations directly instantiate their dependencies or use service locator patterns, they create tight coupling that makes the code difficult to test, maintain, and configure. This violates the Dependency Inversion Principle and makes it challenging to swap implementations or mock dependencies for testing."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// PROBLEM: Direct service instantiation\npublic class BadTransformNode : TransformNode<string, string>\n{\n    private readonly BadService _badService = new BadService(); // NP9401: Direct instantiation\n\n    public override Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        return Task.FromResult(_badService.Process(item));\n    }\n}\n\n// PROBLEM: Static singleton assignment\npublic class BadSourceNode : SourceNode<int>\n{\n    private static BadService _service; // Static field\n\n    public BadSourceNode()\n    {\n        _service = new BadService(); // NP9401: Static singleton assignment\n    }\n}\n\n// PROBLEM: Service locator pattern\npublic class BadSinkNode : SinkNode<string>\n{\n    private readonly IServiceProvider _serviceProvider;\n\n    public BadSinkNode(IServiceProvider serviceProvider)\n    {\n        _serviceProvider = serviceProvider;\n    }\n\n    public override async Task ExecuteAsync(IDataPipe<string> input, PipelineContext context, CancellationToken cancellationToken)\n    {\n        var badService = _serviceProvider.GetService(typeof(BadService)) as BadService; // NP9401: Service locator\n        await foreach (var item in input.WithCancellation(cancellationToken))\n        {\n            // Process item\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"solution-use-constructor-injection",children:"Solution: Use Constructor Injection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// CORRECT: Constructor injection\npublic class GoodTransformNode : TransformNode<string, string>\n{\n    private readonly BadService _badService;\n\n    public GoodTransformNode(BadService badService) // Constructor injection\n    {\n        _badService = badService;\n    }\n\n    public override Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        return Task.FromResult(_badService.Process(item));\n    }\n}\n\n// CORRECT: Multiple dependencies via constructor\npublic class GoodSinkNode : SinkNode<string>\n{\n    private readonly IEmailService _emailService;\n    private readonly ILoggingService _loggingService;\n    private readonly IDataRepository _repository;\n\n    public GoodSinkNode(\n        IEmailService emailService,\n        ILoggingService loggingService,\n        IDataRepository repository) // Multiple dependencies\n    {\n        _emailService = emailService;\n        _loggingService = loggingService;\n        _repository = repository;\n    }\n\n    public override async Task ExecuteAsync(IDataPipe<string> input, PipelineContext context, CancellationToken cancellationToken)\n    {\n        await foreach (var item in input.WithCancellation(cancellationToken))\n        {\n            var processed = await _repository.SaveAsync(item);\n            await _emailService.SendNotificationAsync(processed);\n            _loggingService.Log(processed);\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Always use constructor injection"})," for services in node implementations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Depend on abstractions"})," (interfaces) rather than concrete implementations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Keep constructors focused"})," on dependency injection, not business logic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use factories"})," for complex dependency creation scenarios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Make dependencies explicit"})," - avoid optional dependencies when possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Register dependencies"})," in your DI container at application startup"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["Adjust analyzer severity in ",(0,r.jsx)(n.code,{children:".editorconfig"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ini",children:"# Treat unsafe context access as errors\ndotnet_diagnostic.NP9303.severity = error\n\n# Treat DI anti-patterns as errors\ndotnet_diagnostic.NP9401.severity = error\n"})}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../../extensions/dependency-injection",children:"Dependency Injection Guide"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../../extensions/testing/advanced-testing",children:"Testing Pipelines"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../../architecture/design-principles",children:"SOLID Principles"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);