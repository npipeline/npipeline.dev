"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[2589],{28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>c});var t=r(96540);const o={},i=t.createContext(o);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(i.Provider,{value:n},e.children)}},31078:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"extensions/nodes/conversion","title":"Type Conversion Nodes","description":"Convert between types safely with comprehensive error handling.","source":"@site/docs/extensions/nodes/conversion.md","sourceDirName":"extensions/nodes","slug":"/extensions/nodes/conversion","permalink":"/docs/extensions/nodes/conversion","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Type Conversion Nodes","description":"Convert between types safely with comprehensive error handling.","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Filtering Nodes","permalink":"/docs/extensions/nodes/filtering"},"next":{"title":"Data Enrichment","permalink":"/docs/extensions/nodes/enrichment"}}');var o=r(74848),i=r(28453);const s={title:"Type Conversion Nodes",description:"Convert between types safely with comprehensive error handling.",sidebar_position:4},c="Type Conversion Nodes",a={},d=[{value:"String to Numeric Conversion",id:"string-to-numeric-conversion",level:2},{value:"String to DateTime Conversion",id:"string-to-datetime-conversion",level:2},{value:"String to Boolean Conversion",id:"string-to-boolean-conversion",level:2},{value:"String to Enum Conversion",id:"string-to-enum-conversion",level:2},{value:"Numeric to String Conversion",id:"numeric-to-string-conversion",level:2},{value:"DateTime to String Conversion",id:"datetime-to-string-conversion",level:2},{value:"Boolean to String Conversion",id:"boolean-to-string-conversion",level:2},{value:"Enum to String Conversion",id:"enum-to-string-conversion",level:2},{value:"Custom Converters",id:"custom-converters",level:2},{value:"Culture-Aware Conversions",id:"culture-aware-conversions",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Pipeline Integration",id:"pipeline-integration",level:2},{value:"Complete Example: Data Import with Validation",id:"complete-example-data-import-with-validation",level:2},{value:"Supported Conversions",id:"supported-conversions",level:2},{value:"Edge Cases",id:"edge-cases",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Testing Type Conversions",id:"testing-type-conversions",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"type-conversion-nodes",children:"Type Conversion Nodes"})}),"\n",(0,o.jsxs)(n.p,{children:["Type conversion nodes transform items from one type to another. When conversion fails, a ",(0,o.jsx)(n.code,{children:"TypeConversionException"})," is raised with details about the source type, target type, and the value that failed to convert."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"TypeConversionNode<TIn, TOut>"})," provides factory methods for common conversions and supports custom converters via ",(0,o.jsx)(n.code,{children:"WithConverter()"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"string-to-numeric-conversion",children:"String to Numeric Conversion"}),"\n",(0,o.jsx)(n.p,{children:"Convert string representations to numeric types:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// String to Integer\nvar stringToIntNode = TypeConversionNode<string, int>.StringToInt();\nvar result = await stringToIntNode.ExecuteAsync("42", context, cancellationToken);\n// result = 42\n\n// String to Double\nvar stringToDoubleNode = TypeConversionNode<string, double>.StringToDouble();\nvar result = await stringToDoubleNode.ExecuteAsync("42.5", context, cancellationToken);\n// result = 42.5\n\n// String to Decimal\nvar stringToDecimalNode = TypeConversionNode<string, decimal>.StringToDecimal();\nvar result = await stringToDecimalNode.ExecuteAsync("42.50", context, cancellationToken);\n// result = 42.50m\n\n// String to Long\nvar stringToLongNode = TypeConversionNode<string, long>.StringToLong();\nvar result = await stringToLongNode.ExecuteAsync("9223372036854775807", context, cancellationToken);\n// result = 9223372036854775807L\n'})}),"\n",(0,o.jsx)(n.h2,{id:"string-to-datetime-conversion",children:"String to DateTime Conversion"}),"\n",(0,o.jsx)(n.p,{children:"Parse strings to dates:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Parse with default format\nvar node = TypeConversionNode<string, DateTime>.StringToDateTime();\nvar result = await node.ExecuteAsync("2025-01-15 14:30:00", context, cancellationToken);\n// result = DateTime(2025, 1, 15, 14, 30, 0)\n\n// Parse with specific format\nvar node = TypeConversionNode<string, DateTime>.StringToDateTime(\n    format: "yyyy-MM-dd",\n    formatProvider: CultureInfo.InvariantCulture);\nvar result = await node.ExecuteAsync("2025-01-15", context, cancellationToken);\n// result = DateTime(2025, 1, 15)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"string-to-boolean-conversion",children:"String to Boolean Conversion"}),"\n",(0,o.jsx)(n.p,{children:"Convert strings to boolean values with multiple formats supported:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'var node = TypeConversionNode<string, bool>.StringToBool();\n\n// Supported true values: "true", "1", "yes", "on"\nvar result = await node.ExecuteAsync("true", context, cancellationToken);\n// result = true\n\n// Supported false values: "false", "0", "no", "off"\nvar result = await node.ExecuteAsync("no", context, cancellationToken);\n// result = false\n\n// Case-insensitive\nvar result = await node.ExecuteAsync("YES", context, cancellationToken);\n// result = true\n'})}),"\n",(0,o.jsx)(n.h2,{id:"string-to-enum-conversion",children:"String to Enum Conversion"}),"\n",(0,o.jsx)(n.p,{children:"Convert strings to enum values:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public enum OrderStatus { Pending, Shipped, Delivered }\n\n// Case-insensitive (default)\nvar node = TypeConversionNode<string, OrderStatus>.StringToEnum<OrderStatus>();\nvar result = await node.ExecuteAsync("pending", context, cancellationToken);\n// result = OrderStatus.Pending\n\n// Case-sensitive\nvar node = TypeConversionNode<string, OrderStatus>.StringToEnum<OrderStatus>(ignoreCase: false);\nvar result = await node.ExecuteAsync("Pending", context, cancellationToken);\n// result = OrderStatus.Pending\n\n// Invalid value throws TypeConversionException\nvar result = await node.ExecuteAsync("invalid", context, cancellationToken);\n// throws TypeConversionException\n'})}),"\n",(0,o.jsx)(n.h2,{id:"numeric-to-string-conversion",children:"Numeric to String Conversion"}),"\n",(0,o.jsx)(n.p,{children:"Format numeric values as strings:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Integer to String\nvar node = TypeConversionNode<int, string>.IntToString();\nvar result = await node.ExecuteAsync(42, context, cancellationToken);\n// result = "42"\n\n// With format specifier\nvar node = TypeConversionNode<int, string>.IntToString("D5");\nvar result = await node.ExecuteAsync(42, context, cancellationToken);\n// result = "00042"\n\n// Double to String\nvar node = TypeConversionNode<double, string>.DoubleToString("F2");\nvar result = await node.ExecuteAsync(42.567, context, cancellationToken);\n// result = "42.57"\n\n// Decimal to String\nvar node = TypeConversionNode<decimal, string>.DecimalToString("C");\nvar result = await node.ExecuteAsync(42.50m, context, cancellationToken);\n// result = "$42.50" (culture-dependent)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"datetime-to-string-conversion",children:"DateTime to String Conversion"}),"\n",(0,o.jsx)(n.p,{children:"Format dates as strings:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'var dateTime = new DateTime(2025, 1, 15, 14, 30, 0);\n\n// Default format\nvar node = TypeConversionNode<DateTime, string>.DateTimeToString();\nvar result = await node.ExecuteAsync(dateTime, context, cancellationToken);\n// result = "1/15/2025 2:30:00 PM" (culture-dependent)\n\n// Specific format\nvar node = TypeConversionNode<DateTime, string>.DateTimeToString("yyyy-MM-dd HH:mm:ss");\nvar result = await node.ExecuteAsync(dateTime, context, cancellationToken);\n// result = "2025-01-15 14:30:00"\n'})}),"\n",(0,o.jsx)(n.h2,{id:"boolean-to-string-conversion",children:"Boolean to String Conversion"}),"\n",(0,o.jsx)(n.p,{children:"Convert boolean values with custom representations:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Default representations\nvar node = TypeConversionNode<bool, string>.BoolToString();\nvar result = await node.ExecuteAsync(true, context, cancellationToken);\n// result = "true"\n\n// Custom representations\nvar node = TypeConversionNode<bool, string>.BoolToString("yes", "no");\nvar result = await node.ExecuteAsync(true, context, cancellationToken);\n// result = "yes"\n\n// Binary representation\nvar node = TypeConversionNode<bool, string>.BoolToString("1", "0");\nvar result = await node.ExecuteAsync(false, context, cancellationToken);\n// result = "0"\n'})}),"\n",(0,o.jsx)(n.h2,{id:"enum-to-string-conversion",children:"Enum to String Conversion"}),"\n",(0,o.jsx)(n.p,{children:"Convert enum values to their string representation:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public enum Color { Red, Green, Blue }\n\nvar node = TypeConversionNode<Color, string>.EnumToString<Color>();\nvar result = await node.ExecuteAsync(Color.Red, context, cancellationToken);\n// result = "Red"\n'})}),"\n",(0,o.jsx)(n.h2,{id:"custom-converters",children:"Custom Converters"}),"\n",(0,o.jsx)(n.p,{children:"Use custom conversion functions:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Simple custom converter\nvar node = new TypeConversionNode<string, int>()\n    .WithConverter(input => input.Length);\nvar result = await node.ExecuteAsync("hello", context, cancellationToken);\n// result = 5\n\n// Complex custom converter\nvar node = new TypeConversionNode<string, DateTime>()\n    .WithConverter(input =>\n    {\n        var parts = input.Split(\'/\');\n        if (parts.Length != 3)\n            throw new TypeConversionException(typeof(string), typeof(DateTime), input, "Invalid format");\n        \n        return new DateTime(\n            int.Parse(parts[2]),  // year\n            int.Parse(parts[0]),  // month\n            int.Parse(parts[1])); // day\n    });\nvar result = await node.ExecuteAsync("01/15/2025", context, cancellationToken);\n// result = DateTime(2025, 1, 15)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"culture-aware-conversions",children:"Culture-Aware Conversions"}),"\n",(0,o.jsx)(n.p,{children:"Use specific cultures for culture-sensitive conversions:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'var germanCulture = new CultureInfo("de-DE");\n\n// German uses comma as decimal separator\nvar node = TypeConversionNode<string, double>.StringToDouble(\n    NumberStyles.Float | NumberStyles.AllowThousands,\n    germanCulture);\nvar result = await node.ExecuteAsync("42,5", context, cancellationToken);\n// result = 42.5\n\n// Format output with culture\nvar node = TypeConversionNode<double, string>.DoubleToString("F2", germanCulture);\nvar result = await node.ExecuteAsync(42.567, context, cancellationToken);\n// result = "42,57" (German decimal separator)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,o.jsx)(n.p,{children:"Type conversion exceptions provide detailed error information:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'try\n{\n    var node = TypeConversionNode<string, int>.StringToInt();\n    var result = await node.ExecuteAsync("not a number", context, cancellationToken);\n}\ncatch (TypeConversionException ex)\n{\n    Console.WriteLine($"Source Type: {ex.SourceType.Name}");    // "String"\n    Console.WriteLine($"Target Type: {ex.TargetType.Name}");    // "Int32"\n    Console.WriteLine($"Value: {ex.Value}");                     // "not a number"\n    Console.WriteLine($"Message: {ex.Message}");                 // "Cannot convert \'not a number\' to int."\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"pipeline-integration",children:"Pipeline Integration"}),"\n",(0,o.jsx)(n.p,{children:"Add type conversion nodes to your pipeline:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"var builder = new PipelineBuilder();\n\n// Create a CSV import scenario\nvar pipeline = builder\n    .AddSource<CsvRow>(csvRows)\n    .AddStringCleansing<CsvRow>(name => name)\n        .Trim()\n        .ToLower()\n    .AddTypeConversion<CsvRow, ImportedRecord>()  // Note: needs .WithConverter()\n    .AddSink<ImportedRecord>(database)\n    .Build();\n\n// For type-changing conversions, use custom converter\nvar node = new TypeConversionNode<CsvRow, ImportedRecord>()\n    .WithConverter(row => new ImportedRecord\n    {\n        Id = int.Parse(row.IdString),\n        Amount = decimal.Parse(row.AmountString),\n        Date = DateTime.Parse(row.DateString)\n    });\n"})}),"\n",(0,o.jsx)(n.h2,{id:"complete-example-data-import-with-validation",children:"Complete Example: Data Import with Validation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public class ImportPipeline\n{\n    public async Task ImportAsync(List<string> csvLines)\n    {\n        var converter = new TypeConversionNode<string, ImportRecord>()\n            .WithConverter(line =>\n            {\n                var parts = line.Split(\',\');\n                return new ImportRecord\n                {\n                    Id = int.Parse(parts[0]),\n                    Name = parts[1].Trim(),\n                    Amount = decimal.Parse(parts[2]),\n                    Date = DateTime.Parse(parts[3], CultureInfo.InvariantCulture)\n                };\n            });\n\n        foreach (var line in csvLines)\n        {\n            try\n            {\n                var record = await converter.ExecuteAsync(line, PipelineContext.Default, CancellationToken.None);\n                await ProcessRecord(record);\n            }\n            catch (TypeConversionException ex)\n            {\n                Console.WriteLine($"Error converting line: {ex.Message}");\n                // Log error and continue\n            }\n        }\n    }\n\n    private async Task ProcessRecord(ImportRecord record)\n    {\n        // Process validated, converted record\n        Console.WriteLine($"Processing: {record.Name} - {record.Amount:C}");\n        await Task.Delay(100);\n    }\n\n    private class ImportRecord\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n        public decimal Amount { get; set; }\n        public DateTime Date { get; set; }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"supported-conversions",children:"Supported Conversions"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"From"}),(0,o.jsx)(n.th,{children:"To"}),(0,o.jsx)(n.th,{children:"Method"}),(0,o.jsx)(n.th,{children:"Notes"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"string"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"int"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"StringToInt()"})}),(0,o.jsx)(n.td,{children:"Supports number styles and format providers"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"string"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"long"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"StringToLong()"})}),(0,o.jsx)(n.td,{children:"Supports number styles and format providers"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"string"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"double"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"StringToDouble()"})}),(0,o.jsx)(n.td,{children:"Supports number styles and format providers"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"string"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"decimal"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"StringToDecimal()"})}),(0,o.jsx)(n.td,{children:"Supports number styles and format providers"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"string"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"bool"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"StringToBool()"})}),(0,o.jsx)(n.td,{children:"Supports: true/false, yes/no, on/off, 1/0"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"string"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"DateTime"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"StringToDateTime()"})}),(0,o.jsx)(n.td,{children:"Supports format specifiers and format providers"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"string"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"TEnum"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"StringToEnum<TEnum>()"})}),(0,o.jsx)(n.td,{children:"Case-sensitive or insensitive"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"int"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"string"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"IntToString()"})}),(0,o.jsx)(n.td,{children:"Supports format specifiers"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"double"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"string"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"DoubleToString()"})}),(0,o.jsx)(n.td,{children:"Supports format specifiers"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"decimal"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"string"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"DecimalToString()"})}),(0,o.jsx)(n.td,{children:"Supports format specifiers"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"DateTime"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"string"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"DateTimeToString()"})}),(0,o.jsx)(n.td,{children:"Supports format specifiers"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"bool"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"string"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"BoolToString()"})}),(0,o.jsx)(n.td,{children:"Customizable true/false representations"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"TEnum"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"string"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"EnumToString<TEnum>()"})}),(0,o.jsx)(n.td,{children:"Uses enum's ToString()"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Custom"}),(0,o.jsx)(n.td,{children:"Custom"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"WithConverter()"})}),(0,o.jsx)(n.td,{children:"Custom conversion function"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"edge-cases",children:"Edge Cases"}),"\n",(0,o.jsx)(n.p,{children:"The type conversion nodes handle several edge cases:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Null or empty strings\nvar node = TypeConversionNode<string, int>.StringToInt();\n// Empty string throws: TypeConversionException\n// Null string throws: TypeConversionException\n\n// Infinity and NaN\nvar node = TypeConversionNode<string, double>.StringToDouble();\nvar infinity = await node.ExecuteAsync("Infinity", context, cancellationToken);\n// result = double.PositiveInfinity\n\nvar nan = await node.ExecuteAsync("NaN", context, cancellationToken);\n// result = double.NaN\n\n// Min and Max DateTime values\nvar node = TypeConversionNode<DateTime, string>.DateTimeToString();\nvar minValue = await node.ExecuteAsync(DateTime.MinValue, context, cancellationToken);\n// result = formatted DateTime.MinValue string\n'})}),"\n",(0,o.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Compiled Expressions"}),": Factory methods use compiled functions for optimal performance"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"No Allocations"}),": ValueTask support ensures synchronous conversions don't allocate"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Format Providers"}),": Specify format providers only when culture-specific behavior is needed"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Error Overhead"}),": Throw TypeConversionException only on actual conversion failures"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Reuse Nodes"}),": Create converter nodes once and reuse for multiple conversions"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"testing-type-conversions",children:"Testing Type Conversions"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[Fact]\npublic async Task StringToInt_WithValidNumber_Converts()\n{\n    var node = TypeConversionNode<string, int>.StringToInt();\n    var result = await node.ExecuteAsync("42", PipelineContext.Default, CancellationToken.None);\n    Assert.Equal(42, result);\n}\n\n[Fact]\npublic async Task StringToInt_WithInvalidInput_ThrowsTypeConversionException()\n{\n    var node = TypeConversionNode<string, int>.StringToInt();\n    var ex = await Assert.ThrowsAsync<TypeConversionException>(() =>\n        node.ExecuteAsync("not a number", PipelineContext.Default, CancellationToken.None));\n    \n    Assert.Equal(typeof(string), ex.SourceType);\n    Assert.Equal(typeof(int), ex.TargetType);\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);