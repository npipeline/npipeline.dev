"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[8066],{2837:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"core-concepts/advanced-nodes/type-conversion","title":"Type Conversion Nodes","description":"Convert data types seamlessly within your NPipeline using the fluent API design of Type Conversion Nodes.","source":"@site/docs/core-concepts/advanced-nodes/type-conversion.md","sourceDirName":"core-concepts/advanced-nodes","slug":"/core-concepts/advanced-nodes/type-conversion","permalink":"/npipeline.dev/docs/core-concepts/advanced-nodes/type-conversion","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Type Conversion Nodes","description":"Convert data types seamlessly within your NPipeline using the fluent API design of Type Conversion Nodes.","sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Tap Nodes","permalink":"/npipeline.dev/docs/core-concepts/advanced-nodes/tap"},"next":{"title":"Aggregation Nodes","permalink":"/npipeline.dev/docs/core-concepts/advanced-nodes/aggregation"}}');var i=r(4848),s=r(8453);const o={title:"Type Conversion Nodes",description:"Convert data types seamlessly within your NPipeline using the fluent API design of Type Conversion Nodes.",sidebar_position:6},a="Type Conversion Nodes",c={},d=[{value:"<code>TypeConversionNode&lt;TIn, TOut&gt;</code>",id:"typeconversionnodetin-tout",level:2},{value:"Fluent API Design",id:"fluent-api-design",level:3},{value:"Example: Basic Type Conversion with AutoMap",id:"example-basic-type-conversion-with-automap",level:3},{value:"Mapping Methods",id:"mapping-methods",level:3},{value:"<code>AutoMap(StringComparer? comparer = null)</code>",id:"automapstringcomparer-comparer--null",level:4},{value:"<code>Map&lt;TSrc, TDest&gt;(Expression&lt;Func&lt;TIn, TSrc&gt;&gt; source, Expression&lt;Func&lt;TOut, TDest&gt;&gt; destination, Func&lt;TSrc, TDest&gt; convert)</code>",id:"maptsrc-tdestexpressionfunctin-tsrc-source-expressionfunctout-tdest-destination-functsrc-tdest-convert",level:4},{value:"<code>Map&lt;TSrc, TDest&gt;(Expression&lt;Func&lt;TIn, TSrc&gt;&gt; source, Expression&lt;Func&lt;TOut, TDest&gt;&gt; destination, Func&lt;TIn, TSrc, TDest&gt; convert)</code>",id:"maptsrc-tdestexpressionfunctin-tsrc-source-expressionfunctout-tdest-destination-functin-tsrc-tdest-convert",level:4},{value:"<code>Map&lt;TDest&gt;(Expression&lt;Func&lt;TOut, TDest&gt;&gt; destination, Func&lt;TIn, TDest&gt; convert)</code>",id:"maptdestexpressionfunctout-tdest-destination-functin-tdest-convert",level:4},{value:"Advanced Example: Complex Object Transformation",id:"advanced-example-complex-object-transformation",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Type Conversion Factory",id:"type-conversion-factory",level:3},{value:"Considerations for Type Conversion Nodes",id:"considerations-for-type-conversion-nodes",level:2},{value:"\u27a1\ufe0f Next Steps",id:"arrow_right-next-steps",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"type-conversion-nodes",children:"Type Conversion Nodes"})}),"\n",(0,i.jsx)(n.p,{children:"In data pipelines, it's common to receive data in one format or type and need to convert it to another for downstream processing. NPipeline's Type Conversion Nodes streamline this process with a fluent API design that allows for flexible and robust type transformations between different stages of your pipeline."}),"\n",(0,i.jsx)(n.h2,{id:"typeconversionnodetin-tout",children:(0,i.jsx)(n.a,{href:"src/NPipeline/Nodes/TypeConversion/TypeConversionNode.cs",children:(0,i.jsx)(n.code,{children:"TypeConversionNode<TIn, TOut>"})})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"src/NPipeline/Nodes/TypeConversion/TypeConversionNode.cs",children:(0,i.jsx)(n.code,{children:"TypeConversionNode<TIn, TOut>"})})," is a transform node designed to convert items from an input type ",(0,i.jsx)(n.code,{children:"TIn"})," to an output type ",(0,i.jsx)(n.code,{children:"TOut"})," using a fluent mapping API. It provides both automatic property mapping and explicit property mapping capabilities."]}),"\n",(0,i.jsx)(n.h3,{id:"fluent-api-design",children:"Fluent API Design"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"TypeConversionNode"})," uses a fluent API that allows you to configure mappings through method chaining:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"src/NPipeline/Nodes/TypeConversion/TypeConversionNode.cs:20",children:(0,i.jsx)(n.code,{children:"Map()"})}),": Explicitly map a source property to a destination property with optional conversion"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"src/NPipeline/Nodes/TypeConversion/TypeConversionNode.cs:75",children:(0,i.jsx)(n.code,{children:"AutoMap()"})}),": Automatically map properties with matching names (case-insensitive)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-basic-type-conversion-with-automap",children:"Example: Basic Type Conversion with AutoMap"}),"\n",(0,i.jsxs)(n.p,{children:["Let's say you have a stream of ",(0,i.jsx)(n.code,{children:"SourceData"})," objects and need to convert them to ",(0,i.jsx)(n.code,{children:"TargetData"})," objects:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\n\r\n// Define input and output types\r\npublic sealed record SourceData(string Name, string Value, int Count);\r\npublic sealed record TargetData(string Identifier, int NumericValue, string Description);\r\n\r\npublic sealed class SourceDataSource : SourceNode<SourceData>\r\n{\r\n    public async IAsyncEnumerable<SourceData> ExecuteAsync(CancellationToken cancellationToken = default)\r\n    {\r\n        yield return new SourceData("Item1", "123", 5);\r\n        yield return new SourceData("Item2", "456", 10);\r\n        yield return new SourceData("Item3", "789", 15);\r\n        await Task.CompletedTask;\r\n    }\r\n}\r\n\r\npublic sealed class TargetDataSink : SinkNode<TargetData>\r\n{\r\n    public async Task ExecuteAsync(IAsyncEnumerable<TargetData> input, CancellationToken cancellationToken = default)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            Console.WriteLine($"Sink received: {item}");\r\n        }\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var context = PipelineContext.Default;\r\n        var runner = new PipelineRunner();\r\n\r\n        Console.WriteLine("Starting type conversion pipeline...");\r\n        await runner.RunAsync<TypeConversionPipelineDefinition>(context);\r\n        Console.WriteLine("Type conversion pipeline finished.");\r\n    }\r\n}\r\n\r\npublic sealed class TypeConversionPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<SourceDataSource, SourceData>("source");\r\n        var transformHandle = builder.AddTransform<TypeConversionNode<SourceData, TargetData>, SourceData, TargetData>("conversion");\r\n        var sinkHandle = builder.AddSink<TargetDataSink, TargetData>("sink");\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Expected Output:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'Starting type conversion pipeline...\r\nSink received: TargetData { Identifier = "Item1", NumericValue = 123, Description = "Processed: Item1" }\r\nSink received: TargetData { Identifier = "Item2", NumericValue = 456, Description = "Processed: Item2" }\r\nSink received: TargetData { Identifier = "Item3", NumericValue = 789, Description = "Processed: Item3" }\r\nType conversion pipeline finished.\n'})}),"\n",(0,i.jsx)(n.h3,{id:"mapping-methods",children:"Mapping Methods"}),"\n",(0,i.jsx)(n.h4,{id:"automapstringcomparer-comparer--null",children:(0,i.jsx)(n.code,{children:"AutoMap(StringComparer? comparer = null)"})}),"\n",(0,i.jsxs)(n.p,{children:["Automatically maps properties from ",(0,i.jsx)(n.code,{children:"TIn"})," to ",(0,i.jsx)(n.code,{children:"TOut"})," by matching names (case-insensitive by default) and applying registered type converters."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"comparer"}),": Optional string comparer for property name matching. Defaults to case-insensitive comparison."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// AutoMap with custom comparer\r\nvar conversionNode = new TypeConversionNode<SourceData, TargetData>()\r\n    .AutoMap(StringComparer.Ordinal); // Case-sensitive matching\n"})}),"\n",(0,i.jsx)(n.h4,{id:"maptsrc-tdestexpressionfunctin-tsrc-source-expressionfunctout-tdest-destination-functsrc-tdest-convert",children:(0,i.jsx)(n.code,{children:"Map<TSrc, TDest>(Expression<Func<TIn, TSrc>> source, Expression<Func<TOut, TDest>> destination, Func<TSrc, TDest> convert)"})}),"\n",(0,i.jsx)(n.p,{children:"Maps a source property to a destination property using a converter that takes only the source value."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Simple property mapping with type conversion\r\n.Map(src => src.Price, dest => dest.Cost, price => price * 0.9m) // Apply 10% discount\n"})}),"\n",(0,i.jsx)(n.h4,{id:"maptsrc-tdestexpressionfunctin-tsrc-source-expressionfunctout-tdest-destination-functin-tsrc-tdest-convert",children:(0,i.jsx)(n.code,{children:"Map<TSrc, TDest>(Expression<Func<TIn, TSrc>> source, Expression<Func<TOut, TDest>> destination, Func<TIn, TSrc, TDest> convert)"})}),"\n",(0,i.jsx)(n.p,{children:"Maps a source property to a destination property using a converter that can inspect the whole input object."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Complex mapping using entire input object\r\n.Map(src => src.DiscountCode, dest => dest.FinalPrice,\r\n    (input, code) => input.Price * GetDiscountMultiplier(code))\n"})}),"\n",(0,i.jsx)(n.h4,{id:"maptdestexpressionfunctout-tdest-destination-functin-tdest-convert",children:(0,i.jsx)(n.code,{children:"Map<TDest>(Expression<Func<TOut, TDest>> destination, Func<TIn, TDest> convert)"})}),"\n",(0,i.jsx)(n.p,{children:"Maps a destination property using a converter over the whole input object (no single source property)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// Generate a value based on multiple source properties\r\n.Map(dest => dest.Summary, input => $"{input.Name}: {input.Count} items")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"advanced-example-complex-object-transformation",children:"Advanced Example: Complex Object Transformation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Source and target types with different structures\r\npublic sealed record OrderInput(\r\n    string OrderId,\r\n    string CustomerName,\r\n    decimal Subtotal,\r\n    string DiscountCode,\r\n    DateTime OrderDate\r\n);\r\n\r\npublic sealed record OrderOutput(\r\n    string Id,\r\n    CustomerInfo Customer,\r\n    PricingInfo Pricing,\r\n    DateTime ProcessedAt\r\n);\r\n\r\npublic sealed record CustomerInfo(string Name, bool IsPremium);\r\npublic sealed record PricingInfo(decimal Subtotal, decimal Discount, decimal Total);\r\n\r\n// Complex transformation using fluent API\r\nvar orderTransform = new TypeConversionNode<OrderInput, OrderOutput>()\r\n    .Map(src => src.OrderId, dest => dest.Id, id => id)\r\n    .Map(dest => dest.Customer, input =>\r\n        new CustomerInfo(\r\n            Name: input.CustomerName,\r\n            IsPremium: IsPremiumCustomer(input.CustomerName)\r\n        ))\r\n    .Map(dest => dest.Pricing, input =>\r\n        new PricingInfo(\r\n            Subtotal: input.Subtotal,\r\n            Discount: CalculateDiscount(input.DiscountCode, input.Subtotal),\r\n            Total: CalculateTotal(input.Subtotal, input.DiscountCode)\r\n        ))\r\n    .Map(dest => dest.ProcessedAt, _ => DateTime.UtcNow);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"TypeConversionNode"})," handles conversion errors gracefully:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Invalid type conversions throw exceptions that can be caught by pipeline error handling"}),"\n",(0,i.jsx)(n.li,{children:"Missing mappings don't cause errors - only explicitly mapped properties are transformed"}),"\n",(0,i.jsx)(n.li,{children:"You can provide custom error handling through the pipeline's error handling mechanisms"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"type-conversion-factory",children:"Type Conversion Factory"}),"\n",(0,i.jsxs)(n.p,{children:["The node internally uses ",(0,i.jsx)(n.a,{href:"src/NPipeline/Nodes/TypeConversion/TypeConverterFactory.cs",children:(0,i.jsx)(n.code,{children:"TypeConverterFactory"})})," to discover and create appropriate type converters for various type pairs. This factory handles the complexities of finding the right conversion logic for automatic mappings."]}),"\n",(0,i.jsx)(n.h2,{id:"considerations-for-type-conversion-nodes",children:"Considerations for Type Conversion Nodes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": For high-throughput scenarios, the fluent mapping expressions are compiled to efficient delegates, but complex transformations may still impact performance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Null Handling"}),": Be explicit about null handling in your conversion functions to avoid unexpected runtime errors."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Immutable Types"}),": The API works best with immutable types (like records) as it creates new instances for each transformation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Circular References"}),": The node doesn't handle circular references in object graphs - avoid mapping types with circular references."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Type Conversion Nodes with their fluent API provide a powerful and flexible way to transform data between different types in your NPipelines."}),"\n",(0,i.jsxs)(n.h2,{id:"arrow_right-next-steps",children:["\u27a1\ufe0f"," Next Steps"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/error-handling#advanced-patterns",children:"Advanced Error Handling Patterns"})}),": Learn more about handling errors, especially during conversions."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(6540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);