"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[5802],{23541:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"extensions/composition/performance","title":"Performance Optimization","description":"Overview","source":"@site/docs/extensions/composition/performance.md","sourceDirName":"extensions/composition","slug":"/extensions/composition/performance","permalink":"/docs/extensions/composition/performance","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Nested Composition","permalink":"/docs/extensions/composition/nested-composition"},"next":{"title":"Testing Composite Pipelines","permalink":"/docs/extensions/composition/testing"}}');var r=i(74848),t=i(28453);const o={},l="Performance Optimization",a={},c=[{value:"Overview",id:"overview",level:2},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Overhead Breakdown",id:"overhead-breakdown",level:3},{value:"Comparison: Flat vs Composite",id:"comparison-flat-vs-composite",level:3},{value:"When to Use Composition",id:"when-to-use-composition",level:2},{value:"Good Use Cases (\u2705)",id:"good-use-cases-",level:3},{value:"Avoid Composition (\u274c)",id:"avoid-composition-",level:3},{value:"Optimization Techniques",id:"optimization-techniques",level:2},{value:"1. Minimize Context Inheritance",id:"1-minimize-context-inheritance",level:3},{value:"2. Reduce Nesting Depth",id:"2-reduce-nesting-depth",level:3},{value:"3. Batch Processing",id:"3-batch-processing",level:3},{value:"4. Reuse Pipeline Definitions",id:"4-reuse-pipeline-definitions",level:3},{value:"5. Async Processing",id:"5-async-processing",level:3},{value:"Benchmarking",id:"benchmarking",level:2},{value:"Measuring Composite Overhead",id:"measuring-composite-overhead",level:3},{value:"Profiling Tools",id:"profiling-tools",level:3},{value:"Real-World Scenarios",id:"real-world-scenarios",level:2},{value:"Scenario 1: Data Enrichment Pipeline",id:"scenario-1-data-enrichment-pipeline",level:3},{value:"Scenario 2: High-Throughput Log Processing",id:"scenario-2-high-throughput-log-processing",level:3},{value:"Scenario 3: ETL Pipeline",id:"scenario-3-etl-pipeline",level:3},{value:"Monitoring and Observability",id:"monitoring-and-observability",level:2},{value:"Track Composite Node Performance",id:"track-composite-node-performance",level:3},{value:"Metrics to Track",id:"metrics-to-track",level:3},{value:"Summary",id:"summary",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Decision Matrix",id:"decision-matrix",level:3},{value:"Optimization Priority",id:"optimization-priority",level:3}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"performance-optimization",children:"Performance Optimization"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Composite pipelines introduce some overhead compared to flat pipelines. This guide helps you understand the performance characteristics and optimize for your use case."}),"\n",(0,r.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,r.jsx)(n.h3,{id:"overhead-breakdown",children:"Overhead Breakdown"}),"\n",(0,r.jsx)(n.p,{children:"Per-item overhead when using composite nodes:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Component"}),(0,r.jsx)(n.th,{children:"Time"}),(0,r.jsx)(n.th,{children:"Memory"}),(0,r.jsx)(n.th,{children:"Impact"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Context Creation"}),(0,r.jsx)(n.td,{children:"~1-2\u03bcs"}),(0,r.jsx)(n.td,{children:"~1-5KB"}),(0,r.jsx)(n.td,{children:"Per item per level"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Input/Output Transfer"}),(0,r.jsx)(n.td,{children:"~0.5\u03bcs"}),(0,r.jsx)(n.td,{children:"0 (zero-copy)"}),(0,r.jsx)(n.td,{children:"Per item per level"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Pipeline Runner Reuse"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"0 (shared)"}),(0,r.jsx)(n.td,{children:"No impact"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Sub-Pipeline Execution"}),(0,r.jsx)(n.td,{children:"Variable"}),(0,r.jsx)(n.td,{children:"Variable"}),(0,r.jsx)(n.td,{children:"Depends on nodes"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Total Overhead:"})," ~2-3\u03bcs per item per nesting level (excluding actual processing)"]}),"\n",(0,r.jsx)(n.h3,{id:"comparison-flat-vs-composite",children:"Comparison: Flat vs Composite"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Flat pipeline\n[Source] \u2192 [Transform1] \u2192 [Transform2] \u2192 [Transform3] \u2192 [Sink]\nOverhead: ~0\u03bcs (baseline)\n\n// Composite pipeline (1 level)\n[Source] \u2192 [Composite{Transform1 \u2192 Transform2 \u2192 Transform3}] \u2192 [Sink]\nOverhead: ~2-3\u03bcs per item\n\n// Nested composite (2 levels)\n[Source] \u2192 [Composite{Composite{Transform1 \u2192 Transform2} \u2192 Transform3}] \u2192 [Sink]\nOverhead: ~4-6\u03bcs per item\n"})}),"\n",(0,r.jsx)(n.h2,{id:"when-to-use-composition",children:"When to Use Composition"}),"\n",(0,r.jsx)(n.h3,{id:"good-use-cases-",children:"Good Use Cases (\u2705)"}),"\n",(0,r.jsx)(n.p,{children:"Composition is beneficial when:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Modularity > Raw Speed"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Good: Reusable validation across multiple pipelines\nbuilder.AddComposite<Data, ValidatedData, ValidationPipeline>("validate");\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Low-Throughput Pipelines"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Good: Processing < 1000 items/sec\n// Overhead is negligible compared to processing time\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Complex Business Logic"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Good: Complex logic benefits from modular structure\nbuilder.AddComposite<Order, ProcessedOrder, OrderProcessingPipeline>("process");\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Testing and Maintenance"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Good: Sub-pipelines can be tested independently\n// Easier to maintain and debug\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"avoid-composition-",children:"Avoid Composition (\u274c)"}),"\n",(0,r.jsx)(n.p,{children:"Composition may not be ideal when:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Ultra-High Throughput"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Bad: Processing millions of items/sec\n// Consider flattening the pipeline\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Simple Linear Processing"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Bad: Simple transform doesn\'t need composition\nbuilder.AddComposite<int, int, MultiplyByTwoPipeline>("double");\n\n// Better: Direct transform\nbuilder.AddTransform<MultiplyByTwo, int, int>("double");\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Excessive Nesting"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Bad: 5+ levels of nesting\n// Flatten or refactor to reduce levels\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,r.jsx)(n.h3,{id:"1-minimize-context-inheritance",children:"1. Minimize Context Inheritance"}),"\n",(0,r.jsx)(n.p,{children:"Use default (no inheritance) when possible:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'\u2705 Optimized: No inheritance overhead\nbuilder.AddComposite<T, T, SubPipeline>(\n    contextConfiguration: CompositeContextConfiguration.Default);\n\n\u274c Slow: Copying large context dictionaries\nvar context = new PipelineContext();\n// Add 1000 parameters\nfor (int i = 0; i < 1000; i++)\n{\n    context.Parameters[$"key_{i}"] = $"value_{i}";\n}\n\nbuilder.AddComposite<T, T, SubPipeline>(\n    contextConfiguration: CompositeContextConfiguration.InheritAll);\n// Each item copies 1000 parameters!\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Benchmark Results:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No inheritance: ~1\u03bcs per item"}),"\n",(0,r.jsx)(n.li,{children:"InheritAll (empty context): ~1\u03bcs per item"}),"\n",(0,r.jsx)(n.li,{children:"InheritAll (1000 parameters): ~50\u03bcs per item"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-reduce-nesting-depth",children:"2. Reduce Nesting Depth"}),"\n",(0,r.jsx)(n.p,{children:"Flatten deep hierarchies:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"\u274c Slow: 4 levels deep\n[A] \u2192 [Composite{[B] \u2192 [Composite{[C] \u2192 [Composite{[D]}]}]}]\nOverhead: ~8-12\u03bcs per item\n\n\u2705 Fast: 2 levels\n[A] \u2192 [Composite{[B] \u2192 [C] \u2192 [D]}]\nOverhead: ~2-3\u03bcs per item\n\n\u2705 Fastest: Flat\n[A] \u2192 [B] \u2192 [C] \u2192 [D]\nOverhead: ~0\u03bcs\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-batch-processing",children:"3. Batch Processing"}),"\n",(0,r.jsx)(n.p,{children:"Process multiple items in sub-pipelines:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Instead of: One item at a time\nbuilder.AddComposite<Item, ProcessedItem, ItemPipeline>("process");\n\n// Consider: Batching items\nbuilder.AddComposite<List<Item>, List<ProcessedItem>, BatchPipeline>("process-batch");\n\npublic class BatchPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<List<Item>>, List<Item>>("input");\n        var process = builder.AddTransform<BatchProcessor, List<Item>, List<ProcessedItem>>("process");\n        var output = builder.AddSink<PipelineOutputSink<List<ProcessedItem>>, List<ProcessedItem>>("output");\n        \n        builder.Connect(input, process);\n        builder.Connect(process, output);\n    }\n}\n\n// Amortize overhead across multiple items\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Benchmark Results:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Single item: ~3\u03bcs overhead per item"}),"\n",(0,r.jsx)(n.li,{children:"Batch of 10: ~0.3\u03bcs overhead per item"}),"\n",(0,r.jsx)(n.li,{children:"Batch of 100: ~0.03\u03bcs overhead per item"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-reuse-pipeline-definitions",children:"4. Reuse Pipeline Definitions"}),"\n",(0,r.jsx)(n.p,{children:"Pipeline definitions are lightweight; the runner is shared:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'\u2705 Good: Same definition, multiple instances\npublic class ParentPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var validate1 = builder.AddComposite<Data, Data, ValidationPipeline>("validate1");\n        var validate2 = builder.AddComposite<Data, Data, ValidationPipeline>("validate2");\n        var validate3 = builder.AddComposite<Data, Data, ValidationPipeline>("validate3");\n        \n        // All share the same PipelineRunner instance (efficient)\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"5-async-processing",children:"5. Async Processing"}),"\n",(0,r.jsx)(n.p,{children:"Use async operations in transforms:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public class AsyncTransform : TransformNode<Data, Data>\n{\n    private readonly HttpClient _client;\n    \n    public override async Task<Data> ExecuteAsync(Data input, PipelineContext context, CancellationToken ct)\n    {\n        // Efficient async I/O\n        var result = await _client.GetAsync($"/api/data/{input.Id}", ct);\n        var enriched = await result.Content.ReadAsAsync<EnrichedData>();\n        \n        return input with { Enriched = enriched };\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"benchmarking",children:"Benchmarking"}),"\n",(0,r.jsx)(n.h3,{id:"measuring-composite-overhead",children:"Measuring Composite Overhead"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"using BenchmarkDotNet.Attributes;\n\n[MemoryDiagnoser]\npublic class CompositionBenchmarks\n{\n    private PipelineRunner _runner = null!;\n    private PipelineContext _context = null!;\n    \n    [GlobalSetup]\n    public void Setup()\n    {\n        _runner = PipelineRunner.Create();\n        _context = new PipelineContext();\n    }\n    \n    [Benchmark(Baseline = true)]\n    public async Task FlatPipeline()\n    {\n        await _runner.RunAsync<FlatPipeline>(_context);\n    }\n    \n    [Benchmark]\n    public async Task CompositePipeline_1Level()\n    {\n        await _runner.RunAsync<CompositePipeline1Level>(_context);\n    }\n    \n    [Benchmark]\n    public async Task CompositePipeline_2Levels()\n    {\n        await _runner.RunAsync<CompositePipeline2Levels>(_context);\n    }\n    \n    [Benchmark]\n    public async Task CompositePipeline_NoInheritance()\n    {\n        await _runner.RunAsync<CompositePipelineNoInheritance>(_context);\n    }\n    \n    [Benchmark]\n    public async Task CompositePipeline_InheritAll()\n    {\n        await _runner.RunAsync<CompositePipelineInheritAll>(_context);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example Results:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"| Method                              | Mean     | Error   | StdDev  | Ratio | Gen0   | Allocated |\n|------------------------------------ |---------:|--------:|--------:|------:|-------:|----------:|\n| FlatPipeline                        | 100.0 \u03bcs | 1.5 \u03bcs  | 1.4 \u03bcs  | 1.00  | 2.0    | 8 KB      |\n| CompositePipeline_1Level            | 103.0 \u03bcs | 1.6 \u03bcs  | 1.5 \u03bcs  | 1.03  | 2.5    | 10 KB     |\n| CompositePipeline_2Levels           | 106.0 \u03bcs | 1.7 \u03bcs  | 1.6 \u03bcs  | 1.06  | 3.0    | 12 KB     |\n| CompositePipeline_NoInheritance     | 102.5 \u03bcs | 1.6 \u03bcs  | 1.5 \u03bcs  | 1.03  | 2.5    | 10 KB     |\n| CompositePipeline_InheritAll        | 110.0 \u03bcs | 2.0 \u03bcs  | 1.9 \u03bcs  | 1.10  | 3.5    | 15 KB     |\n"})}),"\n",(0,r.jsx)(n.h3,{id:"profiling-tools",children:"Profiling Tools"}),"\n",(0,r.jsx)(n.p,{children:"Use these tools to identify bottlenecks:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"BenchmarkDotNet"})," - Detailed performance benchmarks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"dotnet-trace"})," - CPU profiling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"dotnet-counters"})," - Real-time metrics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Visual Studio Profiler"})," - Memory and CPU analysis"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"real-world-scenarios",children:"Real-World Scenarios"}),"\n",(0,r.jsx)(n.h3,{id:"scenario-1-data-enrichment-pipeline",children:"Scenario 1: Data Enrichment Pipeline"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Requirements:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Process 10,000 items/sec"}),"\n",(0,r.jsx)(n.li,{children:"Each item requires external API calls"}),"\n",(0,r.jsx)(n.li,{children:"Need modular validation and enrichment"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Analysis:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Composite overhead: ~3\u03bcs per item\n// API call: ~50-100ms per item\n// Overhead is 0.003% of total time - negligible\n\n\u2705 Composition is appropriate here\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Implementation:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public class EnrichmentPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<DataSource, Item>("source");\n        \n        // Validate (composite)\n        var validate = builder.AddComposite<Item, ValidatedItem, ValidationPipeline>("validate");\n        \n        // Enrich (composite, parallel API calls)\n        var enrich = builder.AddComposite<ValidatedItem, EnrichedItem, EnrichmentSubPipeline>("enrich");\n        \n        var sink = builder.AddSink<DatabaseSink, EnrichedItem>("sink");\n        \n        builder.Connect(source, validate);\n        builder.Connect(validate, enrich);\n        builder.Connect(enrich, sink);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"scenario-2-high-throughput-log-processing",children:"Scenario 2: High-Throughput Log Processing"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Requirements:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Process 1,000,000 items/sec"}),"\n",(0,r.jsx)(n.li,{children:"Simple parsing and filtering"}),"\n",(0,r.jsx)(n.li,{children:"Need high performance"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Analysis:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Composite overhead: ~3\u03bcs per item\n// Total processing time: ~5\u03bcs per item\n// Overhead is 60% of total time - significant!\n\n\u274c Composition may not be appropriate here\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Alternative:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Use flat pipeline for maximum performance\npublic class LogProcessingPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<LogSource, LogEntry>("source");\n        \n        // Inline transforms instead of composite\n        var parse = builder.AddTransform<Parser, LogEntry, ParsedEntry>("parse");\n        var filter = builder.AddTransform<Filter, ParsedEntry, ParsedEntry>("filter");\n        var transform = builder.AddTransform<Transformer, ParsedEntry, ProcessedEntry>("transform");\n        \n        var sink = builder.AddSink<LogSink, ProcessedEntry>("sink");\n        \n        builder.Connect(source, parse);\n        builder.Connect(parse, filter);\n        builder.Connect(filter, transform);\n        builder.Connect(transform, sink);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"scenario-3-etl-pipeline",children:"Scenario 3: ETL Pipeline"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Requirements:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Process 100,000 items/hour (27 items/sec)"}),"\n",(0,r.jsx)(n.li,{children:"Complex transformations"}),"\n",(0,r.jsx)(n.li,{children:"Need testing and maintainability"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Analysis:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Composite overhead: ~3\u03bcs per item\n// Total processing time: ~50ms per item\n// Overhead is 0.006% of total time - negligible\n\n\u2705 Composition is excellent here\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Implementation:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public class ETLPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<DatabaseSource, RawData>("source");\n        \n        // Extract (composite)\n        var extract = builder.AddComposite<RawData, ExtractedData, ExtractionPipeline>("extract");\n        \n        // Transform (composite)\n        var transform = builder.AddComposite<ExtractedData, TransformedData, TransformationPipeline>("transform");\n        \n        // Load (composite)\n        var load = builder.AddComposite<TransformedData, LoadResult, LoadPipeline>("load");\n        \n        var sink = builder.AddSink<ResultSink, LoadResult>("sink");\n        \n        builder.Connect(source, extract);\n        builder.Connect(extract, transform);\n        builder.Connect(transform, load);\n        builder.Connect(load, sink);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"monitoring-and-observability",children:"Monitoring and Observability"}),"\n",(0,r.jsx)(n.h3,{id:"track-composite-node-performance",children:"Track Composite Node Performance"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class MonitoredCompositeTransform<TIn, TOut, TDefinition> : CompositeTransformNode<TIn, TOut, TDefinition>\n    where TDefinition : IPipelineDefinition, new()\n{\n    private readonly IMetrics _metrics;\n    \n    public override async Task<TOut> ExecuteAsync(TIn item, PipelineContext context, CancellationToken ct)\n    {\n        var sw = Stopwatch.StartNew();\n        \n        try\n        {\n            var result = await base.ExecuteAsync(item, context, ct);\n            _metrics.RecordSuccess(typeof(TDefinition).Name, sw.Elapsed);\n            return result;\n        }\n        catch (Exception ex)\n        {\n            _metrics.RecordFailure(typeof(TDefinition).Name, sw.Elapsed);\n            throw;\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"metrics-to-track",children:"Metrics to Track"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Execution Time"}),": Per composite node and sub-pipeline"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Throughput"}),": Items/sec through composite nodes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Rate"}),": Failures in sub-pipelines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory Usage"}),": Context size and allocation rate"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nesting Depth"}),": Current and maximum depth"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Overhead is Minimal"}),": ~2-3\u03bcs per item per nesting level"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Context Copies Matter"}),": Large inherited contexts can slow things down"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flat is Fastest"}),": But composition brings other benefits"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Profile First"}),": Measure before optimizing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Context Matters"}),": Overhead impact depends on total processing time"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"decision-matrix",children:"Decision Matrix"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Throughput"}),(0,r.jsx)(n.th,{children:"Processing Time"}),(0,r.jsx)(n.th,{children:"Recommendation"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"< 10K items/sec"}),(0,r.jsx)(n.td,{children:"Any"}),(0,r.jsx)(n.td,{children:"\u2705 Use composition freely"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"10K-100K items/sec"}),(0,r.jsx)(n.td,{children:"> 1ms/item"}),(0,r.jsx)(n.td,{children:"\u2705 Use composition"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"10K-100K items/sec"}),(0,r.jsx)(n.td,{children:"< 100\u03bcs/item"}),(0,r.jsx)(n.td,{children:"\u26a0\ufe0f Measure overhead"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"> 100K items/sec"}),(0,r.jsx)(n.td,{children:"< 10\u03bcs/item"}),(0,r.jsx)(n.td,{children:"\u274c Avoid composition"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"> 100K items/sec"}),(0,r.jsx)(n.td,{children:"> 100\u03bcs/item"}),(0,r.jsx)(n.td,{children:"\u2705 Use composition"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"optimization-priority",children:"Optimization Priority"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Correctness"})," - Get it working correctly first"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Modularity"})," - Make it maintainable and testable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"})," - Optimize only if measurements show it's needed"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:'"Premature optimization is the root of all evil" - Donald Knuth'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Focus on clean, modular code with composition. Optimize only when profiling shows composition overhead is a bottleneck in your specific use case."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var s=i(96540);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);