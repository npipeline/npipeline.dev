"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[8356],{28453:(e,a,n)=>{n.d(a,{R:()=>l,x:()=>s});var t=n(96540);const r={},i=t.createContext(r);function l(e){const a=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function s(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(i.Provider,{value:a},e.children)}},84799:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>c,contentTitle:()=>s,default:()=>y,frontMatter:()=>l,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"core-concepts/resilience/retry-delay-advanced","title":"Advanced Retry Patterns","description":"Implement advanced retry delay patterns including decorrelated jitter, custom strategies, and fallback patterns","source":"@site/docs/core-concepts/resilience/retry-delay-advanced.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/retry-delay-advanced","permalink":"/docs/core-concepts/resilience/retry-delay-advanced","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8.4,"frontMatter":{"title":"Advanced Retry Patterns","description":"Implement advanced retry delay patterns including decorrelated jitter, custom strategies, and fallback patterns","sidebar_position":8.4},"sidebar":"docsSidebar","previous":{"title":"Fixed Delay","permalink":"/docs/core-concepts/resilience/retry-delay-fixed"},"next":{"title":"Testing Retry Behavior","permalink":"/docs/core-concepts/resilience/retry-delay-testing"}}');var r=n(74848),i=n(28453);const l={title:"Advanced Retry Patterns",description:"Implement advanced retry delay patterns including decorrelated jitter, custom strategies, and fallback patterns",sidebar_position:8.4},s="Advanced Retry Patterns",c={},o=[{value:"Decorrelated Jitter",id:"decorrelated-jitter",level:2},{value:"When to Use",id:"when-to-use",level:3},{value:"Implementation",id:"implementation",level:3},{value:"How It Works",id:"how-it-works",level:3},{value:"Example: Adaptive Load Distribution",id:"example-adaptive-load-distribution",level:3},{value:"Custom Backoff Strategies",id:"custom-backoff-strategies",level:2},{value:"Fibonacci Backoff",id:"fibonacci-backoff",level:3},{value:"Polynomial Backoff",id:"polynomial-backoff",level:3},{value:"Time-of-Day Based Strategy",id:"time-of-day-based-strategy",level:3},{value:"Fallback Strategies",id:"fallback-strategies",level:2},{value:"Circuit Breaker Pattern with Retries",id:"circuit-breaker-pattern-with-retries",level:2},{value:"Load-Adaptive Strategy",id:"load-adaptive-strategy",level:2},{value:"Dependency Injection with Custom Strategies",id:"dependency-injection-with-custom-strategies",level:2},{value:"Best Practices for Custom Strategies",id:"best-practices-for-custom-strategies",level:2},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.header,{children:(0,r.jsx)(a.h1,{id:"advanced-retry-patterns",children:"Advanced Retry Patterns"})}),"\n",(0,r.jsx)(a.p,{children:"Beyond the basic strategies (exponential, linear, fixed), NPipeline supports advanced patterns for sophisticated scenarios."}),"\n",(0,r.jsx)(a.h2,{id:"decorrelated-jitter",children:"Decorrelated Jitter"}),"\n",(0,r.jsx)(a.p,{children:"Decorrelated jitter automatically adapts retry delays based on system conditions, providing better load distribution than full jitter in highly concurrent environments."}),"\n",(0,r.jsx)(a.h3,{id:"when-to-use",children:"When to Use"}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:"High concurrency scenarios (thousands of concurrent operations)"}),"\n",(0,r.jsx)(a.li,{children:"Load-adaptive systems"}),"\n",(0,r.jsx)(a.li,{children:"Distributed systems with variable load"}),"\n"]}),"\n",(0,r.jsx)(a.h3,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-csharp",children:"var context = PipelineContext.Default;\ncontext.UseExponentialBackoffDelay(\n    baseDelay: TimeSpan.FromMilliseconds(100),\n    multiplier: 2.0,\n    maxDelay: TimeSpan.FromSeconds(30),\n    jitterStrategy: JitterStrategies.DecorrelatedJitter());\n"})}),"\n",(0,r.jsx)(a.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,r.jsxs)(a.ol,{children:["\n",(0,r.jsx)(a.li,{children:"Initial delay calculated from strategy (exponential/linear/fixed)"}),"\n",(0,r.jsx)(a.li,{children:"Jitter applied adaptively based on previous retry timing"}),"\n",(0,r.jsx)(a.li,{children:"Subsequent delays influenced by system responsiveness"}),"\n",(0,r.jsx)(a.li,{children:"Reduces synchronized retries more effectively than full jitter"}),"\n"]}),"\n",(0,r.jsx)(a.h3,{id:"example-adaptive-load-distribution",children:"Example: Adaptive Load Distribution"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-csharp",children:"// With decorrelated jitter:\n// - If system recovers quickly, next delay is shorter\n// - If system is slow, next delay is longer\n// - Naturally adapts to actual recovery times\n\nvar strategy = new DecorrelatedJitterStrategy(\n    baseDelay: TimeSpan.FromSeconds(1),\n    multiplier: 2.0);\n\nfor (int attempt = 0; attempt < 5; attempt++)\n{\n    var delay = await strategy.GetDelayAsync(attempt);\n    // First attempt: ~1s\n    // Second attempt: adapts to actual recovery\n    // Continues adapting...\n}\n"})}),"\n",(0,r.jsx)(a.h2,{id:"custom-backoff-strategies",children:"Custom Backoff Strategies"}),"\n",(0,r.jsx)(a.p,{children:"Create completely custom backoff logic for domain-specific scenarios:"}),"\n",(0,r.jsx)(a.h3,{id:"fibonacci-backoff",children:"Fibonacci Backoff"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-csharp",children:"public class FibonacciBackoffStrategy : IRetryDelayStrategy\n{\n    private readonly TimeSpan _maxDelay;\n\n    public FibonacciBackoffStrategy(TimeSpan maxDelay)\n    {\n        _maxDelay = maxDelay;\n    }\n\n    public ValueTask<TimeSpan> GetDelayAsync(\n        int attemptNumber,\n        CancellationToken cancellationToken = default)\n    {\n        var fibValue = CalculateFibonacci(attemptNumber + 1);\n        var delay = TimeSpan.FromSeconds(Math.Min(fibValue, _maxDelay.TotalSeconds));\n        return new ValueTask<TimeSpan>(delay);\n    }\n\n    private double CalculateFibonacci(int n)\n    {\n        if (n <= 1) return 1;\n        var prev = 1.0;\n        var curr = 1.0;\n        for (int i = 2; i < n; i++)\n        {\n            var next = prev + curr;\n            prev = curr;\n            curr = next;\n        }\n        return curr;\n    }\n}\n\n// Usage:\nvar fibonacciStrategy = new FibonacciBackoffStrategy(TimeSpan.FromMinutes(1));\n"})}),"\n",(0,r.jsx)(a.h3,{id:"polynomial-backoff",children:"Polynomial Backoff"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-csharp",children:"public class PolynomialBackoffStrategy : IRetryDelayStrategy\n{\n    private readonly double _exponent;\n    private readonly TimeSpan _baseDelay;\n    private readonly TimeSpan _maxDelay;\n\n    public PolynomialBackoffStrategy(double exponent, TimeSpan baseDelay, TimeSpan maxDelay)\n    {\n        _exponent = exponent;\n        _baseDelay = baseDelay;\n        _maxDelay = maxDelay;\n    }\n\n    public ValueTask<TimeSpan> GetDelayAsync(\n        int attemptNumber,\n        CancellationToken cancellationToken = default)\n    {\n        var factor = Math.Pow(attemptNumber + 1, _exponent);\n        var totalMs = _baseDelay.TotalMilliseconds * factor;\n        var cappedMs = Math.Min(totalMs, _maxDelay.TotalMilliseconds);\n        return new ValueTask<TimeSpan>(TimeSpan.FromMilliseconds(cappedMs));\n    }\n}\n\n// Usage - quadratic backoff (^2):\nvar quadraticStrategy = new PolynomialBackoffStrategy(\n    exponent: 2.0,\n    baseDelay: TimeSpan.FromSeconds(1),\n    maxDelay: TimeSpan.FromMinutes(1));\n"})}),"\n",(0,r.jsx)(a.h3,{id:"time-of-day-based-strategy",children:"Time-of-Day Based Strategy"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-csharp",children:"public class TimeOfDayAwareBackoffStrategy : IRetryDelayStrategy\n{\n    private readonly IRetryDelayStrategy _peakHoursStrategy;\n    private readonly IRetryDelayStrategy _offPeakStrategy;\n\n    public TimeOfDayAwareBackoffStrategy(\n        IRetryDelayStrategy peakHoursStrategy,\n        IRetryDelayStrategy offPeakStrategy)\n    {\n        _peakHoursStrategy = peakHoursStrategy;\n        _offPeakStrategy = offPeakStrategy;\n    }\n\n    public async ValueTask<TimeSpan> GetDelayAsync(\n        int attemptNumber,\n        CancellationToken cancellationToken = default)\n    {\n        var hour = DateTime.UtcNow.Hour;\n        var isPeakHours = hour >= 8 && hour < 18; // 8 AM - 6 PM\n\n        var strategy = isPeakHours ? _peakHoursStrategy : _offPeakStrategy;\n        return await strategy.GetDelayAsync(attemptNumber, cancellationToken);\n    }\n}\n\n// Usage:\nvar timeAwareStrategy = new TimeOfDayAwareBackoffStrategy(\n    peakHoursStrategy: new ExponentialBackoffStrategy(\n        TimeSpan.FromSeconds(2), 2.0, TimeSpan.FromMinutes(5)),\n    offPeakStrategy: new ExponentialBackoffStrategy(\n        TimeSpan.FromMilliseconds(500), 2.0, TimeSpan.FromMinutes(1)));\n"})}),"\n",(0,r.jsx)(a.h2,{id:"fallback-strategies",children:"Fallback Strategies"}),"\n",(0,r.jsx)(a.p,{children:"Implement cascading fallback when primary strategy exhausts retries:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-csharp",children:"public class FallbackRetryStrategy : IRetryDelayStrategy\n{\n    private readonly IRetryDelayStrategy _primaryStrategy;\n    private readonly IRetryDelayStrategy _fallbackStrategy;\n    private readonly int _maxPrimaryAttempts;\n\n    public FallbackRetryStrategy(\n        IRetryDelayStrategy primary,\n        IRetryDelayStrategy fallback,\n        int maxPrimaryAttempts = 3)\n    {\n        _primaryStrategy = primary;\n        _fallbackStrategy = fallback;\n        _maxPrimaryAttempts = maxPrimaryAttempts;\n    }\n\n    public async ValueTask<TimeSpan> GetDelayAsync(\n        int attemptNumber,\n        CancellationToken cancellationToken = default)\n    {\n        var strategy = attemptNumber < _maxPrimaryAttempts\n            ? _primaryStrategy\n            : _fallbackStrategy;\n\n        return await strategy.GetDelayAsync(attemptNumber, cancellationToken);\n    }\n}\n\n// Usage - try fast exponential, then fall back to slow linear:\nvar fallbackStrategy = new FallbackRetryStrategy(\n    primary: new ExponentialBackoffStrategy(\n        TimeSpan.FromMilliseconds(100), 2.0, TimeSpan.FromSeconds(5)),\n    fallback: new LinearBackoffStrategy(\n        TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(10)),\n    maxPrimaryAttempts: 3);\n"})}),"\n",(0,r.jsx)(a.h2,{id:"circuit-breaker-pattern-with-retries",children:"Circuit Breaker Pattern with Retries"}),"\n",(0,r.jsx)(a.p,{children:"Combine retry delays with circuit breaker to fail fast:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-csharp",children:'public class CircuitBreakerRetryStrategy : IRetryDelayStrategy\n{\n    private readonly IRetryDelayStrategy _innerStrategy;\n    private readonly CircuitBreaker _circuitBreaker;\n\n    public CircuitBreakerRetryStrategy(\n        IRetryDelayStrategy innerStrategy,\n        CircuitBreaker circuitBreaker)\n    {\n        _innerStrategy = innerStrategy;\n        _circuitBreaker = circuitBreaker;\n    }\n\n    public async ValueTask<TimeSpan> GetDelayAsync(\n        int attemptNumber,\n        CancellationToken cancellationToken = default)\n    {\n        // If circuit is open, fail immediately\n        if (_circuitBreaker.IsOpen)\n            throw new ServiceUnavailableException(\n                "Circuit breaker is open - service unavailable");\n\n        // Otherwise, use normal retry delay\n        return await _innerStrategy.GetDelayAsync(attemptNumber, cancellationToken);\n    }\n}\n'})}),"\n",(0,r.jsx)(a.h2,{id:"load-adaptive-strategy",children:"Load-Adaptive Strategy"}),"\n",(0,r.jsx)(a.p,{children:"Adjust retry delays based on system CPU/memory:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-csharp",children:"public class LoadAdaptiveRetryStrategy : IRetryDelayStrategy\n{\n    private readonly IRetryDelayStrategy _lightLoadStrategy;\n    private readonly IRetryDelayStrategy _heavyLoadStrategy;\n    private readonly float _cpuThreshold;\n\n    public LoadAdaptiveRetryStrategy(\n        IRetryDelayStrategy lightLoadStrategy,\n        IRetryDelayStrategy heavyLoadStrategy,\n        float cpuThreshold = 0.7f)\n    {\n        _lightLoadStrategy = lightLoadStrategy;\n        _heavyLoadStrategy = heavyLoadStrategy;\n        _cpuThreshold = cpuThreshold;\n    }\n\n    public async ValueTask<TimeSpan> GetDelayAsync(\n        int attemptNumber,\n        CancellationToken cancellationToken = default)\n    {\n        var currentLoad = GetSystemLoad();\n        var strategy = currentLoad > _cpuThreshold\n            ? _heavyLoadStrategy\n            : _lightLoadStrategy;\n\n        return await strategy.GetDelayAsync(attemptNumber, cancellationToken);\n    }\n\n    private float GetSystemLoad()\n    {\n        // Get actual CPU/memory load from system\n        // Implementation depends on platform and monitoring solution\n        return 0.5f; // Placeholder\n    }\n}\n"})}),"\n",(0,r.jsx)(a.h2,{id:"dependency-injection-with-custom-strategies",children:"Dependency Injection with Custom Strategies"}),"\n",(0,r.jsx)(a.p,{children:"Register custom strategies in DI container:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-csharp",children:'var services = new ServiceCollection();\n\n// Register custom strategies\nservices.AddSingleton<IRetryDelayStrategy>(sp =>\n    new FibonacciBackoffStrategy(TimeSpan.FromMinutes(1)));\n\nservices.AddSingleton<IRetryDelayStrategy>("polynomial", sp =>\n    new PolynomialBackoffStrategy(2.0,\n        TimeSpan.FromSeconds(1),\n        TimeSpan.FromMinutes(1)));\n\nservices.AddSingleton<IRetryDelayStrategy>("timeaware", sp =>\n    new TimeOfDayAwareBackoffStrategy(\n        new ExponentialBackoffStrategy(TimeSpan.FromSeconds(2), 2.0, TimeSpan.FromMinutes(5)),\n        new ExponentialBackoffStrategy(TimeSpan.FromMilliseconds(500), 2.0, TimeSpan.FromMinutes(1))));\n\nvar provider = services.BuildServiceProvider();\n\n// Use in pipeline\nvar context = PipelineContext.Default;\nvar strategy = provider.GetRequiredService<IRetryDelayStrategy>();\n'})}),"\n",(0,r.jsx)(a.h2,{id:"best-practices-for-custom-strategies",children:"Best Practices for Custom Strategies"}),"\n",(0,r.jsxs)(a.ol,{children:["\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.strong,{children:"Always implement ValueTask"}),": Use ValueTask for efficient async"]}),"\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.strong,{children:"Respect CancellationToken"}),": Honor cancellation requests"]}),"\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.strong,{children:"Cache expensive calculations"}),": Don't recalculate on each call"]}),"\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.strong,{children:"Document behavior"}),": Clearly describe when to use each strategy"]}),"\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.strong,{children:"Test thoroughly"}),": Include edge cases and boundary conditions"]}),"\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.strong,{children:"Monitor performance"}),": Track actual delays in production"]}),"\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.strong,{children:"Set reasonable caps"}),": Prevent indefinitely long delays"]}),"\n"]}),"\n",(0,r.jsx)(a.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.a,{href:"/docs/core-concepts/resilience/retries",children:"Retry Configuration"})," - Overall retry configuration"]}),"\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.a,{href:"/docs/core-concepts/resilience/retry-delays",children:"Retry Delays"})," - Overview of strategies"]}),"\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.a,{href:"/docs/core-concepts/resilience/retry-delay-exponential",children:"Exponential Backoff"})," - Exponential delays"]}),"\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.a,{href:"/docs/core-concepts/resilience/retry-delay-linear",children:"Linear Backoff"})," - Linear delays"]}),"\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.a,{href:"/docs/core-concepts/resilience/retry-delay-fixed",children:"Fixed Delay"})," - Fixed delays"]}),"\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.a,{href:"/docs/core-concepts/resilience/retry-delay-testing",children:"Testing Retries"})," - Testing strategies"]}),"\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.a,{href:"/docs/core-concepts/resilience/retry-delay-monitoring",children:"Monitoring Retries"})," - Observing metrics"]}),"\n"]})]})}function y(e={}){const{wrapper:a}={...(0,i.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);