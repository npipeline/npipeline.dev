"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[2311],{8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var s=r(6540);const a={},t=s.createContext(a);function i(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(t.Provider,{value:n},e.children)}},9916:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"advanced-topics/synchronous-fast-paths","title":"Synchronous Fast Paths and ValueTask Optimization","description":"Deep-dive guide on optimizing transformer nodes for high-throughput scenarios using ValueTask to eliminate GC pressure.","source":"@site/docs/advanced-topics/synchronous-fast-paths.md","sourceDirName":"advanced-topics","slug":"/advanced-topics/synchronous-fast-paths","permalink":"/docs/advanced-topics/synchronous-fast-paths","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Synchronous Fast Paths and ValueTask Optimization","description":"Deep-dive guide on optimizing transformer nodes for high-throughput scenarios using ValueTask to eliminate GC pressure.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Performance Hygiene","permalink":"/docs/advanced-topics/performance-hygiene"},"next":{"title":"Advanced Testing","permalink":"/docs/advanced-topics/testing-pipelines"}}');var a=r(4848),t=r(8453);const i={title:"Synchronous Fast Paths and ValueTask Optimization",description:"Deep-dive guide on optimizing transformer nodes for high-throughput scenarios using ValueTask to eliminate GC pressure.",sidebar_position:2},o="Synchronous Fast Paths and ValueTask Optimization",c={},l=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"The Performance Paradox",id:"the-performance-paradox",level:2},{value:"The Solution: ValueTask",id:"the-solution-valuetask",level:2},{value:"The Pattern: Synchronous Fast Path + Asynchronous Slow Path",id:"the-pattern-synchronous-fast-path--asynchronous-slow-path",level:2},{value:"Real-World Example: Cached Data Enrichment",id:"real-world-example-cached-data-enrichment",level:2},{value:"Performance Impact",id:"performance-impact",level:2},{value:"Practical Guidelines",id:"practical-guidelines",level:2},{value:"When to Use <code>ValueTask</code> for Transforms",id:"when-to-use-valuetask-for-transforms",level:3},{value:"Implementation Checklist",id:"implementation-checklist",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Example 1: Simple Transformation (Always Synchronous)",id:"example-1-simple-transformation-always-synchronous",level:3},{value:"Example 2: Format Transformation with Optional Fallback",id:"example-2-format-transformation-with-optional-fallback",level:3},{value:"Critical Constraints: When NOT to Use ValueTask",id:"critical-constraints-when-not-to-use-valuetask",level:2},{value:"Never Await More Than Once",id:"never-await-more-than-once",level:3},{value:"Avoid When Always Asynchronous",id:"avoid-when-always-asynchronous",level:3},{value:"Consider Public APIs Carefully",id:"consider-public-apis-carefully",level:3},{value:"ConfigureAwait Not Supported",id:"configureawait-not-supported",level:3},{value:"See Also",id:"see-also",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"synchronous-fast-paths-and-valuetask-optimization",children:"Synchronous Fast Paths and ValueTask Optimization"})}),"\n",(0,a.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsx)(n.p,{children:"Before implementing ValueTask optimization, you should be familiar with:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts",children:"Core Concepts Overview"})," - Basic NPipeline concepts and terminology"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts/nodes/",children:"Nodes Overview"})," - Understanding how nodes process data"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts/nodes/transform-nodes",children:"Transform Nodes"})," - Node implementation details"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/architecture/optimization-principles",children:"Optimization Principles"})," - Understanding why ValueTask improves performance"]}),"\n"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["\u2139\ufe0f"," For general performance best practices, see ",(0,a.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Hygiene"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["This is ",(0,a.jsx)(n.strong,{children:"definitive guide"})," for understanding and implementing ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," pattern in transformer nodes. For a quick introduction, see ",(0,a.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene#use-valuetaskt-for-fast-path-scenarios",children:"Performance Hygiene: Use ValueTask<T> for Fast Path Scenarios"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"the-performance-paradox",children:"The Performance Paradox"}),"\n",(0,a.jsx)(n.p,{children:"A common performance pitfall in high-throughput ETL pipelines is contradiction between advice and implementation:"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"The advice says:"}),' "Minimize memory allocations to reduce GC pressure"\r\n',(0,a.jsx)(n.strong,{children:"The code does:"})," Return ",(0,a.jsx)(n.code,{children:"Task<T>"})," for all transformer nodes"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["This creates a subtle but critical performance problem: even when your transform work is ",(0,a.jsx)(n.strong,{children:"completely synchronous"})," (a cache hit, a simple calculation), you're still creating a heap-allocated ",(0,a.jsx)(n.code,{children:"Task<T>"})," object to wrap the result."]}),"\n",(0,a.jsxs)(n.p,{children:["In a pipeline processing ",(0,a.jsx)(n.strong,{children:"millions of items per second"}),", where many transforms are synchronous or have high synchronous fast-path rates, you can easily be creating ",(0,a.jsx)(n.strong,{children:"millions of tiny heap allocations per second"}),". This creates constant pressure on garbage collector, causing pauses that directly undermine your throughput goals."]}),"\n",(0,a.jsx)(n.h2,{id:"the-solution-valuetask",children:"The Solution: ValueTask"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"ValueTask<T>"})," is a struct-based alternative to ",(0,a.jsx)(n.code,{children:"Task<T>"})," that:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Allocates on stack"})," (not heap) when result is available synchronously"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Zero allocations"})," for common case in cache-hit or synchronous scenarios"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Seamlessly transitions"})," to true async work when needed"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The tradeoff: You need to implement a two-path pattern\u2014checking for synchronous case first."}),"\n",(0,a.jsx)(n.h2,{id:"the-pattern-synchronous-fast-path--asynchronous-slow-path",children:"The Pattern: Synchronous Fast Path + Asynchronous Slow Path"}),"\n",(0,a.jsx)(n.p,{children:"Here's pattern that balances performance with practicality:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// High-performance transform with cache optimization using ValueTask.\r\n/// Demonstrates zero-allocation pattern for high-throughput scenarios.\r\n/// In pipelines with 90% cache hits processing 10k items/sec,\r\n/// this eliminates ~9000 allocations/sec compared to Task&lt;T&gt;.\r\n/// </summary>\r\npublic sealed class CachedTransform : TransformNode<string, UserData>\r\n{\r\n    private readonly ConcurrentDictionary<string, UserData> _cache = new();\r\n\r\n    /// <summary>\r\n    /// Processes user data with cache-first strategy.\r\n    /// Fast path: cache hit - no Task allocation\r\n    /// Slow path: cache miss - async database call\r\n    /// </summary>\r\n    public override ValueTask<UserData> ExecuteAsync(\r\n        string userId, \r\n        PipelineContext context, \r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Fast path: cache hit - no Task allocation\r\n        if (_cache.TryGetValue(userId, out var cached))\r\n            return new ValueTask<UserData>(cached);\r\n\r\n        // Slow path: async database call\r\n        return new ValueTask<UserData>(FetchAndCacheAsync(userId, cancellationToken));\r\n    }\r\n\r\n    /// <summary>\r\n    /// Fetches user data from database and caches the result.\r\n    /// This method is only called on cache misses.\r\n    /// </summary>\r\n    private async Task<UserData> FetchAndCacheAsync(string userId, CancellationToken ct)\r\n    {\r\n        var data = await _database.GetUserAsync(userId, ct);\r\n        _cache.TryAdd(userId, data);\r\n        return data;\r\n    }\r\n}\r\n\r\n// Supporting types for the example\r\npublic record UserData(string Id, string Name, string Email);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"real-world-example-cached-data-enrichment",children:"Real-World Example: Cached Data Enrichment"}),"\n",(0,a.jsx)(n.p,{children:"Consider a typical ETL scenario where you enrich data by looking up additional information:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Transform for enriching user data with caching optimization.\r\n/// Demonstrates ValueTask pattern for real-world cache-hit scenarios.\r\n/// </summary>\r\npublic sealed class UserEnrichmentTransform : TransformNode<UserId, EnrichedUser>\r\n{\r\n    private readonly ConcurrentDictionary<string, UserProfile> _profileCache = new();\r\n    private readonly IUserDatabase _userDatabase;\r\n\r\n    public UserEnrichmentTransform(IUserDatabase userDatabase)\r\n    {\r\n        _userDatabase = userDatabase;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Enriches user data with profile information.\r\n    /// Uses cache-first strategy to minimize database calls.\r\n    /// </summary>\r\n    public override ValueTask<EnrichedUser> ExecuteAsync(\r\n        UserId userId,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Check cache first (usually succeeds - fast path)\r\n        if (_profileCache.TryGetValue(userId.Value, out var cachedProfile))\r\n        {\r\n            // Fast path: Return immediately, zero heap allocation\r\n            return new ValueTask<EnrichedUser>(\r\n                new EnrichedUser(userId, cachedProfile)\r\n            );\r\n        }\r\n\r\n        // Cache miss: Fall back to database lookup (slow path)\r\n        return new ValueTask<EnrichedUser>(\r\n            FetchAndEnrichAsync(userId, context, cancellationToken)\r\n        );\r\n    }\r\n\r\n    /// <summary>\r\n    /// Fetches user profile from database and caches the result.\r\n    /// Only executed on cache misses, then cached for future requests.\r\n    /// </summary>\r\n    private async Task<EnrichedUser> FetchAndEnrichAsync(\r\n        UserId userId,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        var profile = await _userDatabase.GetProfileAsync(userId.Value, cancellationToken);\r\n        _profileCache.TryAdd(userId.Value, profile);\r\n        return new EnrichedUser(userId, profile);\r\n    }\r\n}\r\n\r\n// Supporting types for the example\r\npublic record UserId(string Value);\r\npublic record UserProfile(string Name, string Email, DateTime CreatedAt);\r\npublic record EnrichedUser(UserId Id, UserProfile Profile);\r\n\r\n// Interface for database access\r\npublic interface IUserDatabase\r\n{\r\n    Task<UserProfile> GetProfileAsync(string userId, CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-impact",children:"Performance Impact"}),"\n",(0,a.jsx)(n.p,{children:"In a realistic high-volume ETL pipeline:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Scenario"}),(0,a.jsx)(n.th,{children:"Items/Sec"}),(0,a.jsx)(n.th,{children:"Cache Hit Rate"}),(0,a.jsx)(n.th,{children:"Task Allocations/Sec"}),(0,a.jsx)(n.th,{children:"ValueTask Allocations/Sec"}),(0,a.jsx)(n.th,{children:"GC Pressure Reduction"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Simple enrichment"}),(0,a.jsx)(n.td,{children:"1,000,000"}),(0,a.jsx)(n.td,{children:"90%"}),(0,a.jsx)(n.td,{children:"1,000,000"}),(0,a.jsx)(n.td,{children:"100,000"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"90%"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Lookup pipeline"}),(0,a.jsx)(n.td,{children:"5,000,000"}),(0,a.jsx)(n.td,{children:"85%"}),(0,a.jsx)(n.td,{children:"5,000,000"}),(0,a.jsx)(n.td,{children:"750,000"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"85%"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Stream transformation"}),(0,a.jsx)(n.td,{children:"10,000,000"}),(0,a.jsx)(n.td,{children:"95%"}),(0,a.jsx)(n.td,{children:"10,000,000"}),(0,a.jsx)(n.td,{children:"500,000"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"95%"})})]})]})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"The compounding effect:"})," Reduced allocations \u2192 Less GC pressure \u2192 Fewer GC pauses \u2192 More throughput \u2192 Lower latency"]}),"\n",(0,a.jsx)(n.h2,{id:"practical-guidelines",children:"Practical Guidelines"}),"\n",(0,a.jsxs)(n.h3,{id:"when-to-use-valuetask-for-transforms",children:["When to Use ",(0,a.jsx)(n.code,{children:"ValueTask"})," for Transforms"]}),"\n",(0,a.jsxs)(n.p,{children:["\u2705 ",(0,a.jsxs)(n.strong,{children:["Use ",(0,a.jsx)(n.code,{children:"ValueTask"})," when:"]})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The transform can complete synchronously in common case"}),"\n",(0,a.jsx)(n.li,{children:"You have a cache, in-memory lookup, or fast path"}),"\n",(0,a.jsx)(n.li,{children:"The synchronous case is likely to happen frequently"}),"\n",(0,a.jsx)(n.li,{children:"You're optimizing for throughput in high-volume scenarios"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["\u274c ",(0,a.jsxs)(n.strong,{children:["Use ",(0,a.jsx)(n.code,{children:"Task"})," when:"]})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The transform is almost always asynchronous (database queries, network calls every time)"}),"\n",(0,a.jsx)(n.li,{children:"You want simpler code and performance benefit is marginal"}),"\n",(0,a.jsx)(n.li,{children:"You're building a library and want to keep interface simple"}),"\n",(0,a.jsx)(n.li,{children:"The pipeline volume is low enough that allocations don't matter"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"implementation-checklist",children:"Implementation Checklist"}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"Identify fast path:"})," Where can transform return synchronously?"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"Measure fast-path hit rate:"})," Is it worth optimizing? (Usually yes if > 50%)"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsxs)(n.strong,{children:["Implement ",(0,a.jsx)(n.code,{children:"TryGetSynchronousResult()"}),":"]})," Extract synchronous case"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"Benchmark it:"})," Use BenchmarkDotNet to measure allocation reduction"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"Document it:"})," Explain why ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," is used and what fast path is"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,a.jsx)(n.strong,{children:"Test both paths:"})," Ensure your code works when fast path returns and when it doesn't"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,a.jsx)(n.h3,{id:"example-1-simple-transformation-always-synchronous",children:"Example 1: Simple Transformation (Always Synchronous)"}),"\n",(0,a.jsxs)(n.p,{children:["If your transform is ",(0,a.jsx)(n.strong,{children:"always"})," synchronous, even simpler:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Transform for simple synchronous calculations.\r\n/// Demonstrates ValueTask for always-synchronous operations.\r\n/// Using ValueTask eliminates Task allocation even for simple calculations.\r\n/// </summary>\r\npublic sealed class SimpleCalculationTransform : TransformNode<int, int>\r\n{\r\n    /// <summary>\r\n    /// Performs square operation on input integer.\r\n    /// Pure synchronous work - no async operations needed.\r\n    /// </summary>\r\n    public override ValueTask<int> ExecuteAsync(\r\n        int item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // No async work at all - direct calculation\r\n        return new ValueTask<int>(item * item);\r\n    }\r\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"example-2-format-transformation-with-optional-fallback",children:"Example 2: Format Transformation with Optional Fallback"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Transform for data formatting with optional fallback.\r\n/// Demonstrates hybrid pattern with local cache and network service.\r\n/// </summary>\r\npublic sealed class DataFormatTransform : TransformNode<RawData, FormattedData>\r\n{\r\n    private readonly IFormatterCache _formatterCache;\r\n    private readonly INetworkFormatterService _networkFormatter;\r\n\r\n    public DataFormatTransform(\r\n        IFormatterCache formatterCache,\r\n        INetworkFormatterService networkFormatter)\r\n    {\r\n        _formatterCache = formatterCache;\r\n        _networkFormatter = networkFormatter;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Formats raw data using cache-first strategy.\r\n    /// Fast path: local cache hit\r\n    /// Slow path: network service call\r\n    /// </summary>\r\n    public override ValueTask<FormattedData> ExecuteAsync(\r\n        RawData item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Try local cache (fast synchronous path)\r\n        if (_formatterCache.TryFormat(item, out var formatted))\r\n        {\r\n            return new ValueTask<FormattedData>(formatted);\r\n        }\r\n\r\n        // Fall back to network service if needed (slow async path)\r\n        return new ValueTask<FormattedData>(\r\n            _networkFormatter.FormatAsync(item, cancellationToken)\r\n        );\r\n    }\r\n}\r\n\r\n// Supporting types for the example\r\npublic record RawData(string Id, string Content);\r\npublic record FormattedData(string Id, string FormattedContent, DateTime ProcessedAt);\r\n\r\n// Interfaces for dependencies\r\npublic interface IFormatterCache\r\n{\r\n    bool TryFormat(RawData data, out FormattedData formatted);\r\n}\r\n\r\npublic interface INetworkFormatterService\r\n{\r\n    Task<FormattedData> FormatAsync(RawData data, CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"critical-constraints-when-not-to-use-valuetask",children:"Critical Constraints: When NOT to Use ValueTask"}),"\n",(0,a.jsx)(n.p,{children:"While ValueTask is powerful, it comes with strict constraints. Understanding these is essential for correctness."}),"\n",(0,a.jsx)(n.h3,{id:"never-await-more-than-once",children:"Never Await More Than Once"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"The Rule:"})," You can only ",(0,a.jsx)(n.code,{children:"await"})," a ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," exactly once. Multiple awaits on same ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," are undefined behavior and will cause exceptions or incorrect results."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// INCORRECT - DO NOT DO THIS\r\nvar valueTask = GetValueAsync("key");\r\nvar result1 = await valueTask;  // First await - OK\r\nvar result2 = await valueTask;  // Second await - UNDEFINED BEHAVIOR (exception or wrong result)\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Why?"})," The struct-based nature of ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," means its state is mutable. After first await completes, internal state is consumed. A second await has nowhere to go."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Correct usage:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// CORRECT\r\nvar result1 = await GetValueAsync("key");\r\nvar result2 = await GetValueAsync("key"); // Call method again\n'})}),"\n",(0,a.jsx)(n.h3,{id:"avoid-when-always-asynchronous",children:"Avoid When Always Asynchronous"}),"\n",(0,a.jsxs)(n.p,{children:["If your method ",(0,a.jsx)(n.strong,{children:"always"})," performs async work\u2014never returns synchronously\u2014there's no benefit to ",(0,a.jsx)(n.code,{children:"ValueTask<T>"}),". The wrapper adds complexity without any allocation savings."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// WRONG - Always async, so no benefit\r\npublic ValueTask<int> ComputeExpensiveAsync()\r\n{\r\n    return new ValueTask<int>(ExpensiveComputationAsync());\r\n}\r\n\r\n// CORRECT - Use Task for always async operations\r\npublic Task<int> ComputeExpensiveAsync()\r\n{\r\n    return ExpensiveComputationAsync();\r\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"In this case, synchronous fast path never exists, so you're just adding complexity."}),"\n",(0,a.jsx)(n.h3,{id:"consider-public-apis-carefully",children:"Consider Public APIs Carefully"}),"\n",(0,a.jsxs)(n.p,{children:["If this is a public API that external callers will use, consider using ",(0,a.jsx)(n.code,{children:"Task<T>"})," instead. Your callers need to understand constraints of ",(0,a.jsx)(n.code,{children:"ValueTask<T>"})," (single await, no ConfigureAwait) to use it correctly. If those constraints aren't explicitly documented and understood, you may create subtle bugs in calling code."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// If this is internal or well-documented, ValueTask is fine\r\ninternal ValueTask<int> GetItemAsync(string key)\r\n{\r\n    // ...\r\n}\r\n\r\n// If this is public, consider whether ValueTask constraints are worth performance gain\r\n// or whether Task is safer choice for API stability\r\npublic Task<int> GetItemAsync(string key)\r\n{\r\n    // Simpler contract, no surprise constraints\r\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"configureawait-not-supported",children:"ConfigureAwait Not Supported"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"ValueTask<T>"})," does not support ",(0,a.jsx)(n.code,{children:"ConfigureAwait()"}),". If your code requires ",(0,a.jsx)(n.code,{children:"ConfigureAwait(false)"})," for library code or UI synchronization context handling, you cannot use ",(0,a.jsx)(n.code,{children:"ValueTask<T>"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// WRONG - ConfigureAwait not supported on ValueTask\r\nvar result = await GetValueAsync().ConfigureAwait(false);\r\n\r\n// CORRECT if you need ConfigureAwait\r\npublic Task<string> GetValueAsync()\r\n{\r\n    return FetchAsync().ConfigureAwait(false);\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Hygiene"})," - Comprehensive performance best practices"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts/nodes/transform-nodes",children:"Transform Nodes"})," - Node implementation details and ValueTask optimization patterns"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/architecture/optimization-principles",children:"Optimization Principles"})," - Understanding why ValueTask improves performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../../samples/Sample_02_HighPerformanceTransform/",children:"Sample: High-Performance Transforms"})," - Complete working example"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/execution-strategies",children:"Execution Strategies"})," - How ValueTask integrates with execution strategies"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling-guide",children:"Error Handling Guide"})," - Error handling with ValueTask patterns"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Hygiene"})," - Comprehensive performance best practices"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts/nodes/transform-nodes",children:"Transform Nodes"})," - Node implementation details and ValueTask optimization patterns"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/architecture/optimization-principles",children:"Optimization Principles"})," - Understanding why ValueTask improves performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../../samples/Sample_02_HighPerformanceTransform/",children:"Sample: High-Performance Transforms"})," - Complete working example"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/execution-strategies",children:"Execution Strategies"})," - How ValueTask integrates with execution strategies"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);