"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[5826],{28453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>d});var i=r(96540);const l={},s=i.createContext(l);function t(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),i.createElement(s.Provider,{value:n},e.children)}},29551:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>u,frontMatter:()=>t,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"core-concepts/pipeline-validation","title":"Pipeline Validation Extensions - Usage Guide","description":"The PipelineBuilderValidationExtensions class provides fluent methods for validating and analyzing pipeline structures before building. This enables early error detection and helps with debugging complex pipelines.","source":"@site/docs/core-concepts/pipeline-validation.md","sourceDirName":"core-concepts","slug":"/core-concepts/pipeline-validation","permalink":"/docs/core-concepts/pipeline-validation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Best Practices","permalink":"/docs/core-concepts/best-practices"},"next":{"title":"Thread Safety Guidelines","permalink":"/docs/core-concepts/thread-safety"}}');var l=r(74848),s=r(28453);const t={},d="Pipeline Validation Extensions - Usage Guide",a={},o=[{value:"Available Methods",id:"available-methods",level:2},{value:"1. <code>Validate()</code> - Validate Pipeline Structure",id:"1-validate---validate-pipeline-structure",level:3},{value:"2. <code>CanConnect&lt;TData&gt;()</code> - Pre-Check Connection Validity",id:"2-canconnecttdata---pre-check-connection-validity",level:3},{value:"3. <code>ToMermaidDiagram()</code> - Generate Visual Diagram",id:"3-tomermaiddiagram---generate-visual-diagram",level:3},{value:"4. <code>Describe()</code> - Get Text Description",id:"4-describe---get-text-description",level:3},{value:"Validation Results Structure",id:"validation-results-structure",level:2},{value:"Validation Rules Overview",id:"validation-rules-overview",level:2},{value:"Core Rules (Always Applied)",id:"core-rules-always-applied",level:3},{value:"Extended Rules (Enabled by Default)",id:"extended-rules-enabled-by-default",level:3},{value:"Resilience Configuration Rule Details",id:"resilience-configuration-rule-details",level:3},{value:"Parallel Configuration Rule Details",id:"parallel-configuration-rule-details",level:3},{value:"Validation Workflow &amp; Patterns",id:"validation-workflow--patterns",level:2},{value:"Quick Reference: Validation Methods",id:"quick-reference-validation-methods",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Extended Validation with Advanced Features",id:"extended-validation-with-advanced-features",level:3},{value:"Error Handling Strategy",id:"error-handling-strategy",level:2},{value:"Performance Notes",id:"performance-notes",level:2},{value:"Integration with Build Validation",id:"integration-with-build-validation",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"pipeline-validation-extensions---usage-guide",children:"Pipeline Validation Extensions - Usage Guide"})}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"PipelineBuilderValidationExtensions"})," class provides fluent methods for validating and analyzing pipeline structures before building. This enables early error detection and helps with debugging complex pipelines."]}),"\n",(0,l.jsx)(n.h2,{id:"available-methods",children:"Available Methods"}),"\n",(0,l.jsxs)(n.h3,{id:"1-validate---validate-pipeline-structure",children:["1. ",(0,l.jsx)(n.code,{children:"Validate()"})," - Validate Pipeline Structure"]}),"\n",(0,l.jsx)(n.p,{children:"Validates the current pipeline structure without building the complete pipeline."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'var builder = new PipelineBuilder()\r\n    .AddSource<MySource, int>("source")\r\n    .AddTransform<MyTransform, int, string>("transform")\r\n    .AddSink<MySink, string>("sink");\r\n\r\nbuilder.Connect("source", "transform");\r\nbuilder.Connect("transform", "sink");\r\n\r\n// Validate before building\r\nvar result = builder.Validate();\r\nif (!result.IsValid)\r\n{\r\n    foreach (var error in result.Errors)\r\n        Console.WriteLine($"Error: {error}");\r\n}\r\nelse\r\n{\r\n    var pipeline = builder.Build(); // Safe to build\r\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Returns:"})," ",(0,l.jsx)(n.code,{children:"PipelineValidationResult"})," containing:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"IsValid"}),": Boolean indicating if all errors passed"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Errors"}),": List of error messages"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Warnings"}),": List of warning messages"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Issues"}),": Complete list of validation issues with severity and category"]}),"\n"]}),"\n",(0,l.jsxs)(n.h3,{id:"2-canconnecttdata---pre-check-connection-validity",children:["2. ",(0,l.jsx)(n.code,{children:"CanConnect<TData>()"})," - Pre-Check Connection Validity"]}),"\n",(0,l.jsx)(n.p,{children:"Checks if a connection between two nodes is valid before adding it to the pipeline."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'var builder = new PipelineBuilder();\r\nvar source = builder.AddSource<MySource, int>("source");\r\nvar transform = builder.AddTransform<MyTransform, int, string>("transform");\r\n\r\n// Check if connection is valid\r\nif (builder.CanConnect(source, transform, out var reason))\r\n{\r\n    builder.Connect(source, transform);\r\n}\r\nelse\r\n{\r\n    Console.WriteLine($"Cannot connect: {reason}");\r\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Checks:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Type compatibility between source output and target input"}),"\n",(0,l.jsx)(n.li,{children:"Whether the connection would create a cycle"}),"\n",(0,l.jsx)(n.li,{children:"Whether both nodes exist in the builder"}),"\n",(0,l.jsx)(n.li,{children:"Self-loop detection"}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Returns:"})," Boolean indicating validity, with optional reason string explaining why the connection is invalid."]}),"\n",(0,l.jsxs)(n.h3,{id:"3-tomermaiddiagram---generate-visual-diagram",children:["3. ",(0,l.jsx)(n.code,{children:"ToMermaidDiagram()"})," - Generate Visual Diagram"]}),"\n",(0,l.jsx)(n.p,{children:"Generates a Mermaid flowchart diagram of the current pipeline structure."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'var builder = new PipelineBuilder()\r\n    .AddSource<MySource, int>("source")\r\n    .AddTransform<MyTransform, int, string>("transform")\r\n    .AddSink<MySink, string>("sink");\r\n\r\nbuilder.Connect("source", "transform");\r\nbuilder.Connect("transform", "sink");\r\n\r\nvar mermaid = builder.ToMermaidDiagram();\r\nConsole.WriteLine(mermaid);\r\n\r\n/* Output:\r\ngraph TD\r\n    source["source : Source"]\r\n    transform["transform : Transform"]\r\n    sink["sink : Sink"]\r\n    source --\x3e transform\r\n    transform --\x3e sink\r\n*/\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Visualize complex pipelines in Mermaid Live Editor"}),"\n",(0,l.jsx)(n.li,{children:"Generate documentation diagrams"}),"\n",(0,l.jsx)(n.li,{children:"Debug pipeline structure visually"}),"\n",(0,l.jsx)(n.li,{children:"Share pipeline designs in GitHub/documentation"}),"\n"]}),"\n",(0,l.jsxs)(n.h3,{id:"4-describe---get-text-description",children:["4. ",(0,l.jsx)(n.code,{children:"Describe()"})," - Get Text Description"]}),"\n",(0,l.jsx)(n.p,{children:"Gets a human-readable textual description of the current pipeline structure."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'var builder = new PipelineBuilder()\r\n    .AddSource<MySource, int>("source")\r\n    .AddSink<MySink, string>("sink");\r\n\r\nbuilder.Connect("source", "sink");\r\n\r\nvar description = builder.Describe();\r\nConsole.WriteLine(description);\r\n\r\n/* Output:\r\nNodes:\r\n  source | source | Source | MySource | In=-, Out=System.Int32\r\n  sink | sink | Sink | MySink | In=System.String, Out=-\r\n\r\nEdges:\r\n  source --\x3e sink\r\n*/\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Debugging and logging pipeline structures"}),"\n",(0,l.jsx)(n.li,{children:"Text-based reports"}),"\n",(0,l.jsx)(n.li,{children:"Console output for pipeline analysis"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"validation-results-structure",children:"Validation Results Structure"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"public sealed record PipelineValidationResult(ImmutableList<ValidationIssue> Issues)\r\n{\r\n    // Built-in properties\r\n    public bool IsValid => Issues.All(i => i.Severity != ValidationSeverity.Error);\r\n    public ImmutableList<string> Errors => Issues\r\n        .Where(i => i.Severity == ValidationSeverity.Error)\r\n        .Select(i => i.Message)\r\n        .ToImmutableList();\r\n    public ImmutableList<string> Warnings => Issues\r\n        .Where(i => i.Severity == ValidationSeverity.Warning)\r\n        .Select(i => i.Message)\r\n        .ToImmutableList();\r\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"validation-rules-overview",children:"Validation Rules Overview"}),"\n",(0,l.jsxs)(n.p,{children:["NPipeline includes comprehensive validation rules that run automatically during pipeline building and validation. Rules are categorized as ",(0,l.jsx)(n.strong,{children:"core"})," (always applied) and ",(0,l.jsx)(n.strong,{children:"extended"})," (enabled by default, opt-out via ",(0,l.jsx)(n.code,{children:"WithoutExtendedValidation()"}),")."]}),"\n",(0,l.jsx)(n.h3,{id:"core-rules-always-applied",children:"Core Rules (Always Applied)"}),"\n",(0,l.jsx)(n.p,{children:"These rules prevent invalid pipeline construction and are always checked:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"UniqueNodeNameRule"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Ensures all node names within a pipeline are unique"}),"\n",(0,l.jsx)(n.li,{children:"Prevents confusion and naming conflicts"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Severity:"})," Error"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"DuplicateNodeIdRule"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Prevents duplicate node IDs from being added to the same pipeline"}),"\n",(0,l.jsx)(n.li,{children:"Node IDs must be unique for proper graph traversal"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Severity:"})," Error"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"EdgeReferenceRule"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Validates that all edges reference valid, existing nodes"}),"\n",(0,l.jsx)(n.li,{children:"Prevents dangling connections or references to non-existent nodes"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Severity:"})," Error"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"SourceAndReachabilityRule"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Ensures at least one source node exists in the pipeline"}),"\n",(0,l.jsx)(n.li,{children:"Verifies all nodes are reachable from at least one source node"}),"\n",(0,l.jsx)(n.li,{children:"Prevents unreachable/orphaned nodes"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Severity:"})," Error"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"CycleDetectionRule"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Enforces that the pipeline graph is acyclic (DAG - Directed Acyclic Graph)"}),"\n",(0,l.jsx)(n.li,{children:"Detects circular dependencies in pipeline topology"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Severity:"})," Error"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"extended-rules-enabled-by-default",children:"Extended Rules (Enabled by Default)"}),"\n",(0,l.jsxs)(n.p,{children:["Extended rules are ",(0,l.jsx)(n.strong,{children:"enabled by default"})," to provide additional guidance on best practices and potential issues. Use ",(0,l.jsx)(n.code,{children:"builder.WithoutExtendedValidation()"})," to disable them if maximum build performance is critical:"]}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"MissingSinkRule"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Warns if the pipeline has no sink nodes"}),"\n",(0,l.jsx)(n.li,{children:"Sinks are typically needed to consume pipeline output"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Severity:"})," Warning"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"When to Enable:"})," Development and testing to catch incomplete pipelines"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"SelfLoopRule"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Detects when a node is connected to itself"}),"\n",(0,l.jsx)(n.li,{children:"Self-loops are rarely intentional and usually indicate errors"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Severity:"})," Warning"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"DuplicateEdgeRule"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Prevents duplicate connections between the same pair of nodes"}),"\n",(0,l.jsx)(n.li,{children:"Multiple connections between two nodes serve no purpose"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Severity:"})," Warning"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"MultiInboundNonJoinRule"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Warns if non-join nodes have multiple input connections"}),"\n",(0,l.jsx)(n.li,{children:"Only join nodes are designed to handle multiple inputs"}),"\n",(0,l.jsx)(n.li,{children:"Other node types expect a single input stream"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Severity:"})," Warning"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"TypeCompatibilityRule"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Validates that output types from source nodes match input types of target nodes"}),"\n",(0,l.jsx)(n.li,{children:"Ensures data flows correctly through the pipeline without type mismatches"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Severity:"})," Error"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"ResilienceConfigurationRule"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Validates that nodes using ",(0,l.jsx)(n.code,{children:"ResilientExecutionStrategy"})," are properly configured for node restarts"]}),"\n",(0,l.jsx)(n.li,{children:"Checks for error handlers, retry options, and materialization limits"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Severity:"})," Warning"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"When to Enable:"})," When using resilience features for node restart capability"]}),"\n",(0,l.jsxs)(n.li,{children:["See ",(0,l.jsx)(n.a,{href:"#resilience-configuration-rule-details",children:"Resilience Configuration Rule Details"})," below for details"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"ParallelConfigurationRule"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Validates that nodes using parallel execution have appropriate queue and parallelism settings"}),"\n",(0,l.jsx)(n.li,{children:"Detects potential memory issues and performance antipatterns"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Severity:"})," Warning"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"When to Enable:"})," When using parallel execution for CPU-bound or I/O-bound workloads"]}),"\n",(0,l.jsxs)(n.li,{children:["See ",(0,l.jsx)(n.a,{href:"#parallel-configuration-rule-details",children:"Parallel Configuration Rule Details"})," below for details"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"resilience-configuration-rule-details",children:"Resilience Configuration Rule Details"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Purpose:"})," Ensures nodes using ",(0,l.jsx)(n.code,{children:"ResilientExecutionStrategy"})," are fully configured for proper restart behavior."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Why This Matters:"})," Partial resilience configuration silently disables node restarts, allowing the entire pipeline to fail instead of recovering individual nodes. This can lead to unexplained pipeline crashes in production."]}),"\n",(0,l.jsxs)(n.p,{children:["For nodes with ",(0,l.jsx)(n.code,{children:"ResilientExecutionStrategy"}),", validates:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Error Handler"})," - ",(0,l.jsx)(n.code,{children:"IPipelineErrorHandler"})," is registered (required for restart decisions)"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Error handler makes the decision to restart, retry, skip, or fail on exceptions"}),"\n",(0,l.jsx)(n.li,{children:"Missing error handler means restarts can never be triggered"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Restart Attempts"})," - ",(0,l.jsx)(n.code,{children:"MaxNodeRestartAttempts > 0"})," is configured"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Controls how many times a node can be restarted"}),"\n",(0,l.jsx)(n.li,{children:"Must be greater than 0 to enable restarts"}),"\n",(0,l.jsx)(n.li,{children:"Value of 0 disables restart functionality silently"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Materialization"})," - ",(0,l.jsx)(n.code,{children:"MaxMaterializedItems"})," is positive (not null or zero) to prevent unbounded memory"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Streaming inputs must be materialized before retry to preserve them for restart"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"null"})," (unbounded) disables materialization and makes restarts impossible"]}),"\n",(0,l.jsx)(n.li,{children:"Zero or negative values are treated as disabled"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Retry Configuration"})," - Retry options are set at graph or node level"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Ensures at least one layer of retry configuration exists"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"When Validation Occurs:"})," During ",(0,l.jsx)(n.code,{children:"Build()"})," or ",(0,l.jsx)(n.code,{children:"Validate()"})," calls with extended validation enabled (default)."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Severity:"})," Warning (does not prevent build, but indicates likely misconfiguration)."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Example Problems and Solutions:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'// PROBLEM: ResilientExecutionStrategy without error handler\r\nvar resilientTransform = builder.AddTransform<MyTransform, int, string>("transform")\r\n    .WithExecutionStrategy(builder, new ResilientExecutionStrategy(...));\r\n// Missing: builder.AddPipelineErrorHandler<MyErrorHandler>();\r\nbuilder.Validate(); // WARNING: Error handler not configured\r\n\r\n// SOLUTION: Configure all three prerequisites\r\nbuilder.AddPipelineErrorHandler<MyErrorHandler>();\r\nbuilder.WithRetryOptions(opts => opts.With(\r\n    maxNodeRestartAttempts: 3,\r\n    maxMaterializedItems: 1000));\r\nvar resilientTransform = builder.AddTransform<MyTransform, int, string>("transform")\r\n    .WithExecutionStrategy(builder, new ResilientExecutionStrategy(...));\r\nbuilder.Validate(); // OK: All prerequisites configured\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Quick Fix Checklist:"})}),"\n",(0,l.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,l.jsxs)(n.li,{className:"task-list-item",children:[(0,l.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Apply ",(0,l.jsx)(n.code,{children:"ResilientExecutionStrategy"})," to nodes that need restart capability"]}),"\n",(0,l.jsxs)(n.li,{className:"task-list-item",children:[(0,l.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Register an ",(0,l.jsx)(n.code,{children:"IPipelineErrorHandler"})," implementation"]}),"\n",(0,l.jsxs)(n.li,{className:"task-list-item",children:[(0,l.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Set ",(0,l.jsx)(n.code,{children:"MaxNodeRestartAttempts > 0"})," (typically 2-3)"]}),"\n",(0,l.jsxs)(n.li,{className:"task-list-item",children:[(0,l.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Set ",(0,l.jsx)(n.code,{children:"MaxMaterializedItems"})," to a positive value based on item size (typically 100-10000)"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"See Also:"})," ",(0,l.jsx)(n.a,{href:"./resilience/getting-started",children:"Getting Started with Resilience"}),", ",(0,l.jsx)(n.a,{href:"../../architecture/error-handling-architecture",children:"Resilience Architecture"})]}),"\n",(0,l.jsx)(n.h3,{id:"parallel-configuration-rule-details",children:"Parallel Configuration Rule Details"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Purpose:"})," Ensures nodes using parallel execution have appropriate queue and threading settings to prevent resource exhaustion and performance degradation."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Why This Matters:"})," Misconfigured parallelism can cause:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Unbounded memory growth"})," when queue limits aren't set"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"High latency and buffering"})," when ordering is preserved with excessive parallelism"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Thread pool starvation"})," when parallelism is too high"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Silent performance degradation"})," when drop policies are used without bounded queues"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"For nodes with parallel execution, validates:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Queue Limits"})," - No high parallelism (>4) without ",(0,l.jsx)(n.code,{children:"MaxQueueLength"})," to prevent unbounded memory growth"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"High parallelism without queue limits allows unlimited items in memory"}),"\n",(0,l.jsx)(n.li,{children:"Items accumulate if downstream processing is slower than upstream production"}),"\n",(0,l.jsxs)(n.li,{children:["Recommended: Set ",(0,l.jsx)(n.code,{children:"MaxQueueLength"})," to 2-10x your parallelism level"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Order Preservation"})," - Warns if high parallelism (>8) with ",(0,l.jsx)(n.code,{children:"PreserveOrdering: true"})," causes buffering/latency"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Preserving order with high parallelism requires buffering all out-of-order items"}),"\n",(0,l.jsx)(n.li,{children:"Causes significant memory overhead and latency"}),"\n",(0,l.jsxs)(n.li,{children:["Recommended: Set ",(0,l.jsx)(n.code,{children:"PreserveOrdering: false"})," unless order is critical"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Drop Policies"})," - Detects ",(0,l.jsx)(n.code,{children:"MaxQueueLength: null"})," with drop policies (policy would have no effect)"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Drop policies (",(0,l.jsx)(n.code,{children:"DropOldest"}),", ",(0,l.jsx)(n.code,{children:"DropNewest"}),") only work with bounded queues"]}),"\n",(0,l.jsxs)(n.li,{children:["Setting a drop policy without ",(0,l.jsx)(n.code,{children:"MaxQueueLength"})," is ineffective"]}),"\n",(0,l.jsxs)(n.li,{children:["Recommended: Either set ",(0,l.jsx)(n.code,{children:"MaxQueueLength"})," or use ",(0,l.jsx)(n.code,{children:"Block"})," policy"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Thread Explosion"})," - Warns if parallelism exceeds ",(0,l.jsx)(n.code,{children:"ProcessorCount * 4"})]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Excessive parallelism may indicate configuration error or unusual workload"}),"\n",(0,l.jsx)(n.li,{children:"General guideline: Parallelism should be 1-4x processor count for most workloads"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"When Validation Occurs:"})," During ",(0,l.jsx)(n.code,{children:"Build()"})," or ",(0,l.jsx)(n.code,{children:"Validate()"})," calls with extended validation enabled (default)."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Severity:"})," Warning (informational, helps prevent performance issues)."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Example Problems and Solutions:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"// PROBLEM 1: High parallelism without queue limits\r\nvar parallelOptions = new ParallelOptions(\r\n    MaxDegreeOfParallelism: 16,\r\n    MaxQueueLength: null,  // Unbounded!\r\n    QueuePolicy: BoundedQueuePolicy.Block);\r\nbuilder.SetNodeExecutionOption(transform.Id, parallelOptions);\r\nbuilder.Validate(); // WARNING: High parallelism without queue limits\r\n\r\n// SOLUTION 1: Set appropriate queue length\r\nvar parallelOptions = new ParallelOptions(\r\n    MaxDegreeOfParallelism: 16,\r\n    MaxQueueLength: 100,  // Bounded to prevent memory issues\r\n    QueuePolicy: BoundedQueuePolicy.Block);\r\nbuilder.SetNodeExecutionOption(transform.Id, parallelOptions);\r\n\r\n// PROBLEM 2: High parallelism with order preservation\r\nvar parallelOptions = new ParallelOptions(\r\n    MaxDegreeOfParallelism: 16,\r\n    MaxQueueLength: 100,\r\n    QueuePolicy: BoundedQueuePolicy.Block,\r\n    PreserveOrdering: true);  // High overhead with 16 parallel tasks!\r\nbuilder.SetNodeExecutionOption(transform.Id, parallelOptions);\r\nbuilder.Validate(); // WARNING: Order preservation causes buffering\r\n\r\n// SOLUTION 2: Disable ordering if not needed\r\nvar parallelOptions = new ParallelOptions(\r\n    MaxDegreeOfParallelism: 16,\r\n    MaxQueueLength: 100,\r\n    QueuePolicy: BoundedQueuePolicy.Block,\r\n    PreserveOrdering: false);  // Better performance\r\nbuilder.SetNodeExecutionOption(transform.Id, parallelOptions);\r\n\r\n// PROBLEM 3: Drop policy without queue length\r\nvar parallelOptions = new ParallelOptions(\r\n    MaxDegreeOfParallelism: 8,\r\n    MaxQueueLength: null,  // Unbounded - drop policy won't work!\r\n    QueuePolicy: BoundedQueuePolicy.DropOldest);\r\nbuilder.SetNodeExecutionOption(transform.Id, parallelOptions);\r\nbuilder.Validate(); // WARNING: Drop policy ineffective\r\n\r\n// SOLUTION 3: Set queue length for drop policies\r\nvar parallelOptions = new ParallelOptions(\r\n    MaxDegreeOfParallelism: 8,\r\n    MaxQueueLength: 100,  // Bounded queue for drop policy\r\n    QueuePolicy: BoundedQueuePolicy.DropOldest);\r\nbuilder.SetNodeExecutionOption(transform.Id, parallelOptions);\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Parallelism Sizing Guide:"})}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Workload Type"}),(0,l.jsx)(n.th,{children:"Recommended DOP"}),(0,l.jsx)(n.th,{children:"Queue Length"}),(0,l.jsx)(n.th,{children:"PreserveOrder"}),(0,l.jsx)(n.th,{children:"Reason"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"CPU-bound"}),(0,l.jsx)(n.td,{children:"ProcessorCount"}),(0,l.jsx)(n.td,{children:"2x-4x DOP"}),(0,l.jsx)(n.td,{children:"Only if needed"}),(0,l.jsx)(n.td,{children:"Limited by CPU resources"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"I/O-bound"}),(0,l.jsx)(n.td,{children:"2x-4x ProcessorCount"}),(0,l.jsx)(n.td,{children:"4x-10x DOP"}),(0,l.jsx)(n.td,{children:"Only if needed"}),(0,l.jsx)(n.td,{children:"Can handle more concurrent I/O"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Network"}),(0,l.jsx)(n.td,{children:"4x-8x ProcessorCount"}),(0,l.jsx)(n.td,{children:"8x-20x DOP"}),(0,l.jsx)(n.td,{children:"Only if needed"}),(0,l.jsx)(n.td,{children:"Very high latency allows more concurrency"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Memory-constrained"}),(0,l.jsx)(n.td,{children:"ProcessorCount/2"}),(0,l.jsx)(n.td,{children:"1x-2x DOP"}),(0,l.jsx)(n.td,{children:"Only if needed"}),(0,l.jsx)(n.td,{children:"Conservative allocation"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Quick Fix Checklist:"})}),"\n",(0,l.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,l.jsxs)(n.li,{className:"task-list-item",children:[(0,l.jsx)(n.input,{type:"checkbox",disabled:!0})," ","For high parallelism (>4), set ",(0,l.jsx)(n.code,{children:"MaxQueueLength"})," to 2-10x your parallelism level"]}),"\n",(0,l.jsxs)(n.li,{className:"task-list-item",children:[(0,l.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Set ",(0,l.jsx)(n.code,{children:"PreserveOrdering: false"})," unless downstream requires strict ordering"]}),"\n",(0,l.jsxs)(n.li,{className:"task-list-item",children:[(0,l.jsx)(n.input,{type:"checkbox",disabled:!0})," ","If using drop policies, ensure ",(0,l.jsx)(n.code,{children:"MaxQueueLength"})," is set to a positive value"]}),"\n",(0,l.jsxs)(n.li,{className:"task-list-item",children:[(0,l.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Monitor actual utilization to ensure parallelism matches your workload"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"See Also:"})," ",(0,l.jsx)(n.a,{href:"../../extensions/parallelism",children:"Parallel Execution Guide"}),", ",(0,l.jsx)(n.a,{href:"../../architecture/optimization-principles",children:"Performance Optimization"})]}),"\n",(0,l.jsx)(n.h2,{id:"validation-workflow--patterns",children:"Validation Workflow & Patterns"}),"\n",(0,l.jsx)(n.h3,{id:"quick-reference-validation-methods",children:"Quick Reference: Validation Methods"}),"\n",(0,l.jsx)(n.p,{children:"Use these methods during pipeline construction and testing:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"CanConnect()"})})," - Check connection validity before adding it"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"Validate()"})})," - Run all validation rules and get comprehensive results"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"ToMermaidDiagram()"})})," - Generate visual diagram for documentation"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"Describe()"})})," - Get text description for logging/debugging"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"Build()"})," / ",(0,l.jsx)(n.code,{children:"TryBuild()"})]})," - Create final pipeline after validation"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'public void BuildAndValidatePipeline()\r\n{\r\n    var builder = new PipelineBuilder();\r\n    \r\n    // Build pipeline\r\n    var source = builder.AddSource<DataSource, int>("source");\r\n    var transform = builder.AddTransform<Uppercase, int, string>("transform");\r\n    var sink = builder.AddSink<ConsoleSink, string>("sink");\r\n    \r\n    // Validate before connecting\r\n    if (!builder.CanConnect(source, transform, out var reason))\r\n    {\r\n        throw new InvalidOperationException($"Cannot connect: {reason}");\r\n    }\r\n    \r\n    builder.Connect(source, transform);\r\n    \r\n    if (!builder.CanConnect(transform, sink, out reason))\r\n    {\r\n        throw new InvalidOperationException($"Cannot connect: {reason}");\r\n    }\r\n    \r\n    builder.Connect(transform, sink);\r\n    \r\n    // Comprehensive validation\r\n    var validationResult = builder.Validate();\r\n    if (!validationResult.IsValid)\r\n    {\r\n        Console.WriteLine("Validation errors:");\r\n        foreach (var error in validationResult.Errors)\r\n            Console.WriteLine($"  - {error}");\r\n        return;\r\n    }\r\n    \r\n    // Generate visualization for documentation\r\n    var diagram = builder.ToMermaidDiagram();\r\n    File.WriteAllText("pipeline.mermaid", diagram);\r\n    \r\n    // Build and run\r\n    var pipeline = builder.Build();\r\n    // ... execute pipeline\r\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"extended-validation-with-advanced-features",children:"Extended Validation with Advanced Features"}),"\n",(0,l.jsx)(n.p,{children:"When working with resilience or parallel execution:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'public void BuildPipelineWithAdvancedFeatures()\r\n{\r\n    var builder = new PipelineBuilder();  // Extended validation enabled by default\r\n    \r\n    var source = builder.AddSource<DataSource, int>("source");\r\n    var parallelTransform = builder.AddTransform<ParallelTransform, int, string>("transform");\r\n    var resilientSink = builder.AddSink<ResilientSink, string>("sink");\r\n    \r\n    builder.Connect(source, parallelTransform);\r\n    builder.Connect(parallelTransform, resilientSink);\r\n    \r\n    // Configure parallel execution\r\n    var parallelOptions = new ParallelOptions(\r\n        MaxDegreeOfParallelism: Environment.ProcessorCount * 2,\r\n        MaxQueueLength: 100,\r\n        QueuePolicy: BoundedQueuePolicy.Block,\r\n        PreserveOrdering: false);\r\n    builder.SetNodeExecutionOption(parallelTransform.Id, parallelOptions);\r\n    \r\n    // Configure resilience\r\n    builder.AddPipelineErrorHandler<MyErrorHandler>();\r\n    builder.WithRetryOptions(opts => opts.With(\r\n        maxNodeRestartAttempts: 3,\r\n        maxMaterializedItems: 1000));\r\n    builder.WithResilience(resilientSink);\r\n    \r\n    // Validate - checks both core and extended rules\r\n    var result = builder.Validate();\r\n    if (!result.IsValid)\r\n    {\r\n        foreach (var error in result.Errors)\r\n            Console.WriteLine($"Error: {error}");\r\n        return;\r\n    }\r\n    \r\n    // Display warnings from extended rules\r\n    foreach (var warning in result.Warnings)\r\n        Console.WriteLine($"Warning: {warning}");\r\n    \r\n    var pipeline = builder.Build();\r\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"error-handling-strategy",children:"Error Handling Strategy"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Recommended Validation Pattern:"})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Build phase"})," - Use ",(0,l.jsx)(n.code,{children:"CanConnect()"})," to validate each connection as you build"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Validation phase"})," - Call ",(0,l.jsx)(n.code,{children:"Validate()"})," with appropriate rule scope (core or extended)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Diagnostic phase"})," - Use ",(0,l.jsx)(n.code,{children:"Describe()"})," or ",(0,l.jsx)(n.code,{children:"ToMermaidDiagram()"})," to understand issues"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Build phase"})," - Call ",(0,l.jsx)(n.code,{children:"Build()"})," or ",(0,l.jsx)(n.code,{children:"TryBuild()"})," for final pipeline creation"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Core vs Extended Validation:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Core rules"})," (always active) catch fundamental graph errors"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Extended rules"})," (enabled by default) guide best practices for features like resilience and parallelism"]}),"\n",(0,l.jsx)(n.li,{children:"Extended validation is recommended for development, testing, and production"}),"\n",(0,l.jsxs)(n.li,{children:["Use ",(0,l.jsx)(n.code,{children:"WithoutExtendedValidation()"})," only if maximum build performance is critical"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Validation Example with Error Handling:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'public Pipeline BuildPipelineWithErrorHandling(bool skipExtendedValidation = false)\r\n{\r\n    var builder = new PipelineBuilder();\r\n    if (skipExtendedValidation)\r\n        builder = builder.WithoutExtendedValidation();\r\n    \r\n    try\r\n    {\r\n        // Step 1: Build with connection validation\r\n        var source = builder.AddSource<MySource, int>("source");\r\n        var transform = builder.AddTransform<MyTransform, int, string>("transform");\r\n        var sink = builder.AddSink<MySink, string>("sink");\r\n        \r\n        if (!builder.CanConnect(source, transform, out var reason))\r\n            throw new InvalidOperationException($"Invalid connection: {reason}");\r\n        builder.Connect(source, transform);\r\n        \r\n        if (!builder.CanConnect(transform, sink, out reason))\r\n            throw new InvalidOperationException($"Invalid connection: {reason}");\r\n        builder.Connect(transform, sink);\r\n        \r\n        // Step 2: Comprehensive validation\r\n        var validation = builder.Validate();\r\n        if (!validation.IsValid)\r\n        {\r\n            Console.WriteLine("Validation errors:");\r\n            foreach (var error in validation.Errors)\r\n                Console.WriteLine($"  - {error}");\r\n            throw new InvalidOperationException("Pipeline validation failed");\r\n        }\r\n        \r\n        if (validation.Warnings.Count > 0)\r\n        {\r\n            Console.WriteLine("Validation warnings:");\r\n            foreach (var warning in validation.Warnings)\r\n                Console.WriteLine($"  - {warning}");\r\n        }\r\n        \r\n        // Step 3: Safe to build\r\n        return builder.Build();\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        Console.Error.WriteLine($"Pipeline creation failed: {ex.Message}");\r\n        // Generate diagnostic report\r\n        Console.Error.WriteLine("\\nPipeline structure:");\r\n        Console.Error.WriteLine(builder.Describe());\r\n        throw;\r\n    }\r\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"performance-notes",children:"Performance Notes"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Validate()"})," and ",(0,l.jsx)(n.code,{children:"Describe()"})," construct a temporary ",(0,l.jsx)(n.code,{children:"PipelineGraph"})," for analysis"]}),"\n",(0,l.jsx)(n.li,{children:"No graph freezing occurs - builder state remains mutable"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"CanConnect()"})," uses depth-first search for cycle detection (O(V+E) complexity)"]}),"\n",(0,l.jsx)(n.li,{children:"Extended validation rules add minimal overhead (typically <1ms per build)"}),"\n",(0,l.jsxs)(n.li,{children:["Use ",(0,l.jsx)(n.code,{children:"WithoutExtendedValidation()"})," only if you need maximum build performance in hot paths"]}),"\n",(0,l.jsx)(n.li,{children:"Consider caching validation results for repeated validations"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"integration-with-build-validation",children:"Integration with Build Validation"}),"\n",(0,l.jsxs)(n.p,{children:["These extensions complement the standard ",(0,l.jsx)(n.code,{children:"Build()"})," and ",(0,l.jsx)(n.code,{children:"TryBuild()"})," methods:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Validate()"})," - Early, incremental validation"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Build()"})," - Final validation with ",(0,l.jsx)(n.code,{children:"GraphValidationMode"})," settings"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"TryBuild()"})," - Non-throwing validation wrapper"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Use extensions during development; rely on ",(0,l.jsx)(n.code,{children:"Build()"})," for final pipeline creation."]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}}}]);