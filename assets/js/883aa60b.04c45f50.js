"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3668],{28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>d});var s=i(96540);const r={},l=s.createContext(r);function t(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(l.Provider,{value:n},e.children)}},82934:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>p,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"core-concepts/defining-pipelines","title":"Defining Pipelines","description":"Learn how to define and construct your data pipelines using both the fluent PipelineBuilder API and class-based IPipelineDefinition approach.","source":"@site/docs/core-concepts/defining-pipelines.md","sourceDirName":"core-concepts","slug":"/core-concepts/defining-pipelines","permalink":"/docs/core-concepts/defining-pipelines","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Defining Pipelines","description":"Learn how to define and construct your data pipelines using both the fluent PipelineBuilder API and class-based IPipelineDefinition approach.","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Dead-Letter Queues","permalink":"/docs/core-concepts/resilience/dead-letter-queues"},"next":{"title":"Pipeline Definition (IPipelineDefinition, PipelineBuilder)","permalink":"/docs/core-concepts/pipeline-definition"}}');var r=i(74848),l=i(28453);const t={title:"Defining Pipelines",description:"Learn how to define and construct your data pipelines using both the fluent PipelineBuilder API and class-based IPipelineDefinition approach.",sidebar_position:5},d="Defining Pipelines",o={},c=[{value:"The PipelineBuilder: Fluent API (Recommended for Most Cases)",id:"the-pipelinebuilder-fluent-api-recommended-for-most-cases",level:2},{value:"The Core Workflow",id:"the-core-workflow",level:3},{value:"Key Methods",id:"key-methods",level:3},{value:"Basic Example",id:"basic-example",level:3},{value:"When to Use PipelineBuilder",id:"when-to-use-pipelinebuilder",level:3},{value:"The IPipelineDefinition: Class-Based Approach (For Reusable, Complex Pipelines)",id:"the-ipipelinedefinition-class-based-approach-for-reusable-complex-pipelines",level:2},{value:"Interface Definition",id:"interface-definition",level:3},{value:"Advantages of Class-Based Definitions",id:"advantages-of-class-based-definitions",level:3},{value:"Example with Dependency Injection",id:"example-with-dependency-injection",level:3},{value:"Choosing Your Approach",id:"choosing-your-approach",level:2},{value:"Decision Guide",id:"decision-guide",level:3},{value:"Executing Your Pipelines",id:"executing-your-pipelines",level:2},{value:"Related Topics",id:"related-topics",level:2},{value:"Next Steps",id:"next-steps",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"defining-pipelines",children:"Defining Pipelines"})}),"\n",(0,r.jsxs)(n.p,{children:["Defining a pipeline in NPipeline involves specifying the sequence of nodes and how they connect. NPipeline provides two complementary approaches: the fluent ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"PipelineBuilder"})})," API for direct, expressive construction, and the ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"IPipelineDefinition"})})," interface for class-based, reusable definitions."]}),"\n",(0,r.jsx)(n.h2,{id:"the-pipelinebuilder-fluent-api-recommended-for-most-cases",children:"The PipelineBuilder: Fluent API (Recommended for Most Cases)"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"PipelineBuilder"})," is a fluent API that provides a simple and expressive way to define the structure of your data pipeline. It is the primary tool for adding nodes, connecting them, and compiling the final, runnable ",(0,r.jsx)(n.code,{children:"IPipeline"})," instance."]}),"\n",(0,r.jsx)(n.h3,{id:"the-core-workflow",children:"The Core Workflow"}),"\n",(0,r.jsxs)(n.p,{children:["Building a pipeline with ",(0,r.jsx)(n.code,{children:"PipelineBuilder"})," involves three main steps:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Add Nodes"}),": Use methods like ",(0,r.jsx)(n.code,{children:"AddSource"}),", ",(0,r.jsx)(n.code,{children:"AddTransform"}),", and ",(0,r.jsx)(n.code,{children:"AddSink"})," to register the processing units of your pipeline."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Connect Nodes"}),": Use the ",(0,r.jsx)(n.code,{children:"Connect"})," method to define the flow of data between the nodes you have added."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Build the Pipeline"}),": Call the ",(0,r.jsx)(n.code,{children:"Build"})," method to validate your configuration and create an executable ",(0,r.jsx)(n.code,{children:"IPipeline"})," instance."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-methods",children:"Key Methods"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"new PipelineBuilder()"}),": Creates a new pipeline builder instance."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"AddSource<TNode, TOut>(name)"}),": Adds a source node to the pipeline and returns a handle."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"AddTransform<TNode, TIn, TOut>(name)"}),": Adds a transform node and returns a handle. The input type ",(0,r.jsx)(n.code,{children:"TIn"})," must match the output type of the connected source."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"AddSink<TNode, TIn>(name)"}),": Adds a sink node and returns a handle. The input type ",(0,r.jsx)(n.code,{children:"TIn"})," must match the output type of the connected node."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Connect(handle1, handle2)"}),": Connects two node handles in the pipeline."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Build()"}),": Finalizes the pipeline definition and returns a ",(0,r.jsx)(n.code,{children:"Pipeline"})," instance ready for execution."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"basic-example",children:"Basic Example"}),"\n",(0,r.jsxs)(n.p,{children:["Let's walk through a complete example using PipelineBuilder within an ",(0,r.jsx)(n.code,{children:"IPipelineDefinition"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\nusing NPipeline.Nodes;\nusing NPipeline.Pipeline;\n\n// Define your custom nodes\npublic sealed class HelloWorldSource : SourceNode<string>\n{\n    public override IDataPipe<string> Initialize(PipelineContext context, CancellationToken cancellationToken)\n    {\n        return new StreamingDataPipe<string>(GenerateMessages());\n\n        static async IAsyncEnumerable<string> GenerateMessages()\n        {\n            string[] messages = { "Hello", "World", "from", "NPipeline" };\n            \n            foreach (var message in messages)\n            {\n                yield return message;\n                await Task.Delay(100, cancellationToken);\n            }\n        }\n    }\n}\n\npublic sealed class UppercaseTransform : ITransformNode<string, string>\n{\n    public Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        var uppercase = item.ToUpperInvariant();\n        return Task.FromResult(uppercase);\n    }\n}\n\npublic sealed class ConsoleSink : ISinkNode<string>\n{\n    public async Task ExecuteAsync(IDataPipe<string> input, PipelineContext context, CancellationToken cancellationToken)\n    {\n        await foreach (var message in input.WithCancellation(cancellationToken))\n        {\n            Console.WriteLine(message);\n        }\n    }\n}\n\n// Define the pipeline using the fluent PipelineBuilder API\npublic sealed class HelloWorldPipelineDefinition : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        // Step 1: Add nodes and store their handles\n        var sourceHandle = builder.AddSource<HelloWorldSource, string>("message_source");\n        var transformHandle = builder.AddTransform<UppercaseTransform, string, string>("uppercase_transform");\n        var sinkHandle = builder.AddSink<ConsoleSink, string>("console_sink");\n\n        // Step 2: Connect nodes to define data flow\n        builder.Connect(sourceHandle, transformHandle);\n        builder.Connect(transformHandle, sinkHandle);\n\n        // Step 3: Build pipeline (implicit when RunAsync is called by PipelineRunner)\n    }\n}\n\npublic static class Program\n{\n    public static async Task Main(string[] args)\n    {\n        // Create pipeline runner to execute the defined pipeline\n        var runner = PipelineRunner.Create();\n        \n        // Run the pipeline using the definition\n        await runner.RunAsync<HelloWorldPipelineDefinition>();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-pipelinebuilder",children:"When to Use PipelineBuilder"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simple to moderate pipelines"}),": For straightforward data flows with a manageable number of nodes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Quick prototyping"}),": When you want to get a pipeline running quickly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fluent, expressive API"}),": When you prefer readable, method-chaining style code"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ad-hoc definitions"}),": When the pipeline structure is unlikely to be reused"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"the-ipipelinedefinition-class-based-approach-for-reusable-complex-pipelines",children:"The IPipelineDefinition: Class-Based Approach (For Reusable, Complex Pipelines)"}),"\n",(0,r.jsxs)(n.p,{children:["For more complex or reusable pipeline structures, you can define your pipeline by implementing the ",(0,r.jsx)(n.code,{children:"IPipelineDefinition"})," interface. This allows you to encapsulate the pipeline's structure within a dedicated class, making it easier to manage, test, and integrate with dependency injection frameworks."]}),"\n",(0,r.jsx)(n.h3,{id:"interface-definition",children:"Interface Definition"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public interface IPipelineDefinition\n{\n    void Define(PipelineBuilder builder, PipelineContext context);\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"Define"})}),": This method is where you add your sources, transforms, and sinks to the provided ",(0,r.jsx)(n.code,{children:"builder"}),". The ",(0,r.jsx)(n.code,{children:"context"})," parameter allows for dynamic pipeline construction based on runtime parameters or injected dependencies."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"advantages-of-class-based-definitions",children:"Advantages of Class-Based Definitions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Separation of Concerns"}),": Keeps pipeline logic separate from execution code"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reusability"}),": Define once, execute multiple times with different configurations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Testability"}),": Easier to unit test pipeline structure independently"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dependency Injection"}),": Seamlessly integrates with DI containers for injecting node dependencies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Complex Pipelines"}),": Better organization for pipelines with many branches, joins, or conditional logic"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-with-dependency-injection",children:"Example with Dependency Injection"}),"\n",(0,r.jsxs)(n.p,{children:["Here's how you can use ",(0,r.jsx)(n.code,{children:"IPipelineDefinition"})," with dependency injection:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'using Microsoft.Extensions.DependencyInjection;\nusing NPipeline;\nusing NPipeline.Pipeline;\n\npublic sealed class MyPipelineDefinition : IPipelineDefinition\n{\n    private readonly ILogger<MyPipelineDefinition> _logger;\n    private readonly IDataService _dataService;\n\n    // Inject dependencies\n    public MyPipelineDefinition(ILogger<MyPipelineDefinition> logger, IDataService dataService)\n    {\n        _logger = logger;\n        _dataService = dataService;\n    }\n\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        _logger.LogInformation("Defining pipeline with injected dependencies");\n\n        // Use injected services to configure nodes\n        var sourceHandle = builder.AddSource<ConfiguredSource, Data>();\n        var transformHandle = builder.AddTransform<DependentTransform, Data, ProcessedData>();\n        var sinkHandle = builder.AddSink<DatabaseSink, ProcessedData>();\n\n        builder.Connect(sourceHandle, transformHandle);\n        builder.Connect(transformHandle, sinkHandle);\n    }\n}\n\npublic static class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var services = new ServiceCollection();\n        \n        // Register pipeline and its dependencies\n        services.AddLogging();\n        services.AddScoped<IDataService, DataService>();\n        services.AddScoped<IPipelineDefinition, MyPipelineDefinition>();\n\n        var provider = services.BuildServiceProvider();\n        \n        // Create runner and execute\n        var runner = PipelineRunner.Create();\n        await runner.RunAsync<MyPipelineDefinition>();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"choosing-your-approach",children:"Choosing Your Approach"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"PipelineBuilder"}),(0,r.jsx)(n.th,{children:"IPipelineDefinition"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Use When"})}),(0,r.jsx)(n.td,{children:"Simple pipelines, quick prototyping"}),(0,r.jsx)(n.td,{children:"Complex pipelines, reusable definitions, Dependency Injection (DI) needed"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Code Style"})}),(0,r.jsx)(n.td,{children:"Fluent, expressive"}),(0,r.jsx)(n.td,{children:"Class-based, organized"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Testability"})}),(0,r.jsx)(n.td,{children:"Moderate"}),(0,r.jsx)(n.td,{children:"Excellent (isolated test fixtures)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Dependency Injection"})}),(0,r.jsx)(n.td,{children:"Possible but awkward"}),(0,r.jsx)(n.td,{children:"Natural, seamless integration"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Reusability"})}),(0,r.jsx)(n.td,{children:"Limited"}),(0,r.jsx)(n.td,{children:"Excellent"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Learning Curve"})}),(0,r.jsx)(n.td,{children:"Gentle"}),(0,r.jsx)(n.td,{children:"Moderate"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"decision-guide",children:"Decision Guide"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Use ",(0,r.jsx)(n.code,{children:"PipelineBuilder"})," directly if:"]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Your pipeline is simple or moderate in complexity"}),"\n",(0,r.jsx)(n.li,{children:"You're building a one-off data processing task"}),"\n",(0,r.jsx)(n.li,{children:"You prefer fluent, method-chaining style code"}),"\n",(0,r.jsx)(n.li,{children:"You want to get started quickly"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Use ",(0,r.jsx)(n.code,{children:"IPipelineDefinition"})," if:"]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Your pipeline will be used in multiple places"}),"\n",(0,r.jsx)(n.li,{children:"You have complex branching, joining, or conditional logic"}),"\n",(0,r.jsx)(n.li,{children:"You want to inject dependencies (loggers, services, configuration)"}),"\n",(0,r.jsx)(n.li,{children:"You plan to test the pipeline structure independently"}),"\n",(0,r.jsx)(n.li,{children:"You want better separation of concerns in your codebase"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"executing-your-pipelines",children:"Executing Your Pipelines"}),"\n",(0,r.jsxs)(n.p,{children:["Regardless of which approach you use, pipelines are executed using the ",(0,r.jsx)(n.code,{children:"PipelineRunner"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"var runner = PipelineRunner.Create();\nawait runner.RunAsync<MyPipelineDefinition>();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"PipelineRunner"})," handles:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Instantiating your ",(0,r.jsx)(n.code,{children:"IPipelineDefinition"})]}),"\n",(0,r.jsxs)(n.li,{children:["Calling the ",(0,r.jsx)(n.code,{children:"Define"})," method with a builder and context"]}),"\n",(0,r.jsx)(n.li,{children:"Building the pipeline graph"}),"\n",(0,r.jsx)(n.li,{children:"Validating the configuration"}),"\n",(0,r.jsx)(n.li,{children:"Executing the pipeline"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution",children:"Pipeline Execution"})})," - Learn how to run your defined pipelines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-concepts/pipeline-context",children:"Pipeline Context"})})," - Understand how to pass state and configuration to your pipeline nodes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-concepts/nodes/",children:"Nodes Overview"})})," - Learn about source, transform, and sink nodes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/execution-strategies",children:"Execution Strategies"})})," - Control how nodes process data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling Guide"})})," - Add resilience to your pipelines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/extensions/dependency-injection",children:"Dependency Injection"})})," - Using DI with pipelines"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-concepts/pipeline-context",children:"Pipeline Context"})})," - Learn about the final component that carries state across your pipeline"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/execution-strategies",children:"Execution Strategies"})})," - Control how nodes process data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling Guide"})})," - Add resilience to your pipelines"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);