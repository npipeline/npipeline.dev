"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[8919],{4216:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"extensions/testing/index","title":"Testing Extensions","description":"Learn about NPipeline\'s testing utilities and helpers for writing comprehensive tests.","source":"@site/docs/extensions/testing/index.md","sourceDirName":"extensions/testing","slug":"/extensions/testing","permalink":"/docs/extensions/testing","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Testing Extensions","description":"Learn about NPipeline\'s testing utilities and helpers for writing comprehensive tests.","sidebar_position":3,"slug":"/extensions/testing"},"sidebar":"docsSidebar","previous":{"title":"Parallelism","permalink":"/docs/extensions/parallelism"},"next":{"title":"AwesomeAssertions","permalink":"/docs/extensions/testing/awesome-assertions"}}');var r=s(4848),t=s(8453);const o={title:"Testing Extensions",description:"Learn about NPipeline's testing utilities and helpers for writing comprehensive tests.",sidebar_position:3,slug:"/extensions/testing"},a="Testing Extensions",l={},c=[{value:"Available Testing Packages",id:"available-testing-packages",level:2},{value:"NPipeline.Extensions.Testing",id:"npipelineextensionstesting",level:3},{value:"NPipeline.Extensions.Testing.AwesomeAssertions",id:"npipelineextensionstestingawesomeassertions",level:3},{value:"NPipeline.Extensions.Testing.FluentAssertions",id:"npipelineextensionstestingfluentassertions",level:3},{value:"Quick Start",id:"quick-start",level:2},{value:"Testing with PipelineTestHarness",id:"testing-with-pipelinetestharness",level:3},{value:"Basic Testing Pattern",id:"basic-testing-pattern",level:3},{value:"Integration Testing Full Pipelines",id:"integration-testing-full-pipelines",level:3},{value:"Error Handling Testing",id:"error-handling-testing",level:3},{value:"Pipeline Builder Testing Extensions",id:"pipeline-builder-testing-extensions",level:2},{value:"In-Memory Sources",id:"in-memory-sources",level:3},{value:"In-Memory Sinks",id:"in-memory-sinks",level:3},{value:"Pass-Through Transforms",id:"pass-through-transforms",level:3},{value:"Context Extensions for Testing",id:"context-extensions-for-testing",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"testing-extensions",children:"Testing Extensions"})}),"\n",(0,r.jsx)(n.p,{children:"NPipeline provides comprehensive testing support through dedicated extensions that make it easy to write unit and integration tests for your pipelines. These testing utilities help you verify the behavior of your pipelines, mock external dependencies, and ensure data flows correctly through your transformations."}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Need to test complex scenarios?"})," See ",(0,r.jsx)(n.a,{href:"/docs/advanced-topics/testing-pipelines",children:"Advanced Testing"})," for strategies with dependencies, mocking, error handling, and integration tests."]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"This guide"})," covers: ",(0,r.jsx)(n.strong,{children:"Installation, packages, basic patterns, and simple unit testing"}),(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Advanced Testing"})," covers: ",(0,r.jsx)(n.strong,{children:"Mocking services, dependency injection, error handling, and complex scenarios"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"available-testing-packages",children:"Available Testing Packages"}),"\n",(0,r.jsx)(n.h3,{id:"npipelineextensionstesting",children:"NPipeline.Extensions.Testing"}),"\n",(0,r.jsx)(n.p,{children:"The core testing package provides essential utilities for testing NPipeline pipelines:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"In-memory source and sink nodes"})," for testing data flows without external dependencies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pipeline builder extensions"})," for setting up test pipelines with fluent syntax"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test context extensions"})," for setting up pipeline execution environments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mock node implementations"})," for isolating components under test"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"npipelineextensionstestingawesomeassertions",children:"NPipeline.Extensions.Testing.AwesomeAssertions"}),"\n",(0,r.jsx)(n.p,{children:"Provides assertion extensions using the AwesomeAssertions library for fluent, readable test assertions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Example using AwesomeAssertions\r\nsink.ShouldHaveReceived(5);\r\nsink.ShouldContain(expectedItem);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"npipelineextensionstestingfluentassertions",children:"NPipeline.Extensions.Testing.FluentAssertions"}),"\n",(0,r.jsx)(n.p,{children:"Provides assertion extensions using the FluentAssertions library for expressive test assertions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Example using FluentAssertions\r\nsink.Items.Should().HaveCount(5);\r\nsink.Items.Should().Contain(expectedItem);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,r.jsx)(n.h3,{id:"testing-with-pipelinetestharness",children:"Testing with PipelineTestHarness"}),"\n",(0,r.jsxs)(n.p,{children:["The easiest way to test pipelines is using the ",(0,r.jsx)(n.code,{children:"PipelineTestHarness<TPipeline>"})," class, which provides a fluent API for configuring and executing pipelines with automatic error capturing and assertions:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.Extensions.Testing;\r\nusing NPipeline.Pipeline;\r\n\r\npublic class MyPipelineTests\r\n{\r\n    [Fact]\r\n    public async Task Pipeline_ShouldTransformDataCorrectly()\r\n    {\r\n        // Arrange & Act\r\n        var result = await new PipelineTestHarness<MyPipeline>()\r\n            .WithParameter("input", testData)\r\n            .RunAsync();\r\n\r\n        // Assert\r\n        result.AssertSuccess();\r\n        result.AssertNoErrors();\r\n        result.AssertCompletedWithin(TimeSpan.FromSeconds(5));\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"basic-testing-pattern",children:"Basic Testing Pattern"}),"\n",(0,r.jsx)(n.p,{children:"Alternatively, you can build pipelines manually for more control:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.Extensions.Testing;\r\nusing NPipeline.Extensions.Testing.AwesomeAssertions; // or FluentAssertions\r\nusing NPipeline.Pipeline;\r\nusing NPipeline.Execution;\r\n\r\npublic class MyPipelineTests\r\n{\r\n    [Fact]\r\n    public async Task Pipeline_ShouldTransformDataCorrectly()\r\n    {\r\n        // Arrange\r\n        var testData = new[] { "input1", "input2", "input3" };\r\n        var context = new PipelineContext();\r\n        context.SetSourceData(testData);\r\n\r\n        // Act\r\n        var builder = new PipelineBuilder();\r\n        var source = builder.AddInMemorySource<string>();\r\n        var transform = builder.AddTransform<MyTransform, string, string>();\r\n        var sink = builder.AddInMemorySink<string>(context);\r\n\r\n        builder.Connect(source, transform);\r\n        builder.Connect(transform, sink);\r\n\r\n        var pipeline = builder.Build();\r\n        await PipelineRunner.Create().RunAsync(pipeline, context);\r\n\r\n        // Assert\r\n        sink.ShouldHaveReceived(3);\r\n        sink.Items.Should().BeEquivalentTo(expectedData);\r\n    }\r\n}\r\n\r\n## Testing Strategies\r\n\r\n### Unit Testing Individual Nodes\r\n\r\nTest individual nodes in isolation:\r\n\r\n```csharp\r\n    [Fact]\r\n    public async Task Transform_ShouldApplyCorrectLogic()\r\n    {\r\n        // Arrange\r\n        var transform = new MyTransform();\r\n        var input = new TestData { Value = "test" };\r\n        var context = new PipelineContext();\r\n\r\n        // Act\r\n        var result = await transform.ExecuteAsync(input, context);    // Assert\r\n    result.Should().Be("processed_test");\r\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"integration-testing-full-pipelines",children:"Integration Testing Full Pipelines"}),"\n",(0,r.jsx)(n.p,{children:"Test entire pipelines to verify end-to-end behavior:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'    [Fact]\r\n    public async Task FullPipeline_ShouldProcessDataFlow()\r\n    {\r\n        // Arrange\r\n        var testData = new[] { "test1", "test2", "test3" };\r\n        var context = new PipelineContext();\r\n        context.SetSourceData(testData);    \r\n        var builder = new PipelineBuilder();\r\n        var source = builder.AddInMemorySource<string>();\r\n        var transform1 = builder.AddTransform<MyTransform1, string, string>();\r\n        var transform2 = builder.AddTransform<MyTransform2, string, string>();\r\n        var sink = builder.AddInMemorySink<string>(context);\r\n\r\n        builder.Connect(source, transform1);\r\n        builder.Connect(transform1, transform2);\r\n        builder.Connect(transform2, sink);\r\n\r\n        var pipeline = builder.Build();\r\n\r\n        // Act\r\n        await PipelineRunner.Create().RunAsync(pipeline, context);\r\n\r\n        // Assert\r\n        sink.ShouldHaveReceived(3);\r\n        sink.Items.Should().NotBeEmpty();\r\n    }\n'})}),"\n",(0,r.jsx)(n.h3,{id:"error-handling-testing",children:"Error Handling Testing"}),"\n",(0,r.jsx)(n.p,{children:"Test error scenarios and recovery:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'    [Fact]\r\n    public async Task Pipeline_ShouldHandleErrorsGracefully()\r\n    {\r\n        // Arrange\r\n        var testData = new[] { "valid", "invalid", "valid" };\r\n        var context = new PipelineContext();\r\n        context.SetSourceData(testData);    \r\n        var builder = new PipelineBuilder();\r\n        var source = builder.AddInMemorySource<string>();\r\n        var transform = builder.AddTransform<TransformThatFails, string, string>();\r\n        var sink = builder.AddInMemorySink<string>(context);\r\n\r\n        builder.Connect(source, transform);\r\n        builder.Connect(transform, sink);\r\n\r\n        var pipeline = builder.Build();\r\n\r\n        // Act & Assert\r\n        await Assert.ThrowsAsync<InvalidOperationException>(() =>\r\n            PipelineRunner.Create().RunAsync(pipeline, context));\r\n    }\n'})}),"\n",(0,r.jsx)(n.h2,{id:"pipeline-builder-testing-extensions",children:"Pipeline Builder Testing Extensions"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"../../../src/NPipeline.Extensions.Testing/PipelineBuilderTestingExtensions.cs",children:(0,r.jsx)(n.code,{children:"PipelineBuilderTestingExtensions"})})," class provides convenient methods for setting up test pipelines:"]}),"\n",(0,r.jsx)(n.h3,{id:"in-memory-sources",children:"In-Memory Sources"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Add empty source\r\nvar source = builder.AddInMemorySource<int>();\r\n\r\n// Add source with data\r\nvar source = builder.AddInMemorySource(new[] { 1, 2, 3 });\r\n\r\n// Add named source\r\nvar source = builder.AddInMemorySource<int>("MySource");\r\n\r\n// Add source with context-backed data\r\nvar source = builder.AddInMemorySourceWithDataFromContext<int>(context, new[] { 1, 2, 3 });\n'})}),"\n",(0,r.jsx)(n.h3,{id:"in-memory-sinks",children:"In-Memory Sinks"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Add sink and register in context\r\nvar sink = builder.AddInMemorySink<string>(context);\r\n\r\n// Add named sink\r\nvar sink = builder.AddInMemorySink<string>("MySink");\r\n\r\n// Add sink without context registration\r\nvar sink = builder.AddInMemorySink<string>();\n'})}),"\n",(0,r.jsx)(n.h3,{id:"pass-through-transforms",children:"Pass-Through Transforms"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Add transform that casts from int to string\r\nvar transform = builder.AddPassThroughTransform<int, string>();\r\n\r\n// Add named transform\r\nvar transform = builder.AddPassThroughTransform<string, int>("ToInt");\n'})}),"\n",(0,r.jsx)(n.h2,{id:"context-extensions-for-testing",children:"Context Extensions for Testing"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"../../../src/NPipeline.Extensions.Testing/TestingContextExtensions.cs",children:(0,r.jsx)(n.code,{children:"TestingContextExtensions"})})," provides methods for managing test data:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Set source data for a specific node type\r\ncontext.SetSourceData(new[] { 1, 2, 3 });\r\n\r\n// Set source data for a specific node instance\r\ncontext.SetSourceData(new[] { 1, 2, 3 }, nodeId: "MyNodeId");\r\n\r\n// Retrieve sink from context\r\nvar sink = context.GetSink<InMemorySink<string>>();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use descriptive test names"})," that clearly indicate what scenario is being tested"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Arrange-Act-Assert pattern"})," for clear test structure"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test both success and failure scenarios"})," to ensure robust error handling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mock external dependencies"})," to isolate the code under test"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use test data builders"})," for creating complex test scenarios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Assert on both the process and the results"})," for comprehensive validation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use context.SetSourceData()"})," to provide test data to in-memory sources"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Register sinks in context"})," to easily access results after pipeline execution"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For more advanced testing scenarios, see the ",(0,r.jsx)(n.a,{href:"/docs/extensions/dependency-injection",children:"Dependency Injection"})," documentation for patterns involving dependency injection, error handling, and mock services."]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);