"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[4960],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>t});var r=i(96540);const s={},l=r.createContext(s);function a(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(l.Provider,{value:n},e.children)}},78461:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"extensions/lineage/performance","title":"Lineage Performance","description":"Performance characteristics, benchmarks, and optimization strategies for NPipeline Lineage extension.","source":"@site/docs/extensions/lineage/performance.md","sourceDirName":"extensions/lineage","slug":"/extensions/lineage/performance","permalink":"/docs/extensions/lineage/performance","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Lineage Performance","description":"Performance characteristics, benchmarks, and optimization strategies for NPipeline Lineage extension."},"sidebar":"docsSidebar","previous":{"title":"Getting Started with Lineage","permalink":"/docs/extensions/lineage/getting-started"},"next":{"title":"Lineage Use Cases","permalink":"/docs/extensions/lineage/use-cases"}}');var s=i(74848),l=i(28453);const a={title:"Lineage Performance",description:"Performance characteristics, benchmarks, and optimization strategies for NPipeline Lineage extension."},t="Lineage Performance",c={},o=[{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Overhead Breakdown",id:"overhead-breakdown",level:3},{value:"Estimated Performance Impact",id:"estimated-performance-impact",level:3},{value:"Memory Usage",id:"memory-usage",level:2},{value:"Per-Item Memory",id:"per-item-memory",level:3},{value:"Per-Pipeline Memory",id:"per-pipeline-memory",level:3},{value:"Memory Scaling",id:"memory-scaling",level:3},{value:"CPU Impact",id:"cpu-impact",level:2},{value:"Per-Operation Costs",id:"per-operation-costs",level:3},{value:"Hash vs Random Sampling",id:"hash-vs-random-sampling",level:3},{value:"Optimization Strategies",id:"optimization-strategies",level:2},{value:"1. Use Sampling",id:"1-use-sampling",level:3},{value:"2. Enable Data Redaction",id:"2-enable-data-redaction",level:3},{value:"3. Use Materialization Cap",id:"3-use-materialization-cap",level:3},{value:"4. Use Async Sinks",id:"4-use-async-sinks",level:3},{value:"5. Batch Sink Operations",id:"5-batch-sink-operations",level:3},{value:"6. Use Degrade Overflow Policy",id:"6-use-degrade-overflow-policy",level:3},{value:"7. Minimize Hop Count",id:"7-minimize-hop-count",level:3},{value:"Benchmarking",id:"benchmarking",level:2},{value:"Measuring Lineage Overhead",id:"measuring-lineage-overhead",level:3},{value:"Real-World Scenarios",id:"real-world-scenarios",level:2},{value:"Scenario 1: Production ETL Pipeline",id:"scenario-1-production-etl-pipeline",level:3},{value:"Scenario 2: High-Volume Analytics Pipeline",id:"scenario-2-high-volume-analytics-pipeline",level:3},{value:"Scenario 3: Development/Debugging Pipeline",id:"scenario-3-developmentdebugging-pipeline",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:2},{value:"Track Lineage Performance",id:"track-lineage-performance",level:3},{value:"Metrics to Track",id:"metrics-to-track",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Profile Before Optimizing",id:"1-profile-before-optimizing",level:3},{value:"2. Start Conservative, Adjust Later",id:"2-start-conservative-adjust-later",level:3},{value:"3. Use Appropriate Overflow Policy",id:"3-use-appropriate-overflow-policy",level:3},{value:"4. Implement Async Sinks",id:"4-implement-async-sinks",level:3},{value:"5. Monitor Memory Usage",id:"5-monitor-memory-usage",level:3},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"lineage-performance",children:"Lineage Performance"})}),"\n",(0,s.jsx)(n.p,{children:"This guide covers performance characteristics, benchmarks, and optimization strategies for NPipeline Lineage extension."}),"\n",(0,s.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,s.jsx)(n.h3,{id:"overhead-breakdown",children:"Overhead Breakdown"}),"\n",(0,s.jsx)(n.p,{children:"Lineage tracking introduces overhead at several points in pipeline execution:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Component"}),(0,s.jsx)(n.th,{children:"Impact"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"LineagePacket creation"}),(0,s.jsx)(n.td,{children:"Per item"}),(0,s.jsx)(n.td,{children:"One-time allocation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Hop recording"}),(0,s.jsx)(n.td,{children:"Per hop"}),(0,s.jsx)(n.td,{children:"Metadata updates"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Sampling check"}),(0,s.jsx)(n.td,{children:"Per hop"}),(0,s.jsx)(n.td,{children:"Hash or random operation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Dictionary lookup"}),(0,s.jsx)(n.td,{children:"Per hop"}),(0,s.jsx)(n.td,{children:"ConcurrentDictionary access"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Sink export"}),(0,s.jsx)(n.td,{children:"Per item"}),(0,s.jsx)(n.td,{children:"Depends on sink implementation"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," Total overhead scales with the number of items processed and the number of hops in the pipeline."]}),"\n",(0,s.jsx)(n.h3,{id:"estimated-performance-impact",children:"Estimated Performance Impact"}),"\n",(0,s.jsx)(n.p,{children:"Performance impact varies based on configuration and pipeline characteristics:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Configuration"}),(0,s.jsx)(n.th,{children:"Relative Impact"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Without lineage (baseline)"}),(0,s.jsx)(n.td,{children:"None"}),(0,s.jsx)(n.td,{children:"No tracking overhead"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"100% tracking, no redaction"}),(0,s.jsx)(n.td,{children:"Highest"}),(0,s.jsx)(n.td,{children:"Complete visibility"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"10% sampling, no redaction"}),(0,s.jsx)(n.td,{children:"Low"}),(0,s.jsx)(n.td,{children:"Good balance"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1% sampling, no redaction"}),(0,s.jsx)(n.td,{children:"Minimal"}),(0,s.jsx)(n.td,{children:"Minimal overhead"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"10% sampling, with redaction"}),(0,s.jsx)(n.td,{children:"Low"}),(0,s.jsx)(n.td,{children:"Reduces memory usage"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important:"})," Actual performance impact depends on data sizes, pipeline complexity, and hardware. Measure performance in your specific environment to determine the actual impact."]}),"\n",(0,s.jsx)(n.h2,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,s.jsx)(n.h3,{id:"per-item-memory",children:"Per-Item Memory"}),"\n",(0,s.jsx)(n.p,{children:"Memory usage scales with data size and number of hops:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Approximate memory per item\nvar perItemMemory = \n    sizeof(Guid) +                          // LineageId: 16 bytes\n    sizeof(List<string>) +                   // TraversalPath: list overhead\n    sizeof(List<LineageHop>) +              // LineageHops: list overhead\n    (hopCount * perHopOverhead) +           // Per hop: metadata\n    (dataRedacted ? 0 : dataSize);         // Data: 0 or actual size\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Factors affecting memory:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Data size (unless redacted)"}),"\n",(0,s.jsx)(n.li,{children:"Number of hops in the pipeline"}),"\n",(0,s.jsx)(n.li,{children:"Number of items sampled"}),"\n",(0,s.jsx)(n.li,{children:"Metadata stored per hop"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"per-pipeline-memory",children:"Per-Pipeline Memory"}),"\n",(0,s.jsx)(n.p,{children:"Fixed overhead per pipeline execution:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Component"}),(0,s.jsx)(n.th,{children:"Memory"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"LineageCollector"}),(0,s.jsx)(n.td,{children:"Dictionary overhead"}),(0,s.jsx)(n.td,{children:"Scales with items"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"LineageOptions"}),(0,s.jsx)(n.td,{children:"Configuration"}),(0,s.jsx)(n.td,{children:"Negligible"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Total"}),(0,s.jsx)(n.td,{children:"Varies"}),(0,s.jsx)(n.td,{children:"Depends on items sampled"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"memory-scaling",children:"Memory Scaling"}),"\n",(0,s.jsx)(n.p,{children:"Memory usage scales linearly with:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Number of items sampled"}),": Each sampled item adds memory"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Number of hops"}),": Each hop adds metadata"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data size"}),": Proportional to actual data (unless redacted)"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Formula:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"TotalMemory = PipelineOverhead + (SampledItems \xd7 PerItemMemory)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," Use sampling and redaction to control memory usage. The materialization cap provides additional protection against excessive memory consumption."]}),"\n",(0,s.jsx)(n.h2,{id:"cpu-impact",children:"CPU Impact"}),"\n",(0,s.jsx)(n.h3,{id:"per-operation-costs",children:"Per-Operation Costs"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Operation"}),(0,s.jsx)(n.th,{children:"Cost"}),(0,s.jsx)(n.th,{children:"Frequency"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"LineagePacket creation"}),(0,s.jsx)(n.td,{children:"Per item"}),(0,s.jsx)(n.td,{children:"One-time"}),(0,s.jsx)(n.td,{children:"Allocation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Sampling check"}),(0,s.jsx)(n.td,{children:"Per hop"}),(0,s.jsx)(n.td,{children:"Hash or random"}),(0,s.jsx)(n.td,{children:"Fast operation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Hop recording"}),(0,s.jsx)(n.td,{children:"Per hop"}),(0,s.jsx)(n.td,{children:"List operations"}),(0,s.jsx)(n.td,{children:"Metadata updates"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Dictionary lookup"}),(0,s.jsx)(n.td,{children:"Per hop"}),(0,s.jsx)(n.td,{children:"ConcurrentDictionary"}),(0,s.jsx)(n.td,{children:"Efficient access"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Sink export"}),(0,s.jsx)(n.td,{children:"Per item"}),(0,s.jsx)(n.td,{children:"Depends on sink"}),(0,s.jsx)(n.td,{children:"I/O bound"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"hash-vs-random-sampling",children:"Hash vs Random Sampling"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Sampling Type"}),(0,s.jsx)(n.th,{children:"Characteristics"}),(0,s.jsx)(n.th,{children:"Use Case"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Deterministic (hash)"}),(0,s.jsx)(n.td,{children:"Consistent items across runs"}),(0,s.jsx)(n.td,{children:"Debugging, compliance"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Random"}),(0,s.jsx)(n.td,{children:"Different items each run"}),(0,s.jsx)(n.td,{children:"Monitoring, analytics"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," Both sampling methods have similar CPU characteristics. Hash-based sampling provides consistency across runs."]}),"\n",(0,s.jsx)(n.h2,{id:"optimization-strategies",children:"Optimization Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"1-use-sampling",children:"1. Use Sampling"}),"\n",(0,s.jsx)(n.p,{children:"The most effective optimization is sampling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Production: 1% sampling\nbuilder.EnableItemLevelLineage(options =>\n{\n    options.SampleEvery = 100;\n    options.DeterministicSampling = true;\n});\n\n// High-volume: 0.1% sampling\nbuilder.EnableItemLevelLineage(options =>\n{\n    options.SampleEvery = 1000;\n    options.DeterministicSampling = false;\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Impact:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduces memory usage proportionally"}),"\n",(0,s.jsx)(n.li,{children:"Reduces CPU overhead proportionally"}),"\n",(0,s.jsx)(n.li,{children:"Maintains representative visibility"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-enable-data-redaction",children:"2. Enable Data Redaction"}),"\n",(0,s.jsx)(n.p,{children:"Redact data when possible:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"builder.EnableItemLevelLineage(options =>\n{\n    options.RedactData = true;  // Reduces memory usage\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Impact:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduces memory usage by not storing actual data"}),"\n",(0,s.jsx)(n.li,{children:"No CPU impact"}),"\n",(0,s.jsx)(n.li,{children:"Maintains all metadata"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-use-materialization-cap",children:"3. Use Materialization Cap"}),"\n",(0,s.jsx)(n.p,{children:"Limit in-memory storage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"builder.EnableItemLevelLineage(options =>\n{\n    options.MaterializationCap = 10000;  // Default\n    options.OverflowPolicy = LineageOverflowPolicy.Degrade;\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Impact:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Predictable memory usage"}),"\n",(0,s.jsx)(n.li,{children:"Prevents out-of-memory errors"}),"\n",(0,s.jsx)(n.li,{children:"Graceful degradation"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"4-use-async-sinks",children:"4. Use Async Sinks"}),"\n",(0,s.jsx)(n.p,{children:"Implement async sink operations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public sealed class DatabaseLineageSink : ILineageSink\n{\n    public async Task RecordAsync(LineageInfo lineageInfo, CancellationToken cancellationToken)\n    {\n        // Non-blocking async I/O\n        await _database.SaveChangesAsync(cancellationToken);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Impact:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Non-blocking to pipeline execution"}),"\n",(0,s.jsx)(n.li,{children:"Better throughput"}),"\n",(0,s.jsx)(n.li,{children:"No pipeline stalls"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"5-batch-sink-operations",children:"5. Batch Sink Operations"}),"\n",(0,s.jsx)(n.p,{children:"Batch multiple lineage records:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public sealed class BatchedLineageSink : ILineageSink\n{\n    private readonly List<LineageInfo> _batch = new();\n    private readonly int _batchSize;\n\n    public Task RecordAsync(LineageInfo lineageInfo, CancellationToken cancellationToken)\n    {\n        lock (_batch)\n        {\n            _batch.Add(lineageInfo);\n            \n            if (_batch.Count >= _batchSize)\n            {\n                return FlushBatchAsync(cancellationToken);\n            }\n        }\n        return Task.CompletedTask;\n    }\n\n    private async Task FlushBatchAsync(CancellationToken cancellationToken)\n    {\n        List<LineageInfo> itemsToFlush;\n        lock (_batch)\n        {\n            itemsToFlush = _batch.ToList();\n            _batch.Clear();\n        }\n        \n        await _database.BulkInsertAsync(itemsToFlush, cancellationToken);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Impact:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduces database round trips"}),"\n",(0,s.jsx)(n.li,{children:"Better throughput"}),"\n",(0,s.jsx)(n.li,{children:"Lower CPU overhead"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"6-use-degrade-overflow-policy",children:"6. Use Degrade Overflow Policy"}),"\n",(0,s.jsx)(n.p,{children:"Default policy provides best balance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"options.OverflowPolicy = LineageOverflowPolicy.Degrade;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Impact:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Predictable memory usage"}),"\n",(0,s.jsx)(n.li,{children:"Maintains visibility"}),"\n",(0,s.jsx)(n.li,{children:"Automatic cleanup"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"7-minimize-hop-count",children:"7. Minimize Hop Count"}),"\n",(0,s.jsx)(n.p,{children:"Reduce pipeline complexity:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Complex: Many hops\n[Source] \u2192 [Transform1] \u2192 [Transform2] \u2192 [Transform3] \u2192 [Sink]\n\n// Simplified: Fewer hops\n[Source] \u2192 [CombinedTransform] \u2192 [Sink]\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Impact:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduces lineage overhead"}),"\n",(0,s.jsx)(n.li,{children:"Faster pipeline execution"}),"\n",(0,s.jsx)(n.li,{children:"Lower memory usage"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"benchmarking",children:"Benchmarking"}),"\n",(0,s.jsx)(n.h3,{id:"measuring-lineage-overhead",children:"Measuring Lineage Overhead"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using BenchmarkDotNet.Attributes;\n\n[MemoryDiagnoser]\npublic class LineageBenchmarks\n{\n    private PipelineRunner _runner = null!;\n    private PipelineContext _context = null!;\n    \n    [GlobalSetup]\n    public void Setup()\n    {\n        _runner = PipelineRunner.Create();\n        _context = new PipelineContext();\n    }\n    \n    [Benchmark(Baseline = true)]\n    public async Task NoLineage()\n    {\n        var builder = new PipelineBuilder("TestPipeline");\n        // No lineage enabled\n        await _runner.RunAsync(builder.Build(), _context);\n    }\n    \n    [Benchmark]\n    public async Task WithLineage_100Percent()\n    {\n        var builder = new PipelineBuilder("TestPipeline");\n        builder.EnableItemLevelLineage(options =>\n        {\n            options.SampleEvery = 1;  // 100%\n        });\n        await _runner.RunAsync(builder.Build(), _context);\n    }\n    \n    [Benchmark]\n    public async Task WithLineage_10Percent()\n    {\n        var builder = new PipelineBuilder("TestPipeline");\n        builder.EnableItemLevelLineage(options =>\n        {\n            options.SampleEvery = 10;  // 10%\n        });\n        await _runner.RunAsync(builder.Build(), _context);\n    }\n    \n    [Benchmark]\n    public async Task WithLineage_Redacted()\n    {\n        var builder = new PipelineBuilder("TestPipeline");\n        builder.EnableItemLevelLineage(options =>\n        {\n            options.SampleEvery = 1;\n            options.RedactData = true;\n        });\n        await _runner.RunAsync(builder.Build(), _context);\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," Run benchmarks in your specific environment with representative data to measure actual performance impact."]}),"\n",(0,s.jsx)(n.h2,{id:"real-world-scenarios",children:"Real-World Scenarios"}),"\n",(0,s.jsx)(n.h3,{id:"scenario-1-production-etl-pipeline",children:"Scenario 1: Production ETL Pipeline"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Requirements:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Process items at production volume"}),"\n",(0,s.jsx)(n.li,{children:"Multiple nodes in pipeline"}),"\n",(0,s.jsx)(n.li,{children:"Need compliance tracking"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"builder.EnableItemLevelLineage(options =>\n{\n    options.SampleEvery = 1;  // 100% for compliance\n    options.RedactData = true;  // Sensitive data\n    options.MaterializationCap = 100000;  // All items\n    options.OverflowPolicy = LineageOverflowPolicy.Degrade;\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Considerations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"CPU overhead is present but acceptable for compliance"}),"\n",(0,s.jsx)(n.li,{children:"Memory usage scales with number of items processed"}),"\n",(0,s.jsx)(n.li,{children:"Throughput impact depends on pipeline complexity and data sizes"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"scenario-2-high-volume-analytics-pipeline",children:"Scenario 2: High-Volume Analytics Pipeline"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Requirements:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"High throughput processing"}),"\n",(0,s.jsx)(n.li,{children:"Multiple nodes in pipeline"}),"\n",(0,s.jsx)(n.li,{children:"Need monitoring, not compliance"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"builder.EnableItemLevelLineage(options =>\n{\n    options.SampleEvery = 1000;  // 0.1% sampling\n    options.RedactData = true;\n    options.MaterializationCap = 1000;  // Small cap\n    options.OverflowPolicy = LineageOverflowPolicy.Drop;\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Considerations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Minimal CPU overhead with aggressive sampling"}),"\n",(0,s.jsx)(n.li,{children:"Low memory footprint with small cap"}),"\n",(0,s.jsx)(n.li,{children:"Throughput impact is negligible"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"scenario-3-developmentdebugging-pipeline",children:"Scenario 3: Development/Debugging Pipeline"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Requirements:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Process items for testing"}),"\n",(0,s.jsx)(n.li,{children:"Multiple nodes in pipeline"}),"\n",(0,s.jsx)(n.li,{children:"Need complete visibility"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"builder.EnableItemLevelLineage(options =>\n{\n    options.SampleEvery = 1;  // 100% for debugging\n    options.RedactData = false;  // Keep data for inspection\n    options.MaterializationCap = int.MaxValue;  // No cap\n    options.OverflowPolicy = LineageOverflowPolicy.Materialize;\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Considerations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"CPU overhead is acceptable for development"}),"\n",(0,s.jsx)(n.li,{children:"Memory usage scales with test data size"}),"\n",(0,s.jsx)(n.li,{children:"Throughput is not critical for development"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,s.jsx)(n.h3,{id:"track-lineage-performance",children:"Track Lineage Performance"}),"\n",(0,s.jsx)(n.p,{children:"Monitor lineage-specific metrics:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public sealed class LineagePerformanceSink : ILineageSink\n{\n    private readonly ILogger _logger;\n    private readonly Stopwatch _sw = new();\n\n    public LineagePerformanceSink(ILogger<LineagePerformanceSink> logger)\n    {\n        _logger = logger;\n    }\n\n    public async Task RecordAsync(LineageInfo lineageInfo, CancellationToken cancellationToken)\n    {\n        _sw.Restart();\n        \n        // Actual sink operation\n        await _database.SaveAsync(lineageInfo, cancellationToken);\n        \n        var elapsed = _sw.ElapsedMilliseconds;\n        \n        if (elapsed > 100)\n        {\n            _logger.LogWarning(\n                "Slow lineage export: {ElapsedMs}ms for {LineageId}",\n                elapsed,\n                lineageInfo.LineageId);\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"metrics-to-track",children:"Metrics to Track"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lineage export time"}),": Time to write to sinks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory usage"}),": Collector memory over time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sampling rate"}),": Actual vs configured"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Overflow events"}),": How often cap is reached"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sink errors"}),": Failed exports"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-profile-before-optimizing",children:"1. Profile Before Optimizing"}),"\n",(0,s.jsx)(n.p,{children:"Measure before making changes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Use BenchmarkDotNet or similar tools\n[Benchmark]\npublic async Task Baseline()\n{\n    await RunPipeline(withLineage: false);\n}\n\n[Benchmark]\npublic async Task WithLineage()\n{\n    await RunPipeline(withLineage: true);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-start-conservative-adjust-later",children:"2. Start Conservative, Adjust Later"}),"\n",(0,s.jsx)(n.p,{children:"Begin with low sampling rate:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"options.SampleEvery = 100;  // Conservative start\n"})}),"\n",(0,s.jsx)(n.p,{children:"Monitor and adjust based on requirements."}),"\n",(0,s.jsx)(n.h3,{id:"3-use-appropriate-overflow-policy",children:"3. Use Appropriate Overflow Policy"}),"\n",(0,s.jsx)(n.p,{children:"Choose policy based on scenario:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Scenario"}),(0,s.jsx)(n.th,{children:"Policy"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Production"}),(0,s.jsx)(n.td,{children:"Degrade"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Development"}),(0,s.jsx)(n.td,{children:"Materialize"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"High-volume"}),(0,s.jsx)(n.td,{children:"Drop"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Compliance"}),(0,s.jsx)(n.td,{children:"Degrade"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"4-implement-async-sinks",children:"4. Implement Async Sinks"}),"\n",(0,s.jsx)(n.p,{children:"Always use async operations in sinks:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public async Task RecordAsync(LineageInfo lineageInfo, CancellationToken cancellationToken)\n{\n    await _repository.SaveAsync(lineageInfo, cancellationToken);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-monitor-memory-usage",children:"5. Monitor Memory Usage"}),"\n",(0,s.jsx)(n.p,{children:"Track collector memory:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'var collector = serviceProvider.GetRequiredService<ILineageCollector>();\nvar lineageCount = collector.GetAllLineageInfo().Count;\nvar estimatedMemory = lineageCount * 750;  // Approximate bytes\n\n_logger.LogInformation(\n    "Lineage memory: {Count} items, ~{MemoryMB} MB",\n    lineageCount,\n    estimatedMemory / (1024 * 1024));\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," Actual memory usage depends on data sizes and pipeline complexity. Monitor in production to understand real memory consumption."]}),"\n",(0,s.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/extensions/lineage/getting-started",children:"Getting Started"})})," - Installation and basic setup"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/extensions/lineage/configuration",children:"Configuration"})})," - Configuration options and settings"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/extensions/lineage/architecture",children:"Architecture"})})," - Internal architecture and design decisions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/extensions/lineage/use-cases",children:"Use Cases"})})," - Common use cases and examples"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);