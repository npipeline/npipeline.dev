"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[4738],{11441:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-concepts/nodes/branch","title":"Branch Nodes","description":"Duplicate data streams to multiple downstream paths for branching logic or monitoring using NPipeline\'s Branch Nodes.","source":"@site/docs/core-concepts/nodes/branch.md","sourceDirName":"core-concepts/nodes","slug":"/core-concepts/nodes/branch","permalink":"/docs/core-concepts/nodes/branch","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Branch Nodes","description":"Duplicate data streams to multiple downstream paths for branching logic or monitoring using NPipeline\'s Branch Nodes.","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Lookup Nodes","permalink":"/docs/core-concepts/nodes/lookup"},"next":{"title":"Tap Nodes","permalink":"/docs/core-concepts/nodes/tap"}}');var a=r(74848),o=r(28453);const s={title:"Branch Nodes",description:"Duplicate data streams to multiple downstream paths for branching logic or monitoring using NPipeline's Branch Nodes.",sidebar_position:5},t="Branch Nodes",l={},c=[{value:"<code>BranchNode&lt;T&gt;</code>: Duplicating Streams",id:"branchnodet-duplicating-streams",level:2},{value:"Example: Processing Data in Multiple Ways",id:"example-processing-data-in-multiple-ways",level:3},{value:"Error Handling in Branch Nodes",id:"error-handling-in-branch-nodes",level:2},{value:"Error Handling Modes",id:"error-handling-modes",level:3},{value:"Example: Configuring Error Handling Mode",id:"example-configuring-error-handling-mode",level:3},{value:"Example: Handling Branch Errors with IPipelineErrorHandler",id:"example-handling-branch-errors-with-ipipelineerrorhandler",level:3},{value:"BranchHandlerException Properties",id:"branchhandlerexception-properties",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Considerations for Branch Nodes",id:"considerations-for-branch-nodes",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"branch-nodes",children:"Branch Nodes"})}),"\n",(0,a.jsx)(n.p,{children:"Branch nodes allow you to duplicate (fan-out) an incoming data stream and send identical copies of each item to multiple downstream paths. This is incredibly useful for scenarios where you need to process the same data in different ways concurrently, or for parallel processing of the same data across multiple independent branches."}),"\n",(0,a.jsx)(n.mermaid,{value:"graph TD\r\n    A[Source Data Stream] --\x3e B[BranchNode]\r\n    B --\x3e C[Branch 1: Main Processing]\r\n    B --\x3e D[Branch 2: Processing]\r\n    B --\x3e E[Branch 3: Processing]\r\n\r\n    C --\x3e F[Sink]\r\n    D --\x3e G[Sink]\r\n    E --\x3e H[Sink]\r\n\r\n    style B fill:#e1f5fe,stroke:#01579b,stroke-width:2px\r\n    style C fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\r\n    style D fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\r\n    style E fill:#f3e5f5,stroke:#4a148c,stroke-width:2px"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Figure: BranchNode fan-out pattern showing how a single input stream is duplicated to multiple independent processing branches."})}),"\n",(0,a.jsxs)(n.p,{children:["NPipeline provides the ",(0,a.jsx)(n.a,{href:"src/NPipeline/Nodes/BranchNode.cs",children:(0,a.jsx)(n.code,{children:"BranchNode<T>"})})," for general-purpose stream duplication. For non-intrusive monitoring and side-channel processing, see ",(0,a.jsx)(n.a,{href:"/docs/core-concepts/nodes/tap",children:"Tap Nodes"}),"."]}),"\n",(0,a.jsxs)(n.h2,{id:"branchnodet-duplicating-streams",children:[(0,a.jsx)(n.a,{href:"src/NPipeline/Nodes/BranchNode.cs",children:(0,a.jsx)(n.code,{children:"BranchNode<T>"})}),": Duplicating Streams"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"src/NPipeline/Nodes/BranchNode.cs",children:(0,a.jsx)(n.code,{children:"BranchNode<T>"})})," takes a single input stream of type ",(0,a.jsx)(n.code,{children:"T"})," and produces multiple output streams of the same type ",(0,a.jsx)(n.code,{children:"T"}),". Each item that enters the ",(0,a.jsx)(n.code,{children:"BranchNode"})," is sent to all connected downstream nodes."]}),"\n",(0,a.jsx)(n.h3,{id:"example-processing-data-in-multiple-ways",children:"Example: Processing Data in Multiple Ways"}),"\n",(0,a.jsx)(n.p,{children:"Imagine a scenario where you receive a stream of sensor readings. You might want to:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Store the raw readings in a database."}),"\n",(0,a.jsx)(n.li,{children:"Analyze the readings for anomalies in real-time."}),"\n",(0,a.jsx)(n.li,{children:"Aggregate the readings for hourly reports."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"BranchNode"})," allows you to achieve this by fanning out the raw readings to three different processing branches."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\n\r\npublic sealed record SensorReading(DateTime Timestamp, double Value);\r\n\r\npublic sealed class SensorReadingSource : SourceNode<SensorReading>\r\n{\r\n    public async IAsyncEnumerable<SensorReading> ExecuteAsync(CancellationToken cancellationToken = default)\r\n    {\r\n        for (int i = 0; i < 5; i++)\r\n        {\r\n            if (cancellationToken.IsCancellationRequested) yield break;\r\n            var reading = new SensorReading(DateTime.UtcNow.AddSeconds(i), i * 10.0);\r\n            Console.WriteLine($"Source: Producing {reading}");\r\n            yield return reading;\r\n            await Task.Delay(100, cancellationToken);\r\n        }\r\n    }\r\n}\r\n\r\npublic sealed class RawDataSink : SinkNode<SensorReading>\r\n{\r\n    public async Task ExecuteAsync(IAsyncEnumerable<SensorReading> input, CancellationToken cancellationToken = default)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            Console.WriteLine($"RawDataSink: Stored {item}");\r\n        }\r\n    }\r\n}\r\n\r\npublic sealed class AnomalyDetector : ITransformNode<SensorReading, string>\r\n{\r\n    public async IAsyncEnumerable<string> ExecuteAsync(IAsyncEnumerable<SensorReading> input, CancellationToken cancellationToken = default)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            if (cancellationToken.IsCancellationRequested) yield break;\r\n            if (item.Value > 30.0 && item.Value < 60.0) // Simple anomaly detection\r\n            {\r\n                yield return $"Anomaly Detected: Reading {item.Value} at {item.Timestamp}";\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var context = PipelineContext.Default;\r\n        var runner = PipelineRunner.Create();\r\n        \r\n        Console.WriteLine("Starting branching pipeline...");\r\n        await runner.RunAsync<BranchingPipelineDefinition>(context);\r\n        Console.WriteLine("Branching pipeline finished.");\r\n    }\r\n}\r\n\r\npublic sealed class BranchingPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<SensorReadingSource, SensorReading>("source");\r\n        var branchHandle = builder.AddBranch<BranchNode<SensorReading>>("branch");\r\n        var rawDataSinkHandle = builder.AddSink<RawDataSink, SensorReading>("rawSink");\r\n        var anomalyDetectorHandle = builder.AddTransform<AnomalyDetector, SensorReading, string>("anomaly");\r\n        var consoleSinkHandle = builder.AddSink<ConsoleSink<string>, string>("consoleSink");\r\n\r\n        // First branch: direct to raw data sink\r\n        builder.Connect(sourceHandle, branchHandle);\r\n        builder.Connect(branchHandle, rawDataSinkHandle);\r\n        \r\n        // Second branch: through anomaly detector\r\n        builder.Connect(branchHandle, anomalyDetectorHandle);\r\n        builder.Connect(anomalyDetectorHandle, consoleSinkHandle);\r\n    }\r\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In this example, the ",(0,a.jsx)(n.code,{children:"BranchNode"})," duplicates the input stream, sending copies to multiple downstream paths. One copy goes to ",(0,a.jsx)(n.code,{children:"RawDataSink"})," for storage, and another copy goes through ",(0,a.jsx)(n.code,{children:"AnomalyDetector"})," for real-time anomaly alerts."]}),"\n",(0,a.jsx)(n.h2,{id:"error-handling-in-branch-nodes",children:"Error Handling in Branch Nodes"}),"\n",(0,a.jsxs)(n.p,{children:["Branch handlers are user-provided delegates that execute in parallel. When a branch handler throws an exception, the behavior is controlled by the ",(0,a.jsx)(n.code,{children:"ErrorHandlingMode"})," property:"]}),"\n",(0,a.jsx)(n.h3,{id:"error-handling-modes",children:"Error Handling Modes"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Mode"}),(0,a.jsx)(n.th,{children:"Behavior"}),(0,a.jsx)(n.th,{children:"Use Case"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.code,{children:"RouteToErrorHandler"})," (default)"]}),(0,a.jsxs)(n.td,{children:["Exceptions are wrapped in ",(0,a.jsx)(n.code,{children:"BranchHandlerException"})," and routed through the pipeline's ",(0,a.jsx)(n.code,{children:"IPipelineErrorHandler"}),". If no handler is configured, the exception propagates."]}),(0,a.jsx)(n.td,{children:"Production pipelines with error monitoring"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"CollectAndThrow"})}),(0,a.jsxs)(n.td,{children:["All branch exceptions are collected and thrown as an ",(0,a.jsx)(n.code,{children:"AggregateException"})," after all branches complete."]}),(0,a.jsx)(n.td,{children:"When you need all branches to attempt execution"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"LogAndContinue"})}),(0,a.jsx)(n.td,{children:"Exceptions are logged but swallowed, allowing the pipeline to continue."}),(0,a.jsx)(n.td,{children:"Non-critical side effects (use with caution)"})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"example-configuring-error-handling-mode",children:"Example: Configuring Error Handling Mode"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Create a branch node with explicit error handling mode\r\nvar branchNode = new BranchNode<SensorReading>\r\n{\r\n    ErrorHandlingMode = BranchErrorHandlingMode.RouteToErrorHandler\r\n};\r\n\r\nbranchNode.AddOutput(async reading =>\r\n{\r\n    // This handler's errors will be routed through the pipeline error handler\r\n    await SendToAlertSystemAsync(reading);\r\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"example-handling-branch-errors-with-ipipelineerrorhandler",children:"Example: Handling Branch Errors with IPipelineErrorHandler"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'public class MyErrorHandler : IPipelineErrorHandler\r\n{\r\n    public Task<PipelineErrorDecision> HandleNodeFailureAsync(\r\n        string nodeId,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        if (error is BranchHandlerException branchEx)\r\n        {\r\n            // Log the branch failure but continue the pipeline\r\n            Console.WriteLine($"Branch {branchEx.BranchIndex} failed: {branchEx.InnerException?.Message}");\r\n            return Task.FromResult(PipelineErrorDecision.ContinueWithoutNode);\r\n        }\r\n\r\n        // For other errors, fail the pipeline\r\n        return Task.FromResult(PipelineErrorDecision.FailPipeline);\r\n    }\r\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"branchhandlerexception-properties",children:"BranchHandlerException Properties"}),"\n",(0,a.jsxs)(n.p,{children:["When a branch handler fails, the ",(0,a.jsx)(n.code,{children:"BranchHandlerException"})," provides context about the failure:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"NodeId"}),": The ID of the branch node where the failure occurred"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"BranchIndex"}),": The zero-based index of the failed branch handler"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"FailedItem"}),": The item that was being processed when the failure occurred"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"InnerException"}),": The original exception from the branch handler"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory Usage"}),": For large-scale fan-out scenarios, be mindful of memory consumption. Each branch maintains its own processing queue and buffers, which can multiply memory usage with multiple branches."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Backpressure"}),": If one branch of a ",(0,a.jsx)(n.code,{children:"BranchNode"})," becomes slow, it can create backpressure that affects other branches. Consider using appropriate buffering strategies or async processing in sink implementations."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Throughput Impact"}),": Duplicating streams incurs overhead. For high-throughput scenarios, profile your pipeline to ensure the fan-out doesn't become a bottleneck."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Resource Management"}),": Ensure all branches properly dispose of resources, especially when using sinks that maintain connections or file handles."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"considerations-for-branch-nodes",children:"Considerations for Branch Nodes"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Order of Processing:"})," While ",(0,a.jsx)(n.code,{children:"BranchNode"})," duplicates items, the order in which items are processed in parallel branches is not guaranteed unless explicitly managed (e.g., by subsequent synchronization points)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance Impact:"})," Duplicating streams and processing them in parallel can increase resource consumption (CPU, memory) if not managed carefully."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Error Handling:"})," By default, errors in branch handlers are routed through the pipeline's error handling system. Configure ",(0,a.jsx)(n.code,{children:"ErrorHandlingMode"})," to control this behavior."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/core-concepts/nodes/tap",children:"Tap Nodes"})}),": Learn about non-intrusive monitoring and side-channel processing."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling#advanced-patterns",children:"Advanced Error Handling Patterns"})}),": Learn more about handling errors in complex pipeline structures."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>t});var i=r(96540);const a={},o=i.createContext(a);function s(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);