"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[5980],{1683:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>h});const c=JSON.parse('{"id":"architecture/execution-plan-caching","title":"Execution Plan Caching","description":"How NPipeline caches compiled execution plans to eliminate repetitive expression compilation overhead.","source":"@site/docs/architecture/execution-plan-caching.md","sourceDirName":"architecture","slug":"/architecture/execution-plan-caching","permalink":"/docs/architecture/execution-plan-caching","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":14,"frontMatter":{"title":"Execution Plan Caching","description":"How NPipeline caches compiled execution plans to eliminate repetitive expression compilation overhead.","sidebar_position":14},"sidebar":"docsSidebar","previous":{"title":"Optimization Principles - How NPipeline Achieves High Performance","permalink":"/docs/architecture/optimization-principles"},"next":{"title":"NPipeline Extensions","permalink":"/docs/extensions"}}');var l=i(4848),a=i(8453);const s={title:"Execution Plan Caching",description:"How NPipeline caches compiled execution plans to eliminate repetitive expression compilation overhead.",sidebar_position:14},r="Execution Plan Caching: Eliminating Compilation Overhead",t={},h=[{value:"The Problem: Compilation Overhead",id:"the-problem-compilation-overhead",level:2},{value:"The Solution: Cache Compiled Plans",id:"the-solution-cache-compiled-plans",level:2},{value:"Architecture: The Caching System",id:"architecture-the-caching-system",level:2},{value:"Cache Interface (<code>IPipelineExecutionPlanCache</code>)",id:"cache-interface-ipipelineexecutionplancache",level:3},{value:"Default Implementation: <code>InMemoryPipelineExecutionPlanCache</code>",id:"default-implementation-inmemorypipelineexecutionplancache",level:3},{value:"Null Cache: <code>NullPipelineExecutionPlanCache</code>",id:"null-cache-nullpipelineexecutionplancache",level:3},{value:"How It Works: Execution Flow",id:"how-it-works-execution-flow",level:2},{value:"First Run: Compilation &amp; Caching",id:"first-run-compilation--caching",level:3},{value:"Subsequent Runs: Cache Hit",id:"subsequent-runs-cache-hit",level:3},{value:"Safety: When Caching Is Disabled",id:"safety-when-caching-is-disabled",level:2},{value:"1. Pipelines with Preconfigured Nodes",id:"1-pipelines-with-preconfigured-nodes",level:3},{value:"2. Explicit Null Cache",id:"2-explicit-null-cache",level:3},{value:"3. Null Cache Implementation",id:"3-null-cache-implementation",level:3},{value:"Usage Patterns",id:"usage-patterns",level:2},{value:"1. Default (Automatic Caching)",id:"1-default-automatic-caching",level:3},{value:"2. Custom Cache with Monitoring",id:"2-custom-cache-with-monitoring",level:3},{value:"3. Disabling Caching",id:"3-disabling-caching",level:3},{value:"4. Custom Cache Implementation",id:"4-custom-cache-implementation",level:3},{value:"When to Disable Caching",id:"when-to-disable-caching",level:2},{value:"Testing",id:"testing",level:3},{value:"Dynamic Pipelines",id:"dynamic-pipelines",level:3},{value:"Memory Constraints",id:"memory-constraints",level:3},{value:"Debugging Compilation",id:"debugging-compilation",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Memory Usage",id:"memory-usage",level:3},{value:"Cache Hit Rate",id:"cache-hit-rate",level:3},{value:"CPU Impact",id:"cpu-impact",level:3},{value:"Integration Points",id:"integration-points",level:2},{value:"PipelineRunner",id:"pipelinerunner",level:3},{value:"PipelineExecutionCoordinator",id:"pipelineexecutioncoordinator",level:3},{value:"FAQ",id:"faq",level:2},{value:"See Also",id:"see-also",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"execution-plan-caching-eliminating-compilation-overhead",children:"Execution Plan Caching: Eliminating Compilation Overhead"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"This page explains HOW execution plan caching works and WHEN it's applied."})," For configuration details, see ",(0,l.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/ipipelinerunner",children:"Pipeline Runner Configuration"}),"."]}),"\n",(0,l.jsx)(n.h2,{id:"the-problem-compilation-overhead",children:"The Problem: Compilation Overhead"}),"\n",(0,l.jsx)(n.p,{children:"When a pipeline runs, NPipeline compiles execution plans for each node:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"// For each pipeline run:\n// 1. Compile expression trees for source initialization\n// 2. Compile delegates for transform execution\n// 3. Build execution plans for sinks and joins\n"})}),"\n",(0,l.jsx)(n.p,{children:"For pipelines that run multiple times:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Small datasets (1K items):"})," 1.6-1.9ms of per-run overhead (mostly compilation)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Impact:"})," This represents ~40-50% of total pipeline execution time for small datasets"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Root cause:"})," Expression tree compilation happens even though the pipeline structure never changes"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"the-solution-cache-compiled-plans",children:"The Solution: Cache Compiled Plans"}),"\n",(0,l.jsx)(n.p,{children:"Instead of recompiling on every run, NPipeline caches the compiled execution plans keyed by pipeline definition type and graph structure:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"// First run: Compile and cache\nvar runner = PipelineRunner.Create();\nawait runner.RunAsync<MyPipeline>(); // 1.9ms (with compilation)\n\n// Subsequent runs: Use cached plans\nawait runner.RunAsync<MyPipeline>(); // 0.4-0.5ms (cached)\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Expected Performance Improvement:"})}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Scenario"}),(0,l.jsx)(n.th,{children:"Before Caching"}),(0,l.jsx)(n.th,{children:"After Caching"}),(0,l.jsx)(n.th,{children:"Improvement"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"First Run"}),(0,l.jsx)(n.td,{children:"1.9ms"}),(0,l.jsx)(n.td,{children:"1.9ms"}),(0,l.jsx)(n.td,{children:"\u2014"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Subsequent Runs"}),(0,l.jsx)(n.td,{children:"1.9ms"}),(0,l.jsx)(n.td,{children:"0.4-0.5ms"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"75% reduction"})})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Per-run overhead"}),(0,l.jsx)(n.td,{children:"300-500\u03bcs"}),(0,l.jsx)(n.td,{children:"50\u03bcs"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"250-450\u03bcs saved"})})]})]})]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"architecture-the-caching-system",children:"Architecture: The Caching System"}),"\n",(0,l.jsxs)(n.h3,{id:"cache-interface-ipipelineexecutionplancache",children:["Cache Interface (",(0,l.jsx)(n.code,{children:"IPipelineExecutionPlanCache"}),")"]}),"\n",(0,l.jsx)(n.p,{children:"The caching system is built on a flexible abstraction that allows different implementations:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"public interface IPipelineExecutionPlanCache\n{\n    /// <summary>\n    /// Attempts to retrieve cached execution plans for the specified pipeline.\n    /// </summary>\n    bool TryGetCachedPlans(\n        Type pipelineDefinitionType,\n        PipelineGraph graph,\n        out Dictionary<string, NodeExecutionPlan>? cachedPlans);\n\n    /// <summary>\n    /// Stores execution plans in the cache.\n    /// </summary>\n    void CachePlans(\n        Type pipelineDefinitionType,\n        PipelineGraph graph,\n        Dictionary<string, NodeExecutionPlan> plans);\n\n    /// <summary>\n    /// Clears all cached plans.\n    /// </summary>\n    void Clear();\n\n    /// <summary>\n    /// Gets the number of cached pipeline definitions.\n    /// </summary>\n    int Count { get; }\n}\n"})}),"\n",(0,l.jsxs)(n.h3,{id:"default-implementation-inmemorypipelineexecutionplancache",children:["Default Implementation: ",(0,l.jsx)(n.code,{children:"InMemoryPipelineExecutionPlanCache"})]}),"\n",(0,l.jsx)(n.p,{children:"The default cache provides:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Thread-safe caching"})," via ",(0,l.jsx)(n.code,{children:"ConcurrentDictionary"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Automatic cache keying"})," based on pipeline type and graph structure"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Zero configuration"})," - works out of the box"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Observable"})," - check cache count for diagnostics"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Cache Key Generation:"})}),"\n",(0,l.jsx)(n.p,{children:"Cache keys are generated from:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Pipeline definition type"})," - Full name for type distinction"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Graph structure hash"})," - SHA256 hash of:","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Node IDs and types"}),"\n",(0,l.jsx)(n.li,{children:"Input/output types"}),"\n",(0,l.jsx)(n.li,{children:"Edge connections"}),"\n",(0,l.jsx)(n.li,{children:"Execution strategies"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"This ensures:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Structurally identical pipelines ",(0,l.jsx)(n.strong,{children:"share"})," cached plans"]}),"\n",(0,l.jsxs)(n.li,{children:["Any structural change ",(0,l.jsx)(n.strong,{children:"invalidates"})," the cache automatically"]}),"\n",(0,l.jsx)(n.li,{children:"No manual cache invalidation needed"}),"\n",(0,l.jsx)(n.li,{children:"Type-safe - mismatched types can't accidentally share plans"}),"\n"]}),"\n",(0,l.jsxs)(n.h3,{id:"null-cache-nullpipelineexecutionplancache",children:["Null Cache: ",(0,l.jsx)(n.code,{children:"NullPipelineExecutionPlanCache"})]}),"\n",(0,l.jsx)(n.p,{children:"For scenarios where caching should be disabled:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"var runner = new PipelineRunnerBuilder()\n    .WithoutExecutionPlanCache()\n    .Build();\n\n// No caching occurs\nawait runner.RunAsync<MyPipeline>();\n"})}),"\n",(0,l.jsx)(n.p,{children:"The null cache implementation:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Always reports cache misses"}),"\n",(0,l.jsx)(n.li,{children:"Discards any plans provided to it"}),"\n",(0,l.jsx)(n.li,{children:"Has zero overhead when caching is disabled"}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"how-it-works-execution-flow",children:"How It Works: Execution Flow"}),"\n",(0,l.jsx)(n.h3,{id:"first-run-compilation--caching",children:"First Run: Compilation & Caching"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"1. PipelineRunner.RunAsync() called\n2. Check cache for compiled plans\n3. Cache miss \u2717\n4. Call executionCoordinator.BuildPlans()\n   \u2514\u2500 Compile expression trees for all nodes\n   \u2514\u2500 Create delegates for transforms/sinks\n   \u2514\u2500 Build execution plan dictionary\n5. Store plans in cache\n6. Execute pipeline with cached plans\n"})}),"\n",(0,l.jsx)(n.h3,{id:"subsequent-runs-cache-hit",children:"Subsequent Runs: Cache Hit"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"1. PipelineRunner.RunAsync() called\n2. Check cache for compiled plans\n3. Cache hit \u2713\n4. Retrieve cached plans immediately\n5. Execute pipeline with cached plans\n   \u2514\u2500 No expression compilation\n   \u2514\u2500 No reflection overhead\n"})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"safety-when-caching-is-disabled",children:"Safety: When Caching Is Disabled"}),"\n",(0,l.jsxs)(n.p,{children:["Caching is ",(0,l.jsx)(n.strong,{children:"automatically disabled"})," for scenarios where it wouldn't be safe:"]}),"\n",(0,l.jsx)(n.h3,{id:"1-pipelines-with-preconfigured-nodes",children:"1. Pipelines with Preconfigured Nodes"}),"\n",(0,l.jsx)(n.p,{children:"If a pipeline has preconfigured node instances, caching is skipped:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"var pipeline = builder.Build();\n\n// If graph has preconfigured instances:\ngraph.PreconfiguredNodeInstances.Count > 0  // \u2190 Cache disabled\n\n// Why: Preconfigured nodes may have state that changes between runs\n// The compiled plan might reference mutable state\n"})}),"\n",(0,l.jsx)(n.h3,{id:"2-explicit-null-cache",children:"2. Explicit Null Cache"}),"\n",(0,l.jsx)(n.p,{children:"When explicitly disabled:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"var runner = new PipelineRunnerBuilder()\n    .WithoutExecutionPlanCache()\n    .Build();\n\n// Cache disabled - plans recompiled every run\nawait runner.RunAsync<MyPipeline>();\n"})}),"\n",(0,l.jsx)(n.h3,{id:"3-null-cache-implementation",children:"3. Null Cache Implementation"}),"\n",(0,l.jsx)(n.p,{children:"When using the null cache intentionally:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"var runner = new PipelineRunnerBuilder()\n    .WithExecutionPlanCache(NullPipelineExecutionPlanCache.Instance)\n    .Build();\n\n// Effectively disables caching\n"})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"usage-patterns",children:"Usage Patterns"}),"\n",(0,l.jsx)(n.h3,{id:"1-default-automatic-caching",children:"1. Default (Automatic Caching)"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"No configuration needed"})," - caching is enabled by default:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"// Caching enabled automatically\nvar runner = PipelineRunner.Create();\n\n// First execution: compiles and caches\nawait runner.RunAsync<DataProcessingPipeline>();\n\n// Second execution: uses cache (75% faster!)\nawait runner.RunAsync<DataProcessingPipeline>();\n"})}),"\n",(0,l.jsx)(n.h3,{id:"2-custom-cache-with-monitoring",children:"2. Custom Cache with Monitoring"}),"\n",(0,l.jsx)(n.p,{children:"Track cache effectiveness:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'var cache = new InMemoryPipelineExecutionPlanCache();\nvar runner = new PipelineRunnerBuilder()\n    .WithExecutionPlanCache(cache)\n    .Build();\n\n// Monitor cache size\nConsole.WriteLine($"Cached pipelines: {cache.Count}");\n\n// Clear cache if needed\ncache.Clear();\n'})}),"\n",(0,l.jsx)(n.h3,{id:"3-disabling-caching",children:"3. Disabling Caching"}),"\n",(0,l.jsx)(n.p,{children:"For testing or dynamic pipelines:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"var runner = new PipelineRunnerBuilder()\n    .WithoutExecutionPlanCache()\n    .Build();\n\n// Fresh compilation every run\n// Useful for: testing, dynamic pipelines, debugging\nawait runner.RunAsync<MyPipeline>();\n"})}),"\n",(0,l.jsx)(n.h3,{id:"4-custom-cache-implementation",children:"4. Custom Cache Implementation"}),"\n",(0,l.jsx)(n.p,{children:"For distributed scenarios:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"public class RedisPipelineExecutionPlanCache : IPipelineExecutionPlanCache\n{\n    private readonly IConnectionMultiplexer _redis;\n\n    public bool TryGetCachedPlans(Type type, PipelineGraph graph, \n        out Dictionary<string, NodeExecutionPlan>? plans)\n    {\n        var key = GenerateCacheKey(type, graph);\n        var cached = _redis.GetDatabase().StringGet(key);\n        \n        if (cached.HasValue)\n        {\n            plans = JsonSerializer.Deserialize<Dictionary<string, NodeExecutionPlan>>(cached);\n            return true;\n        }\n        \n        plans = null;\n        return false;\n    }\n\n    public void CachePlans(Type type, PipelineGraph graph, \n        Dictionary<string, NodeExecutionPlan> plans)\n    {\n        var key = GenerateCacheKey(type, graph);\n        var json = JsonSerializer.Serialize(plans);\n        _redis.GetDatabase().StringSet(key, json, \n            expiry: TimeSpan.FromHours(24));\n    }\n\n    public void Clear()\n    {\n        // Clear Redis cache\n        _redis.GetDatabase().FlushAll();\n    }\n\n    public int Count => _redis.GetDatabase().Keys().Count();\n}\n\n// Usage\nvar cache = new RedisPipelineExecutionPlanCache(redisConnection);\nvar runner = new PipelineRunnerBuilder()\n    .WithExecutionPlanCache(cache)\n    .Build();\n\n// Cache is shared across instances/processes!\n"})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"when-to-disable-caching",children:"When to Disable Caching"}),"\n",(0,l.jsx)(n.h3,{id:"testing",children:"Testing"}),"\n",(0,l.jsx)(n.p,{children:"When unit testing pipeline behavior that requires isolated compilation (stateful tests, benchmarks):"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"[Fact]\npublic async Task StatefulNode_MaintainsStateAcrossItems()\n{\n    // Use helper from NPipeline.Tests.Common for convenience\n    var runner = TestCachingHelpers.CreateRunnerWithoutCaching();\n\n    // Each test gets fresh compilation, ensuring isolation\n    await runner.RunAsync<TestPipeline>();\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"For the majority of tests, caching can remain enabled (default behavior). Different pipeline types/structures result in automatic cache misses, providing natural test isolation:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"[Fact]\npublic async Task DataFlow_ProcessesCorrectly()\n{\n    // Standard approach - caching enabled but with natural isolation\n    var runner = new PipelineRunnerBuilder()\n        .WithPipelineFactory(pipelineFactory)\n        .WithNodeFactory(nodeFactory)\n        .Build();\n\n    await runner.RunAsync<MyPipeline>();\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"dynamic-pipelines",children:"Dynamic Pipelines"}),"\n",(0,l.jsx)(n.p,{children:"When pipeline structure changes frequently:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"// Pipeline structure varies based on user input\nvar builder = new PipelineBuilder();\nApplyUserDefinedStages(builder); // Structure changes each time\n\nvar runner = new PipelineRunnerBuilder()\n    .WithoutExecutionPlanCache()\n    .Build();\n"})}),"\n",(0,l.jsx)(n.h3,{id:"memory-constraints",children:"Memory Constraints"}),"\n",(0,l.jsx)(n.p,{children:"When running thousands of unique pipeline definitions:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"// Generating many different pipeline types dynamically\n// Caching would cause unbounded memory growth\nvar runner = new PipelineRunnerBuilder()\n    .WithoutExecutionPlanCache()\n    .Build();\n\n// Or implement a custom cache with LRU eviction\n"})}),"\n",(0,l.jsx)(n.h3,{id:"debugging-compilation",children:"Debugging Compilation"}),"\n",(0,l.jsx)(n.p,{children:"When troubleshooting expression tree compilation:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'// Disable cache to see compilation overhead\nvar runner = new PipelineRunnerBuilder()\n    .WithoutExecutionPlanCache()\n    .Build();\n\n// Profile to measure compilation time\nvar sw = Stopwatch.StartNew();\nawait runner.RunAsync<MyPipeline>();\nsw.Stop();\nConsole.WriteLine($"Execution time: {sw.ElapsedMilliseconds}ms");\n'})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,l.jsx)(n.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Per-pipeline cache entry:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Small pipelines (3-5 nodes): ~1-2 KB"}),"\n",(0,l.jsx)(n.li,{children:"Medium pipelines (10-20 nodes): ~5-10 KB"}),"\n",(0,l.jsx)(n.li,{children:"Large pipelines (50+ nodes): ~20-50 KB"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Total cache overhead:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Typical application (5-10 pipelines): 10-100 KB"}),"\n",(0,l.jsx)(n.li,{children:"Large application (50+ pipelines): 1-5 MB"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"cache-hit-rate",children:"Cache Hit Rate"}),"\n",(0,l.jsx)(n.p,{children:"Cache effectiveness depends on pipeline reuse:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Batch processing:"})," 100% hit rate after first run (pipeline runs many times)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Request-driven:"})," 95%+ hit rate (same pipelines serve many requests)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Dynamic pipelines:"})," 0% hit rate (each structure is unique)"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"cpu-impact",children:"CPU Impact"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Expression Compilation (per pipeline run without cache):"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Cost: 300-500\u03bcs"}),"\n",(0,l.jsx)(n.li,{children:"GC allocations: Several KB per pipeline"}),"\n",(0,l.jsx)(n.li,{children:"CPU time: ~1-2% of typical pipeline execution"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Cache Lookup (per pipeline run with cache):"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Cost: <1\u03bcs (hash table lookup)"}),"\n",(0,l.jsx)(n.li,{children:"GC allocations: None"}),"\n",(0,l.jsx)(n.li,{children:"CPU time: Negligible"}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,l.jsx)(n.h3,{id:"pipelinerunner",children:"PipelineRunner"}),"\n",(0,l.jsx)(n.p,{children:"The pipeline runner accepts an optional cache:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"public sealed class PipelineRunner(\n    // ... other dependencies ...\n    IPipelineExecutionPlanCache? executionPlanCache = null) : IPipelineRunner\n{\n    private readonly IPipelineExecutionPlanCache _executionPlanCache = \n        executionPlanCache ?? new InMemoryPipelineExecutionPlanCache();\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"pipelineexecutioncoordinator",children:"PipelineExecutionCoordinator"}),"\n",(0,l.jsx)(n.p,{children:"The coordinator implements the caching logic:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"public Dictionary<string, NodeExecutionPlan> BuildPlansWithCache(\n    Type pipelineDefinitionType,\n    PipelineGraph graph,\n    IReadOnlyDictionary<string, INode> nodeInstances,\n    IPipelineExecutionPlanCache cache)\n{\n    // Try cache first\n    if (cache.TryGetCachedPlans(pipelineDefinitionType, graph, out var cached))\n        return cached;\n\n    // Cache miss - compile and store\n    var plans = nodeInstantiationService.BuildPlans(graph, nodeInstances);\n    cache.CachePlans(pipelineDefinitionType, graph, plans);\n    \n    return plans;\n}\n"})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"faq",children:"FAQ"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Q: Is caching enabled by default?"})}),"\n",(0,l.jsxs)(n.p,{children:["A: Yes. Caching is enabled by default with the ",(0,l.jsx)(n.code,{children:"InMemoryPipelineExecutionPlanCache"}),". It can be explicitly disabled via ",(0,l.jsx)(n.code,{children:"WithoutExecutionPlanCache()"}),"."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Q: Should I always cache?"})}),"\n",(0,l.jsx)(n.p,{children:"A: Yes, for most applications. Cache only when:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Testing requires fresh compilation"}),"\n",(0,l.jsx)(n.li,{children:"Pipeline structure changes frequently"}),"\n",(0,l.jsx)(n.li,{children:"Memory is severely constrained"}),"\n",(0,l.jsx)(n.li,{children:"You're debugging compilation"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Q: What's the cache key based on?"})}),"\n",(0,l.jsx)(n.p,{children:"A: The cache key includes:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Pipeline definition type (full name)"}),"\n",(0,l.jsx)(n.li,{children:"Graph structure hash (nodes, edges, types, strategies)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"This means structurally identical pipelines share cached plans, but any structural change creates a new cache entry."}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Q: Is it thread-safe?"})}),"\n",(0,l.jsxs)(n.p,{children:["A: Yes. ",(0,l.jsx)(n.code,{children:"InMemoryPipelineExecutionPlanCache"})," uses ",(0,l.jsx)(n.code,{children:"ConcurrentDictionary"})," for thread-safe operations."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Q: Can I use a distributed cache?"})}),"\n",(0,l.jsxs)(n.p,{children:["A: Yes! Implement ",(0,l.jsx)(n.code,{children:"IPipelineExecutionPlanCache"})," and pass it to ",(0,l.jsx)(n.code,{children:"PipelineRunnerBuilder.WithExecutionPlanCache()"}),"."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Q: What if my pipeline graph changes?"})}),"\n",(0,l.jsx)(n.p,{children:"A: Cache miss - the hash changes, so a new plan is compiled and cached separately."}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Q: Can different pipeline types share cached plans?"})}),"\n",(0,l.jsx)(n.p,{children:"A: No - the cache key includes the pipeline definition type for isolation."}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/ipipelinerunner",children:"Pipeline Runner Configuration"})," - Configuring the pipeline runner"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/architecture/optimization-principles",children:"Optimization Principles"})," - Performance design decisions"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/architecture/performance-characteristics",children:"Performance Characteristics"})," - Understanding pipeline performance"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/advanced-topics/",children:"Advanced Topics"})," - Performance tuning and optimization"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>r});var c=i(6540);const l={},a=c.createContext(l);function s(e){const n=c.useContext(a);return c.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),c.createElement(a.Provider,{value:n},e.children)}}}]);