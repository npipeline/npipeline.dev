"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[6219],{1715:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"core-concepts/advanced-nodes/valuetask-transforms","title":"ValueTask Transforms","description":"Optimize synchronous transform nodes using ValueTask to eliminate allocation overhead.","source":"@site/docs/core-concepts/advanced-nodes/valuetask-transforms.md","sourceDirName":"core-concepts/advanced-nodes","slug":"/core-concepts/advanced-nodes/valuetask-transforms","permalink":"/docs/core-concepts/advanced-nodes/valuetask-transforms","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"title":"ValueTask Transforms","description":"Optimize synchronous transform nodes using ValueTask to eliminate allocation overhead.","sidebar_position":10},"sidebar":"docsSidebar","previous":{"title":"Time-Windowed Joins","permalink":"/docs/core-concepts/advanced-nodes/time-windowed-join"},"next":{"title":"Pipeline Definition (IPipelineDefinition, PipelineBuilder)","permalink":"/docs/core-concepts/pipeline-definition"}}');var t=r(4848),a=r(8453);const i={title:"ValueTask Transforms",description:"Optimize synchronous transform nodes using ValueTask to eliminate allocation overhead.",sidebar_position:10},o=void 0,l={},c=[{value:"Overview",id:"overview",level:2},{value:"Why ValueTask?",id:"why-valuetask",level:2},{value:"When to Use ValueTask Transforms",id:"when-to-use-valuetask-transforms",level:2},{value:"Basic Example",id:"basic-example",level:2},{value:"Mixed Sync/Async Example",id:"mixed-syncasync-example",level:2},{value:"Interaction with Execution Strategies",id:"interaction-with-execution-strategies",level:2},{value:"Sequential Strategy",id:"sequential-strategy",level:3},{value:"Parallel Strategy",id:"parallel-strategy",level:3},{value:"Performance Implications",id:"performance-implications",level:2},{value:"Implementation Pattern",id:"implementation-pattern",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Testing ValueTask Transforms",id:"testing-valuetask-transforms",level:2},{value:"Opt-in Optimization",id:"opt-in-optimization",level:2},{value:"Summary",id:"summary",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["NPipeline's ",(0,t.jsx)(n.code,{children:"TransformNode<TIn, TOut>"})," base class supports an optional ",(0,t.jsx)(n.code,{children:"ExecuteValueTaskAsync"})," override that enables high-performance, allocation-free execution for transforms that complete synchronously."]}),"\n",(0,t.jsx)(n.p,{children:"Execution strategies (sequential, parallel, and custom) automatically detect nodes implementing this optimization and avoid Task allocation overhead when the work completes synchronously."}),"\n",(0,t.jsx)(n.h2,{id:"why-valuetask",children:"Why ValueTask?"}),"\n",(0,t.jsxs)(n.p,{children:["When a transform operation ",(0,t.jsx)(n.strong,{children:"completes synchronously"})," (e.g., in-memory validation, simple calculations), the standard ",(0,t.jsx)(n.code,{children:"Task<T>"})," approach creates allocations:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Standard approach - allocates Task<T> even when work is immediate\r\npublic override Task<int> ExecuteAsync(int item, PipelineContext context, CancellationToken cancellationToken)\r\n{\r\n    return Task.FromResult(item + 1); // Allocates even though it's synchronous\r\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ValueTask<T>"})," avoids this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// ValueTask approach - zero allocation when complete immediately\r\nprotected internal override ValueTask<int> ExecuteValueTaskAsync(int item, PipelineContext context, CancellationToken cancellationToken)\r\n{\r\n    return ValueTask.FromResult(item + 1); // No allocation\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"For pipelines processing millions of items through synchronous transforms, this can reduce garbage collection pressure and improve throughput."}),"\n",(0,t.jsx)(n.h2,{id:"when-to-use-valuetask-transforms",children:"When to Use ValueTask Transforms"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"ExecuteValueTaskAsync"})," when your transform:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Completes synchronously"})," (no I/O, no waiting)"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Is in a hot path"})," (processes many items)"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Has simple logic"})," (validation, transformation, mapping)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Don't use ",(0,t.jsx)(n.code,{children:"ExecuteValueTaskAsync"})," if your transform:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\u274c Always performs async operations (database calls, API requests, ",(0,t.jsx)(n.code,{children:"await"})," operations)"]}),"\n",(0,t.jsx)(n.li,{children:"\u274c Is not performance-critical"}),"\n",(0,t.jsx)(n.li,{children:"\u274c Would require complex branching based on sync/async conditions"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"basic-example",children:"Basic Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Validates and transforms items synchronously.\r\n/// Uses ExecuteValueTaskAsync to avoid Task allocations.\r\n/// </summary>\r\npublic sealed class FastValidator : TransformNode<int, string>\r\n{\r\n    public override Task<string> ExecuteAsync(int item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // This is called by frameworks expecting Task<T>\r\n        // It delegates to ExecuteValueTaskAsync and wraps the result\r\n        return FromValueTask(ExecuteValueTaskAsync(item, context, cancellationToken));\r\n    }\r\n\r\n    protected internal override ValueTask<string> ExecuteValueTaskAsync(int item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Fast, synchronous work - no allocation\r\n        if (item < 0)\r\n            throw new ArgumentException("Item must be non-negative");\r\n\r\n        return ValueTask.FromResult($"Item-{item}");\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"mixed-syncasync-example",children:"Mixed Sync/Async Example"}),"\n",(0,t.jsxs)(n.p,{children:["For transforms that are ",(0,t.jsx)(n.strong,{children:"mostly synchronous"})," but occasionally async:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public sealed class CachedLookupTransform : TransformNode<string, string>\r\n{\r\n    private readonly Dictionary<string, string> _cache = new();\r\n    private readonly Func<string, Task<string>> _lookupAsync;\r\n\r\n    public CachedLookupTransform(Func<string, Task<string>> lookupAsync)\r\n    {\r\n        _lookupAsync = lookupAsync;\r\n    }\r\n\r\n    public override Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        return FromValueTask(ExecuteValueTaskAsync(item, context, cancellationToken));\r\n    }\r\n\r\n    protected internal override async ValueTask<string> ExecuteValueTaskAsync(string item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Fast path: check cache first (synchronous)\r\n        if (_cache.TryGetValue(item, out var cached))\r\n            return cached;\r\n\r\n        // Slow path: async lookup if not cached\r\n        var result = await _lookupAsync(item);\r\n        _cache[item] = result;\r\n        return result;\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this case:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache hits"})," return a ",(0,t.jsx)(n.code,{children:"ValueTask"})," with no allocation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache misses"})," still perform async work but benefit from the ValueTask envelope"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"interaction-with-execution-strategies",children:"Interaction with Execution Strategies"}),"\n",(0,t.jsxs)(n.p,{children:["All execution strategies (sequential, parallel variants) automatically detect ",(0,t.jsx)(n.code,{children:"ExecuteValueTaskAsync"})," and prefer it over ",(0,t.jsx)(n.code,{children:"ExecuteAsync"}),":"]}),"\n",(0,t.jsx)(n.h3,{id:"sequential-strategy",children:"Sequential Strategy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// No special configuration needed - it just works\r\nvar pipeline = new PipelineBuilder()\r\n    .AddSource(/* ... */)\r\n    .AddTransform<FastValidator, int, string>()  // Automatically uses ValueTask path\r\n    .AddSink(/* ... */);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"parallel-strategy",children:"Parallel Strategy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Parallel strategies also benefit from ValueTask optimization\r\nvar pipeline = new PipelineBuilder()\r\n    .AddSource(/* ... */)\r\n    .AddTransform<FastValidator, int, string>()\r\n    .WithParallelism(Environment.ProcessorCount)  // Uses ValueTask path in worker threads\r\n    .AddSink(/* ... */);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"performance-implications",children:"Performance Implications"}),"\n",(0,t.jsx)(n.p,{children:"Benchmarks show typical improvements for synchronous transforms:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Scenario"}),(0,t.jsx)(n.th,{children:"Improvement"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Simple validation (synchronous)"}),(0,t.jsx)(n.td,{children:"10-15% throughput increase"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Mapping operations (synchronous)"}),(0,t.jsx)(n.td,{children:"5-10% throughput increase"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Cache-heavy workloads"}),(0,t.jsx)(n.td,{children:"20-30% throughput increase (when hit rate is high)"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"Note: Improvements depend on workload and system load. Always profile your specific pipelines."}),"\n",(0,t.jsx)(n.h2,{id:"implementation-pattern",children:"Implementation Pattern"}),"\n",(0,t.jsx)(n.p,{children:"The recommended pattern for new transform nodes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public sealed class MyOptimizedTransform : TransformNode<TIn, TOut>\r\n{\r\n    // Step 1: Override ExecuteAsync to delegate to ExecuteValueTaskAsync\r\n    public override Task<TOut> ExecuteAsync(TIn item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        return FromValueTask(ExecuteValueTaskAsync(item, context, cancellationToken));\r\n    }\r\n\r\n    // Step 2: Implement the ValueTask version with your actual logic\r\n    protected internal override ValueTask<TOut> ExecuteValueTaskAsync(TIn item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Your synchronous (or mostly synchronous) work here\r\n        var result = DoWork(item);\r\n        return ValueTask.FromResult(result);\r\n    }\r\n\r\n    private TOut DoWork(TIn item)\r\n    {\r\n        // Implementation\r\n        throw new NotImplementedException();\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"Error handling works transparently:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public sealed class ValidatingTransform : TransformNode<Order, Order>\r\n{\r\n    public override Task<Order> ExecuteAsync(Order item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        return FromValueTask(ExecuteValueTaskAsync(item, context, cancellationToken));\r\n    }\r\n\r\n    protected internal override ValueTask<Order> ExecuteValueTaskAsync(Order item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Exceptions are handled by execution strategies just like in ExecuteAsync\r\n        if (item.Total < 0)\r\n            throw new ArgumentException("Order total must be non-negative");\r\n\r\n        return ValueTask.FromResult(item);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Both synchronous exceptions and async exceptions (if your ValueTask is faulted) are caught and handled by error handlers configured on the node."}),"\n",(0,t.jsx)(n.h2,{id:"testing-valuetask-transforms",children:"Testing ValueTask Transforms"}),"\n",(0,t.jsx)(n.p,{children:"Test ValueTask transforms the same way you test regular transforms:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'[Fact]\r\npublic async Task FastValidator_ValidatesCorrectly()\r\n{\r\n    // Arrange\r\n    var transform = new FastValidator();\r\n    var context = PipelineContext.Default;\r\n\r\n    // Act\r\n    var result = await transform.ExecuteAsync(42, context, CancellationToken.None);\r\n\r\n    // Assert\r\n    Assert.Equal("Item-42", result);\r\n}\r\n\r\n[Fact]\r\npublic async Task FastValidator_ThrowsOnInvalid()\r\n{\r\n    // Arrange\r\n    var transform = new FastValidator();\r\n    var context = PipelineContext.Default;\r\n\r\n    // Act & Assert\r\n    await Assert.ThrowsAsync<ArgumentException>(\r\n        () => transform.ExecuteAsync(-1, context, CancellationToken.None));\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"The testing utilities handle both sync and async paths transparently."}),"\n",(0,t.jsx)(n.h2,{id:"opt-in-optimization",children:"Opt-in Optimization"}),"\n",(0,t.jsx)(n.p,{children:"ValueTask transforms are entirely optional and transparent:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Existing transforms without ",(0,t.jsx)(n.code,{children:"ExecuteValueTaskAsync"})," override continue to work"]}),"\n",(0,t.jsx)(n.li,{children:"No configuration required\u2014execution strategies handle detection automatically"}),"\n",(0,t.jsx)(n.li,{children:"The optimization is transparent to pipeline authors"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"ExecuteValueTaskAsync"})," to optimize synchronous transforms:"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Aspect"}),(0,t.jsx)(n.th,{children:"Details"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"When"})}),(0,t.jsx)(n.td,{children:"Synchronous, hot-path transforms"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"How"})}),(0,t.jsxs)(n.td,{children:["Override ",(0,t.jsx)(n.code,{children:"ExecuteValueTaskAsync"}),", use ",(0,t.jsx)(n.code,{children:"FromValueTask"})," helper"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Benefit"})}),(0,t.jsx)(n.td,{children:"Reduced allocations, improved throughput"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Adoption"})}),(0,t.jsx)(n.td,{children:"Opt-in, automatic detection by execution strategies"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Testing"})}),(0,t.jsx)(n.td,{children:"Same as regular transforms"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Strategies"})}),(0,t.jsx)(n.td,{children:"Works with sequential, parallel, and custom execution strategies"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/nodes/transform-nodes",children:"Transform Nodes"})," - General transform node documentation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/best-practices",children:"Best Practices"})," - General best practices including performance optimization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/architecture/execution-flow",children:"Execution Strategies"})," - How strategies interact with transforms"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var s=r(6540);const t={},a=s.createContext(t);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);