"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[2216],{1885:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-concepts/resilience/retry-configuration","title":"Retry Configuration","description":"Learn how to configure retry behavior in NPipeline using PipelineRetryOptions to manage item retries and node restarts.","source":"@site/docs/core-concepts/resilience/retry-configuration.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/retry-configuration","permalink":"/docs/core-concepts/resilience/retry-configuration","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Retry Configuration","description":"Learn how to configure retry behavior in NPipeline using PipelineRetryOptions to manage item retries and node restarts.","sidebar_position":7},"sidebar":"docsSidebar","previous":{"title":"Troubleshooting","permalink":"/docs/core-concepts/resilience/troubleshooting"},"next":{"title":"Circuit Breaker Configuration","permalink":"/docs/core-concepts/resilience/circuit-breaker-configuration"}}');var t=n(4848),a=n(8453);const s={title:"Retry Configuration",description:"Learn how to configure retry behavior in NPipeline using PipelineRetryOptions to manage item retries and node restarts.",sidebar_position:7},l="Retry Configuration",o={},c=[{value:"Overview",id:"overview",level:2},{value:"PipelineRetryOptions",id:"pipelineretryoptions",level:2},{value:"Basic Retry Configuration",id:"basic-retry-configuration",level:2},{value:"Global Retry Options",id:"global-retry-options",level:3},{value:"Per-Node Retry Options",id:"per-node-retry-options",level:3},{value:"Use Cases for Per-Node Retry Configuration",id:"use-cases-for-per-node-retry-configuration",level:4},{value:"Precedence Rules",id:"precedence-rules",level:4},{value:"Integrating External Retry Libraries",id:"integrating-external-retry-libraries",level:2},{value:"Built-in Retry Delay Strategies",id:"built-in-retry-delay-strategies",level:2},{value:"Why Backoff and Jitter Matter",id:"why-backoff-and-jitter-matter",level:3},{value:"Available Backoff Strategies",id:"available-backoff-strategies",level:3},{value:"Exponential Backoff",id:"exponential-backoff",level:4},{value:"Linear Backoff",id:"linear-backoff",level:4},{value:"Fixed Delay",id:"fixed-delay",level:4},{value:"Available Jitter Strategies",id:"available-jitter-strategies",level:3},{value:"Full Jitter",id:"full-jitter",level:4},{value:"Equal Jitter",id:"equal-jitter",level:4},{value:"Decorrelated Jitter",id:"decorrelated-jitter",level:4},{value:"No Jitter",id:"no-jitter",level:4},{value:"Recommended Strategy Combinations",id:"recommended-strategy-combinations",level:3},{value:"Configuration at Initialization",id:"configuration-at-initialization",level:3},{value:"Runtime Configuration",id:"runtime-configuration",level:3},{value:"Retry Delay API Reference",id:"retry-delay-api-reference",level:2},{value:"Core Interfaces",id:"core-interfaces",level:3},{value:"IRetryDelayStrategy",id:"iretrydelaystrategy",level:4},{value:"IBackoffStrategy",id:"ibackoffstrategy",level:4},{value:"IJitterStrategy",id:"ijitterstrategy",level:4},{value:"Strategy Classes",id:"strategy-classes",level:3},{value:"ExponentialBackoffStrategy",id:"exponentialbackoffstrategy",level:4},{value:"LinearBackoffStrategy",id:"linearbackoffstrategy",level:4},{value:"FixedDelayStrategy",id:"fixeddelaystrategy",level:4},{value:"Jitter Strategies",id:"jitter-strategies",level:4},{value:"CompositeRetryDelayStrategy",id:"compositeretrydelaystrategy",level:4},{value:"NoOpRetryDelayStrategy",id:"noopretrydelaystrategy",level:4},{value:"Configuration Classes",id:"configuration-classes",level:3},{value:"ExponentialBackoffConfiguration",id:"exponentialbackoffconfiguration",level:4},{value:"LinearBackoffConfiguration",id:"linearbackoffconfiguration",level:4},{value:"FixedDelayConfiguration",id:"fixeddelayconfiguration",level:4},{value:"Jitter Configurations",id:"jitter-configurations",level:4},{value:"RetryDelayStrategyConfiguration",id:"retrydelaystrategyconfiguration",level:4},{value:"Extension Methods",id:"extension-methods",level:3},{value:"PipelineContextRetryDelayExtensions",id:"pipelinecontextretrydelayextensions",level:4},{value:"Factory",id:"factory",level:3},{value:"DefaultRetryDelayStrategyFactory",id:"defaultretrydelaystrategyfactory",level:4},{value:"Validation",id:"validation",level:3},{value:"RetryDelayStrategyValidator",id:"retrydelaystrategyvalidator",level:4},{value:"Retry Strategies",id:"retry-strategies",level:2},{value:"Fixed Delay Retry",id:"fixed-delay-retry",level:3},{value:"Exponential Backoff with Jitter",id:"exponential-backoff-with-jitter",level:3},{value:"Context-Aware Retry",id:"context-aware-retry",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Production Example",id:"production-example",level:2},{value:"Troubleshooting Retry Strategies",id:"troubleshooting-retry-strategies",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"Too Many Retries",id:"too-many-retries",level:4},{value:"Too Few Retries",id:"too-few-retries",level:4},{value:"Thundering Herd Problem",id:"thundering-herd-problem",level:4},{value:"Long Recovery Times",id:"long-recovery-times",level:4},{value:"Debugging Retry Patterns",id:"debugging-retry-patterns",level:3},{value:"Performance Profiling",id:"performance-profiling",level:3},{value:"Implementation Guidelines",id:"implementation-guidelines",level:2},{value:"Integration Checklist",id:"integration-checklist",level:3},{value:"Parameter Selection Guidelines",id:"parameter-selection-guidelines",level:3},{value:"Base Delay",id:"base-delay",level:4},{value:"Backoff Multiplier/Increment",id:"backoff-multiplierincrement",level:4},{value:"Maximum Delay",id:"maximum-delay",level:4},{value:"Monitoring Key Metrics",id:"monitoring-key-metrics",level:3},{value:"See Also",id:"see-also",level:2},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const r={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"retry-configuration",children:"Retry Configuration"})}),"\n",(0,t.jsx)(r.p,{children:"Retry configuration in NPipeline allows you to define how the pipeline should respond to transient failures by retrying operations. This is essential for building resilient pipelines that can recover from temporary issues without manual intervention."}),"\n",(0,t.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(r.p,{children:"NPipeline provides configurable retry options that control both individual item retries (for node-level errors) and node restart attempts (for pipeline-level errors). These options can be set globally for the entire pipeline or overridden for specific nodes."}),"\n",(0,t.jsx)(r.h2,{id:"pipelineretryoptions",children:"PipelineRetryOptions"}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.a,{href:"../../src/NPipeline/Configuration/PipelineRetryOptions.cs",children:(0,t.jsx)(r.code,{children:"PipelineRetryOptions"})})," record configures retry behavior for items and node restarts."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public sealed record PipelineRetryOptions(\r\n    int MaxItemRetries,\r\n    int MaxNodeRestartAttempts,\r\n    int MaxSequentialNodeAttempts,\r\n    int? MaxMaterializedItems = null) // Null => unbounded (no cap)\r\n{\r\n    public static PipelineRetryOptions Default { get; } = new(0, 3, 5);\r\n\r\n    public PipelineRetryOptions With(\r\n        int? maxItemRetries = null,\r\n        int? maxNodeRestartAttempts = null,\r\n        int? maxSequentialNodeAttempts = null,\r\n        int? maxMaterializedItems = null)\r\n    {\r\n        return new PipelineRetryOptions(\r\n            maxItemRetries ?? MaxItemRetries,\r\n            maxNodeRestartAttempts ?? MaxNodeRestartAttempts,\r\n            maxSequentialNodeAttempts ?? MaxSequentialNodeAttempts,\r\n            maxMaterializedItems ?? MaxMaterializedItems);\r\n    }\r\n}\n"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"MaxItemRetries"})}),": The maximum number of times an individual item will be re-processed by a node's execution strategy if its ",(0,t.jsx)(r.code,{children:"INodeErrorHandler"})," returns ",(0,t.jsx)(r.code,{children:"NodeErrorDecision.Retry"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"MaxNodeRestartAttempts"})}),": The maximum number of times a node's entire stream will be re-executed by ",(0,t.jsx)(r.code,{children:"ResilientExecutionStrategy"})," if ",(0,t.jsx)(r.code,{children:"IPipelineErrorHandler"})," returns ",(0,t.jsx)(r.code,{children:"PipelineErrorDecision.RestartNode"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"MaxSequentialNodeAttempts"})}),": (Used by ",(0,t.jsx)(r.code,{children:"SequentialExecutionStrategy"})," for node restarts) The maximum number of attempts for a node in a sequential pipeline."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"MaxMaterializedItems"})}),": An optional cap on the number of items to materialize (buffer) for replay when using ",(0,t.jsx)(r.code,{children:"ResilientExecutionStrategy"}),".","\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["When ",(0,t.jsx)(r.code,{children:"null"})," (default): Unbounded materialization - all items are buffered"]}),"\n",(0,t.jsx)(r.li,{children:"When has a value: Limited materialization - only the specified number of items are buffered, after which new items replace the oldest ones"}),"\n",(0,t.jsx)(r.li,{children:"This parameter prevents excessive memory consumption in case of large streams and is particularly important for long-running pipelines with high throughput"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"basic-retry-configuration",children:"Basic Retry Configuration"}),"\n",(0,t.jsx)(r.h3,{id:"global-retry-options",children:"Global Retry Options"}),"\n",(0,t.jsx)(r.p,{children:"You can set retry options globally for the pipeline:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\npublic sealed class RetryPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<DataSource, string>();\r\n        var transformHandle = builder.AddTransform<DataTransform, string, string>();\r\n        var sinkHandle = builder.AddSink<DataSink, string>();\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n\r\n        // Configure retry policy using PipelineRetryOptions\r\n        builder.WithRetryOptions(new PipelineRetryOptions(\r\n            MaxItemRetries: 3,\r\n            MaxNodeRestartAttempts: 2,\r\n            MaxSequentialNodeAttempts: 5\r\n        ));\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var runner = new PipelineRunner();\r\n        await runner.RunAsync<RetryPipelineDefinition>();\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"per-node-retry-options",children:"Per-Node Retry Options"}),"\n",(0,t.jsxs)(r.p,{children:["You can override the global retry options for a specific node using the ",(0,t.jsx)(r.code,{children:"WithRetryOptions"})," method that accepts a ",(0,t.jsx)(r.code,{children:"NodeHandle"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\npublic sealed class PerNodeRetryPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<DataSource, string>("source");\r\n        var criticalTransformHandle = builder.AddTransform<CriticalDataTransform, string, string>("critical-transform");\r\n        var normalTransformHandle = builder.AddTransform<NormalDataTransform, string, string>("normal-transform");\r\n        var sinkHandle = builder.AddSink<DataSink, string>("sink");\r\n\r\n        builder.Connect(sourceHandle, criticalTransformHandle);\r\n        builder.Connect(criticalTransformHandle, normalTransformHandle);\r\n        builder.Connect(normalTransformHandle, sinkHandle);\r\n\r\n        // Configure global retry options (default for all nodes)\r\n        builder.WithRetryOptions(new PipelineRetryOptions(\r\n            MaxItemRetries: 2,\r\n            MaxNodeRestartAttempts: 3,\r\n            MaxSequentialNodeAttempts: 5\r\n        ));\r\n\r\n        // Override retry options for the critical transform\r\n        builder.WithRetryOptions(criticalTransformHandle, new PipelineRetryOptions(\r\n            MaxItemRetries: 5,              // More retries for critical processing\r\n            MaxNodeRestartAttempts: 10,      // More restart attempts\r\n            MaxSequentialNodeAttempts: 15,   // Higher total attempt limit\r\n            MaxMaterializedItems: 1000       // Higher memory limit for replay\r\n        ));\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h4,{id:"use-cases-for-per-node-retry-configuration",children:"Use Cases for Per-Node Retry Configuration"}),"\n",(0,t.jsx)(r.p,{children:"Per-node retry options are useful in scenarios where different parts of your pipeline have different resilience requirements:"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"1. External API Calls vs. Internal Processing"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// More aggressive retries for external API calls\r\nbuilder.WithRetryOptions(apiTransformHandle, new PipelineRetryOptions(\r\n    MaxItemRetries: 5,\r\n    MaxNodeRestartAttempts: 3,\r\n    MaxSequentialNodeAttempts: 10\r\n));\r\n\r\n// Conservative retries for internal data processing\r\nbuilder.WithRetryOptions(internalTransformHandle, new PipelineRetryOptions(\r\n    MaxItemRetries: 1,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 3\r\n));\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"2. Critical vs. Non-Critical Processing"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Maximum resilience for critical business logic\r\nbuilder.WithRetryOptions(criticalProcessorHandle, new PipelineRetryOptions(\r\n    MaxItemRetries: 10,\r\n    MaxNodeRestartAttempts: 5,\r\n    MaxSequentialNodeAttempts: 20,\r\n    MaxMaterializedItems: 5000\r\n));\r\n\r\n// Best-effort processing for non-critical data\r\nbuilder.WithRetryOptions(loggingProcessorHandle, new PipelineRetryOptions(\r\n    MaxItemRetries: 0,  // No retries for logging\r\n    MaxNodeRestartAttempts: 1,\r\n    MaxSequentialNodeAttempts: 2\r\n));\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"3. Resource-Intensive Operations"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Limited retries for memory-intensive operations\r\nbuilder.WithRetryOptions(memoryIntensiveHandle, new PipelineRetryOptions(\r\n    MaxItemRetries: 1,\r\n    MaxNodeRestartAttempts: 1,\r\n    MaxSequentialNodeAttempts: 2,\r\n    MaxMaterializedItems: 100  // Strict memory limit\r\n));\n"})}),"\n",(0,t.jsx)(r.h4,{id:"precedence-rules",children:"Precedence Rules"}),"\n",(0,t.jsx)(r.p,{children:"When both global and per-node retry options are configured:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Per-node options take precedence"})," over global options"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Unspecified properties"})," in per-node options inherit from global options"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Global options"})," apply to all nodes without specific overrides"]}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Global configuration\r\nbuilder.WithRetryOptions(new PipelineRetryOptions(\r\n    MaxItemRetries: 2,\r\n    MaxNodeRestartAttempts: 3,\r\n    MaxSequentialNodeAttempts: 5\r\n));\r\n\r\n// Per-node override (only MaxItemRetries is overridden)\r\nbuilder.WithRetryOptions(specificNodeHandle, new PipelineRetryOptions(\r\n    MaxItemRetries: 5,              // Overridden\r\n    MaxNodeRestartAttempts: 3,       // Inherited from global\r\n    MaxSequentialNodeAttempts: 5      // Inherited from global\r\n));\n"})}),"\n",(0,t.jsx)(r.h2,{id:"integrating-external-retry-libraries",children:"Integrating External Retry Libraries"}),"\n",(0,t.jsx)(r.p,{children:"For advanced retry patterns like exponential backoff and jitter, you can integrate external libraries like Polly:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'using Polly;\r\nusing Polly.Retry;\r\nusing NPipeline.ErrorHandling;\r\n\r\npublic class AdvancedRetryHandler : INodeErrorHandler<ITransformNode<string, string>, string>\r\n{\r\n    private readonly AsyncRetryPolicy _retryPolicy;\r\n\r\n    public AdvancedRetryHandler()\r\n    {\r\n        // Configure exponential backoff with jitter\r\n        _retryPolicy = Policy\r\n            .Handle<HttpRequestException>() // Retry on network errors\r\n            .WaitAndRetryAsync(\r\n                retryCount: 5,\r\n                sleepDurationProvider: retryAttempt =>\r\n                    TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + // Exponential backoff\r\n                    TimeSpan.FromMilliseconds(new Random().Next(0, 1000)), // Add jitter\r\n                onRetry: (outcome, timespan, retryAttempt, context) =>\r\n                {\r\n                    Console.WriteLine($"Retry {retryAttempt} after {timespan.TotalSeconds}s due to: {outcome.Exception?.Message}");\r\n                });\r\n    }\r\n\r\n    public async Task<NodeErrorDecision> HandleAsync(\r\n        ITransformNode<string, string> node,\r\n        string failedItem,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        if (error is HttpRequestException)\r\n        {\r\n            try\r\n            {\r\n                // Execute the retry policy\r\n                await _retryPolicy.ExecuteAsync(async () =>\r\n                {\r\n                    // In a real implementation, you would re-execute the node logic here\r\n                    // This is a simplified example\r\n                    Console.WriteLine($"Retrying processing of: {failedItem}");\r\n                    await Task.Delay(100, cancellationToken);\r\n                });\r\n\r\n                return NodeErrorDecision.Retry;\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine($"All retries failed: {ex.Message}");\r\n                return NodeErrorDecision.DeadLetter; // Send to dead-letter after all retries fail\r\n            }\r\n        }\r\n\r\n        return NodeErrorDecision.Skip; // For other error types, just skip\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"built-in-retry-delay-strategies",children:"Built-in Retry Delay Strategies"}),"\n",(0,t.jsxs)(r.p,{children:["NPipeline provides built-in retry delay strategies that combine ",(0,t.jsx)(r.strong,{children:"backoff"})," (how delays increase over time) with ",(0,t.jsx)(r.strong,{children:"jitter"})," (randomness to prevent synchronized retries). These strategies are essential for distributed systems to prevent thundering herd problems."]}),"\n",(0,t.jsx)(r.h3,{id:"why-backoff-and-jitter-matter",children:"Why Backoff and Jitter Matter"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"The Thundering Herd Problem:"})," When multiple pipeline instances encounter failures simultaneously and retry immediately, they can overwhelm a recovering service, causing cascading failures. Backoff strategies prevent this by increasing delays between retries, and jitter adds randomness to prevent synchronized retries."]}),"\n",(0,t.jsx)(r.h3,{id:"available-backoff-strategies",children:"Available Backoff Strategies"}),"\n",(0,t.jsx)(r.h4,{id:"exponential-backoff",children:"Exponential Backoff"}),"\n",(0,t.jsx)(r.p,{children:"Delays grow exponentially, ideal for distributed systems with transient failures:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Configuration approach\r\nvar config = new ExponentialBackoffConfiguration(\r\n    baseDelay: TimeSpan.FromSeconds(1),\r\n    multiplier: 2.0,\r\n    maxDelay: TimeSpan.FromMinutes(1));\r\n\r\n// Runtime configuration via PipelineContext\r\ncontext.UseExponentialBackoffDelay(\r\n    baseDelay: TimeSpan.FromSeconds(1),\r\n    multiplier: 2.0,\r\n    maxDelay: TimeSpan.FromMinutes(1));\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Delay progression:"})," 1s \u2192 2s \u2192 4s \u2192 8s \u2192 16s \u2192 32s \u2192 60s (capped)"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Use cases:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Web API calls with transient network failures"}),"\n",(0,t.jsx)(r.li,{children:"Database connections during temporary overload"}),"\n",(0,t.jsx)(r.li,{children:"Microservice communication during partial outages"}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"linear-backoff",children:"Linear Backoff"}),"\n",(0,t.jsx)(r.p,{children:"Delays grow linearly, providing predictable recovery:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Configuration approach\r\nvar config = new LinearBackoffConfiguration(\r\n    baseDelay: TimeSpan.FromSeconds(1),\r\n    increment: TimeSpan.FromSeconds(2),\r\n    maxDelay: TimeSpan.FromSeconds(30));\r\n\r\n// Runtime configuration\r\ncontext.UseLinearBackoffDelay(\r\n    baseDelay: TimeSpan.FromSeconds(1),\r\n    increment: TimeSpan.FromSeconds(2),\r\n    maxDelay: TimeSpan.FromSeconds(30));\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Delay progression:"})," 1s \u2192 3s \u2192 5s \u2192 7s \u2192 9s \u2192 ... \u2192 30s (capped)"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Use cases:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"File processing with temporary resource contention"}),"\n",(0,t.jsx)(r.li,{children:"Batch operations with predictable recovery patterns"}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"fixed-delay",children:"Fixed Delay"}),"\n",(0,t.jsx)(r.p,{children:"Constant delay between all retries:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Configuration approach\r\nvar config = new FixedDelayConfiguration(\r\n    delay: TimeSpan.FromSeconds(5));\r\n\r\n// Runtime configuration\r\ncontext.UseFixedDelay(\r\n    delay: TimeSpan.FromSeconds(5));\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Delay progression:"})," 5s \u2192 5s \u2192 5s \u2192 5s \u2192 ..."]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Use cases:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Testing and debugging scenarios"}),"\n",(0,t.jsx)(r.li,{children:"Known recovery times"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"available-jitter-strategies",children:"Available Jitter Strategies"}),"\n",(0,t.jsx)(r.h4,{id:"full-jitter",children:"Full Jitter"}),"\n",(0,t.jsx)(r.p,{children:"Provides best protection against thundering herd:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"var config = new FullJitterConfiguration();\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Formula:"})," ",(0,t.jsx)(r.code,{children:"random(0, baseDelay)"})]}),"\n",(0,t.jsx)(r.h4,{id:"equal-jitter",children:"Equal Jitter"}),"\n",(0,t.jsx)(r.p,{children:"Balances predictability with randomness:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"var config = new EqualJitterConfiguration();\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Formula:"})," ",(0,t.jsx)(r.code,{children:"baseDelay/2 + random(0, baseDelay/2)"})]}),"\n",(0,t.jsx)(r.h4,{id:"decorrelated-jitter",children:"Decorrelated Jitter"}),"\n",(0,t.jsx)(r.p,{children:"Adapts based on previous delays:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"var config = new DecorrelatedJitterConfiguration(\r\n    maxDelay: TimeSpan.FromMinutes(1),\r\n    multiplier: 3.0);\n"})}),"\n",(0,t.jsx)(r.h4,{id:"no-jitter",children:"No Jitter"}),"\n",(0,t.jsx)(r.p,{children:"Deterministic timing (useful for testing):"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"var config = new NoJitterConfiguration();\n"})}),"\n",(0,t.jsx)(r.h3,{id:"recommended-strategy-combinations",children:"Recommended Strategy Combinations"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Web APIs (Recommended):"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"context.UseExponentialBackoffDelay(\r\n    baseDelay: TimeSpan.FromSeconds(1),\r\n    multiplier: 2.0,\r\n    maxDelay: TimeSpan.FromMinutes(1));\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Database Operations:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"context.UseLinearBackoffDelay(\r\n    baseDelay: TimeSpan.FromMilliseconds(100),\r\n    increment: TimeSpan.FromMilliseconds(200),\r\n    maxDelay: TimeSpan.FromSeconds(5));\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"File Processing:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"context.UseFixedDelay(\r\n    delay: TimeSpan.FromSeconds(2));\n"})}),"\n",(0,t.jsx)(r.h3,{id:"configuration-at-initialization",children:"Configuration at Initialization"}),"\n",(0,t.jsx)(r.p,{children:"You can configure delay strategies when building your pipeline:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"var retryOptions = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    delayStrategyConfiguration: new RetryDelayStrategyConfiguration(\r\n        new ExponentialBackoffConfiguration(\r\n            TimeSpan.FromSeconds(1), 2.0, TimeSpan.FromMinutes(1)),\r\n        new FullJitterConfiguration()));\r\n\r\nbuilder.WithRetryOptions(retryOptions);\n"})}),"\n",(0,t.jsx)(r.h3,{id:"runtime-configuration",children:"Runtime Configuration"}),"\n",(0,t.jsx)(r.p,{children:"Configure delay strategies at runtime within your pipeline definition:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public void Define(PipelineBuilder builder, PipelineContext context)\r\n{\r\n    // Check system conditions and configure accordingly\r\n    if (IsHighLoad(context))\r\n    {\r\n        context.UseExponentialBackoffDelay(\r\n            baseDelay: TimeSpan.FromSeconds(2),\r\n            multiplier: 3.0,\r\n            maxDelay: TimeSpan.FromMinutes(5));\r\n    }\r\n    else\r\n    {\r\n        context.UseExponentialBackoffDelay(\r\n            baseDelay: TimeSpan.FromSeconds(1),\r\n            multiplier: 2.0,\r\n            maxDelay: TimeSpan.FromMinutes(1));\r\n    }\r\n\r\n    var source = builder.AddSource<MySource, MyData>("Source");\r\n    var transform = builder.AddTransform<MyTransform, MyData, ProcessedData>("Transform");\r\n    builder.Connect(source, transform);\r\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["For more advanced retry delay patterns and scenarios, see the ",(0,t.jsx)(r.a,{href:"/docs/advanced-topics/retry-delay-advanced",children:"Advanced Retry Delay Strategies"})," guide."]}),"\n",(0,t.jsx)(r.h2,{id:"retry-delay-api-reference",children:"Retry Delay API Reference"}),"\n",(0,t.jsx)(r.h3,{id:"core-interfaces",children:"Core Interfaces"}),"\n",(0,t.jsx)(r.h4,{id:"iretrydelaystrategy",children:"IRetryDelayStrategy"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public interface IRetryDelayStrategy\r\n{\r\n    ValueTask<TimeSpan> GetDelayAsync(int attemptNumber, CancellationToken cancellationToken = default);\r\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Defines the contract for calculating retry delays. The ",(0,t.jsx)(r.code,{children:"attemptNumber"})," is 0-based (0 = first retry)."]}),"\n",(0,t.jsx)(r.h4,{id:"ibackoffstrategy",children:"IBackoffStrategy"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public interface IBackoffStrategy\r\n{\r\n    TimeSpan CalculateDelay(int attemptNumber);\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Determines how delays increase over time based on attempt number."}),"\n",(0,t.jsx)(r.h4,{id:"ijitterstrategy",children:"IJitterStrategy"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public interface IJitterStrategy\r\n{\r\n    TimeSpan ApplyJitter(TimeSpan baseDelay, Random random);\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Adds randomness to retry delays to prevent synchronized retries."}),"\n",(0,t.jsx)(r.h3,{id:"strategy-classes",children:"Strategy Classes"}),"\n",(0,t.jsx)(r.h4,{id:"exponentialbackoffstrategy",children:"ExponentialBackoffStrategy"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public sealed class ExponentialBackoffStrategy : IBackoffStrategy\r\n{\r\n    public ExponentialBackoffStrategy(ExponentialBackoffConfiguration configuration);\r\n    public TimeSpan CalculateDelay(int attemptNumber);\r\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Formula: ",(0,t.jsx)(r.code,{children:"delay = baseDelay \xd7 multiplier^attemptNumber"})," (capped at maxDelay)"]}),"\n",(0,t.jsx)(r.h4,{id:"linearbackoffstrategy",children:"LinearBackoffStrategy"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public sealed class LinearBackoffStrategy : IBackoffStrategy\r\n{\r\n    public LinearBackoffStrategy(LinearBackoffConfiguration configuration);\r\n    public TimeSpan CalculateDelay(int attemptNumber);\r\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Formula: ",(0,t.jsx)(r.code,{children:"delay = baseDelay + (increment \xd7 attemptNumber)"})," (capped at maxDelay)"]}),"\n",(0,t.jsx)(r.h4,{id:"fixeddelaystrategy",children:"FixedDelayStrategy"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public sealed class FixedDelayStrategy : IBackoffStrategy\r\n{\r\n    public FixedDelayStrategy(FixedDelayConfiguration configuration);\r\n    public TimeSpan CalculateDelay(int attemptNumber);\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Returns the same delay for all attempts."}),"\n",(0,t.jsx)(r.h4,{id:"jitter-strategies",children:"Jitter Strategies"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"FullJitterStrategy:"})," ",(0,t.jsx)(r.code,{children:"random(0, baseDelay)"}),"\r\n",(0,t.jsx)(r.strong,{children:"EqualJitterStrategy:"})," ",(0,t.jsx)(r.code,{children:"baseDelay/2 + random(0, baseDelay/2)"}),"\r\n",(0,t.jsx)(r.strong,{children:"DecorrelatedJitterStrategy:"})," ",(0,t.jsx)(r.code,{children:"random(baseDelay, min(maxDelay, previousDelay \xd7 multiplier))"}),"\r\n",(0,t.jsx)(r.strong,{children:"NoJitterStrategy:"})," Returns baseDelay unchanged"]}),"\n",(0,t.jsx)(r.h4,{id:"compositeretrydelaystrategy",children:"CompositeRetryDelayStrategy"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public sealed class CompositeRetryDelayStrategy : IRetryDelayStrategy\r\n{\r\n    public CompositeRetryDelayStrategy(\r\n        IBackoffStrategy backoffStrategy,\r\n        IJitterStrategy jitterStrategy);\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Combines backoff and jitter strategies."}),"\n",(0,t.jsx)(r.h4,{id:"noopretrydelaystrategy",children:"NoOpRetryDelayStrategy"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public sealed class NoOpRetryDelayStrategy : IRetryDelayStrategy\r\n{\r\n    public static NoOpRetryDelayStrategy Instance { get; }\r\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Singleton that always returns ",(0,t.jsx)(r.code,{children:"TimeSpan.Zero"})," for immediate retries."]}),"\n",(0,t.jsx)(r.h3,{id:"configuration-classes",children:"Configuration Classes"}),"\n",(0,t.jsx)(r.h4,{id:"exponentialbackoffconfiguration",children:"ExponentialBackoffConfiguration"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public sealed class ExponentialBackoffConfiguration : BackoffStrategyConfiguration\r\n{\r\n    public ExponentialBackoffConfiguration(TimeSpan baseDelay, double multiplier, TimeSpan maxDelay);\r\n    public TimeSpan BaseDelay { get; }\r\n    public double Multiplier { get; }\r\n    public TimeSpan MaxDelay { get; }\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Constraints:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"baseDelay"})," > TimeSpan.Zero"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"multiplier"})," \u2265 1.0"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"maxDelay"})," \u2265 baseDelay"]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"linearbackoffconfiguration",children:"LinearBackoffConfiguration"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public sealed class LinearBackoffConfiguration : BackoffStrategyConfiguration\r\n{\r\n    public LinearBackoffConfiguration(TimeSpan baseDelay, TimeSpan increment, TimeSpan maxDelay);\r\n    public TimeSpan BaseDelay { get; }\r\n    public TimeSpan Increment { get; }\r\n    public TimeSpan MaxDelay { get; }\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Constraints:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"baseDelay"})," > TimeSpan.Zero"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"increment"})," \u2265 TimeSpan.Zero"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"maxDelay"})," \u2265 baseDelay"]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"fixeddelayconfiguration",children:"FixedDelayConfiguration"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public sealed class FixedDelayConfiguration : BackoffStrategyConfiguration\r\n{\r\n    public FixedDelayConfiguration(TimeSpan delay);\r\n    public TimeSpan Delay { get; }\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Constraints:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"delay"})," > TimeSpan.Zero"]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"jitter-configurations",children:"Jitter Configurations"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"FullJitterConfiguration"})," - No parameters required"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"EqualJitterConfiguration"})," - No parameters required"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"DecorrelatedJitterConfiguration"})," - No parameters required"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"NoJitterConfiguration"})," - No parameters required"]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"retrydelaystrategyconfiguration",children:"RetryDelayStrategyConfiguration"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public sealed class RetryDelayStrategyConfiguration\r\n{\r\n    public RetryDelayStrategyConfiguration(\r\n        BackoffStrategyConfiguration backoffConfiguration,\r\n        JitterStrategyConfiguration jitterConfiguration);\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Combines backoff and jitter configurations."}),"\n",(0,t.jsx)(r.h3,{id:"extension-methods",children:"Extension Methods"}),"\n",(0,t.jsx)(r.h4,{id:"pipelinecontextretrydelayextensions",children:"PipelineContextRetryDelayExtensions"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public static class PipelineContextRetryDelayExtensions\r\n{\r\n    public static IRetryDelayStrategy GetRetryDelayStrategy(this PipelineContext context);\r\n    public static Task<TimeSpan> GetRetryDelayAsync(this PipelineContext context, int attempt);\r\n    \r\n    public static PipelineContext UseExponentialBackoffDelay(\r\n        this PipelineContext context,\r\n        TimeSpan baseDelay,\r\n        double multiplier = 2.0,\r\n        TimeSpan? maxDelay = null);\r\n    \r\n    public static PipelineContext UseLinearBackoffDelay(\r\n        this PipelineContext context,\r\n        TimeSpan baseDelay,\r\n        TimeSpan increment,\r\n        TimeSpan? maxDelay = null);\r\n    \r\n    public static PipelineContext UseFixedDelay(\r\n        this PipelineContext context,\r\n        TimeSpan delay);\r\n    \r\n    public static PipelineContext UseExponentialBackoffWithJitter(\r\n        this PipelineContext context,\r\n        TimeSpan baseDelay,\r\n        double multiplier = 2.0,\r\n        TimeSpan? maxDelay = null,\r\n        TimeSpan? jitterMax = null);\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"factory",children:"Factory"}),"\n",(0,t.jsx)(r.h4,{id:"defaultretrydelaystrategyfactory",children:"DefaultRetryDelayStrategyFactory"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public sealed class DefaultRetryDelayStrategyFactory\r\n{\r\n    public IRetryDelayStrategy CreateStrategy(RetryDelayStrategyConfiguration configuration);\r\n    public IRetryDelayStrategy CreateExponentialBackoff(ExponentialBackoffConfiguration config);\r\n    public IRetryDelayStrategy CreateLinearBackoff(LinearBackoffConfiguration config);\r\n    public IRetryDelayStrategy CreateFixedDelay(FixedDelayConfiguration config);\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Creates retry delay strategies from configurations."}),"\n",(0,t.jsx)(r.h3,{id:"validation",children:"Validation"}),"\n",(0,t.jsx)(r.h4,{id:"retrydelaystrategyvalidator",children:"RetryDelayStrategyValidator"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public static class RetryDelayStrategyValidator\r\n{\r\n    public static void ValidateExponentialBackoffConfiguration(ExponentialBackoffConfiguration configuration);\r\n    public static void ValidateLinearBackoffConfiguration(LinearBackoffConfiguration configuration);\r\n    public static void ValidateFixedDelayConfiguration(FixedDelayConfiguration configuration);\r\n    public static bool IsValidAttemptNumber(int attemptNumber);\r\n    public static bool IsValidDelay(TimeSpan delay);\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Validates retry delay strategy configurations."}),"\n",(0,t.jsx)(r.h2,{id:"retry-strategies",children:"Retry Strategies"}),"\n",(0,t.jsx)(r.h3,{id:"fixed-delay-retry",children:"Fixed Delay Retry"}),"\n",(0,t.jsx)(r.p,{children:"The simplest retry strategy uses a fixed delay between attempts:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public class FixedDelayRetryHandler : INodeErrorHandler<ITransformNode<string, string>, string>\r\n{\r\n    private readonly TimeSpan _delay = TimeSpan.FromSeconds(2);\r\n    private readonly ILogger _logger;\r\n\r\n    public FixedDelayRetryHandler(ILogger logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task<NodeErrorDecision> HandleAsync(\r\n        ITransformNode<string, string> node,\r\n        string failedItem,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        if (IsTransientError(error))\r\n        {\r\n            _logger.LogInformation("Retrying in {Delay}ms for item: {Item}", _delay.TotalMilliseconds, failedItem);\r\n            await Task.Delay(_delay, cancellationToken);\r\n            return NodeErrorDecision.Retry;\r\n        }\r\n\r\n        return NodeErrorDecision.Skip;\r\n    }\r\n\r\n    private static bool IsTransientError(Exception error)\r\n    {\r\n        return error is TimeoutException or HttpRequestException;\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"exponential-backoff-with-jitter",children:"Exponential Backoff with Jitter"}),"\n",(0,t.jsx)(r.p,{children:"Exponential backoff with jitter is a more sophisticated strategy that helps prevent thundering herd problems:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public class ExponentialBackoffRetryHandler : INodeErrorHandler<ITransformNode<string, string>, string>\r\n{\r\n    private readonly TimeSpan _baseDelay = TimeSpan.FromSeconds(1);\r\n    private readonly TimeSpan _maxDelay = TimeSpan.FromMinutes(1);\r\n    private readonly Random _jitter = new();\r\n    private readonly ILogger _logger;\r\n\r\n    public ExponentialBackoffRetryHandler(ILogger logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task<NodeErrorDecision> HandleAsync(\r\n        ITransformNode<string, string> node,\r\n        string failedItem,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        if (IsTransientError(error))\r\n        {\r\n            // Get retry count from context (you would need to implement this)\r\n            var retryCount = GetRetryCount(context, failedItem);\r\n\r\n            // Calculate exponential delay with jitter\r\n            var exponentialDelay = TimeSpan.FromSeconds(Math.Pow(2, retryCount));\r\n            var jitter = TimeSpan.FromMilliseconds(_jitter.Next(0, 1000));\r\n            var delay = TimeSpan.FromTicks(Math.Min(\r\n                (_baseDelay + exponentialDelay + jitter).Ticks,\r\n                _maxDelay.Ticks));\r\n\r\n            _logger.LogInformation("Retrying in {Delay}ms (attempt {RetryCount}) for item: {Item}",\r\n                delay.TotalMilliseconds, retryCount + 1, failedItem);\r\n\r\n            await Task.Delay(delay, cancellationToken);\r\n            return NodeErrorDecision.Retry;\r\n        }\r\n\r\n        return NodeErrorDecision.Skip;\r\n    }\r\n\r\n    private static bool IsTransientError(Exception error)\r\n    {\r\n        return error is TimeoutException or HttpRequestException;\r\n    }\r\n\r\n    private int GetRetryCount(PipelineContext context, string item)\r\n    {\r\n        // In a real implementation, you would track retry count in the context\r\n        // This is a simplified example\r\n        return 0;\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"context-aware-retry",children:"Context-Aware Retry"}),"\n",(0,t.jsx)(r.p,{children:"Sometimes you want to adjust retry behavior based on the context:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public class ContextAwareRetryHandler : INodeErrorHandler<ITransformNode<string, string>, string>\r\n{\r\n    private readonly ILogger _logger;\r\n    private readonly Dictionary<string, RetryPolicy> _policies;\r\n\r\n    public ContextAwareRetryHandler(ILogger logger)\r\n    {\r\n        _logger = logger;\r\n        _policies = new Dictionary<string, RetryPolicy>\r\n        {\r\n            ["critical"] = new RetryPolicy(maxRetries: 5, baseDelay: TimeSpan.FromSeconds(1)),\r\n            ["normal"] = new RetryPolicy(maxRetries: 3, baseDelay: TimeSpan.FromSeconds(2)),\r\n            ["low"] = new RetryPolicy(maxRetries: 1, baseDelay: TimeSpan.FromSeconds(5))\r\n        };\r\n    }\r\n\r\n    public async Task<NodeErrorDecision> HandleAsync(\r\n        ITransformNode<string, string> node,\r\n        string failedItem,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Determine priority from context or item\r\n        var priority = GetPriority(context, failedItem);\r\n        var policy = _policies[priority];\r\n\r\n        if (IsTransientError(error) && policy.CanRetry)\r\n        {\r\n            _logger.LogInformation("Retrying with {Priority} policy (attempt {RetryCount}/{MaxRetries}) for item: {Item}",\r\n                priority, policy.CurrentRetry + 1, policy.MaxRetries, failedItem);\r\n\r\n            await Task.Delay(policy.GetDelay(), cancellationToken);\r\n            policy.IncrementRetry();\r\n\r\n            return NodeErrorDecision.Retry;\r\n        }\r\n\r\n        return NodeErrorDecision.Skip;\r\n    }\r\n\r\n    private static bool IsTransientError(Exception error)\r\n    {\r\n        return error is TimeoutException or HttpRequestException;\r\n    }\r\n\r\n    private string GetPriority(PipelineContext context, string item)\r\n    {\r\n        // In a real implementation, you would determine priority from context or item\r\n        // This is a simplified example\r\n        return item.Contains("critical") ? "critical" :\r\n               item.Contains("low") ? "low" : "normal";\r\n    }\r\n\r\n    private class RetryPolicy\r\n    {\r\n        public int MaxRetries { get; }\r\n        public TimeSpan BaseDelay { get; }\r\n        public int CurrentRetry { get; private set; }\r\n\r\n        public bool CanRetry => CurrentRetry < MaxRetries;\r\n\r\n        public RetryPolicy(int maxRetries, TimeSpan baseDelay)\r\n        {\r\n            MaxRetries = maxRetries;\r\n            BaseDelay = baseDelay;\r\n        }\r\n\r\n        public TimeSpan GetDelay()\r\n        {\r\n            // Simple exponential backoff\r\n            return TimeSpan.FromSeconds(Math.Pow(2, CurrentRetry) * BaseDelay.TotalSeconds);\r\n        }\r\n\r\n        public void IncrementRetry()\r\n        {\r\n            CurrentRetry++;\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Differentiate between transient and permanent errors"}),": Only retry transient errors that might resolve themselves."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Implement appropriate delays"}),": Use delays between retries to give the system time to recover."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Set reasonable retry limits"}),": Prevent infinite loops by setting maximum retry counts."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Use jitter in distributed systems"}),": Add randomness to retry delays to prevent thundering herd problems."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Monitor retry patterns"}),": Track retry metrics to identify systemic issues."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Consider resource constraints"}),": Be mindful of the resources consumed by retries, especially in high-volume scenarios."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Implement circuit breakers"}),": Combine retries with circuit breakers to prevent cascading failures."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"production-example",children:"Production Example"}),"\n",(0,t.jsx)(r.p,{children:"Here's a comprehensive example that combines multiple retry strategies:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.ErrorHandling;\r\nusing NPipeline.Pipeline;\r\n\r\npublic class ProductionRetryHandler : INodeErrorHandler<ITransformNode<string, string>, string>\r\n{\r\n    private readonly ILogger _logger;\r\n    private readonly IMetrics _metrics;\r\n    private readonly Dictionary<string, RetryState> _retryStates = new();\r\n    private readonly TimeSpan _baseDelay = TimeSpan.FromSeconds(1);\r\n    private readonly TimeSpan _maxDelay = TimeSpan.FromMinutes(1);\r\n    private readonly Random _jitter = new();\r\n\r\n    private class RetryState\r\n    {\r\n        public int RetryCount { get; set; }\r\n        public DateTime FirstFailureTime { get; set; }\r\n    }\r\n\r\n    public ProductionRetryHandler(ILogger logger, IMetrics metrics)\r\n    {\r\n        _logger = logger;\r\n        _metrics = metrics;\r\n    }\r\n\r\n    public async Task<NodeErrorDecision> HandleAsync(\r\n        ITransformNode<string, string> node,\r\n        string failedItem,\r\n        Exception error,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        var itemKey = $"{node.Id}:{failedItem}";\r\n\r\n        if (!_retryStates.TryGetValue(itemKey, out var retryState))\r\n        {\r\n            retryState = new RetryState { FirstFailureTime = DateTime.UtcNow };\r\n            _retryStates[itemKey] = retryState;\r\n        }\r\n\r\n        // Record metrics\r\n        _metrics.Increment("item_retries", new[]\r\n        {\r\n            new KeyValuePair<string, object>("node_id", node.Id),\r\n            new KeyValuePair<string, object>("error_type", error.GetType().Name),\r\n            new KeyValuePair<string, object>("retry_count", retryState.RetryCount)\r\n        });\r\n\r\n        if (IsTransientError(error))\r\n        {\r\n            // Check if we\'ve exceeded the maximum retry count\r\n            if (retryState.RetryCount >= 3)\r\n            {\r\n                _logger.LogWarning("Maximum retries exceeded for item {Item} in node {NodeId}", failedItem, node.Id);\r\n                _retryStates.Remove(itemKey);\r\n                return NodeErrorDecision.DeadLetter;\r\n            }\r\n\r\n            // Calculate delay with exponential backoff and jitter\r\n            var exponentialDelay = TimeSpan.FromSeconds(Math.Pow(2, retryState.RetryCount));\r\n            var jitter = TimeSpan.FromMilliseconds(_jitter.Next(0, 1000));\r\n            var delay = TimeSpan.FromTicks(Math.Min(\r\n                (_baseDelay + exponentialDelay + jitter).Ticks,\r\n                _maxDelay.Ticks));\r\n\r\n            _logger.LogInformation("Retrying item {Item} in node {NodeId} (attempt {RetryCount}/{MaxRetries}) after {Delay}ms",\r\n                failedItem, node.Id, retryState.RetryCount + 1, 3, delay.TotalMilliseconds);\r\n\r\n            retryState.RetryCount++;\r\n            await Task.Delay(delay, cancellationToken);\r\n            return NodeErrorDecision.Retry;\r\n        }\r\n\r\n        // For non-transient errors, don\'t retry\r\n        _logger.LogWarning("Non-transient error for item {Item} in node {NodeId}: {ErrorType}",\r\n            failedItem, node.Id, error.GetType().Name);\r\n\r\n        _retryStates.Remove(itemKey);\r\n        return NodeErrorDecision.Skip;\r\n    }\r\n\r\n    private static bool IsTransientError(Exception error)\r\n    {\r\n        return error is TimeoutException or HttpRequestException or OperationCanceledException;\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsxs)(r.p,{children:["\u26a0\ufe0f"," Materialization Requirements\r\nWhen configuring retries with ",(0,t.jsx)(r.code,{children:"MaxMaterializedItems"}),", it's important to understand how buffering enables replay functionality. Materialization is critical because it creates a snapshot of input items that can be replayed if a node fails and needs to restart, preventing data loss and ensuring processing continuity. See ",(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/materialization-and-buffering",children:"Materialization and Buffering"})," in the resilience section for detailed guidance."]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"troubleshooting-retry-strategies",children:"Troubleshooting Retry Strategies"}),"\n",(0,t.jsx)(r.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,t.jsx)(r.h4,{id:"too-many-retries",children:"Too Many Retries"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Symptoms:"})," High retry counts, long processing times"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Solutions:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Increase base delay or multiplier to back off more aggressively"}),"\n",(0,t.jsx)(r.li,{children:"Lower maximum retry count"}),"\n",(0,t.jsx)(r.li,{children:"Add circuit breaker to fail fast"}),"\n",(0,t.jsx)(r.li,{children:"Check for systemic issues beyond transient failures"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"too-few-retries",children:"Too Few Retries"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Symptoms:"})," Premature failures, low success rate"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Solutions:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Decrease base delay or multiplier for faster retry attempts"}),"\n",(0,t.jsx)(r.li,{children:"Increase maximum retry count"}),"\n",(0,t.jsx)(r.li,{children:"Verify error classification (distinguish transient vs permanent failures)"}),"\n",(0,t.jsx)(r.li,{children:"Check timeout configurations"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"thundering-herd-problem",children:"Thundering Herd Problem"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Symptoms:"})," Synchronized retry spikes, sudden service overload"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Solutions:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Add or increase jitter (full jitter is most effective)"}),"\n",(0,t.jsx)(r.li,{children:"Use decorrelated jitter for adaptive behavior"}),"\n",(0,t.jsx)(r.li,{children:"Reduce concurrent retry attempts"}),"\n",(0,t.jsx)(r.li,{children:"Implement rate limiting"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"long-recovery-times",children:"Long Recovery Times"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Symptoms:"})," Slow recovery after service restoration"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Solutions:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Decrease maximum delay cap"}),"\n",(0,t.jsx)(r.li,{children:"Use linear backoff instead of exponential for more predictable delays"}),"\n",(0,t.jsx)(r.li,{children:"Lower base delay for faster initial retries"}),"\n",(0,t.jsx)(r.li,{children:"Implement circuit breaker reset mechanisms"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"debugging-retry-patterns",children:"Debugging Retry Patterns"}),"\n",(0,t.jsx)(r.p,{children:"Monitor retry behavior using PipelineContext:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public class RetryAnalyzer\r\n{\r\n    public async Task AnalyzeRetryPatternAsync(PipelineContext context)\r\n    {\r\n        var strategy = context.GetRetryDelayStrategy();\r\n        var delays = new List<TimeSpan>();\r\n        \r\n        // Simulate retry delays for analysis\r\n        for (int attempt = 0; attempt < 5; attempt++)\r\n        {\r\n            var delay = await strategy.GetDelayAsync(attempt);\r\n            delays.Add(delay);\r\n            Console.WriteLine($"Attempt {attempt}: {delay.TotalMilliseconds:F2}ms");\r\n        }\r\n        \r\n        Console.WriteLine($"Average delay: {delays.Average(d => d.TotalMilliseconds):F2}ms");\r\n        Console.WriteLine($"Max delay: {delays.Max(d => d.TotalMilliseconds):F2}ms");\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"performance-profiling",children:"Performance Profiling"}),"\n",(0,t.jsx)(r.p,{children:"Profile strategy performance:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public class RetryStrategyProfiler\r\n{\r\n    public async Task ProfileStrategyAsync(\r\n        IRetryDelayStrategy strategy, \r\n        int attempts = 10)\r\n    {\r\n        var stopwatch = Stopwatch.StartNew();\r\n        var delays = new List<TimeSpan>();\r\n        \r\n        for (int i = 0; i < attempts; i++)\r\n        {\r\n            var delay = await strategy.GetDelayAsync(i);\r\n            delays.Add(delay);\r\n        }\r\n        \r\n        stopwatch.Stop();\r\n        \r\n        Console.WriteLine($"Strategy: {strategy.GetType().Name}");\r\n        Console.WriteLine($"Total time: {stopwatch.ElapsedMilliseconds}ms");\r\n        Console.WriteLine($"Average delay: {delays.Average(d => d.TotalMilliseconds):F2}ms");\r\n        Console.WriteLine($"Min delay: {delays.Min(d => d.TotalMilliseconds):F2}ms");\r\n        Console.WriteLine($"Max delay: {delays.Max(d => d.TotalMilliseconds):F2}ms");\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"implementation-guidelines",children:"Implementation Guidelines"}),"\n",(0,t.jsx)(r.h3,{id:"integration-checklist",children:"Integration Checklist"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Assess current retry behavior"})," - Understand existing patterns and limitations"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Choose appropriate strategy"})," - Based on your service type and use case"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Test with new configuration"})," - Validate retry behavior in test environments"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Monitor in production"})," - Observe actual retry patterns and success rates"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Fine-tune parameters"})," - Optimize base delay, multiplier/increment, and max delay based on metrics"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Document decisions"})," - Record why specific strategies were chosen for future reference"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"parameter-selection-guidelines",children:"Parameter Selection Guidelines"}),"\n",(0,t.jsx)(r.h4,{id:"base-delay",children:"Base Delay"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Too short:"})," Can overwhelm the failing service, defeating the purpose of backoff"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Too long:"})," Unnecessary delays during normal recovery"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Guidance:"})," Start with 10-50% of expected operation time, then adjust based on observation"]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"backoff-multiplierincrement",children:"Backoff Multiplier/Increment"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Exponential multiplier:"})," 1.5-3.0 (2.0 is a common default)"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Linear increment:"})," 50-200% of base delay"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Consider:"})," Service recovery patterns and whether you want aggressive or conservative backoff"]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"maximum-delay",children:"Maximum Delay"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Web APIs:"})," 30 seconds to 5 minutes (services usually recover quickly)"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Databases:"})," 5-30 seconds (recovery time depends on lock contention and query queues)"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"File operations:"})," 1-10 seconds (filesystem recovery is usually immediate)"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Message queues:"})," 10-60 seconds (depends on queue depth and processing rate)"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"monitoring-key-metrics",children:"Monitoring Key Metrics"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'public class RetryMetricsCollector\r\n{\r\n    public void CollectMetrics(PipelineContext context)\r\n    {\r\n        var metrics = new\r\n        {\r\n            TotalAttempts = context.Metrics.GetCounter("total_attempts"),\r\n            SuccessfulRetries = context.Metrics.GetCounter("successful_retries"),\r\n            FailedRetries = context.Metrics.GetCounter("failed_retries"),\r\n            AverageRetryDelay = context.Metrics.GetGauge("average_retry_delay_ms"),\r\n            MaxRetryDelayReached = context.Metrics.GetCounter("max_retry_delay_reached")\r\n        };\r\n        \r\n        var successRate = (double)metrics.SuccessfulRetries / metrics.TotalAttempts;\r\n        Console.WriteLine($"Retry success rate: {successRate:P}");\r\n        Console.WriteLine($"Average retry delay: {metrics.AverageRetryDelay:F2}ms");\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/",children:"Resilience Overview"})}),": Comprehensive guide to building fault-tolerant pipelines"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/materialization-and-buffering",children:"Materialization and Buffering"})}),": Understanding buffer requirements for resilience"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/configuration-guide",children:"Configuration Guide"})}),": Practical implementation guidance with code examples"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting"})}),": Diagnose and resolve common resilience issues"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/error-handling-guide",children:"Node-level Error Handling"})}),": Learn about handling errors for individual items."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/error-handling-guide",children:"Pipeline-level Error Handling"})}),": Learn about handling errors that affect entire node streams."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/circuit-breaker-configuration",children:"Circuit Breaker Configuration"})}),": Configure circuit breaker patterns."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/dead-letter-queues",children:"Dead-Letter Queues"})}),": Implement dead-letter queues for problematic items."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/error-handling-guide",children:"Error Handling Overview"})}),": Return to the error handling overview."]}),"\n"]})]})}function p(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>l});var i=n(6540);const t={},a=i.createContext(t);function s(e){const r=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(a.Provider,{value:r},e.children)}}}]);