"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[2047],{10598:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"extensions/observability/advanced-patterns","title":"Advanced Observability Patterns","description":"This guide covers advanced patterns and real-world scenarios for the NPipeline Observability extension.","source":"@site/docs/extensions/observability/advanced-patterns.md","sourceDirName":"extensions/observability","slug":"/extensions/observability/advanced-patterns","permalink":"/docs/extensions/observability/advanced-patterns","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Distributed Tracing","permalink":"/docs/extensions/observability/tracing"},"next":{"title":"Observability Configuration","permalink":"/docs/extensions/observability/configuration"}}');var r=i(74848),s=i(28453);const a={},o="Advanced Observability Patterns",l={},c=[{value:"Custom Metrics Collectors",id:"custom-metrics-collectors",level:2},{value:"Implementing a Custom Collector",id:"implementing-a-custom-collector",level:3},{value:"Using Custom Collector",id:"using-custom-collector",level:3},{value:"Integration with Monitoring Systems",id:"integration-with-monitoring-systems",level:2},{value:"Application Insights Integration",id:"application-insights-integration",level:3},{value:"Prometheus Integration",id:"prometheus-integration",level:3},{value:"OpenTelemetry Integration",id:"opentelemetry-integration",level:3},{value:"Batching and Buffering",id:"batching-and-buffering",level:2},{value:"Buffered Metrics Sink",id:"buffered-metrics-sink",level:3},{value:"Sampling Strategies",id:"sampling-strategies",level:2},{value:"Rate-Limited Sink",id:"rate-limited-sink",level:3},{value:"Sampling Sink",id:"sampling-sink",level:3},{value:"Composite Sinks",id:"composite-sinks",level:2},{value:"Multi-Destination Sink",id:"multi-destination-sink",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Pre-Aggregation Sink",id:"pre-aggregation-sink",level:3},{value:"Error Handling and Resilience",id:"error-handling-and-resilience",level:2},{value:"Retry Sink",id:"retry-sink",level:3},{value:"Circuit Breaker Sink",id:"circuit-breaker-sink",level:3},{value:"Testing Custom Implementations",id:"testing-custom-implementations",level:2},{value:"Test Sink",id:"test-sink",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"advanced-observability-patterns",children:"Advanced Observability Patterns"})}),"\n",(0,r.jsx)(n.p,{children:"This guide covers advanced patterns and real-world scenarios for the NPipeline Observability extension."}),"\n",(0,r.jsx)(n.h2,{id:"custom-metrics-collectors",children:"Custom Metrics Collectors"}),"\n",(0,r.jsx)(n.h3,{id:"implementing-a-custom-collector",children:"Implementing a Custom Collector"}),"\n",(0,r.jsx)(n.p,{children:"Create custom collectors when you need to track additional metadata or metrics beyond the standard interface. This example captures host information and process details for distributed tracing scenarios."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public class DetailedObservabilityCollector : IObservabilityCollector\n{\n    private readonly ConcurrentDictionary<string, DetailedNodeMetrics> _metrics = new();\n    private readonly ILogger<DetailedObservabilityCollector> _logger;\n    \n    public DetailedObservabilityCollector(ILogger<DetailedObservabilityCollector> logger)\n    {\n        _logger = logger;\n    }\n    \n    public void RecordNodeStart(string nodeId, DateTimeOffset timestamp, int? threadId = null, long? initialMemoryMb = null)\n    {\n        var detailed = new DetailedNodeMetrics\n        {\n            NodeId = nodeId,\n            StartTime = timestamp,\n            ThreadId = threadId,\n            InitialMemoryMb = initialMemoryMb,\n            // Add custom tracking\n            HostName = Environment.MachineName,\n            ProcessId = Environment.ProcessId\n        };\n        \n        _metrics.TryAdd(nodeId, detailed);\n        _logger.LogDebug("Node {NodeId} started on host {HostName}", nodeId, detailed.HostName);\n    }\n    \n    // Implement other IObservabilityCollector methods...\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"using-custom-collector",children:"Using Custom Collector"}),"\n",(0,r.jsx)(n.p,{children:"Register your custom collector in the dependency injection container to replace the default implementation with your specialized version."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"services.AddNPipelineObservability<\n    DetailedObservabilityCollector,\n    LoggingMetricsSink,\n    LoggingPipelineMetricsSink>();\n"})}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-monitoring-systems",children:"Integration with Monitoring Systems"}),"\n",(0,r.jsx)(n.h3,{id:"application-insights-integration",children:"Application Insights Integration"}),"\n",(0,r.jsx)(n.p,{children:"Send pipeline metrics directly to Azure Application Insights for cloud-native monitoring, alerting, and analysis within the Azure ecosystem."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public class ApplicationInsightsMetricsSink : IMetricsSink\n{\n    private readonly TelemetryClient _telemetryClient;\n    \n    public ApplicationInsightsMetricsSink(TelemetryClient telemetryClient)\n    {\n        _telemetryClient = telemetryClient;\n    }\n    \n    public Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        var properties = new Dictionary<string, string>\n        {\n            ["NodeId"] = nodeMetrics.NodeId,\n            ["Success"] = nodeMetrics.Success.ToString(),\n            ["ThreadId"] = nodeMetrics.ThreadId?.ToString() ?? "N/A"\n        };\n        \n        var metrics = new Dictionary<string, double>();\n        \n        if (nodeMetrics.DurationMs.HasValue)\n            metrics["DurationMs"] = nodeMetrics.DurationMs.Value;\n            \n        if (nodeMetrics.ThroughputItemsPerSec.HasValue)\n            metrics["ThroughputItemsPerSec"] = nodeMetrics.ThroughputItemsPerSec.Value;\n        \n        _telemetryClient.TrackEvent($"NodeExecution_{nodeMetrics.NodeId}", properties, metrics);\n        \n        if (!nodeMetrics.Success && nodeMetrics.Exception != null)\n        {\n            _telemetryClient.TrackException(nodeMetrics.Exception);\n        }\n        \n        return Task.CompletedTask;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"prometheus-integration",children:"Prometheus Integration"}),"\n",(0,r.jsx)(n.p,{children:"Expose metrics in Prometheus format for integration with Grafana dashboards, alerting rules, and time-series analysis in Kubernetes and on-premises environments."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public class PrometheusMetricsSink : IMetricsSink\n{\n    private static readonly Counter ItemsProcessedCounter = Metrics\n        .CreateCounter("npipeline_items_processed_total", "Total items processed", "node_id");\n    \n    private static readonly Histogram ExecutionDurationHistogram = Metrics\n        .CreateHistogram("npipeline_execution_duration_seconds", "Node execution duration", "node_id");\n    \n    private static readonly Gauge ActiveNodesGauge = Metrics\n        .CreateGauge("npipeline_active_nodes", "Currently executing nodes");\n    \n    public Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        ItemsProcessedCounter.WithLabels(nodeMetrics.NodeId).Inc(nodeMetrics.ItemsProcessed);\n        \n        if (nodeMetrics.DurationMs.HasValue)\n        {\n            ExecutionDurationHistogram.WithLabels(nodeMetrics.NodeId)\n                .Observe(nodeMetrics.DurationMs.Value / 1000.0);\n        }\n        \n        return Task.CompletedTask;\n    }\n}\n\n// Configure in DI\nservices.AddNPipelineObservability<PrometheusMetricsSink, PrometheusMetricsSink>();\n'})}),"\n",(0,r.jsx)(n.h3,{id:"opentelemetry-integration",children:"OpenTelemetry Integration"}),"\n",(0,r.jsx)(n.p,{children:"Use the OpenTelemetry standards for vendor-agnostic instrumentation, allowing you to switch monitoring backends without code changes."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public class OpenTelemetryMetricsSink : IMetricsSink\n{\n    private readonly Meter _meter;\n    private readonly Counter<long> _itemsProcessed;\n    private readonly Histogram<double> _executionDuration;\n    \n    public OpenTelemetryMetricsSink(IMeterFactory meterFactory)\n    {\n        _meter = meterFactory.Create("NPipeline.Observability");\n        _itemsProcessed = _meter.CreateCounter<long>("npipeline.items.processed");\n        _executionDuration = _meter.CreateHistogram<double>("npipeline.execution.duration");\n    }\n    \n    public Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        var tags = new TagList\n        {\n            { "node.id", nodeMetrics.NodeId },\n            { "node.success", nodeMetrics.Success }\n        };\n        \n        _itemsProcessed.Add(nodeMetrics.ItemsProcessed, tags);\n        \n        if (nodeMetrics.DurationMs.HasValue)\n        {\n            _executionDuration.Record(nodeMetrics.DurationMs.Value, tags);\n        }\n        \n        return Task.CompletedTask;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"batching-and-buffering",children:"Batching and Buffering"}),"\n",(0,r.jsx)(n.h3,{id:"buffered-metrics-sink",children:"Buffered Metrics Sink"}),"\n",(0,r.jsx)(n.p,{children:"Buffer metrics in an in-memory channel before sending them to the underlying sink, reducing network calls and improving throughput for high-volume pipelines."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public class BufferedMetricsSink : IMetricsSink, IAsyncDisposable\n{\n    private readonly Channel<INodeMetrics> _channel;\n    private readonly Task _processingTask;\n    private readonly IMetricsSink _underlyingSink;\n    \n    public BufferedMetricsSink(IMetricsSink underlyingSink, int bufferSize = 1000)\n    {\n        _underlyingSink = underlyingSink;\n        _channel = Channel.CreateBounded<INodeMetrics>(bufferSize);\n        _processingTask = ProcessBatchesAsync();\n    }\n    \n    public async Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        await _channel.Writer.WriteAsync(nodeMetrics, cancellationToken);\n    }\n    \n    private async Task ProcessBatchesAsync()\n    {\n        await foreach (var metrics in _channel.Reader.ReadAllAsync())\n        {\n            try\n            {\n                await _underlyingSink.RecordAsync(metrics, CancellationToken.None);\n            }\n            catch (Exception ex)\n            {\n                // Log error but don\'t stop processing\n                Console.Error.WriteLine($"Error recording metrics: {ex.Message}");\n            }\n        }\n    }\n    \n    public async ValueTask DisposeAsync()\n    {\n        _channel.Writer.Complete();\n        await _processingTask;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"sampling-strategies",children:"Sampling Strategies"}),"\n",(0,r.jsx)(n.h3,{id:"rate-limited-sink",children:"Rate-Limited Sink"}),"\n",(0,r.jsx)(n.p,{children:"Enforce a maximum metrics submission rate to prevent overwhelming downstream systems while maintaining visibility into pipeline behavior."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class RateLimitedMetricsSink : IMetricsSink\n{\n    private readonly IMetricsSink _underlyingSink;\n    private readonly SemaphoreSlim _rateLimiter;\n    private readonly Timer _resetTimer;\n    \n    public RateLimitedMetricsSink(IMetricsSink underlyingSink, int maxPerSecond = 100)\n    {\n        _underlyingSink = underlyingSink;\n        _rateLimiter = new SemaphoreSlim(maxPerSecond, maxPerSecond);\n        _resetTimer = new Timer(_ => ResetLimit(), null, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));\n    }\n    \n    public async Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        if (await _rateLimiter.WaitAsync(0, cancellationToken))\n        {\n            await _underlyingSink.RecordAsync(nodeMetrics, cancellationToken);\n        }\n        // Else: silently drop the metric\n    }\n    \n    private void ResetLimit()\n    {\n        while (_rateLimiter.CurrentCount < 100)\n        {\n            _rateLimiter.Release();\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sampling-sink",children:"Sampling Sink"}),"\n",(0,r.jsx)(n.p,{children:"Reduce metric volume by probabilistically recording only a sample of successful operations while always capturing failures for debugging."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class SamplingMetricsSink : IMetricsSink\n{\n    private readonly IMetricsSink _underlyingSink;\n    private readonly double _sampleRate; // 0.0 to 1.0\n    private readonly Random _random = new();\n    \n    public SamplingMetricsSink(IMetricsSink underlyingSink, double sampleRate = 0.1)\n    {\n        _underlyingSink = underlyingSink;\n        _sampleRate = Math.Clamp(sampleRate, 0.0, 1.0);\n    }\n    \n    public Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        // Always record failures\n        if (!nodeMetrics.Success)\n        {\n            return _underlyingSink.RecordAsync(nodeMetrics, cancellationToken);\n        }\n        \n        // Sample successes\n        if (_random.NextDouble() < _sampleRate)\n        {\n            return _underlyingSink.RecordAsync(nodeMetrics, cancellationToken);\n        }\n        \n        return Task.CompletedTask;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"composite-sinks",children:"Composite Sinks"}),"\n",(0,r.jsx)(n.h3,{id:"multi-destination-sink",children:"Multi-Destination Sink"}),"\n",(0,r.jsx)(n.p,{children:"Send metrics to multiple monitoring systems simultaneously (e.g., Prometheus and Application Insights) with error isolation so one sink's failure doesn't affect others."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public class CompositeMetricsSink : IMetricsSink\n{\n    private readonly IReadOnlyList<IMetricsSink> _sinks;\n    \n    public CompositeMetricsSink(params IMetricsSink[] sinks)\n    {\n        _sinks = sinks;\n    }\n    \n    public async Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        var tasks = _sinks.Select(sink => \n            RecordWithErrorHandling(sink, nodeMetrics, cancellationToken));\n        \n        await Task.WhenAll(tasks);\n    }\n    \n    private async Task RecordWithErrorHandling(\n        IMetricsSink sink,\n        INodeMetrics nodeMetrics,\n        CancellationToken cancellationToken)\n    {\n        try\n        {\n            await sink.RecordAsync(nodeMetrics, cancellationToken);\n        }\n        catch (Exception ex)\n        {\n            // Log but don\'t fail the entire operation\n            Console.Error.WriteLine($"Sink {sink.GetType().Name} failed: {ex.Message}");\n        }\n    }\n}\n\n// Usage\nservices.AddNPipelineObservability(\n    sp => new CompositeMetricsSink(\n        sp.GetRequiredService<LoggingMetricsSink>(),\n        sp.GetRequiredService<PrometheusMetricsSink>(),\n        sp.GetRequiredService<ApplicationInsightsMetricsSink>()\n    ),\n    sp => new LoggingPipelineMetricsSink(sp.GetService<ILogger<LoggingPipelineMetricsSink>>()));\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsx)(n.h3,{id:"pre-aggregation-sink",children:"Pre-Aggregation Sink"}),"\n",(0,r.jsx)(n.p,{children:"Aggregate metrics from multiple executions of the same node before flushing, significantly reducing the number of events sent to downstream systems."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class PreAggregationMetricsSink : IMetricsSink\n{\n    private readonly ConcurrentDictionary<string, AggregatedMetrics> _aggregates = new();\n    private readonly Timer _flushTimer;\n    private readonly IMetricsSink _underlyingSink;\n    \n    public PreAggregationMetricsSink(IMetricsSink underlyingSink, TimeSpan flushInterval)\n    {\n        _underlyingSink = underlyingSink;\n        _flushTimer = new Timer(_ => FlushAggregates(), null, flushInterval, flushInterval);\n    }\n    \n    public Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        _aggregates.AddOrUpdate(\n            nodeMetrics.NodeId,\n            _ => new AggregatedMetrics(nodeMetrics),\n            (_, existing) => existing.Merge(nodeMetrics));\n        \n        return Task.CompletedTask;\n    }\n    \n    private async void FlushAggregates()\n    {\n        var snapshots = _aggregates.ToArray();\n        _aggregates.Clear();\n        \n        foreach (var (nodeId, aggregate) in snapshots)\n        {\n            var aggregatedMetrics = aggregate.ToNodeMetrics();\n            await _underlyingSink.RecordAsync(aggregatedMetrics, CancellationToken.None);\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling-and-resilience",children:"Error Handling and Resilience"}),"\n",(0,r.jsx)(n.h3,{id:"retry-sink",children:"Retry Sink"}),"\n",(0,r.jsx)(n.p,{children:"Automatically retry failed metric submissions with exponential backoff to handle transient failures in downstream monitoring systems."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class RetrySink : IMetricsSink\n{\n    private readonly IMetricsSink _underlyingSink;\n    private readonly int _maxRetries;\n    private readonly TimeSpan _retryDelay;\n    \n    public RetrySink(IMetricsSink underlyingSink, int maxRetries = 3)\n    {\n        _underlyingSink = underlyingSink;\n        _maxRetries = maxRetries;\n        _retryDelay = TimeSpan.FromMilliseconds(100);\n    }\n    \n    public async Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        for (int attempt = 0; attempt <= _maxRetries; attempt++)\n        {\n            try\n            {\n                await _underlyingSink.RecordAsync(nodeMetrics, cancellationToken);\n                return;\n            }\n            catch (Exception) when (attempt < _maxRetries)\n            {\n                await Task.Delay(_retryDelay * (attempt + 1), cancellationToken);\n            }\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"circuit-breaker-sink",children:"Circuit Breaker Sink"}),"\n",(0,r.jsx)(n.p,{children:"Stop attempting to send metrics when a monitoring system repeatedly fails, preventing cascading failures and allowing time for recovery."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class CircuitBreakerSink : IMetricsSink\n{\n    private readonly IMetricsSink _underlyingSink;\n    private int _failureCount;\n    private DateTime _lastFailure;\n    private const int FailureThreshold = 5;\n    private static readonly TimeSpan RecoveryTimeout = TimeSpan.FromMinutes(1);\n    \n    public CircuitBreakerSink(IMetricsSink underlyingSink)\n    {\n        _underlyingSink = underlyingSink;\n    }\n    \n    public async Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        if (IsCircuitOpen())\n        {\n            // Circuit is open, don't attempt\n            return;\n        }\n        \n        try\n        {\n            await _underlyingSink.RecordAsync(nodeMetrics, cancellationToken);\n            ResetFailureCount();\n        }\n        catch (Exception)\n        {\n            IncrementFailureCount();\n            throw;\n        }\n    }\n    \n    private bool IsCircuitOpen()\n    {\n        if (_failureCount >= FailureThreshold)\n        {\n            if (DateTime.UtcNow - _lastFailure > RecoveryTimeout)\n            {\n                ResetFailureCount();\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    \n    private void IncrementFailureCount()\n    {\n        Interlocked.Increment(ref _failureCount);\n        _lastFailure = DateTime.UtcNow;\n    }\n    \n    private void ResetFailureCount()\n    {\n        Interlocked.Exchange(ref _failureCount, 0);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing-custom-implementations",children:"Testing Custom Implementations"}),"\n",(0,r.jsx)(n.h3,{id:"test-sink",children:"Test Sink"}),"\n",(0,r.jsx)(n.p,{children:"Capture all recorded metrics in memory during unit tests to verify observability behavior and assert on pipeline execution details."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class TestMetricsSink : IMetricsSink\n{\n    public List<INodeMetrics> RecordedMetrics { get; } = new();\n    public int CallCount => RecordedMetrics.Count;\n    \n    public Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        RecordedMetrics.Add(nodeMetrics);\n        return Task.CompletedTask;\n    }\n    \n    public void Clear() => RecordedMetrics.Clear();\n}\n\n// Usage in tests\n[Fact]\npublic async Task Pipeline_Should_RecordMetrics()\n{\n    var testSink = new TestMetricsSink();\n    services.AddSingleton<IMetricsSink>(testSink);\n    services.AddNPipelineObservability<TestMetricsSink, TestMetricsSink>();\n    \n    // Run pipeline...\n    \n    Assert.True(testSink.CallCount > 0);\n    Assert.All(testSink.RecordedMetrics, m => Assert.True(m.Success));\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Async All The Way"}),": Always implement sinks as truly async to avoid blocking"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Isolation"}),": Never let sink failures affect pipeline execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Buffering"}),": Use buffering for high-throughput scenarios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sampling"}),": Consider sampling for extremely high-volume pipelines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitoring"}),": Monitor your monitoring - track sink performance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Testing"}),": Test sinks in isolation with realistic metrics volumes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Graceful Degradation"}),": Have fallback strategies when primary sinks fail"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/extensions/observability/",children:"Getting Started"})," - Basic setup and usage"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/extensions/observability/configuration",children:"Configuration"})," - DI configuration options"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/extensions/observability/metrics",children:"Metrics Reference"})," - Complete metrics documentation"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);