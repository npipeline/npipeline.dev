"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[2716],{7256:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"architecture/component-architecture","title":"Component Architecture","description":"The major system components and their roles in NPipeline.","source":"@site/docs/architecture/component-architecture.md","sourceDirName":"architecture","slug":"/architecture/component-architecture","permalink":"/docs/architecture/component-architecture","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Component Architecture","description":"The major system components and their roles in NPipeline.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Core Concepts","permalink":"/docs/architecture/core-concepts"},"next":{"title":"Execution Flow","permalink":"/docs/architecture/execution-flow"}}');var t=r(4848),o=r(8453);const l={title:"Component Architecture",description:"The major system components and their roles in NPipeline.",sidebar_position:2},s="Component Architecture",c={},a=[{value:"Major Components Overview",id:"major-components-overview",level:2},{value:"1. Pipeline Definition (<code>IPipelineDefinition</code>)",id:"1-pipeline-definition-ipipelinedefinition",level:3},{value:"2. Pipeline Builder",id:"2-pipeline-builder",level:3},{value:"3. Pipeline Context",id:"3-pipeline-context",level:3},{value:"4. Cached Node Execution Context",id:"4-cached-node-execution-context",level:3},{value:"5. Pipeline Runner",id:"5-pipeline-runner",level:3},{value:"5. Node Execution Model",id:"5-node-execution-model",level:3},{value:"Component Interaction Flow",id:"component-interaction-flow",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"component-architecture",children:"Component Architecture"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"This page explains WHAT the components are and WHY they exist."})," For HOW TO use them to build pipelines, see ",(0,t.jsx)(n.a,{href:"/docs/core-concepts",children:"Core Concepts"})," and ",(0,t.jsx)(n.a,{href:"/docs/core-concepts/pipelinebuilder",children:"PipelineBuilder"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"NPipeline consists of several key components that work together to define, build, and execute pipelines. Understanding their roles and interactions is essential to working effectively with the framework."}),"\n",(0,t.jsx)(n.h2,{id:"major-components-overview",children:"Major Components Overview"}),"\n",(0,t.jsxs)(n.h3,{id:"1-pipeline-definition-ipipelinedefinition",children:["1. Pipeline Definition (",(0,t.jsx)(n.code,{children:"IPipelineDefinition"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Declarative blueprint of your pipeline structure"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public interface IPipelineDefinition\r\n{\r\n    void Define(PipelineBuilder builder, PipelineContext context);\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Responsibilities:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Connect nodes via the builder"}),"\n",(0,t.jsx)(n.li,{children:"Configure the execution topology"}),"\n",(0,t.jsx)(n.li,{children:"Define error handling strategy"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class OrderProcessingPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var source = builder.AddSource<OrderSource, Order>();\r\n        var validator = builder.AddTransform<OrderValidator, Order, ValidatedOrder>();\r\n        var enricher = builder.AddTransform<OrderEnricher, ValidatedOrder, EnrichedOrder>();\r\n        var sink = builder.AddSink<OrderSink, EnrichedOrder>();\r\n\r\n        builder.Connect(source, validator);\r\n        builder.Connect(validator, enricher);\r\n        builder.Connect(enricher, sink);\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-pipeline-builder",children:"2. Pipeline Builder"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Orchestrates node creation and graph construction"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class PipelineBuilder\r\n{\r\n    public SourceNodeHandle<TOut> AddSource<TNode, TOut>() \r\n        where TNode : ISourceNode<TOut>;\r\n    public TransformNodeHandle<TIn, TOut> AddTransform<TNode, TIn, TOut>() \r\n        where TNode : ITransformNode<TIn, TOut>;\r\n    public SinkNodeHandle<TIn> AddSink<TNode, TIn>() \r\n        where TNode : ISinkNode<TIn>;\r\n    \r\n    public PipelineBuilder Connect<TData>(\r\n        SourceNodeHandle<TData> source, \r\n        TransformNodeHandle<TData, TOut> target);\r\n    // ... other Connect overloads\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Builder Process:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Resolves nodes from dependency injection"}),"\n",(0,t.jsx)(n.li,{children:"Builds execution graph"}),"\n",(0,t.jsx)(n.li,{children:"Validates connectivity"}),"\n",(0,t.jsx)(n.li,{children:"Compiles to executable pipeline"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-pipeline-context",children:"3. Pipeline Context"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Shared runtime context for all nodes in the pipeline"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class PipelineContext\r\n{\r\n    public Dictionary<string, object> Items { get; }\r\n    public Dictionary<string, object> Parameters { get; }\r\n    public Dictionary<string, object> Properties { get; }\r\n    public CancellationToken CancellationToken { get; }\r\n    public string CurrentNodeId { get; }\r\n    public IPipelineLoggerFactory LoggerFactory { get; }\r\n    public IPipelineTracer Tracer { get; }\r\n    public IErrorHandlerFactory ErrorHandlerFactory { get; }\r\n    public ILineageFactory LineageFactory { get; }\r\n    public IObservabilityFactory ObservabilityFactory { get; }\r\n    public IDeadLetterSink? DeadLetterSink { get; }\r\n    public IPipelineErrorHandler? PipelineErrorHandler { get; }\r\n    public PipelineRetryOptions RetryOptions { get; }\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Contains:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Items"})," - Shared state between nodes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parameters"})," - Input parameters for the pipeline"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Properties"})," - Dictionary for extensions and plugins to store custom data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CancellationToken"})," - For cancellation propagation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CurrentNodeId"})," - ID of the node currently being executed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"LoggerFactory"})," - Factory to create loggers for nodes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tracer"})," - For distributed tracing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ErrorHandlerFactory"})," - Factory for creating error handlers and dead-letter sinks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"LineageFactory"})," - Factory for creating lineage sinks and resolving lineage collectors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ObservabilityFactory"})," - Factory for resolving observability collectors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DeadLetterSink"})," - Sink for handling failed items"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"PipelineErrorHandler"})," - Error handler for pipeline-level errors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RetryOptions"})," - Configuration for retry behavior"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Usage Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public override Task<TOut> ExecuteAsync(\r\n    TIn item,\r\n    PipelineContext context,\r\n    CancellationToken cancellationToken)\r\n{\r\n    var logger = context.LoggerFactory.CreateLogger("MyTransform");\r\n    logger.Log(LogLevel.Information, "Processing item");\r\n\r\n    // Access shared state\r\n    if (context.Items.TryGetValue("state", out var stateObj))\r\n    {\r\n        var sharedState = stateObj as MyState;\r\n    }\r\n\r\n    return Task.FromResult(transformedItem);\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"4-cached-node-execution-context",children:"4. Cached Node Execution Context"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Performance optimization - reduces per-item context access overhead"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public readonly struct CachedNodeExecutionContext\r\n{\r\n    public string NodeId { get; }\r\n    public PipelineRetryOptions RetryOptions { get; }\r\n    public bool TracingEnabled { get; }\r\n    public bool LoggingEnabled { get; }\r\n    public CancellationToken CancellationToken { get; }\r\n    \r\n    public static CachedNodeExecutionContext Create(\r\n        PipelineContext context, \r\n        string nodeId);\r\n    \r\n    public static CachedNodeExecutionContext CreateWithRetryOptions(\r\n        PipelineContext context,\r\n        string nodeId,\r\n        PipelineRetryOptions preResolvedRetryOptions);\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why This Exists:"})}),"\n",(0,t.jsxs)(n.p,{children:["During high-throughput node execution, accessing the same context properties repeatedly for each item creates dictionary lookup overhead. ",(0,t.jsx)(n.code,{children:"CachedNodeExecutionContext"})," captures frequently-accessed values once at node scope, then reuses them for all items."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How It Works:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"At node execution start:"})," Creation methods capture current context state"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"During item processing:"})," Nodes use cached values instead of context lookups"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Immutability validation:"})," ",(0,t.jsx)(n.code,{children:"PipelineContextImmutabilityGuard"})," (DEBUG-only) validates that context hasn't changed"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Transparent to Users:"})}),"\n",(0,t.jsxs)(n.p,{children:["Execution strategies automatically use ",(0,t.jsx)(n.code,{children:"CachedNodeExecutionContext"}),". Pipeline authors don't need to interact with it directly."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Performance Benefit:"})}),"\n",(0,t.jsx)(n.p,{children:"~150-250\u03bcs overhead reduction per 1K items in typical pipelines."}),"\n",(0,t.jsxs)(n.p,{children:["For complete details, see ",(0,t.jsx)(n.a,{href:"/docs/architecture/optimization-principles#3-cached-context-access-per-item-optimization",children:"Optimization Principles: Cached Context Access"}),"."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"5-pipeline-runner",children:"5. Pipeline Runner"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Executes compiled pipelines"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class PipelineRunner\r\n{\r\n    // Overload 1: With PipelineContext only\r\n    public Task RunAsync<TDefinition>(\r\n        PipelineContext context)\r\n        where TDefinition : IPipelineDefinition, new();\r\n\r\n    // Overload 2: With CancellationToken only\r\n    public Task RunAsync<TDefinition>(\r\n        CancellationToken cancellationToken = default)\r\n        where TDefinition : IPipelineDefinition, new();\r\n\r\n    // Overload 3: With both PipelineContext and CancellationToken\r\n    public Task RunAsync<TDefinition>(\r\n        PipelineContext context, \r\n        CancellationToken cancellationToken)\r\n        where TDefinition : IPipelineDefinition, new();\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Execution Workflow:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Instantiates pipeline definition"}),"\n",(0,t.jsx)(n.li,{children:"Creates pipeline builder"}),"\n",(0,t.jsxs)(n.li,{children:["Calls ",(0,t.jsx)(n.code,{children:"Define()"})," to build graph"]}),"\n",(0,t.jsx)(n.li,{children:"Traverses graph and connects nodes"}),"\n",(0,t.jsx)(n.li,{children:"Starts execution from source nodes"}),"\n",(0,t.jsx)(n.li,{children:"Waits for completion"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Usage Examples:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Using only PipelineContext\r\nvar context = PipelineContext.Default;\r\nvar runner = PipelineRunner.Create();\r\nawait runner.RunAsync<MyPipeline>(context);\r\n\r\n// Using only CancellationToken\r\nvar cts = new CancellationTokenSource();\r\nawait runner.RunAsync<MyPipeline>(cts.Token);\r\n\r\n// Using both PipelineContext and CancellationToken\r\nvar context = PipelineContext.Default;\r\nvar cts = new CancellationTokenSource();\r\nawait runner.RunAsync<MyPipeline>(context, cts.Token);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"5-node-execution-model",children:"5. Node Execution Model"}),"\n",(0,t.jsxs)(n.p,{children:["NPipeline uses a ",(0,t.jsx)(n.strong,{children:"plan-based execution model"})," for optimal performance. During pipeline initialization, the system generates pre-compiled execution plans for each node containing strongly-typed delegates that eliminate reflection overhead during steady-state execution."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Zero reflection overhead during execution"}),"\n",(0,t.jsx)(n.li,{children:"Improved performance through direct delegate calls"}),"\n",(0,t.jsx)(n.li,{children:"Type safety enforced at plan creation time"}),"\n",(0,t.jsx)(n.li,{children:"Reduced allocation and GC pressure"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Node Execution Patterns:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SourceNode Execution:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public abstract IDataPipe<T> Initialize(\r\n    PipelineContext context,\r\n    CancellationToken cancellationToken);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Produces initial ",(0,t.jsx)(n.code,{children:"IDataPipe<T>"})," containing all source data synchronously."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"TransformNode Execution:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public abstract Task<T> ExecuteAsync(\r\n    T item,\r\n    PipelineContext context,\r\n    CancellationToken cancellationToken);\n"})}),"\n",(0,t.jsx)(n.p,{children:"Called for each item; returns transformed item or throws to fail."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SinkNode Execution:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public abstract Task ExecuteAsync(\r\n    IDataPipe<T> input,\r\n    PipelineContext context,\r\n    CancellationToken cancellationToken);\n"})}),"\n",(0,t.jsx)(n.p,{children:"Consumes entire data pipe for final processing (save, send, etc)."}),"\n",(0,t.jsx)(n.h2,{id:"component-interaction-flow",children:"Component Interaction Flow"}),"\n",(0,t.jsx)(n.mermaid,{value:'graph TD\r\n    subgraph "Definition Phase"\r\n        PD[IPipelineDefinition] --\x3e|Calls| PB[PipelineBuilder]\r\n        PB --\x3e|AddSource| N1[Node Handles]\r\n        PB --\x3e|AddTransform| N2[Node Handles]\r\n        PB --\x3e|AddSink| N3[Node Handles]\r\n        PB --\x3e|Connect| G[Execution Graph]\r\n    end\r\n\r\n    subgraph "Execution Phase"\r\n        PR[PipelineRunner] --\x3e|Creates| PD\r\n        PR --\x3e|Builds| PB\r\n        PR --\x3e|Provides| PC[PipelineContext]\r\n        PR --\x3e|Executes| G\r\n        G --\x3e|Uses| PC\r\n    end\r\n\r\n    subgraph "Runtime"\r\n        SN[Nodes]\r\n        G --\x3e|Calls| SN\r\n        PC --\x3e|Available to| SN\r\n    end\r\n\r\n    style PD fill:#e1f5fe\r\n    style PB fill:#f3e5f5\r\n    style PR fill:#e8f5e9\r\n    style PC fill:#fff3e0\r\n    style G fill:#f1f8e9'}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/node-definition",children:"Node Definition Structure"})})," - Understanding the nested configuration structure of NodeDefinition"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/architecture/node-instantiation",children:"Node Instantiation"})})," - Understand node creation patterns and performance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/architecture/execution-flow",children:"Execution Flow"})})," - Understand sequential and parallel execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/architecture/dependency-injection",children:"Dependency Injection Integration"})})," - Learn about DI integration"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>s});var i=r(6540);const t={},o=i.createContext(t);function l(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);