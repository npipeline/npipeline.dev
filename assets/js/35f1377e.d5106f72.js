"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[5194],{8453:(e,n,o)=>{o.d(n,{R:()=>d,x:()=>s});var r=o(6540);const i={},t=r.createContext(i);function d(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),r.createElement(t.Provider,{value:n},e.children)}},8464:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>d,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"core-concepts/advanced-nodes/lookup","title":"Lookup Nodes","description":"Enrich your data streams by performing lookups against external data sources using NPipeline\'s Lookup Nodes.","source":"@site/docs/core-concepts/advanced-nodes/lookup.md","sourceDirName":"core-concepts/advanced-nodes","slug":"/core-concepts/advanced-nodes/lookup","permalink":"/docs/core-concepts/advanced-nodes/lookup","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Lookup Nodes","description":"Enrich your data streams by performing lookups against external data sources using NPipeline\'s Lookup Nodes.","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Join Nodes","permalink":"/docs/core-concepts/advanced-nodes/join"},"next":{"title":"Branch Nodes","permalink":"/docs/core-concepts/advanced-nodes/branch"}}');var i=o(4848),t=o(8453);const d={title:"Lookup Nodes",description:"Enrich your data streams by performing lookups against external data sources using NPipeline's Lookup Nodes.",sidebar_position:4},s="Lookup Nodes",c={},a=[{value:"<code>LookupNode&lt;TIn, TKey, TValue, TOut&gt;</code>",id:"lookupnodetin-tkey-tvalue-tout",level:2},{value:"<code>InMemoryLookupNode&lt;TIn, TKey, TValue, TOut&gt;</code>",id:"inmemorylookupnodetin-tkey-tvalue-tout",level:2},{value:"Example: Enriching Product Orders with Product Details",id:"example-enriching-product-orders-with-product-details",level:3},{value:"<code>PipelineBuilderLookupExtensions</code>",id:"pipelinebuilderlookupextensions",level:2},{value:"Configuration Pattern",id:"configuration-pattern",level:2},{value:"Considerations for Lookup Nodes",id:"considerations-for-lookup-nodes",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"lookup-nodes",children:"Lookup Nodes"})}),"\n",(0,i.jsx)(n.p,{children:"Lookup nodes are specialized transforms that enrich incoming data items by querying an external data source (e.g., a database, an in-memory cache, an API) to retrieve additional information. This is a common pattern in ETL and data processing pipelines where raw data needs to be augmented with reference data."}),"\n",(0,i.jsxs)(n.p,{children:["NPipeline provides an abstract ",(0,i.jsx)(n.a,{href:"src/NPipeline/Nodes/Lookup/LookupNode.cs",children:(0,i.jsx)(n.code,{children:"LookupNode<TIn, TKey, TValue, TOut>"})})," base class and a concrete ",(0,i.jsx)(n.a,{href:"src/NPipeline/Nodes/Lookup/InMemoryLookupNode.cs",children:(0,i.jsx)(n.code,{children:"InMemoryLookupNode<TIn, TKey, TValue, TOut>"})})," for in-memory lookups."]}),"\n",(0,i.jsx)(n.h2,{id:"lookupnodetin-tkey-tvalue-tout",children:(0,i.jsx)(n.code,{children:"LookupNode<TIn, TKey, TValue, TOut>"})}),"\n",(0,i.jsx)(n.p,{children:"This abstract base class allows you to define custom lookup logic. You need to specify:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TIn"}),": The type of the input item to be enriched."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TKey"}),": The type of the key used to perform the lookup (extracted from ",(0,i.jsx)(n.code,{children:"TIn"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TValue"}),": The type of the value retrieved from the lookup source."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TOut"}),": The type of the enriched output item."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"To implement a custom lookup, you typically override methods to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"src/NPipeline/Nodes/Lookup/LookupNode.cs:22",children:(0,i.jsx)(n.code,{children:"ExtractKey(TIn input, PipelineContext context)"})}),": Extracts the lookup key from the input item."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"src/NPipeline/Nodes/Lookup/LookupNode.cs:33",children:(0,i.jsx)(n.code,{children:"LookupAsync(TKey key, PipelineContext context, CancellationToken cancellationToken)"})}),": Asynchronously performs the actual lookup operation and returns the ",(0,i.jsx)(n.code,{children:"TValue"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"src/NPipeline/Nodes/Lookup/LookupNode.cs:46",children:(0,i.jsx)(n.code,{children:"CreateOutput(TIn input, TValue? lookupValue, PipelineContext context)"})}),": Combines the original input item with the retrieved lookup value to form the enriched output."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"inmemorylookupnodetin-tkey-tvalue-tout",children:(0,i.jsx)(n.code,{children:"InMemoryLookupNode<TIn, TKey, TValue, TOut>"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"InMemoryLookupNode"})," is a concrete implementation of ",(0,i.jsx)(n.code,{children:"LookupNode"})," that performs lookups against an in-memory dictionary. It's useful for small to medium-sized reference datasets that can be loaded entirely into memory."]}),"\n",(0,i.jsx)(n.h3,{id:"example-enriching-product-orders-with-product-details",children:"Example: Enriching Product Orders with Product Details"}),"\n",(0,i.jsxs)(n.p,{children:["Let's say we have a stream of ",(0,i.jsx)(n.code,{children:"OrderLine"})," items containing a ",(0,i.jsx)(n.code,{children:"ProductId"})," and a static, in-memory collection of ",(0,i.jsx)(n.code,{children:"Product"})," details. We want to enrich each ",(0,i.jsx)(n.code,{children:"OrderLine"})," with the ",(0,i.jsx)(n.code,{children:"ProductName"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\n\r\n// Define input and lookup data structures\r\npublic sealed record OrderLine(int OrderLineId, int ProductId, int Quantity);\r\npublic sealed record Product(int ProductId, string ProductName, decimal UnitPrice);\r\npublic sealed record EnrichedOrderLine(int OrderLineId, int ProductId, string ProductName, int Quantity);\r\n\r\npublic sealed class ProductLookupNode : InMemoryLookupNode<OrderLine, int, Product, EnrichedOrderLine>\r\n{\r\n    public ProductLookupNode(IReadOnlyDictionary<int, Product> lookupData) : base(lookupData) { }\r\n\r\n    protected override int ExtractKey(OrderLine input, PipelineContext context) => input.ProductId;\r\n\r\n    protected override EnrichedOrderLine CreateOutput(OrderLine input, Product? lookupValue, PipelineContext context)\r\n    {\r\n        if (lookupValue is null)\r\n        {\r\n            Console.WriteLine($"Warning: Product with ID {input.ProductId} not found for OrderLine {input.OrderLineId}. Skipping enrichment.");\r\n            return new EnrichedOrderLine(input.OrderLineId, input.ProductId, "Unknown Product", input.Quantity);\r\n        }\r\n\r\n        return new EnrichedOrderLine(\r\n            input.OrderLineId,\r\n            input.ProductId,\r\n            lookupValue.ProductName,\r\n            input.Quantity\r\n        );\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var productCatalog = new Dictionary<int, Product>\r\n        {\r\n            { 1, new Product(1, "Laptop", 1200.00m) },\r\n            { 2, new Product(2, "Mouse", 25.00m) },\r\n            { 3, new Product(3, "Keyboard", 75.00m) }\r\n        };\r\n\r\n        var orderLineSource = new InMemorySourceNode<OrderLine>(\r\n            new OrderLine(1, 1, 1),\r\n            new OrderLine(2, 3, 2),\r\n            new OrderLine(3, 99, 1) // Product 99 does not exist\r\n        );\r\n\r\n        var context = PipelineContext.Default;\r\n        var runner = new PipelineRunner();\r\n        \r\n        Console.WriteLine("Starting lookup pipeline...");\r\n        await runner.RunAsync<LookupPipelineDefinition>(context);\r\n        Console.WriteLine("Lookup pipeline finished.");\r\n    }\r\n}\r\n\r\npublic sealed class LookupPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<InMemorySourceNode<OrderLine>, OrderLine>("source");\r\n        var transformHandle = builder.AddTransform<ProductLookupNode, OrderLine, EnrichedOrderLine>("lookup");\r\n        var sinkHandle = builder.AddSink<ConsoleSink<EnrichedOrderLine>, EnrichedOrderLine>("sink");\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Expected Output:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'Starting lookup pipeline...\r\nSink received: EnrichedOrderLine { OrderLineId = 1, ProductId = 1, ProductName = "Laptop", Quantity = 1 }\r\nSink received: EnrichedOrderLine { OrderLineId = 2, ProductId = 3, ProductName = "Keyboard", Quantity = 2 }\r\nWarning: Product with ID 99 not found for OrderLine 3. Skipping enrichment.\r\nSink received: EnrichedOrderLine { OrderLineId = 3, ProductId = 99, ProductName = "Unknown Product", Quantity = 1 }\r\nLookup pipeline finished.\n'})}),"\n",(0,i.jsx)(n.h2,{id:"pipelinebuilderlookupextensions",children:(0,i.jsx)(n.code,{children:"PipelineBuilderLookupExtensions"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"src/NPipeline/Pipeline/PipelineBuilderLookupExtensions.cs",children:(0,i.jsx)(n.code,{children:"PipelineBuilderLookupExtensions"})})," provide convenient extension methods for integrating lookup nodes into your pipelines, often simplifying the syntax for common lookup scenarios."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// Example using lookup extension\r\npublic sealed class LookupWithExtensionPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<CustomerIdSource, int>("source");\r\n        var sinkHandle = builder.AddSink<EnrichedCustomerSink, EnrichedCustomer>("sink");\r\n\r\n        // Use the lookup extension for concise syntax\r\n        var lookupHandle = builder.AddLookup<int, EnrichedCustomer>("lookup", \r\n            keySelector: (customerId) => customerId,\r\n            lookupFunction: async (key, ct) => await GetCustomerDetailsAsync(key, ct),\r\n            combineFunction: (input, customerValue) => new EnrichedCustomer(input, customerValue)\r\n        );\r\n\r\n        builder.Connect(sourceHandle, lookupHandle);\r\n        builder.Connect(lookupHandle, sinkHandle);\r\n    }\r\n\r\n    private async Task<CustomerDetails> GetCustomerDetailsAsync(int customerId, CancellationToken ct)\r\n    {\r\n        // Implementation\r\n        return new CustomerDetails(customerId, "Customer Name");\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"configuration-pattern",children:"Configuration Pattern"}),"\n",(0,i.jsx)(n.p,{children:"The lookup nodes use a configuration pattern where the lookup data, key extraction logic, and output creation logic are encapsulated in a configuration object. This pattern allows for flexible setup while maintaining clean separation of concerns."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// The configuration pattern used internally\r\nvar config = new InMemoryLookupNode<TIn, TKey, TValue, TOut>.Configuration(\r\n    lookupData: dictionary,           // The data to lookup against\r\n    keyExtractor: input => input.Id,  // How to extract the key from input\r\n    outputCreator: (input, value) =>  // How to create the output\r\n        new EnrichedInput(input, value)\r\n);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"considerations-for-lookup-nodes",children:"Considerations for Lookup Nodes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lookup Source Performance:"})," The performance of your lookup node is heavily dependent on the underlying lookup source. Optimize your data access (e.g., indexing, caching) for frequently accessed lookup data."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory vs. External Calls:"})," For large lookup datasets, consider whether an ",(0,i.jsx)(n.code,{children:"InMemoryLookupNode"})," is feasible or if an external lookup (e.g., database query, API call) is more appropriate."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling:"})," Implement robust error handling for lookup failures (e.g., key not found, external service unavailable). Decide whether to skip the item, return a default value, or halt the pipeline."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Asynchronous Lookups:"})," Ensure your ",(0,i.jsx)(n.a,{href:"/docs-final/api/NPipeline.Nodes.Lookup.LookupNode#lookupAsync",children:(0,i.jsx)(n.code,{children:"LookupAsync"})})," implementation is truly asynchronous to avoid blocking the pipeline."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Lookup nodes are powerful for creating rich, contextual data streams within your NPipelines."}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/core-concepts/advanced-nodes/branch",children:"Branch Nodes"})}),": Learn about duplicating data streams to multiple downstream paths."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/core-concepts/advanced-nodes/type-conversion",children:"Type Conversion Nodes"})}),": Discover how to transform data between different types."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);