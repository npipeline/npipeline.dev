"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[9060],{6822:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"architecture/node-instantiation","title":"Node Instantiation","description":"How NPipeline instantiates nodes and optimization techniques.","source":"@site/docs/architecture/node-instantiation.md","sourceDirName":"architecture","slug":"/architecture/node-instantiation","permalink":"/docs/architecture/node-instantiation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5.5,"frontMatter":{"title":"Node Instantiation","description":"How NPipeline instantiates nodes and optimization techniques.","sidebar_position":5.5},"sidebar":"docsSidebar","previous":{"title":"Dependency Injection Integration","permalink":"/docs/architecture/dependency-injection"},"next":{"title":"Error Handling Architecture","permalink":"/docs/architecture/error-handling-architecture"}}');var i=r(4848),o=r(8453);const s={title:"Node Instantiation",description:"How NPipeline instantiates nodes and optimization techniques.",sidebar_position:5.5},c="Node Instantiation",a={},l=[{value:"Overview",id:"overview",level:2},{value:"DefaultNodeFactory (Optimized)",id:"defaultnodefactory-optimized",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Performance Impact",id:"performance-impact",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Node Constructor Patterns",id:"node-constructor-patterns",level:2},{value:"Pattern 1: Parameterless Constructor (Recommended)",id:"pattern-1-parameterless-constructor-recommended",level:3},{value:"Pattern 2: Mixed Constructors (DI + Default)",id:"pattern-2-mixed-constructors-di--default",level:3},{value:"Pattern 3: Dependency-Only Constructor",id:"pattern-3-dependency-only-constructor",level:3},{value:"Factory Selection",id:"factory-selection",level:2},{value:"DefaultNodeFactory",id:"defaultnodefactory",level:3},{value:"DIContainerNodeFactory",id:"dicontainernodefactory",level:3},{value:"Pre-configured Instances",id:"pre-configured-instances",level:3},{value:"Analyzer Support",id:"analyzer-support",level:2},{value:"Warning Detection",id:"warning-detection",level:3},{value:"Automatic Code Fix",id:"automatic-code-fix",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Performance Comparison",id:"performance-comparison",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"node-instantiation",children:"Node Instantiation"})}),"\n",(0,i.jsx)(n.p,{children:"NPipeline uses an optimized factory pattern to instantiate nodes with minimal overhead. This page explains how node creation works and how to structure your nodes for best performance."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Node instantiation happens when a pipeline is built. NPipeline provides multiple instantiation strategies to support different scenarios:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compiled factory (default)"})," - Fast path for nodes with parameterless constructors"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dependency injection"})," - For nodes requiring constructor dependencies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pre-configured instances"})," - For complex or custom initialization"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"defaultnodefactory-optimized",children:"DefaultNodeFactory (Optimized)"}),"\n",(0,i.jsxs)(n.p,{children:["The default node factory uses ",(0,i.jsx)(n.strong,{children:"compiled expression delegates"})," to achieve 3-5x faster instantiation than reflection-based approaches."]}),"\n",(0,i.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,i.jsx)(n.p,{children:"For nodes with public parameterless constructors, NPipeline compiles an optimized factory:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// First instantiation of a node type:\nvar node = factory.Create(nodeDefinition, graph);\n// Internally: Compiles () => new MyNode() and caches it\n\n// Subsequent instantiations of same type:\nvar node2 = factory.Create(nodeDefinition2, graph);\n// Uses cached compiled delegate (no reflection!)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"performance-impact",children:"Performance Impact"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Optimized path"}),": ~50-100\u03bcs per instantiation (compiled delegate)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fallback path"}),": ~200-300\u03bcs per instantiation (reflection)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Savings per pipeline"}),": 200-300\u03bcs on average"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Relative improvement"}),": 3-5x faster for parameterless constructors"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsxs)(n.p,{children:["The factory implementation is in ",(0,i.jsx)(n.code,{children:"NPipeline.Execution.Factories.DefaultNodeFactory"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"private static Func<INode>? BuildCompiledFactory(Type nodeType)\n{\n    var constructor = nodeType.GetConstructor(Type.EmptyTypes);\n    \n    if (constructor == null)\n        return null; // Fallback to Activator.CreateInstance\n    \n    // Compile: () => (INode)new TNode()\n    var newExpression = Expression.New(constructor);\n    var castExpression = Expression.Convert(newExpression, typeof(INode));\n    var lambda = Expression.Lambda<Func<INode>>(castExpression);\n    \n    return lambda.Compile(); // Cached per type\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"node-constructor-patterns",children:"Node Constructor Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"pattern-1-parameterless-constructor-recommended",children:"Pattern 1: Parameterless Constructor (Recommended)"}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Optimized"})," - Uses compiled factory for maximum performance"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public class SimpleTransform : TransformNode<string, int>\n{\n    // Implicit or explicit parameterless constructor\n    // Both are optimized by the compiled factory\n    \n    public override Task<int> ExecuteAsync(\n        string item, \n        PipelineContext context, \n        CancellationToken cancellationToken)\n    {\n        return Task.FromResult(item.Length);\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Best for"}),": Stateless transforms, utility nodes, simple processing logic"]}),"\n",(0,i.jsx)(n.h3,{id:"pattern-2-mixed-constructors-di--default",children:"Pattern 2: Mixed Constructors (DI + Default)"}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Optimized"})," - Uses parameterless constructor path, but supports DI"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public class DependencyAwareNode : TransformNode<Order, ProcessedOrder>\n{\n    private IPaymentService? _paymentService;\n\n    // Default constructor for DefaultNodeFactory (optimized)\n    public DependencyAwareNode()\n    {\n    }\n\n    // DI constructor for DIContainerNodeFactory\n    public DependencyAwareNode(IPaymentService paymentService)\n    {\n        _paymentService = paymentService;\n    }\n\n    public override Task<ProcessedOrder> ExecuteAsync(\n        Order item, \n        PipelineContext context, \n        CancellationToken cancellationToken)\n    {\n        // Handle both cases: DI-provided or null\n        if (_paymentService != null)\n        {\n            return ProcessWithServiceAsync(item, cancellationToken);\n        }\n        else\n        {\n            return ProcessWithoutServiceAsync(item, cancellationToken);\n        }\n    }\n\n    private async Task<ProcessedOrder> ProcessWithServiceAsync(\n        Order item, \n        CancellationToken cancellationToken)\n    {\n        var result = await _paymentService.ChargeAsync(item.Amount, cancellationToken);\n        return new ProcessedOrder { /* ... */ };\n    }\n\n    private Task<ProcessedOrder> ProcessWithoutServiceAsync(Order item, CancellationToken cancellationToken)\n    {\n        return Task.FromResult(new ProcessedOrder { /* ... */ });\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Best for"}),": Nodes that optionally use dependencies, testing scenarios"]}),"\n",(0,i.jsx)(n.h3,{id:"pattern-3-dependency-only-constructor",children:"Pattern 3: Dependency-Only Constructor"}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,i.jsx)(n.strong,{children:"Not optimized"})," - Falls back to reflection, but fully supports DI"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'public class DIOnlyNode : TransformNode<string, int>\n{\n    private readonly ILogger _logger;\n\n    // Only parameterized constructor - uses reflection fallback\n    public DIOnlyNode(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    public override Task<int> ExecuteAsync(\n        string item, \n        PipelineContext context, \n        CancellationToken cancellationToken)\n    {\n        _logger.LogInformation($"Processing: {item}");\n        return Task.FromResult(item.Length);\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Best for"}),": Nodes that require external services, when DI flexibility is more important than the ~200-300\u03bcs overhead"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"}),": Use ",(0,i.jsx)(n.code,{children:"DIContainerNodeFactory"})," for these nodes to ensure proper instantiation."]}),"\n",(0,i.jsx)(n.h2,{id:"factory-selection",children:"Factory Selection"}),"\n",(0,i.jsx)(n.h3,{id:"defaultnodefactory",children:"DefaultNodeFactory"}),"\n",(0,i.jsx)(n.p,{children:"Used by default when you don't configure DI. Optimized for parameterless constructors."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"var builder = new PipelineBuilder();\nvar source = builder.AddSource<SimpleSource, int>();\nvar transform = builder.AddTransform<OptimizedTransform, int, string>();\nbuilder.Connect(source, transform);\n\nvar pipeline = builder.Build(); // Uses DefaultNodeFactory\n"})}),"\n",(0,i.jsx)(n.h3,{id:"dicontainernodefactory",children:"DIContainerNodeFactory"}),"\n",(0,i.jsx)(n.p,{children:"Use when you need dependency injection. Supports parameterized constructors."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"var services = new ServiceCollection();\nservices.AddSingleton<ILogger, ConsoleLogger>();\nservices.AddNPipeline(builder => \n{\n    builder.UseDIContainerNodeFactory();\n});\n\nvar pipeline = PipelineFactory.Create<MyPipeline>(context);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pre-configured-instances",children:"Pre-configured Instances"}),"\n",(0,i.jsx)(n.p,{children:"For complex initialization or testing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"var builder = new PipelineBuilder();\nvar customInstance = new MyNode(complexConfig);\n\nvar nodeHandle = builder.AddTransform<MyNode, string, int>();\nbuilder.AddPreconfiguredNodeInstance(nodeHandle.Id, customInstance);\n\nvar pipeline = builder.Build();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"analyzer-support",children:"Analyzer Support"}),"\n",(0,i.jsxs)(n.p,{children:["NPipeline includes analyzer ",(0,i.jsx)(n.strong,{children:"NP9505"})," that detects nodes without parameterless constructors:"]}),"\n",(0,i.jsx)(n.h3,{id:"warning-detection",children:"Warning Detection"}),"\n",(0,i.jsx)(n.p,{children:"The analyzer warns when a node has parameterized constructors but no parameterless fallback:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public class ProblematicNode : TransformNode<string, int>\n{\n    private readonly ILogger _logger;\n\n    // \u26a0\ufe0f Warning NP9505: No parameterless constructor\n    public ProblematicNode(ILogger logger)\n    {\n        _logger = logger;\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Message"}),": \"Node 'ProblematicNode' does not have a public parameterless constructor and requires DI or pre-configured instances\""]}),"\n",(0,i.jsx)(n.h3,{id:"automatic-code-fix",children:"Automatic Code Fix"}),"\n",(0,i.jsx)(n.p,{children:"The analyzer provides a one-click code fix that adds a parameterless constructor:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'public class ProblematicNode : TransformNode<string, int>\n{\n    private ILogger? _logger;\n\n    /// <summary>\n    ///     Initializes a new instance of the <see cref="ProblematicNode" /> class.\n    /// </summary>\n    public ProblematicNode()\n    {\n    }\n\n    public ProblematicNode(ILogger logger)\n    {\n        _logger = logger;\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"}),": Implicit parameterless constructors (when no constructors are defined) don't trigger warnings - they're already optimized."]}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Add explicit parameterless constructors"})," for clarity and to prevent accidental removal"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public MyNode() { } // Explicit, won't be accidentally removed\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use both constructors"})," when you need flexibility"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public MyNode() { }\npublic MyNode(IService service) { _service = service; }\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Keep constructors simple"})," - Complex initialization belongs in a factory method or builder pattern"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Good\npublic MyNode() { }\npublic MyNode(ILogger logger) { _logger = logger; }\n\n// Consider refactoring\npublic MyNode(ILogger logger, IConfig config, ICache cache, \n              INotification notif, ISecurity sec) { /* complex */ }\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Don't worry about implicit constructors"})," - They're already optimized"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// This is fine - it has an implicit parameterless constructor\npublic MyNode : TransformNode<string, int>\n{\n    public override Task<string> ExecuteAsync(...) { ... }\n}\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use DIContainerNodeFactory for pure DI scenarios"})," if performance isn't critical"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// When you always use DI and don't care about ~200\u03bcs overhead\nbuilder.UseDIContainerNodeFactory();\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"performance-comparison",children:"Performance Comparison"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Pattern"}),(0,i.jsx)(n.th,{children:"Factory"}),(0,i.jsx)(n.th,{children:"Instantiation Time"}),(0,i.jsx)(n.th,{children:"Use Case"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Parameterless"}),(0,i.jsx)(n.td,{children:"Compiled (optimized)"}),(0,i.jsx)(n.td,{children:"~50-100\u03bcs"}),(0,i.jsx)(n.td,{children:"Stateless, simple nodes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Mixed constructors"}),(0,i.jsx)(n.td,{children:"Compiled (optimized)"}),(0,i.jsx)(n.td,{children:"~50-100\u03bcs"}),(0,i.jsx)(n.td,{children:"Optional DI, flexible"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Parameterized only"}),(0,i.jsx)(n.td,{children:"Reflection (fallback)"}),(0,i.jsx)(n.td,{children:"~200-300\u03bcs"}),(0,i.jsx)(n.td,{children:"Requires dependencies"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/architecture/component-architecture",children:"Component Architecture"})," - Overview of node factory role"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/core-concepts/node-definition",children:"Node Definition Structure"})," - Understanding the nested configuration structure of NodeDefinition"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/architecture/dependency-injection",children:"Dependency Injection Integration"})," - DI setup and patterns"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/core-concepts/pipelinebuilder",children:"PipelineBuilder"})," - How nodes are added to pipelines"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/architecture/performance-characteristics",children:"Performance Characteristics"})," - Overall framework performance"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>c});var t=r(6540);const i={},o=t.createContext(i);function s(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);