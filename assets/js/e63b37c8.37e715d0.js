"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3994],{12300:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"core-concepts/resilience/node-error-handling","title":"Node-Level Error Handling","description":"Handle errors for individual items within nodes using INodeErrorHandler","source":"@site/docs/core-concepts/resilience/node-error-handling.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/node-error-handling","permalink":"/docs/core-concepts/resilience/node-error-handling","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Node-Level Error Handling","description":"Handle errors for individual items within nodes using INodeErrorHandler","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Resilience Quick Start","permalink":"/docs/core-concepts/resilience/getting-started"},"next":{"title":"Circuit Breakers","permalink":"/docs/core-concepts/resilience/circuit-breakers"}}');var o=n(74848),t=n(28453);const a={title:"Node-Level Error Handling",description:"Handle errors for individual items within nodes using INodeErrorHandler",sidebar_position:2},s="Node-Level Error Handling",l={},d=[{value:"INodeErrorHandler Interface",id:"inodeerrorhandler-interface",level:2},{value:"Interface Components",id:"interface-components",level:3},{value:"NodeErrorDecision Enum",id:"nodeerrordecision-enum",level:2},{value:"Implementing a Custom Node Error Handler",id:"implementing-a-custom-node-error-handler",level:2},{value:"Registering a Node Error Handler",id:"registering-a-node-error-handler",level:2},{value:"Common Scenarios",id:"common-scenarios",level:2},{value:"Scenario 1: Handling Transient Network Errors",id:"scenario-1-handling-transient-network-errors",level:3},{value:"Scenario 2: Data Validation Errors",id:"scenario-2-data-validation-errors",level:3},{value:"Scenario 3: Production-Ready Error Handler with Metrics Integration",id:"scenario-3-production-ready-error-handler-with-metrics-integration",level:3},{value:"Fluent Error Handler Builder",id:"fluent-error-handler-builder",level:2},{value:"Pre-built Handler Factories",id:"pre-built-handler-factories",level:3},{value:"Exception Type Matching",id:"exception-type-matching",level:3},{value:"Custom Predicate Matching",id:"custom-predicate-matching",level:3},{value:"Default Behavior",id:"default-behavior",level:3},{value:"Fluent Builder Best Practices",id:"fluent-builder-best-practices",level:2},{value:"When to Use Each Approach",id:"when-to-use-each-approach",level:2},{value:"Use Fluent Builder When:",id:"use-fluent-builder-when",level:3},{value:"Implement INodeErrorHandler When:",id:"implement-inodeerrorhandler-when",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function c(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"node-level-error-handling",children:"Node-Level Error Handling"})}),"\n",(0,o.jsx)(r.p,{children:"Node-level error handling allows you to define what happens to problematic items without affecting the entire pipeline. When an error occurs during the processing of an individual item in a node, NPipeline invokes your error handler to determine how to proceed."}),"\n",(0,o.jsx)(r.h2,{id:"inodeerrorhandler-interface",children:"INodeErrorHandler Interface"}),"\n",(0,o.jsxs)(r.p,{children:["To handle errors within a specific node, implement the ",(0,o.jsx)(r.a,{href:"../../../src/NPipeline/Abstractions/ErrorHandling/INodeErrorHandler.cs",children:(0,o.jsx)(r.code,{children:"INodeErrorHandler<in TNode, in TData>"})})," interface."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:'public interface INodeErrorHandler\n{\n}\n\n/// <summary>\n///     Defines the contract for handling errors that occur within a specific node.\n/// </summary>\n/// <typeparam name="TNode">The type of node where the error occurred.</typeparam>\n/// <typeparam name="TData">The type of the data item that failed.</typeparam>\npublic interface INodeErrorHandler<in TNode, in TData> : INodeErrorHandler where TNode : INode\n{\n    /// <summary>\n    ///     Handles an error that occurred during node execution.\n    /// </summary>\n    /// <param name="node">The instance of node that failed.</param>\n    /// <param name="failedItem">The data item that caused the error.</param>\n    /// <param name="error">The exception that was thrown.</param>\n    /// <param name="context">The current pipeline context.</param>\n    /// <param name="cancellationToken">A token to observe for cancellation requests.</param>\n    /// <returns>A <see cref="NodeErrorDecision" /> indicating how to proceed.</returns>\n    Task<NodeErrorDecision> HandleAsync(\n        TNode node,\n        TData failedItem,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken);\n}\n'})}),"\n",(0,o.jsx)(r.h3,{id:"interface-components",children:"Interface Components"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"INodeErrorHandler"})}),": Marker interface for dependency injection registration."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"INodeErrorHandler<in TNode, in TData>"})}),": Generic interface defining the actual error handling logic."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"TNode"})}),": The type of node where the error occurred."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"TData"})}),": The type of the data item that caused the error."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"HandleAsync"})}),": Called when an error occurs. Receives the failing node, item, exception, and pipeline context. Must return a ",(0,o.jsx)(r.code,{children:"NodeErrorDecision"}),"."]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"nodeerrordecision-enum",children:"NodeErrorDecision Enum"}),"\n",(0,o.jsx)(r.p,{children:"This enum dictates how the pipeline should proceed after a node-level error:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"Skip"})}),": The failed item is discarded, and the pipeline continues processing subsequent items."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"Retry"})}),": The pipeline attempts to re-process the failed item. The number of retries is configured via ",(0,o.jsx)(r.code,{children:"PipelineRetryOptions"}),"."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"DeadLetter"})}),": The failed item is sent to a configured dead-letter sink, and the pipeline continues."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:(0,o.jsx)(r.code,{children:"Fail"})}),": The pipeline immediately terminates with an exception."]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"implementing-a-custom-node-error-handler",children:"Implementing a Custom Node Error Handler"}),"\n",(0,o.jsx)(r.p,{children:"Here's a basic example:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Nodes;\nusing NPipeline.Pipeline;\n\n/// <summary>\n/// Custom node error handler for transform nodes processing string data.\n/// Demonstrates error classification and appropriate response strategies.\n/// </summary>\npublic sealed class MyNodeErrorHandler : INodeErrorHandler<ITransformNode<string, string>, string>\n{\n    private readonly ILogger _logger;\n\n    public MyNodeErrorHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles errors that occur during string transformation.\n    /// Implements different strategies based on error type for optimal recovery.\n    /// </summary>\n    public Task<NodeErrorDecision> HandleAsync(\n        ITransformNode<string, string> node,\n        string failedItem,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Log error with full context for troubleshooting\n        _logger.LogError(error, \"Error in node '{NodeName}' processing '{FailedItem}': {ErrorMessage}\",\n            node.Name, failedItem, error.Message);\n\n        // Choose error handling strategy based on exception type\n        return error switch\n        {\n            // Data format errors are permanent - send to dead letter queue\n            FormatException => Task.FromResult(NodeErrorDecision.DeadLetter),\n            \n            // Items marked for retry get another chance\n            _ when failedItem.Contains(\"retry\") => Task.FromResult(NodeErrorDecision.Retry),\n            \n            // All other errors are skipped to continue processing\n            _ => Task.FromResult(NodeErrorDecision.Skip)\n        };\n    }\n}\n"})}),"\n",(0,o.jsx)(r.h2,{id:"registering-a-node-error-handler",children:"Registering a Node Error Handler"}),"\n",(0,o.jsxs)(r.p,{children:["Register your error handler with the ",(0,o.jsx)(r.code,{children:"PipelineBuilder"}),":"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"using NPipeline;\nusing NPipeline.ErrorHandling;\nusing NPipeline.Pipeline;\n\npublic sealed class ErrorHandlingPipelineDefinition : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var sourceHandle = builder.AddSource<DataSource, string>();\n        var transformHandle = builder.AddTransform<DataTransform, string, string>();\n        var sinkHandle = builder.AddSink<DataSink, string>();\n\n        builder.Connect(sourceHandle, transformHandle);\n        builder.Connect(transformHandle, sinkHandle);\n\n        // Configure retry options\n        builder.WithRetryOptions(new PipelineRetryOptions(\n            MaxItemRetries: 3,\n            MaxNodeRestartAttempts: 2,\n            MaxSequentialNodeAttempts: 5\n        ));\n    }\n}\n"})}),"\n",(0,o.jsx)(r.p,{children:"Also register with your DI container:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"services.AddSingleton<INodeErrorHandler<ITransformNode<string, string>, string>, MyNodeErrorHandler>();\n"})}),"\n",(0,o.jsxs)(r.p,{children:["The marker interface ",(0,o.jsx)(r.code,{children:"INodeErrorHandler"})," (non-generic) is used for DI registration, allowing the container to discover all node error handler implementations."]}),"\n",(0,o.jsx)(r.h2,{id:"common-scenarios",children:"Common Scenarios"}),"\n",(0,o.jsx)(r.h3,{id:"scenario-1-handling-transient-network-errors",children:"Scenario 1: Handling Transient Network Errors"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:'public class NetworkErrorHandler : INodeErrorHandler<IApiTransformNode, string>\n{\n    private readonly ILogger _logger;\n    private int _retryCount = 0;\n\n    public NetworkErrorHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles network errors with exponential backoff retry strategy.\n    /// Transient errors are retried, persistent failures are redirected.\n    /// </summary>\n    public Task<NodeErrorDecision> HandleAsync(\n        IApiTransformNode node,\n        string failedItem,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Handle network-related errors specifically\n        if (error is HttpRequestException httpEx)\n        {\n            _retryCount++;\n            _logger.LogWarning("Network error (attempt {RetryCount}): {ErrorMessage}", \n                _retryCount, httpEx.Message);\n\n            // Retry up to 3 times for transient network errors\n            if (_retryCount <= 3)\n            {\n                return Task.FromResult(NodeErrorDecision.Retry);\n            }\n            else\n            {\n                // After max retries, reset counter and redirect to dead letter\n                _retryCount = 0;\n                return Task.FromResult(NodeErrorDecision.DeadLetter);\n            }\n        }\n\n        // Non-network errors are skipped to continue processing\n        return Task.FromResult(NodeErrorDecision.Skip);\n    }\n}\n'})}),"\n",(0,o.jsx)(r.h3,{id:"scenario-2-data-validation-errors",children:"Scenario 2: Data Validation Errors"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:'public class ValidationErrorHandler : INodeErrorHandler<IValidatorNode, string>\n{\n    private readonly ILogger _logger;\n\n    public ValidationErrorHandler(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Handles validation errors by redirecting to dead letter queue.\n    /// Data quality issues are logged separately from system errors.\n    /// </summary>\n    public Task<NodeErrorDecision> HandleAsync(\n        IValidatorNode node,\n        string failedItem,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Handle validation errors specifically\n        if (error is ValidationException validationEx)\n        {\n            _logger.LogWarning("Validation failed for item: {Item}. Error: {Error}", \n                failedItem, validationEx.Message);\n\n            // Validation failures indicate data quality issues - redirect for manual review\n            return Task.FromResult(NodeErrorDecision.DeadLetter);\n        }\n\n        // Other types of errors are skipped to continue processing\n        return Task.FromResult(NodeErrorDecision.Skip);\n    }\n}\n'})}),"\n",(0,o.jsx)(r.h3,{id:"scenario-3-production-ready-error-handler-with-metrics-integration",children:"Scenario 3: Production-Ready Error Handler with Metrics Integration"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:'public class ProductionNodeErrorHandler : INodeErrorHandler<ITransformNode<string, string>, string>\n{\n    private readonly ILogger _logger;\n    private readonly IMetrics _metrics;\n\n    public ProductionNodeErrorHandler(ILogger logger, IMetrics metrics)\n    {\n        _logger = logger;\n        _metrics = metrics;\n    }\n\n    /// <summary>\n    /// Handles errors with comprehensive logging and metrics collection.\n    /// Enables monitoring and alerting for production environments.\n    /// </summary>\n    public Task<NodeErrorDecision> HandleAsync(\n        ITransformNode<string, string> node,\n        string failedItem,\n        Exception error,\n        PipelineContext context,\n        CancellationToken cancellationToken)\n    {\n        // Record error metrics for monitoring\n        _metrics.Increment("node_errors", new[] { \n            new KeyValuePair<string, object>("node_type", node.GetType().Name),\n            new KeyValuePair<string, object>("error_type", error.GetType().Name)\n        });\n\n        // Log error with full context\n        _logger.LogError(error, "Error processing item in node {NodeName}", node.Name);\n\n        // Implement error handling strategy based on exception type\n        return error switch\n        {\n            // Data validation errors - redirect to dead letter\n            ValidationException => Task.FromResult(NodeErrorDecision.DeadLetter),\n            \n            // Transient errors - retry\n            TimeoutException => Task.FromResult(NodeErrorDecision.Retry),\n            HttpRequestException => Task.FromResult(NodeErrorDecision.Retry),\n            \n            // All other errors - skip\n            _ => Task.FromResult(NodeErrorDecision.Skip)\n        };\n    }\n}\n'})}),"\n",(0,o.jsx)(r.h2,{id:"fluent-error-handler-builder",children:"Fluent Error Handler Builder"}),"\n",(0,o.jsx)(r.p,{children:"For simpler scenarios, use the fluent builder API to construct error handlers inline:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"using NPipeline.ErrorHandling;\n\n// Create a handler that retries on timeout, skips on validation errors\nvar handler = ErrorHandler.ForNode<MyTransform, string>()\n    .On<TimeoutException>().Retry(3)\n    .On<ValidationException>().Skip()\n    .OnAny().DeadLetter()\n    .Build();\n"})}),"\n",(0,o.jsx)(r.h3,{id:"pre-built-handler-factories",children:"Pre-built Handler Factories"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"// Retry all errors up to N times, then dead-letter\nvar retryHandler = ErrorHandler.RetryAlways<MyTransform, string>(maxRetries: 3);\n\n// Skip all errors and continue processing\nvar skipHandler = ErrorHandler.SkipAlways<MyTransform, string>();\n\n// Send all errors to dead-letter sink\nvar deadLetterHandler = ErrorHandler.DeadLetterAlways<MyTransform, string>();\n"})}),"\n",(0,o.jsx)(r.h3,{id:"exception-type-matching",children:"Exception Type Matching"}),"\n",(0,o.jsx)(r.p,{children:"Rules are evaluated in order, so place more specific rules first:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"var handler = ErrorHandler.ForNode<MyTransform, string>()\n    .On<TimeoutException>().Retry(3)\n    .On<IOException>().Retry(5)\n    .On<ArgumentException>().Skip()\n    .On<InvalidOperationException>().Fail()\n    .OnAny().DeadLetter()  // Catch-all (must be last)\n    .Build();\n"})}),"\n",(0,o.jsxs)(r.p,{children:["\u26a0\ufe0f ",(0,o.jsx)(r.strong,{children:"Important"}),": ",(0,o.jsx)(r.code,{children:"OnAny()"})," must be the last rule because it matches all exceptions."]}),"\n",(0,o.jsx)(r.h3,{id:"custom-predicate-matching",children:"Custom Predicate Matching"}),"\n",(0,o.jsx)(r.p,{children:"For complex scenarios, use custom predicates:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:'var handler = ErrorHandler.ForNode<MyTransform, string>()\n    .When(ex => ex.Message.Contains("timeout", StringComparison.OrdinalIgnoreCase))\n        .Retry(3)\n    .When(ex => ex.Message.Contains("invalid", StringComparison.OrdinalIgnoreCase))\n        .Skip()\n    .OnAny().Fail()\n    .Build();\n'})}),"\n",(0,o.jsx)(r.h3,{id:"default-behavior",children:"Default Behavior"}),"\n",(0,o.jsxs)(r.p,{children:["Use ",(0,o.jsx)(r.code,{children:"Otherwise()"})," for a default behavior when no rules match:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-csharp",children:"var handler = ErrorHandler.ForNode<MyTransform, string>()\n    .On<TimeoutException>().Retry(2)\n    .Otherwise(NodeErrorDecision.Skip)  // Default for unmatched exceptions\n    .Build();\n"})}),"\n",(0,o.jsx)(r.h2,{id:"fluent-builder-best-practices",children:"Fluent Builder Best Practices"}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Rule Evaluation Order"}),": Rules are evaluated in order added. First match wins."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Retry Counting"}),": Automatically tracks retry attempts and transitions to dead-letter when exhausted."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Type Hierarchy"}),": Exception matching respects inheritance - ",(0,o.jsx)(r.code,{children:"On<ArgumentException>()"})," matches derived types."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Catch-All Pattern"}),": Use ",(0,o.jsx)(r.code,{children:"OnAny()"})," only at the end as a catch-all."]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"when-to-use-each-approach",children:"When to Use Each Approach"}),"\n",(0,o.jsx)(r.h3,{id:"use-fluent-builder-when",children:"Use Fluent Builder When:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"\u2705 Simple error handling logic with clear exception-to-action mapping"}),"\n",(0,o.jsx)(r.li,{children:"\u2705 Prototyping or quick implementations"}),"\n",(0,o.jsx)(r.li,{children:"\u2705 Straightforward retry/skip/dead-letter strategies"}),"\n"]}),"\n",(0,o.jsx)(r.h3,{id:"implement-inodeerrorhandler-when",children:"Implement INodeErrorHandler When:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"\u2705 Complex state management across multiple items"}),"\n",(0,o.jsx)(r.li,{children:"\u2705 Advanced logging, metrics, or custom recovery logic"}),"\n",(0,o.jsx)(r.li,{children:"\u2705 Error handling that requires dependency injection"}),"\n",(0,o.jsx)(r.li,{children:"\u2705 Need access to custom services or configuration"}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Be specific about error types"}),": Different error types should be handled differently. Transient errors might be worth retrying, while data validation errors should probably be redirected."]}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Implement retry limits"}),": Always limit the number of retries to prevent infinite loops and resource exhaustion."]}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Log detailed error information"}),": Include sufficient context in your error logs to help with troubleshooting."]}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Use dead-letter queues for problematic items"}),": Items that consistently fail should be redirected to a dead-letter queue for later analysis."]}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Consider performance implications"}),": Error handling logic adds overhead to normal processing, so keep it efficient."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.a,{href:"/docs/core-concepts/resilience/error-handling-overview",children:"Error Handling Overview"})," - Understand both levels of error handling"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.a,{href:"/docs/core-concepts/resilience/pipeline-error-handling",children:"Pipeline-Level Error Handling"})," - Handle stream/node failures"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.a,{href:"/docs/core-concepts/resilience/retries",children:"Retries"})," - Configure retry policies and strategies"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.a,{href:"/docs/core-concepts/resilience/dead-letter-queues",children:"Dead Letter Queues"})," - Route problematic items for analysis"]}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>s});var i=n(96540);const o={},t=i.createContext(o);function a(e){const r=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(t.Provider,{value:r},e.children)}}}]);