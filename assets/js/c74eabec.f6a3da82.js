"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[4309],{3381:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"advanced-topics/testing-pipelines","title":"Advanced Testing","description":"Learn how to test complex pipeline scenarios, including nodes with dependencies, error handling, and more.","source":"@site/docs/advanced-topics/testing-pipelines.md","sourceDirName":"advanced-topics","slug":"/advanced-topics/testing-pipelines","permalink":"/docs/advanced-topics/testing-pipelines","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Advanced Testing","description":"Learn how to test complex pipeline scenarios, including nodes with dependencies, error handling, and more.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Synchronous Fast Paths and ValueTask Optimization","permalink":"/docs/advanced-topics/synchronous-fast-paths"},"next":{"title":"Advanced Retry Delay Strategies","permalink":"/docs/advanced-topics/retry-delay-advanced"}}');var s=i(4848),t=i(8453);const o={title:"Advanced Testing",description:"Learn how to test complex pipeline scenarios, including nodes with dependencies, error handling, and more.",sidebar_position:2},a="Advanced Pipeline Testing",c={},l=[{value:"Testing Nodes with Dependencies",id:"testing-nodes-with-dependencies",level:2},{value:"Example: Mocking a Service with Moq",id:"example-mocking-a-service-with-moq",level:3},{value:"Testing Error Handling",id:"testing-error-handling",level:2},{value:"Example: Testing Error Handling in a Transform",id:"example-testing-error-handling-in-a-transform",level:3},{value:"Best Practices for Advanced Testing",id:"best-practices-for-advanced-testing",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"advanced-pipeline-testing",children:"Advanced Pipeline Testing"})}),"\n",(0,s.jsxs)(n.p,{children:["While the ",(0,s.jsx)(n.a,{href:"../extensions/testing",children:"basic testing utilities"})," are great for simple, stateless pipelines, real-world scenarios are often more complex. Your nodes may have dependencies on external services, implement complex error handling, or manage internal state."]}),"\n",(0,s.jsx)(n.p,{children:"This guide covers strategies for testing these advanced scenarios effectively."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Getting started with testing?"})," Start with the ",(0,s.jsx)(n.a,{href:"../extensions/testing",children:"Testing Extensions"})," overview for basic patterns."]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"This guide"})," focuses on: ",(0,s.jsx)(n.strong,{children:"Dependencies, mocking, error handling, state management, and integration tests"}),(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Testing Extensions"})," covers: ",(0,s.jsx)(n.strong,{children:"Installation, quick start, available packages, and basic patterns"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"testing-nodes-with-dependencies",children:"Testing Nodes with Dependencies"}),"\n",(0,s.jsx)(n.p,{children:"When your nodes rely on external services (like a database repository or a web API client), you'll want to replace those dependencies with mock or fake implementations during tests. This isolates your node's logic and makes your tests fast and reliable."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"NPipeline.Extensions.DependencyInjection"})," package is invaluable here."]}),"\n",(0,s.jsx)(n.h3,{id:"example-mocking-a-service-with-moq",children:"Example: Mocking a Service with Moq"}),"\n",(0,s.jsxs)(n.p,{children:["Let's expand on the ",(0,s.jsx)(n.code,{children:"NotificationTransform"})," example from the ",(0,s.jsx)(n.a,{href:"../extensions/dependency-injection",children:"Dependency Injection"})," page. We want to test the transform without actually sending an email. We can use a mocking library like ",(0,s.jsx)(n.a,{href:"https://github.com/moq/moq4",children:"Moq"})," to provide a mock ",(0,s.jsx)(n.code,{children:"IEmailService"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. Install required packages:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"dotnet add package Moq\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. The Test:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using Moq;\r\nusing NPipeline.Execution;\r\nusing NPipeline.Extensions.DependencyInjection;\r\nusing NPipeline.Extensions.Testing;\r\nusing Microsoft.Extensions.DependencyInjection;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\nusing Xunit;\r\n\r\npublic interface IEmailService\r\n{\r\n    Task SendEmailAsync(string to, string subject, string body);\r\n}\r\n\r\npublic sealed class NotificationTransform : TransformNode<string, string>\r\n{\r\n    private readonly IEmailService _emailService;\r\n\r\n    public NotificationTransform(IEmailService emailService)\r\n    {\r\n        _emailService = emailService;\r\n    }\r\n\r\n    public override async Task<string> ExecuteAsync(\r\n        string item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        await _emailService.SendEmailAsync(\r\n            "admin@example.com",\r\n            "Processing Item",\r\n            $"Item \'{item}\' was processed.");\r\n        return $"Notified for {item}";\r\n    }\r\n}\r\n\r\npublic sealed class NotificationPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var source = builder.AddSource<InMemorySourceNode<string>, string>();\r\n        var transform = builder.AddTransform<NotificationTransform, string, string>();\r\n        var sink = builder.AddSink<InMemorySinkNode<string>, string>();\r\n\r\n        builder.Connect(source, transform);\r\n        builder.Connect(transform, sink);\r\n    }\r\n}\r\n\r\npublic class NotificationTransformTests\r\n{\r\n    [Fact]\r\n    public async Task Transform_Should_Call_Email_Service_For_Each_Item()\r\n    {\r\n        // Arrange\r\n        var mockEmailService = new Mock<IEmailService>();\r\n\r\n        var services = new ServiceCollection();\r\n        \r\n        // Approach 1: Assembly scanning (automatic discovery)\r\n        services.AddNPipeline(typeof(NotificationTransformTests).Assembly);\r\n\r\n        // Approach 2: Fluent configuration (explicit registration)\r\n        // services.AddNPipeline(builder => builder\r\n        //     .AddNode<InMemorySourceNode<string>>()\r\n        //     .AddNode<NotificationTransform>()\r\n        //     .AddNode<InMemorySinkNode<string>>()\r\n        //     .AddPipeline<NotificationPipeline>()\r\n        // );\r\n\r\n        // Register the mock service BEFORE building the provider\r\n        services.AddSingleton(mockEmailService.Object);\r\n\r\n        var serviceProvider = services.BuildServiceProvider();\r\n\r\n        var inputData = new[] { "item1", "item2" };\r\n        var context = new PipelineContext();\r\n        context.SetSourceData(inputData);\r\n\r\n        // Note: IPipelineRunner is registered by AddNPipeline() in the DI container\r\n        var runner = serviceProvider.GetRequiredService<IPipelineRunner>();\r\n\r\n        // Act\r\n        await runner.RunAsync<NotificationPipeline>(context);\r\n\r\n        // Assert\r\n        // Verify that the SendEmailAsync method was called twice\r\n        mockEmailService.Verify(\r\n            x => x.SendEmailAsync(\r\n                It.IsAny<string>(),\r\n                It.IsAny<string>(),\r\n                It.IsAny<string>()),\r\n            Times.Exactly(2));\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"In this test, we:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Create a mock ",(0,s.jsx)(n.code,{children:"IEmailService"})," using ",(0,s.jsx)(n.code,{children:"new Mock<IEmailService>()"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Register this mock service with the ",(0,s.jsx)(n.code,{children:"ServiceCollection"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Set up the test data in the ",(0,s.jsx)(n.code,{children:"PipelineContext"})," for the ",(0,s.jsx)(n.code,{children:"InMemorySourceNode"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["When the pipeline runs, the ",(0,s.jsx)(n.code,{children:"NotificationTransform"})," receives the mock service."]}),"\n",(0,s.jsxs)(n.li,{children:["Finally, we use Moq's verification API (",(0,s.jsx)(n.code,{children:"Verify()"}),") to confirm the service's method was called as expected."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"testing-error-handling",children:"Testing Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"Testing your pipeline's resilience is important. You should verify that your nodes handle errors gracefully."}),"\n",(0,s.jsx)(n.h3,{id:"example-testing-error-handling-in-a-transform",children:"Example: Testing Error Handling in a Transform"}),"\n",(0,s.jsx)(n.p,{children:"Let's test a transform that handles parsing errors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.Execution;\r\nusing NPipeline.Extensions.Testing;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\nusing Xunit;\r\n\r\npublic sealed class ParsingTransform : TransformNode<string, int>\r\n{\r\n    public override Task<int> ExecuteAsync(\r\n        string item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        if (!int.TryParse(item, out var result))\r\n        {\r\n            throw new FormatException($"Cannot parse \'{item}\' as an integer");\r\n        }\r\n        return Task.FromResult(result);\r\n    }\r\n}\r\n\r\npublic sealed class ParsingPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var source = builder.AddSource<InMemorySourceNode<string>, string>();\r\n        var transform = builder.AddTransform<ParsingTransform, string, int>();\r\n        var sink = builder.AddSink<InMemorySinkNode<int>, int>();\r\n\r\n        builder.Connect(source, transform);\r\n        builder.Connect(transform, sink);\r\n    }\r\n}\r\n\r\npublic class ParsingTransformTests\r\n{\r\n    [Fact]\r\n    public async Task Should_Throw_On_Invalid_Input()\r\n    {\r\n        // Arrange\r\n        var inputData = new[] { "1", "two", "3" };\r\n        var context = new PipelineContext();\r\n        context.SetSourceData(inputData);\r\n\r\n        var runner = PipelineRunner.Create();\r\n\r\n        // Act & Assert\r\n        var exception = await Assert.ThrowsAsync<FormatException>(\r\n            async () => await runner.RunAsync<ParsingPipeline>(context));\r\n\r\n        Assert.Contains("Cannot parse", exception.Message);\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-advanced-testing",children:"Best Practices for Advanced Testing"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Isolate What You're Testing:"})," Use mocks and fakes to ensure your test focuses on a single unit of logic (e.g., one node's ",(0,s.jsx)(n.code,{children:"ExecuteAsync"})," method)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Test Both Success and Failure:"})," Don't just test the happy path. Write tests for invalid input, exceptions, cancellations, and other failure modes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Use ",(0,s.jsx)(n.code,{children:"[Theory]"})," for Parameterized Tests:"]})," For nodes with complex conditional logic, use xUnit's ",(0,s.jsx)(n.code,{children:"[Theory]"})," attribute to test many different inputs and expected outputs concisely."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Keep Tests Fast:"})," Avoid ",(0,s.jsx)(n.code,{children:"Task.Delay"}),", network calls, or file system access in your unit tests. Rely on mocks to simulate these operations."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var r=i(6540);const s={},t=r.createContext(s);function o(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);