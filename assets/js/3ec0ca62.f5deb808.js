"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[4662],{28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var s=i(96540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}},73669:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"extensions/observability/index","title":"NPipeline Observability Extension","description":"Comprehensive metrics collection and monitoring for NPipeline pipelines.","source":"@site/docs/extensions/observability/index.md","sourceDirName":"extensions/observability","slug":"/extensions/observability/","permalink":"/docs/extensions/observability/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Testing Composite Pipelines","permalink":"/docs/extensions/composition/testing"},"next":{"title":"OpenTelemetry Integration","permalink":"/docs/extensions/observability/opentelemetry"}}');var r=i(74848),t=i(28453);const l={},o="NPipeline Observability Extension",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:3},{value:"Installation",id:"installation",level:2},{value:"Quick Start",id:"quick-start",level:2},{value:"Basic Setup with Default Logging",id:"basic-setup-with-default-logging",level:3},{value:"Complete Example",id:"complete-example",level:3},{value:"What Gets Logged",id:"what-gets-logged",level:3},{value:"Per-Node Configuration",id:"per-node-configuration",level:2},{value:"ObservabilityOptions Presets",id:"observabilityoptions-presets",level:3},{value:"Metrics Collected",id:"metrics-collected",level:2},{value:"Common Use Cases",id:"common-use-cases",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Minimal Overhead",id:"minimal-overhead",level:3},{value:"Memory Usage",id:"memory-usage",level:3},{value:"CPU Impact",id:"cpu-impact",level:3},{value:"Documentation",id:"documentation",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"npipeline-observability-extension",children:"NPipeline Observability Extension"})}),"\n",(0,r.jsx)(n.p,{children:"Comprehensive metrics collection and monitoring for NPipeline pipelines."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"NPipeline.Extensions.Observability"})," extension provides comprehensive observability capabilities for NPipeline pipelines, including metrics collection and distributed tracing. It enables detailed tracking of pipeline execution, node performance, throughput, resource utilization, and exception handling, making it easier to identify bottlenecks, optimize performance, and troubleshoot issues in production environments."]}),"\n",(0,r.jsx)(n.h3,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node-level metrics"}),": Track execution time, items processed/emitted, retries, memory usage, and processor time for each node"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pipeline-level metrics"}),": Aggregate metrics across all nodes, including total duration, throughput, and success/failure status"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Distributed tracing"}),": OpenTelemetry-compatible tracing through ",(0,r.jsx)(n.code,{children:"PipelineActivity"})," and ",(0,r.jsx)(n.code,{children:"System.Diagnostics.Activity"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-safe collection"}),": Metrics are collected safely across parallel and concurrent pipeline executions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexible sinks"}),": Built-in logging sinks with support for custom metrics sinks (e.g., Application Insights, Prometheus, OpenTelemetry)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dependency injection integration"}),": Seamlessly integrates with Microsoft.Extensions.DependencyInjection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Execution observer pattern"}),": Hooks into the pipeline execution lifecycle to capture metrics without modifying node logic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimal overhead"}),": < 1% typically, with lock-free concurrent operations and memory-efficient storage"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"dotnet add package NPipeline.Extensions.Observability\n"})}),"\n",(0,r.jsx)(n.p,{children:"The extension requires:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"NPipeline"})," (core package)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Microsoft.Extensions.DependencyInjection.Abstractions"})," (10.0.1 or later)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Microsoft.Extensions.Logging.Abstractions"})," (10.0.1 or later)"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,r.jsx)(n.h3,{id:"basic-setup-with-default-logging",children:"Basic Setup with Default Logging"}),"\n",(0,r.jsxs)(n.p,{children:["The simplest way to enable observability is to use the ",(0,r.jsx)(n.code,{children:"IObservablePipelineContextFactory"}),", which automatically configures metrics collection:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"using Microsoft.Extensions.DependencyInjection;\nusing NPipeline.Observability.DependencyInjection;\nusing NPipeline.Extensions.DependencyInjection;\n\nvar services = new ServiceCollection();\n\n// Add observability with default logging sinks\nservices.AddNPipelineObservability();\n\n// Add NPipeline core services\nservices.AddNPipeline(Assembly.GetExecutingAssembly());\n\nvar serviceProvider = services.BuildServiceProvider();\n\n// Run your pipeline - metrics will be automatically collected and logged\nawait using var scope = serviceProvider.CreateAsyncScope();\nvar runner = scope.ServiceProvider.GetRequiredService<IPipelineRunner>();\nvar contextFactory = scope.ServiceProvider.GetRequiredService<IObservablePipelineContextFactory>();\nawait using var context = contextFactory.Create();\nawait runner.RunAsync<MyPipelineDefinition>(context);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"complete-example",children:"Complete Example"}),"\n",(0,r.jsx)(n.p,{children:"Here's a fully working example with a pipeline definition and nodes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'using Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing NPipeline.DataFlow;\nusing NPipeline.DataFlow.DataPipes;\nusing NPipeline.Nodes;\nusing NPipeline.Observability.DependencyInjection;\nusing NPipeline.Extensions.DependencyInjection;\nusing NPipeline.Pipeline;\n\npublic class NumberPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<NumberSource, int>();\n        var transform = builder.AddTransform<DoubleTransform, int, int>();\n        var sink = builder.AddSink<NumberSink, int>();\n\n        builder.Connect(source, transform);\n        builder.Connect(transform, sink);\n    }\n}\n\npublic sealed class NumberSource : SourceNode<int>\n{\n    public IDataPipe<int> ExecuteAsync(PipelineContext context, CancellationToken cancellationToken = default)\n    {\n        static async IAsyncEnumerable<int> Generate()\n        {\n            for (int i = 1; i <= 100; i++)\n            {\n                yield return i;\n            }\n        }\n\n        return new StreamingDataPipe<int>(Generate());\n    }\n}\n\npublic sealed class DoubleTransform : TransformNode<int, int>\n{\n    public override Task<int> ExecuteAsync(int item, PipelineContext context, CancellationToken cancellationToken = default)\n    {\n        return Task.FromResult(item * 2);\n    }\n}\n\npublic sealed class NumberSink : SinkNode<int>\n{\n    public async Task ExecuteAsync(IDataPipe<int> input, PipelineContext context, IPipelineActivity parentActivity, CancellationToken cancellationToken = default)\n    {\n        await foreach (var item in input.WithCancellation(cancellationToken))\n        {\n            Console.WriteLine($"Result: {item}");\n        }\n    }\n}\n\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var host = Host.CreateDefaultBuilder()\n            .ConfigureServices((context, services) =>\n            {\n                services.AddLogging(loggingBuilder => loggingBuilder.AddConsole());\n                services.AddNPipeline(typeof(Program).Assembly);\n                services.AddNPipelineObservability();\n            })\n            .Build();\n\n        await using var scope = host.Services.CreateAsyncScope();\n        var runner = scope.ServiceProvider.GetRequiredService<IPipelineRunner>();\n        var contextFactory = scope.ServiceProvider.GetRequiredService<IObservablePipelineContextFactory>();\n        var collector = scope.ServiceProvider.GetRequiredService<IObservabilityCollector>();\n\n        // Create context with automatic observability\n        await using var pipelineContext = contextFactory.Create();\n\n        // Run pipeline\n        await runner.RunAsync<NumberPipeline>(pipelineContext);\n\n        // Display metrics\n        foreach (var metric in collector.GetNodeMetrics())\n        {\n            Console.WriteLine($"\\nNode: {metric.NodeId}");\n            Console.WriteLine($"  Duration: {metric.DurationMs}ms");\n            Console.WriteLine($"  Success: {metric.Success}");\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"what-gets-logged",children:"What Gets Logged"}),"\n",(0,r.jsx)(n.p,{children:"With the default configuration, you'll see structured logs like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-log",children:"[Information] Pipeline MyPipeline (RunId: 123e4567-e89b-12d3-a456-426614174000) completed successfully. Processed 1000 items in 2500ms\n[Information]   Node TransformNode: Processed 1000 items, emitted 950 items in 1200ms\n[Information]   Node FilterNode: Processed 950 items, emitted 800 items in 800ms\n[Information]   Node SinkNode: Processed 800 items, emitted 800 items in 500ms\n[Information] Overall pipeline throughput: 400.00 items/sec\n"})}),"\n",(0,r.jsx)(n.h2,{id:"per-node-configuration",children:"Per-Node Configuration"}),"\n",(0,r.jsx)(n.p,{children:"You can customize observability settings for individual nodes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"using NPipeline.Observability;\nusing NPipeline.Observability.Configuration;\n\npublic class MyPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<MySource, int>();\n        \n        // Configure with default options\n        var transform = builder.AddTransform<MyTransform, int, string>()\n            .WithObservability(builder);\n        \n        // Configure with full options (includes memory tracking)\n        var sink = builder.AddSink<MySink, string>()\n            .WithObservability(builder, ObservabilityOptions.Full);\n        \n        builder.Connect(source, transform);\n        builder.Connect(transform, sink);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"observabilityoptions-presets",children:"ObservabilityOptions Presets"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Preset"}),(0,r.jsx)(n.th,{children:"Timing"}),(0,r.jsx)(n.th,{children:"Item Counts"}),(0,r.jsx)(n.th,{children:"Memory"}),(0,r.jsx)(n.th,{children:"Thread Info"}),(0,r.jsx)(n.th,{children:"Performance"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Default"})}),(0,r.jsx)(n.td,{children:"\u2713"}),(0,r.jsx)(n.td,{children:"\u2713"}),(0,r.jsx)(n.td,{children:"\u2717"}),(0,r.jsx)(n.td,{children:"\u2713"}),(0,r.jsx)(n.td,{children:"\u2713"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Full"})}),(0,r.jsx)(n.td,{children:"\u2713"}),(0,r.jsx)(n.td,{children:"\u2713"}),(0,r.jsx)(n.td,{children:"\u2713"}),(0,r.jsx)(n.td,{children:"\u2713"}),(0,r.jsx)(n.td,{children:"\u2713"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Minimal"})}),(0,r.jsx)(n.td,{children:"\u2713"}),(0,r.jsx)(n.td,{children:"\u2717"}),(0,r.jsx)(n.td,{children:"\u2717"}),(0,r.jsx)(n.td,{children:"\u2717"}),(0,r.jsx)(n.td,{children:"\u2717"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Disabled"})}),(0,r.jsx)(n.td,{children:"\u2717"}),(0,r.jsx)(n.td,{children:"\u2717"}),(0,r.jsx)(n.td,{children:"\u2717"}),(0,r.jsx)(n.td,{children:"\u2717"}),(0,r.jsx)(n.td,{children:"\u2717"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note on Memory Metrics"}),": Memory metrics require both:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Extension-level configuration: ",(0,r.jsx)(n.code,{children:"services.AddNPipelineObservability(ObservabilityExtensionOptions.WithMemoryMetrics)"})]}),"\n",(0,r.jsxs)(n.li,{children:["Node-level configuration: ",(0,r.jsx)(n.code,{children:".WithObservability(builder, ObservabilityOptions.Full)"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"metrics-collected",children:"Metrics Collected"}),"\n",(0,r.jsx)(n.p,{children:"When observability is enabled, the following metrics are automatically collected:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Node Metrics"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Execution timing (start, end, duration)"}),"\n",(0,r.jsx)(n.li,{children:"Items processed and emitted"}),"\n",(0,r.jsx)(n.li,{children:"Success/failure status"}),"\n",(0,r.jsx)(n.li,{children:"Retry attempts"}),"\n",(0,r.jsx)(n.li,{children:"Throughput (items per second)"}),"\n",(0,r.jsx)(n.li,{children:"Average processing time per item"}),"\n",(0,r.jsx)(n.li,{children:"Thread ID (if enabled)"}),"\n",(0,r.jsx)(n.li,{children:"Memory usage delta (if enabled)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pipeline Metrics"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Total execution time"}),"\n",(0,r.jsx)(n.li,{children:"Overall success/failure status"}),"\n",(0,r.jsx)(n.li,{children:"Total items processed across all nodes"}),"\n",(0,r.jsx)(n.li,{children:"Individual node metrics"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance Monitoring"})," - Track execution time and throughput"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Tracking"})," - Monitor failures and retry patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resource Usage"})," - Track memory and CPU consumption"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Capacity Planning"})," - Analyze historical performance data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debugging"})," - Identify bottlenecks and optimization opportunities"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SLA Compliance"})," - Ensure pipelines meet performance requirements"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Alerting"})," - Integrate with monitoring systems for real-time alerts"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Pipeline Execution              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u251c\u2500> IExecutionObserver\n               \u2502   (MetricsCollectingExecutionObserver)\n               \u2502\n               \u2193\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 IObservabilityCollector \u2502\n        \u2502  (Thread-safe)          \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n                   \u251c\u2500> Node Metrics\n                   \u2514\u2500> Pipeline Metrics\n                   \u2502\n                   \u2193\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502   IMetricsSink       \u2502\n        \u2502 IPipelineMetricsSink \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n                   \u251c\u2500> Logging\n                   \u251c\u2500> Prometheus\n                   \u251c\u2500> App Insights\n                   \u2514\u2500> Custom Sinks\n"})}),"\n",(0,r.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,r.jsx)(n.h3,{id:"minimal-overhead",children:"Minimal Overhead"}),"\n",(0,r.jsx)(n.p,{children:"The extension is designed for production use with minimal performance impact:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Non-blocking metrics collection"}),": Metrics are recorded asynchronously without blocking pipeline execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Efficient data structures"}),": Uses optimized collections for metrics aggregation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optional observability"}),": Can be disabled entirely by not registering the services"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scoped lifetime"}),": Metrics are isolated per pipeline run, preventing memory leaks"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Per-pipeline overhead"}),": Approximately 1-2 KB per node for metrics storage"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transient sinks"}),": Metrics sinks are created per pipeline run and disposed after use"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No persistent storage"}),": Metrics are not retained in memory beyond the pipeline execution"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"cpu-impact",children:"CPU Impact"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lightweight timing"}),": Uses high-resolution timers with minimal CPU overhead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optional performance counters"}),": Memory and processor time collection can be disabled if not needed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Batch-friendly"}),": Metrics collection scales efficiently with large batch sizes"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"documentation",children:"Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/extensions/observability/configuration",children:"Configuration Guide"})})," - DI setup, custom sinks, and advanced registration options"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/extensions/observability/advanced-patterns",children:"Advanced Patterns"})})," - Advanced scenarios like pre-aggregation, rate-limiting, and circuit breakers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/extensions/observability/metrics",children:"Metrics Reference"})})," - Complete metrics documentation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/extensions/observability/examples",children:"Examples"})})," - Real-world usage examples and common patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/extensions/observability/tracing",children:"Distributed Tracing"})})," - Core tracing abstraction and building custom tracers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/extensions/observability/opentelemetry",children:"OpenTelemetry Integration"})})," - Production-grade tracing with OpenTelemetry backends"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);