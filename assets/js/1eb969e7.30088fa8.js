"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[4165],{28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>o});var i=r(96540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}},54799:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"architecture/execution-flow","title":"Execution Flow","description":"Understanding how NPipeline executes pipelines - sequential and parallel execution patterns.","source":"@site/docs/architecture/execution-flow.md","sourceDirName":"architecture","slug":"/architecture/execution-flow","permalink":"/docs/architecture/execution-flow","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Execution Flow","description":"Understanding how NPipeline executes pipelines - sequential and parallel execution patterns.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Component Architecture","permalink":"/docs/architecture/component-architecture"},"next":{"title":"Data Flow Details","permalink":"/docs/architecture/data-flow"}}');var s=r(74848),t=r(28453);const l={title:"Execution Flow",description:"Understanding how NPipeline executes pipelines - sequential and parallel execution patterns.",sidebar_position:3},o="Execution Flow",c={},a=[{value:"Core Design: Source Initialization + Asynchronous Execution",id:"core-design-source-initialization--asynchronous-execution",level:2},{value:"Sequential Execution (Default)",id:"sequential-execution-default",level:2},{value:"Parallel Execution",id:"parallel-execution",level:2},{value:"Hybrid Approaches",id:"hybrid-approaches",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Context Immutability During Execution",id:"context-immutability-during-execution",level:2},{value:"What Must Remain Immutable",id:"what-must-remain-immutable",level:3},{value:"Why This Matters",id:"why-this-matters",level:3},{value:"When You Can Safely Modify Context",id:"when-you-can-safely-modify-context",level:3},{value:"DEBUG Validation",id:"debug-validation",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"execution-flow",children:"Execution Flow"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"This page explains WHAT happens during pipeline execution."})," For HOW TO configure execution strategies, see ",(0,s.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution/execution-strategies",children:"Execution Strategies"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"NPipeline supports multiple execution models to handle different requirements: sequential (the default) and parallel execution through extensions."}),"\n",(0,s.jsx)(n.h2,{id:"core-design-source-initialization--asynchronous-execution",children:"Core Design: Source Initialization + Asynchronous Execution"}),"\n",(0,s.jsx)(n.p,{children:"NPipeline follows a clear separation of concerns:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Synchronous Phase:"})," Source Node Initialization"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Source nodes' ",(0,s.jsx)(n.code,{children:"Initialize()"})," method returns ",(0,s.jsx)(n.code,{children:"IDataPipe<T>"})," synchronously"]}),"\n",(0,s.jsx)(n.li,{children:"The source immediately creates and returns the data pipe without waiting"}),"\n",(0,s.jsx)(n.li,{children:"No Task allocation for source execution"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Asynchronous Phase:"})," Transform & Sink Execution"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Transform nodes' ",(0,s.jsx)(n.code,{children:"ExecuteAsync()"})," method returns ",(0,s.jsx)(n.code,{children:"Task<TOut>"})," asynchronously"]}),"\n",(0,s.jsxs)(n.li,{children:["Sink nodes' ",(0,s.jsx)(n.code,{children:"ExecuteAsync()"})," method returns ",(0,s.jsx)(n.code,{children:"Task"})," asynchronously"]}),"\n",(0,s.jsx)(n.li,{children:"Data flows through pipes when nodes consume it"}),"\n",(0,s.jsxs)(n.li,{children:["Sinks iterate through pipes with ",(0,s.jsx)(n.code,{children:"await foreach"})]}),"\n",(0,s.jsx)(n.li,{children:"Transforms process items as they arrive"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"\ud83d\udca1 Key Insight"})}),"\n",(0,s.jsx)(n.p,{children:"This design provides:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clear execution boundaries:"})," Source setup is fast; transforms and sinks handle async work"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Predictable performance:"})," No hidden delays during source initialization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type safety:"})," Synchronous source returns enable better variance and lazy evaluation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory efficiency:"})," No unnecessary Task allocations for data production"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"sequential-execution-default",children:"Sequential Execution (Default)"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Data Flow Pattern:"})}),"\n",(0,s.jsx)(n.mermaid,{value:'graph TD\r\n    A["Source: Produces item 1"] --\x3e B["Transform 1: Processes item 1"]\r\n    B --\x3e C["Transform 2: Processes item 1"]\r\n    C --\x3e D["Sink: Consumes item 1"]\r\n    D --\x3e E["Source: Produces item 2"]\r\n    E --\x3e F["Transform 1: Processes item 2"]\r\n    F --\x3e G["Transform 2: Processes item 2"]\r\n    G --\x3e H["Sink: Consumes item 2"]\r\n    H --\x3e I["... repeat for remaining items"]\r\n    \r\n    style A fill:#c8e6c9\r\n    style B fill:#bbdefb\r\n    style C fill:#bbdefb\r\n    style D fill:#ffe0b2\r\n    style E fill:#c8e6c9\r\n    style F fill:#bbdefb\r\n    style G fill:#bbdefb\r\n    style H fill:#ffe0b2'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Characteristics:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Items flow one-at-a-time through the pipeline"}),"\n",(0,s.jsx)(n.li,{children:"Order is preserved"}),"\n",(0,s.jsx)(n.li,{children:"Minimal concurrency overhead"}),"\n",(0,s.jsx)(n.li,{children:"Predictable memory usage"}),"\n",(0,s.jsx)(n.li,{children:"Deterministic behavior"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Optimizations:"})}),"\n",(0,s.jsxs)(n.p,{children:["The sequential strategy automatically detects and uses ",(0,s.jsx)(n.code,{children:"ExecuteValueTaskAsync"})," when available on transform nodes. This avoids Task allocation overhead for synchronous operations, improving throughput for pipelines dominated by fast, synchronous transforms. See ",(0,s.jsx)(n.a,{href:"/docs/advanced-topics/synchronous-fast-paths",children:"Synchronous Fast Paths"})," for details."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"\ud83d\ude80 Performance Tip"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"ExecuteValueTaskAsync"})," in your transform nodes for CPU-bound operations to eliminate Task allocation overhead in sequential pipelines."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Default for most pipelines"}),"\n",(0,s.jsx)(n.li,{children:"When order preservation is critical"}),"\n",(0,s.jsx)(n.li,{children:"When external systems require sequential processing"}),"\n",(0,s.jsx)(n.li,{children:"When debugging is important (deterministic behavior)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class SequentialPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var source = builder.AddSource<OrderSource, Order>();\r\n        var validator = builder.AddTransform<OrderValidator, Order, ValidatedOrder>();\r\n        var enricher = builder.AddTransform<OrderEnricher, ValidatedOrder, EnrichedOrder>();\r\n        var sink = builder.AddSink<OrderSink, EnrichedOrder>();\r\n\r\n        builder.Connect(source, validator);\r\n        builder.Connect(validator, enricher);\r\n        builder.Connect(enricher, sink);\r\n        \r\n        // Sequential execution - default behavior\r\n        // Each item flows one at a time through the pipeline\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"parallel-execution",children:"Parallel Execution"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Data Flow Pattern:"})}),"\n",(0,s.jsx)(n.mermaid,{value:'graph TD\r\n    A["Source: Produces<br/>items 1, 2, 3, 4"]\r\n    A --\x3e B1["Transform 1: Item 1<br/>(concurrent)"]\r\n    A --\x3e B2["Transform 1: Item 2<br/>(concurrent)"]\r\n    A --\x3e B3["Transform 1: Item 3<br/>(concurrent)"]\r\n    A --\x3e B4["Transform 1: Item 4<br/>(concurrent)"]\r\n    B1 --\x3e C1["Transform 2: Item 1<br/>(concurrent)"]\r\n    B2 --\x3e C2["Transform 2: Item 2<br/>(concurrent)"]\r\n    B3 --\x3e C3["Transform 2: Item 3<br/>(concurrent)"]\r\n    B4 --\x3e C4["Transform 2: Item 4<br/>(concurrent)"]\r\n    C1 --\x3e D["Sink: Consumes items<br/>(possibly out of order)"]\r\n    C2 --\x3e D\r\n    C3 --\x3e D\r\n    C4 --\x3e D\r\n    \r\n    style A fill:#c8e6c9\r\n    style B1 fill:#bbdefb\r\n    style B2 fill:#bbdefb\r\n    style B3 fill:#bbdefb\r\n    style B4 fill:#bbdefb\r\n    style C1 fill:#bbdefb\r\n    style C2 fill:#bbdefb\r\n    style C3 fill:#bbdefb\r\n    style C4 fill:#bbdefb\r\n    style D fill:#ffe0b2'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Characteristics:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Multiple items processed simultaneously"}),"\n",(0,s.jsx)(n.li,{children:"Order may not be preserved"}),"\n",(0,s.jsx)(n.li,{children:"Better CPU utilization on multi-core systems"}),"\n",(0,s.jsx)(n.li,{children:"Increased memory usage"}),"\n",(0,s.jsx)(n.li,{children:"Better throughput for CPU-bound work"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"CPU-bound transforms (calculations, complex logic)"}),"\n",(0,s.jsx)(n.li,{children:"Multi-core systems available"}),"\n",(0,s.jsx)(n.li,{children:"Order doesn't matter or can be sorted later"}),"\n",(0,s.jsx)(n.li,{children:"High throughput is a priority"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,s.jsxs)(n.p,{children:["Requires ",(0,s.jsx)(n.code,{children:"NPipeline.Extensions.Parallelism"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using NPipeline.Extensions.Parallelism;\r\n\r\npublic class ParallelPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var source = builder.AddSource<DataSource, DataItem>();\r\n        var transform = builder.AddTransform<ComplexTransform, DataItem, ProcessedItem>();\r\n        var sink = builder.AddSink<ResultSink, ProcessedItem>();\r\n\r\n        builder.Connect(source, transform);\r\n        builder.Connect(transform, sink);\r\n\r\n        // Configure parallel execution\r\n        builder.WithParallelOptions(\r\n            transform,\r\n            new ParallelOptions { MaxDegreeOfParallelism = 4 }\r\n        );\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Degree of Parallelism:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"Environment.ProcessorCount"})," for CPU-bound work"]}),"\n",(0,s.jsx)(n.li,{children:"Use smaller values (2-4) for I/O-bound work"}),"\n",(0,s.jsx)(n.li,{children:"Start conservative and measure performance"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"hybrid-approaches",children:"Hybrid Approaches"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Sequential Source \u2192 Parallel Transform \u2192 Sequential Sink:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class HybridPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var source = builder.AddSource<MySource, Data>();\r\n        var transform = builder.AddTransform<MyTransform, Data, Result>();\r\n        var sink = builder.AddSink<MySink, Result>();\r\n\r\n        builder.Connect(source, transform);\r\n        builder.Connect(transform, sink);\r\n\r\n        // Only the transform runs in parallel\r\n        builder.WithParallelism(transform, degree: 4);\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This approach:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Produces data sequentially"}),"\n",(0,s.jsx)(n.li,{children:"Processes items in parallel"}),"\n",(0,s.jsx)(n.li,{children:"Consumes results (possibly buffering to maintain order)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Execution Model"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Throughput"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Memory"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Complexity"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Best For"})})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Sequential"}),(0,s.jsx)(n.td,{children:"Low-Medium"}),(0,s.jsx)(n.td,{children:"\u2705 Low"}),(0,s.jsx)(n.td,{children:"\u2705 Low"}),(0,s.jsx)(n.td,{children:"Default, debugging, order-critical"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Parallel"}),(0,s.jsx)(n.td,{children:"\u2b50 High"}),(0,s.jsx)(n.td,{children:"Medium-High"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"CPU-bound, high throughput"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Hybrid"}),(0,s.jsx)(n.td,{children:"Medium-High"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"Mixed workloads"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Table: Execution Model Comparison"})}),"\n",(0,s.jsx)(n.h2,{id:"context-immutability-during-execution",children:"Context Immutability During Execution"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"\u26a0\ufe0f Important for Performance-Critical Applications"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["When using ",(0,s.jsx)(n.code,{children:"CachedNodeExecutionContext"})," (which all execution strategies do automatically), the framework assumes that certain context state remains immutable during node execution."]}),"\n",(0,s.jsx)(n.h3,{id:"what-must-remain-immutable",children:"What Must Remain Immutable"}),"\n",(0,s.jsx)(n.p,{children:"During the execution of a single node (from start to completion of all items), these context properties must not change:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Retry Options"})," - Changes to ",(0,s.jsx)(n.code,{children:"context.Items[PipelineContextKeys.NodeRetryOptions(...)]"})," or global retry options"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tracer Instance"})," - Replacing ",(0,s.jsx)(n.code,{children:"context.Tracer"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Logger Factory Instance"})," - Replacing ",(0,s.jsx)(n.code,{children:"context.LoggerFactory"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cancellation Token"})," - Replacing ",(0,s.jsx)(n.code,{children:"context.CancellationToken"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"why-this-matters",children:"Why This Matters"}),"\n",(0,s.jsx)(n.p,{children:"The framework caches these values at the start of node execution to avoid dictionary lookups for every item. Mutations during execution break this assumption and can cause:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Inconsistent behavior (some items use old values, others use new values)"}),"\n",(0,s.jsx)(n.li,{children:"Unpredictable retry behavior (items may be retried differently)"}),"\n",(0,s.jsx)(n.li,{children:"Tracing/logging inconsistencies"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"when-you-can-safely-modify-context",children:"When You Can Safely Modify Context"}),"\n",(0,s.jsxs)(n.p,{children:["Context state can be modified ",(0,s.jsx)(n.strong,{children:"between node executions"}),", such as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// \u2705 Safe: Modify context before node execution starts\r\ncontext.Items[PipelineContextKeys.NodeRetryOptions(nodeId)] = newRetryOptions;\r\nvar result = await nodeExecutor.ExecuteAsync(node, item, context);\r\n\r\n// \u274c Don't: Modify context during node execution\r\npublic async Task<TOut> ExecuteAsync(TIn item, PipelineContext context, CancellationToken ct)\r\n{\r\n    // Don't do this - it may be cached and ignored!\r\n    context.Items[PipelineContextKeys.NodeRetryOptions(this.NodeId)] = newRetryOptions;\r\n    // ... rest of node execution\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"debug-validation",children:"DEBUG Validation"}),"\n",(0,s.jsx)(n.p,{children:"In DEBUG builds, NPipeline automatically detects context mutations and throws a clear exception:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"InvalidOperationException: Context immutability violation detected for node 'myNode': \r\nRetry options were modified during node execution. When using CachedNodeExecutionContext, \r\ncontext state must remain immutable during node execution.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This validation is ",(0,s.jsx)(n.strong,{children:"compiled out in RELEASE builds"})," (zero overhead)."]}),"\n",(0,s.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configure context before execution"})," - Set all retry options, tracers, and loggers before starting pipeline execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Don't modify tracer/logger during execution"})," - These should be configured upfront"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Trust the caching"})," - The framework optimizes context access automatically; don't bypass it"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For more guidance, see ",(0,s.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene#avoid-context-mutations-during-node-execution",children:"Performance Hygiene: Avoid Context Mutations"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/architecture/data-flow",children:"Data Flow Details"})})," - Understand how data pipes and lazy evaluation work"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/architecture/performance-characteristics",children:"Performance Characteristics"})})," - Learn about throughput and scalability"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);