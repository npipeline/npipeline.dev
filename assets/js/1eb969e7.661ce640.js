"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[4165],{4799:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"architecture/execution-flow","title":"Execution Flow","description":"Understanding how NPipeline executes pipelines - sequential and parallel execution patterns.","source":"@site/docs/architecture/execution-flow.md","sourceDirName":"architecture","slug":"/architecture/execution-flow","permalink":"/docs/architecture/execution-flow","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Execution Flow","description":"Understanding how NPipeline executes pipelines - sequential and parallel execution patterns.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Component Architecture","permalink":"/docs/architecture/component-architecture"},"next":{"title":"Data Flow Details","permalink":"/docs/architecture/data-flow"}}');var s=r(4848),l=r(8453);const t={title:"Execution Flow",description:"Understanding how NPipeline executes pipelines - sequential and parallel execution patterns.",sidebar_position:3},o="Execution Flow",c={},a=[{value:"Core Design: Synchronous Setup + Asynchronous Execution",id:"core-design-synchronous-setup--asynchronous-execution",level:2},{value:"Sequential Execution (Default)",id:"sequential-execution-default",level:2},{value:"Parallel Execution",id:"parallel-execution",level:2},{value:"Hybrid Approaches",id:"hybrid-approaches",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"\u27a1\ufe0f Next Steps",id:"arrow_right-next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"execution-flow",children:"Execution Flow"})}),"\n",(0,s.jsx)(n.p,{children:"NPipeline supports multiple execution models to handle different requirements: sequential (the default) and parallel execution through extensions."}),"\n",(0,s.jsx)(n.h2,{id:"core-design-synchronous-setup--asynchronous-execution",children:"Core Design: Synchronous Setup + Asynchronous Execution"}),"\n",(0,s.jsx)(n.p,{children:"NPipeline follows a clear separation of concerns:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Synchronous Phase:"})," Pipeline Initialization"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["All nodes' ",(0,s.jsx)(n.code,{children:"ExecuteAsync"})," methods return synchronously"]}),"\n",(0,s.jsxs)(n.li,{children:["Source nodes immediately return ",(0,s.jsx)(n.code,{children:"IDataPipe<T>"})," objects"]}),"\n",(0,s.jsx)(n.li,{children:"Transform nodes return immediately with their execution strategies"}),"\n",(0,s.jsx)(n.li,{children:"No waiting for actual data flow"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Asynchronous Phase:"})," Data Flow"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Data moves through pipes when nodes consume it"}),"\n",(0,s.jsxs)(n.li,{children:["Sinks iterate through pipes with ",(0,s.jsx)(n.code,{children:"await foreach"})]}),"\n",(0,s.jsx)(n.li,{children:"Transforms process items as they arrive"}),"\n",(0,s.jsx)(n.li,{children:"All async work happens during consumption, not setup"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This design provides:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Clear execution boundaries:"})," Setup is fast; data flow is async"]}),"\n",(0,s.jsxs)(n.li,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Predictable performance:"})," No hidden delays during initialization"]}),"\n",(0,s.jsxs)(n.li,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Type safety:"})," Synchronous returns enable better variance"]}),"\n",(0,s.jsxs)(n.li,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Memory efficiency:"})," No unnecessary Task allocations"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"sequential-execution-default",children:"Sequential Execution (Default)"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Data Flow Pattern:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"Source produces item 1\r\n    \u2193\r\nTransform 1 processes item 1\r\n    \u2193\r\nTransform 2 processes item 1\r\n    \u2193\r\nSink consumes item 1\r\n    \u2193\r\nSource produces item 2\r\n    \u2193\r\nTransform 1 processes item 2\r\n    \u2193\r\n... (repeat)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Characteristics:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Items flow one-at-a-time through the pipeline"}),"\n",(0,s.jsx)(n.li,{children:"Order is preserved"}),"\n",(0,s.jsx)(n.li,{children:"Minimal concurrency overhead"}),"\n",(0,s.jsx)(n.li,{children:"Predictable memory usage"}),"\n",(0,s.jsx)(n.li,{children:"Deterministic behavior"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Optimizations:"})}),"\n",(0,s.jsxs)(n.p,{children:["The sequential strategy automatically detects and uses ",(0,s.jsx)(n.code,{children:"ExecuteValueTaskAsync"})," when available on transform nodes. This avoids Task allocation overhead for synchronous operations, improving throughput for pipelines dominated by fast, synchronous transforms. See ",(0,s.jsx)(n.a,{href:"/docs/core-concepts/advanced-nodes/valuetask-transforms",children:"ValueTask Transforms"})," for details."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Default for most pipelines"}),"\n",(0,s.jsx)(n.li,{children:"When order preservation is critical"}),"\n",(0,s.jsx)(n.li,{children:"When external systems require sequential processing"}),"\n",(0,s.jsx)(n.li,{children:"When debugging is important (deterministic behavior)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class SequentialPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var source = builder.AddSource<OrderSource, Order>();\r\n        var validator = builder.AddTransform<OrderValidator, Order, ValidatedOrder>();\r\n        var enricher = builder.AddTransform<OrderEnricher, ValidatedOrder, EnrichedOrder>();\r\n        var sink = builder.AddSink<OrderSink, EnrichedOrder>();\r\n\r\n        builder.Connect(source, validator);\r\n        builder.Connect(validator, enricher);\r\n        builder.Connect(enricher, sink);\r\n        \r\n        // Sequential execution - default behavior\r\n        // Each item flows one at a time through the pipeline\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"parallel-execution",children:"Parallel Execution"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Data Flow Pattern:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"Source produces items 1, 2, 3, 4\r\n    \u2193\r\n[Parallel Processing - Multiple items in flight]\r\nTransform 1 processes items in parallel\r\n    \u2193\r\nTransform 2 processes items in parallel\r\n    \u2193\r\nSink consumes items (possibly out of order)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Characteristics:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Multiple items processed simultaneously"}),"\n",(0,s.jsx)(n.li,{children:"Order may not be preserved"}),"\n",(0,s.jsx)(n.li,{children:"Better CPU utilization on multi-core systems"}),"\n",(0,s.jsx)(n.li,{children:"Increased memory usage"}),"\n",(0,s.jsx)(n.li,{children:"Better throughput for CPU-bound work"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"CPU-bound transforms (calculations, complex logic)"}),"\n",(0,s.jsx)(n.li,{children:"Multi-core systems available"}),"\n",(0,s.jsx)(n.li,{children:"Order doesn't matter or can be sorted later"}),"\n",(0,s.jsx)(n.li,{children:"High throughput is a priority"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,s.jsxs)(n.p,{children:["Requires ",(0,s.jsx)(n.code,{children:"NPipeline.Extensions.Parallelism"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using NPipeline.Extensions.Parallelism;\r\n\r\npublic class ParallelPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var source = builder.AddSource<DataSource, DataItem>();\r\n        var transform = builder.AddTransform<ComplexTransform, DataItem, ProcessedItem>();\r\n        var sink = builder.AddSink<ResultSink, ProcessedItem>();\r\n\r\n        builder.Connect(source, transform);\r\n        builder.Connect(transform, sink);\r\n\r\n        // Configure parallel execution\r\n        builder.WithParallelOptions(\r\n            transform,\r\n            new ParallelOptions { MaxDegreeOfParallelism = 4 }\r\n        );\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Degree of Parallelism:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"Environment.ProcessorCount"})," for CPU-bound work"]}),"\n",(0,s.jsx)(n.li,{children:"Use smaller values (2-4) for I/O-bound work"}),"\n",(0,s.jsx)(n.li,{children:"Start conservative and measure performance"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"hybrid-approaches",children:"Hybrid Approaches"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Sequential Source \u2192 Parallel Transform \u2192 Sequential Sink:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class HybridPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var source = builder.AddSource<MySource, Data>();\r\n        var transform = builder.AddTransform<MyTransform, Data, Result>();\r\n        var sink = builder.AddSink<MySink, Result>();\r\n\r\n        builder.Connect(source, transform);\r\n        builder.Connect(transform, sink);\r\n\r\n        // Only the transform runs in parallel\r\n        builder.WithParallelism(transform, degree: 4);\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This approach:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Produces data sequentially"}),"\n",(0,s.jsx)(n.li,{children:"Processes items in parallel"}),"\n",(0,s.jsx)(n.li,{children:"Consumes results (possibly buffering to maintain order)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Execution Model"}),(0,s.jsx)(n.th,{children:"Throughput"}),(0,s.jsx)(n.th,{children:"Memory"}),(0,s.jsx)(n.th,{children:"Complexity"}),(0,s.jsx)(n.th,{children:"Best For"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Sequential"})}),(0,s.jsx)(n.td,{children:"Low-Medium"}),(0,s.jsx)(n.td,{children:"Low"}),(0,s.jsx)(n.td,{children:"Low"}),(0,s.jsx)(n.td,{children:"Default, debugging, order-critical"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Parallel"})}),(0,s.jsx)(n.td,{children:"High"}),(0,s.jsx)(n.td,{children:"Medium-High"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"CPU-bound, high throughput"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Hybrid"})}),(0,s.jsx)(n.td,{children:"Medium-High"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"Mixed workloads"})]})]})]}),"\n",(0,s.jsxs)(n.h2,{id:"arrow_right-next-steps",children:["\u27a1\ufe0f"," Next Steps"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/architecture/data-flow",children:"Data Flow Details"})})," - Understand how data pipes and lazy evaluation work"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/architecture/performance-characteristics",children:"Performance Characteristics"})})," - Learn about throughput and scalability"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>o});var i=r(6540);const s={},l=i.createContext(s);function t(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);