"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3140],{28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var i=r(96540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}},66077:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"core-concepts/resilience/retry-delays","title":"Retry Delays","description":"Choose and configure retry delay strategies in NPipeline to handle transient failures gracefully","source":"@site/docs/core-concepts/resilience/retry-delays.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/retry-delays","permalink":"/docs/core-concepts/resilience/retry-delays","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"Retry Delays","description":"Choose and configure retry delay strategies in NPipeline to handle transient failures gracefully","sidebar_position":8},"sidebar":"docsSidebar","previous":{"title":"Retry Configuration","permalink":"/docs/core-concepts/resilience/retries"},"next":{"title":"Exponential Backoff","permalink":"/docs/core-concepts/resilience/retry-delay-exponential"}}');var s=r(74848),t=r(28453);const l={title:"Retry Delays",description:"Choose and configure retry delay strategies in NPipeline to handle transient failures gracefully",sidebar_position:8},a="Retry Delays",c={},o=[{value:"Quick Start: Common Retry Patterns",id:"quick-start-common-retry-patterns",level:2},{value:"Web API Calls (Most Common)",id:"web-api-calls-most-common",level:3},{value:"Database Operations",id:"database-operations",level:3},{value:"File Processing",id:"file-processing",level:3},{value:"Decision Flow for Choosing Retry Strategy",id:"decision-flow-for-choosing-retry-strategy",level:2},{value:"Basic Implementation",id:"basic-implementation",level:2},{value:"Basic Pipeline with Retry Delays",id:"basic-pipeline-with-retry-delays",level:3},{value:"Per-Node Retry Configuration",id:"per-node-retry-configuration",level:3},{value:"Available Strategies",id:"available-strategies",level:2},{value:"Basic Strategies",id:"basic-strategies",level:3},{value:"Advanced Strategies",id:"advanced-strategies",level:3},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Jitter",id:"jitter",level:3},{value:"Retry Cap (maxDelay)",id:"retry-cap-maxdelay",level:3},{value:"Topics",id:"topics",level:2},{value:"Guides",id:"guides",level:3},{value:"Advanced",id:"advanced",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Related Documentation",id:"related-documentation",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"retry-delays",children:"Retry Delays"})}),"\n",(0,s.jsx)(n.p,{children:"Retry delays determine how long to wait between retry attempts. Choosing the right strategy is crucial for balancing quick recovery with preventing service overload."}),"\n",(0,s.jsx)(n.h2,{id:"quick-start-common-retry-patterns",children:"Quick Start: Common Retry Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"web-api-calls-most-common",children:"Web API Calls (Most Common)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Recommended for external API calls\ncontext.UseExponentialBackoffDelay(\n    baseDelay: TimeSpan.FromSeconds(1),\n    multiplier: 2.0,\n    maxDelay: TimeSpan.FromMinutes(1));\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Why this pattern:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Exponential backoff gives services time to recover"}),"\n",(0,s.jsx)(n.li,{children:"Prevents thundering herd problems"}),"\n",(0,s.jsx)(n.li,{children:"Balanced for typical API rate limits"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"database-operations",children:"Database Operations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Recommended for database retry scenarios\ncontext.UseLinearBackoffDelay(\n    baseDelay: TimeSpan.FromMilliseconds(100),\n    increment: TimeSpan.FromMilliseconds(200),  // Required - adds 200ms per retry\n    maxDelay: TimeSpan.FromSeconds(5));\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Why this pattern:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Linear growth is predictable for database connection pools"}),"\n",(0,s.jsx)(n.li,{children:"Shorter delays work well for transient lock contention"}),"\n",(0,s.jsx)(n.li,{children:"Conservative max delay prevents long-running transactions"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"file-processing",children:"File Processing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Recommended for file system operations\ncontext.UseFixedDelay(TimeSpan.FromSeconds(2));\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Why this pattern:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"File system recovery is typically immediate"}),"\n",(0,s.jsx)(n.li,{children:"Fixed delay provides predictable behavior"}),"\n",(0,s.jsx)(n.li,{children:"Simple and effective for I/O operations"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"decision-flow-for-choosing-retry-strategy",children:"Decision Flow for Choosing Retry Strategy"}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart TD\n    A[What type of operation?] --\x3e B{External Service?}\n    B --\x3e|Yes| C[Use Exponential Backoff]\n    B --\x3e|No| D{Database Operation?}\n    D --\x3e|Yes| E[Use Linear Backoff]\n    D --\x3e|No| F{File System?}\n    F --\x3e|Yes| G[Use Fixed Delay]\n    F --\x3e|No| H[Use Exponential Backoff<br>Default choice]\n    \n    C --\x3e I[Configure base delay: 1s<br>Configure multiplier: 2.0<br>Configure max delay: 1m]\n    E --\x3e J[Configure base delay: 100ms<br>Configure increment: 200ms<br>Configure max delay: 5s]\n    G --\x3e K[Configure delay: 2s]\n    H --\x3e I\n    \n    style A fill:#e1f5fe\n    style C fill:#e8f5e9\n    style E fill:#e8f5e9\n    style G fill:#e8f5e9\n    style I fill:#fff3e0\n    style J fill:#f3e5f5\n    style K fill:#f3e5f5"}),"\n",(0,s.jsx)(n.h2,{id:"basic-implementation",children:"Basic Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"basic-pipeline-with-retry-delays",children:"Basic Pipeline with Retry Delays"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\nusing NPipeline.Pipeline;\n\npublic sealed class RetryQuickstartPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        // Configure retry delay strategy based on operation type\n        context.UseExponentialBackoffDelay(\n            baseDelay: TimeSpan.FromSeconds(1),\n            multiplier: 2.0,\n            maxDelay: TimeSpan.FromMinutes(1));\n\n        var source = builder.AddSource<ApiSource, ApiResponse>("api-source");\n        var transform = builder.AddTransform<DataTransform, ApiResponse, ProcessedData>("transform");\n        var sink = builder.AddSink<DataSink, ProcessedData>("sink");\n\n        builder.Connect(source, transform);\n        builder.Connect(transform, sink);\n\n        // Configure retry options\n        builder.WithRetryOptions(new PipelineRetryOptions(\n            MaxItemRetries: 3,\n            MaxNodeRestartAttempts: 2,\n            MaxSequentialNodeAttempts: 5\n        ));\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"per-node-retry-configuration",children:"Per-Node Retry Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public void Define(PipelineBuilder builder, PipelineContext context)\n{\n    var source = builder.AddSource<DataSource, string>("source");\n    \n    // Fast retries for in-memory operations\n    context.UseFixedDelay(TimeSpan.FromMilliseconds(50));\n    var memoryTransform = builder.AddTransform<MemoryTransform, string, string>("memory-ops");\n    \n    // Slower retries for external API calls\n    context.UseExponentialBackoffDelay(\n        baseDelay: TimeSpan.FromSeconds(1),\n        multiplier: 2.0,\n        maxDelay: TimeSpan.FromMinutes(1));\n    var apiTransform = builder.AddTransform<ApiTransform, string, string>("api-ops");\n    \n    // Default retries for other operations\n    var sink = builder.AddSink<DataSink, string>("sink");\n\n    builder.Connect(source, memoryTransform);\n    builder.Connect(memoryTransform, apiTransform);\n    builder.Connect(apiTransform, sink);\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"available-strategies",children:"Available Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"basic-strategies",children:"Basic Strategies"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Strategy"}),(0,s.jsx)(n.th,{children:"Pattern"}),(0,s.jsx)(n.th,{children:"Use Case"}),(0,s.jsx)(n.th,{children:"Link"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Exponential Backoff"})}),(0,s.jsx)(n.td,{children:"Delays grow exponentially (1s, 2s, 4s, 8s...)"}),(0,s.jsx)(n.td,{children:"External APIs, distributed systems"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retry-delay-exponential",children:"Learn more"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Linear Backoff"})}),(0,s.jsx)(n.td,{children:"Delays increase linearly (100ms, 300ms, 500ms...)"}),(0,s.jsx)(n.td,{children:"Database operations, lock contention"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retry-delay-linear",children:"Learn more"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Fixed Delay"})}),(0,s.jsx)(n.td,{children:"Same delay each time (2s, 2s, 2s...)"}),(0,s.jsx)(n.td,{children:"File system, simple scenarios, testing"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retry-delay-fixed",children:"Learn more"})})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"advanced-strategies",children:"Advanced Strategies"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retry-delay-advanced#decorrelated-jitter",children:"Decorrelated Jitter"})})," - Adaptive backoff for high concurrency"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retry-delay-advanced#custom-backoff-strategies",children:"Custom Strategies"})})," - Fibonacci, polynomial, time-of-day aware"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retry-delay-advanced#fallback-strategies",children:"Fallback Strategies"})})," - Cascade through multiple strategies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retry-delay-advanced#circuit-breaker-pattern-with-retries",children:"Circuit Breaker Pattern"})})," - Combine with circuit breaker"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"jitter",children:"Jitter"}),"\n",(0,s.jsx)(n.p,{children:"Add randomization to prevent synchronized retries:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"context.UseExponentialBackoffDelay(\n    baseDelay: TimeSpan.FromSeconds(1),\n    multiplier: 2.0,\n    maxDelay: TimeSpan.FromMinutes(1),\n    jitterStrategy: JitterStrategies.FullJitter()); // Add jitter\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Why:"}),' Without jitter, multiple clients retry at the same time, overwhelming the service ("thundering herd").']}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Jitter Options:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"NoJitter()"})," - Exact delays (use for testing only)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FullJitter()"})," - Random 0 to calculated delay"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"EqualJitter()"})," - Random between half and full delay"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DecorrelatedJitter()"})," - Adapts to system load"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"retry-cap-maxdelay",children:"Retry Cap (maxDelay)"}),"\n",(0,s.jsx)(n.p,{children:"Always set a maximum delay to prevent indefinitely long waits:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"context.UseExponentialBackoffDelay(\n    baseDelay: TimeSpan.FromSeconds(1),\n    multiplier: 2.0,\n    maxDelay: TimeSpan.FromMinutes(1)); // Don't wait longer than 1 minute\n"})}),"\n",(0,s.jsx)(n.h2,{id:"topics",children:"Topics"}),"\n",(0,s.jsx)(n.h3,{id:"guides",children:"Guides"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retry-delay-exponential",children:"Exponential Backoff"})," - For external APIs and services"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retry-delay-linear",children:"Linear Backoff"})," - For database operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retry-delay-fixed",children:"Fixed Delay"})," - For file operations and testing"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"advanced",children:"Advanced"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retry-delay-advanced",children:"Advanced Patterns"})," - Custom and adaptive strategies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retry-delay-testing",children:"Testing Retries"})," - Test retry behavior deterministically"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retry-delay-monitoring",children:"Monitoring Metrics"})," - Observe retry behavior in production"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Always add jitter"})," - Prevents thundering herd in distributed systems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Set reasonable caps"})," - Don't wait longer than 1-5 minutes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Start conservative"})," - Begin with shorter delays, increase if needed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use fixed delays in tests"})," - Ensures deterministic timing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitor metrics"})," - Track actual retry patterns in production"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Match strategy to domain"})," - APIs \u2260 Databases \u2260 Files"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Document decisions"})," - Explain why you chose specific settings"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retries",children:"Retry Configuration"})})," - Basic retry options (MaxItemRetries, MaxNodeRestartAttempts)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/",children:"Resilience Overview"})})," - Understanding resilience concepts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling"})})," - How error handling integrates with retries"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/circuit-breakers",children:"Circuit Breakers"})})," - Combine with circuit breaker patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting"})})," - Common retry issues and solutions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/architecture/retry-delay-architecture",children:"Architecture"})})," - Deep dive into implementation"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Choose a strategy based on your use case (API? Database? Files?)"}),"\n",(0,s.jsx)(n.li,{children:"Read the dedicated guide for your chosen strategy"}),"\n",(0,s.jsxs)(n.li,{children:["Test retry behavior with ",(0,s.jsx)(n.a,{href:"/docs/core-concepts/resilience/retry-delay-testing",children:"Testing Retries"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);