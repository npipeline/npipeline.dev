"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[2090],{1274:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"core-concepts/thread-safety","title":"Thread Safety Guidelines","description":"NPipeline is designed for high-performance streaming data processing. This document clarifies thread safety requirements and best practices.","source":"@site/docs/core-concepts/thread-safety.md","sourceDirName":"core-concepts","slug":"/core-concepts/thread-safety","permalink":"/docs/core-concepts/thread-safety","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Pipeline Validation Extensions - Usage Guide","permalink":"/docs/core-concepts/pipeline-validation"},"next":{"title":"Architecture Overview","permalink":"/docs/architecture/"}}');var t=i(4848),s=i(8453);const a={},l="Thread Safety Guidelines",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Single-Pipeline Execution (Default)",id:"single-pipeline-execution-default",level:2},{value:"Parallel Node Execution",id:"parallel-node-execution",level:2},{value:"Critical Distinction",id:"critical-distinction",level:3},{value:"Shared State During Parallel Execution",id:"shared-state-during-parallel-execution",level:3},{value:"Option 1: Use IPipelineStateManager (Recommended)",id:"option-1-use-ipipelinestatemanager-recommended",level:4},{value:"Option 2: Node-Level Synchronization",id:"option-2-node-level-synchronization",level:4},{value:"Option 3: Atomic Operations for Simple Counters",id:"option-3-atomic-operations-for-simple-counters",level:4},{value:"Context Dictionary Thread Safety",id:"context-dictionary-thread-safety",level:2},{value:"Parameters Dictionary",id:"parameters-dictionary",level:3},{value:"Items Dictionary",id:"items-dictionary",level:3},{value:"Properties Dictionary",id:"properties-dictionary",level:3},{value:"Why Not ConcurrentDictionary?",id:"why-not-concurrentdictionary",level:2},{value:"Parallel Execution Best Practices",id:"parallel-execution-best-practices",level:2},{value:"\u2705 DO",id:"-do",level:3},{value:"\u274c DON&#39;T",id:"-dont",level:3},{value:"Example: Safe Parallel Processing",id:"example-safe-parallel-processing",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"thread-safety-guidelines",children:"Thread Safety Guidelines"})}),"\n",(0,t.jsx)(n.p,{children:"NPipeline is designed for high-performance streaming data processing. This document clarifies thread safety requirements and best practices."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"NPipeline is primarily designed for single-threaded pipeline execution."})," However, it provides extensive support for parallel processing of individual data items. Understanding the distinction is critical."]}),"\n",(0,t.jsx)(n.h2,{id:"single-pipeline-execution-default",children:"Single-Pipeline Execution (Default)"}),"\n",(0,t.jsx)(n.p,{children:"In the most common scenario, a single pipeline processes a stream of data items sequentially:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var context = new PipelineContext();\nvar pipeline = builder.Build();\nawait pipeline.ExecuteAsync(dataSource, context);\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this case:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u2705 No synchronization needed"}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 Direct access to ",(0,t.jsx)(n.code,{children:"context.Items"}),", ",(0,t.jsx)(n.code,{children:"context.Parameters"}),", and ",(0,t.jsx)(n.code,{children:"context.Properties"})," is safe"]}),"\n",(0,t.jsx)(n.li,{children:"\u2705 All operations are single-threaded"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Maximum performance with zero overhead"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"parallel-node-execution",children:"Parallel Node Execution"}),"\n",(0,t.jsxs)(n.p,{children:["When using parallel execution strategies, NPipeline processes ",(0,t.jsx)(n.strong,{children:"independent data items"})," concurrently:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var context = new PipelineContext();\nvar pipeline = builder\n    .AddNode(sourceNode)\n    .AddNode(transformNode)\n    .ConfigureParallel(parallelNode, options => options.WithMaxDegreeOfParallelism(4))\n    .AddNode(sinkNode)\n    .Build();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"critical-distinction",children:"Critical Distinction"}),"\n",(0,t.jsxs)(n.p,{children:["Each worker thread processes ",(0,t.jsx)(n.strong,{children:"different data items"}),", not shared state. The ",(0,t.jsx)(n.code,{children:"PipelineContext"})," itself is not shared across threads\u2014only node instances and immutable configuration are shared."]}),"\n",(0,t.jsx)(n.h3,{id:"shared-state-during-parallel-execution",children:"Shared State During Parallel Execution"}),"\n",(0,t.jsxs)(n.p,{children:["If you need ",(0,t.jsx)(n.strong,{children:"shared mutable state"})," during parallel execution, ",(0,t.jsx)(n.strong,{children:"DO NOT"})," access ",(0,t.jsx)(n.code,{children:"context.Items"})," or ",(0,t.jsx)(n.code,{children:"context.Parameters"})," directly. Instead:"]}),"\n",(0,t.jsx)(n.h4,{id:"option-1-use-ipipelinestatemanager-recommended",children:"Option 1: Use IPipelineStateManager (Recommended)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// During context setup\nvar stateManager = new MyThreadSafeStateManager();\ncontext.Properties["NPipeline.StateManager"] = stateManager;\n\n// In your transform node\npublic override async ValueTask<TOut> TransformAsync(TIn input, PipelineContext context, CancellationToken ct)\n{\n    var stateManager = context.StateManager;\n    if (stateManager != null)\n    {\n        // Thread-safe operations\n        var state = await stateManager.GetStateAsync("myKey", ct);\n        // ... process ...\n        await stateManager.UpdateStateAsync("myKey", newState, ct);\n    }\n    return output;\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"option-2-node-level-synchronization",children:"Option 2: Node-Level Synchronization"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class ThreadSafeTransform<T> : TransformNode<T, T>\n{\n    private readonly object _syncLock = new();\n    \n    public override async ValueTask<T> TransformAsync(T input, PipelineContext context, CancellationToken ct)\n    {\n        lock (_syncLock)\n        {\n            // Synchronize access to shared state\n            var value = context.Items.TryGetValue("key", out var v) ? v : null;\n            context.Items["key"] = UpdateSharedState(value);\n        }\n        return input;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"option-3-atomic-operations-for-simple-counters",children:"Option 3: Atomic Operations for Simple Counters"}),"\n",(0,t.jsxs)(n.p,{children:["For simple counters or flags, use ",(0,t.jsx)(n.code,{children:"System.Threading.Interlocked"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class CountingTransform : TransformNode<int, int>\n{\n    private long _processedCount = 0;\n    \n    public override async ValueTask<int> TransformAsync(int input, PipelineContext context, CancellationToken ct)\n    {\n        Interlocked.Increment(ref _processedCount);\n        return input;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"context-dictionary-thread-safety",children:"Context Dictionary Thread Safety"}),"\n",(0,t.jsx)(n.h3,{id:"parameters-dictionary",children:"Parameters Dictionary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Thread Safe?"})," NO"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"When Safe?"})," During initialization (before pipeline execution)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case?"})," Configuration values that don't change during execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recommendation?"})," Populate this during setup phase only"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"items-dictionary",children:"Items Dictionary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Thread Safe?"})," NO"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"When Safe?"})," Single-threaded pipeline execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case?"})," Node-to-node communication, metrics storage"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recommendation?"})," In parallel scenarios, use ",(0,t.jsx)(n.code,{children:"IPipelineStateManager"})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"properties-dictionary",children:"Properties Dictionary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Thread Safe?"})," NO"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"When Safe?"})," Single-threaded pipeline execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case?"})," Extension points, plugin configuration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recommendation?"})," Store thread-safe objects (like ",(0,t.jsx)(n.code,{children:"IPipelineStateManager"}),") here"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"why-not-concurrentdictionary",children:"Why Not ConcurrentDictionary?"}),"\n",(0,t.jsxs)(n.p,{children:['You might wonder: "Why not just use ',(0,t.jsx)(n.code,{children:"ConcurrentDictionary"}),' for thread safety?"']}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Design Rationale:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance:"})," Thread-safe operations add overhead (locks, memory barriers, allocations)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Common Case:"})," ~99% of pipelines run single-threaded; paying the overhead for all is wasteful"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Philosophy:"}),' NPipeline follows "pay only for what you use"']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Alternatives:"})," When thread-safe state IS needed, ",(0,t.jsx)(n.code,{children:"IPipelineStateManager"})," is more purpose-built"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"parallel-execution-best-practices",children:"Parallel Execution Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"-do",children:"\u2705 DO"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\u2705 Use ",(0,t.jsx)(n.code,{children:"IPipelineStateManager"})," for shared state in parallel scenarios"]}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Process independent data items in parallel workers"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Store immutable configuration in context properties"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Use atomic operations for simple counters"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Synchronize access to shared mutable state"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"-dont",children:"\u274c DON'T"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\u274c Directly modify ",(0,t.jsx)(n.code,{children:"context.Items"})," from multiple threads without synchronization"]}),"\n",(0,t.jsx)(n.li,{children:"\u274c Assume context dictionaries are thread-safe"}),"\n",(0,t.jsx)(n.li,{children:"\u274c Share mutable state between parallel workers without explicit synchronization"}),"\n",(0,t.jsxs)(n.li,{children:["\u274c Access ",(0,t.jsx)(n.code,{children:"context.Parameters"})," after pipeline execution has started (in parallel scenarios)"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"example-safe-parallel-processing",children:"Example: Safe Parallel Processing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class SafeParallelTransform : TransformNode<DataItem, ProcessedItem>\n{\n    public override async ValueTask<ProcessedItem> TransformAsync(\n        DataItem input, \n        PipelineContext context, \n        CancellationToken ct)\n    {\n        // Process the individual item (independent work)\n        var processed = ProcessItem(input);\n        \n        // If you need to share state across parallel workers:\n        var stateManager = context.StateManager;\n        if (stateManager != null)\n        {\n            // Use thread-safe state manager\n            await stateManager.UpdateMetricsAsync("processed_count", 1, ct);\n        }\n        \n        return processed;\n    }\n    \n    private ProcessedItem ProcessItem(DataItem input)\n    {\n        // Independent processing - no shared state access\n        return new ProcessedItem { /* ... */ };\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/extensions/parallelism",children:"Parallel Execution"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Hygiene"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/best-practices",children:"Best Practices"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var r=i(6540);const t={},s=r.createContext(t);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);