"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[9559],{7378:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"getting-started/why-npipeline","title":"Why NPipeline?","description":"Explore the benefits, design philosophy, and performance characteristics that make NPipeline an ideal choice for your data processing needs.","source":"@site/docs/getting-started/why-npipeline.md","sourceDirName":"getting-started","slug":"/getting-started/why-npipeline","permalink":"/docs/getting-started/why-npipeline","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Why NPipeline?","description":"Explore the benefits, design philosophy, and performance characteristics that make NPipeline an ideal choice for your data processing needs.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Quick Start","permalink":"/docs/getting-started/quick-start"},"next":{"title":"Core Concepts","permalink":"/docs/core-concepts"}}');var t=i(4848),r=i(8453);const a={title:"Why NPipeline?",description:"Explore the benefits, design philosophy, and performance characteristics that make NPipeline an ideal choice for your data processing needs.",sidebar_position:3},o=void 0,l={},c=[{value:"Why NPipeline?",id:"why-npipeline",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"Design Philosophy",id:"design-philosophy",level:2},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Zero-Allocation Fast Paths: A Competitive Advantage",id:"zero-allocation-fast-paths-a-competitive-advantage",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"why-npipeline",children:"Why NPipeline?"}),"\n",(0,t.jsx)(n.p,{children:"NPipeline is engineered to address the common challenges in building robust and efficient data processing systems. It offers a unique blend of flexibility, performance, and developer experience that sets it apart."}),"\n",(0,t.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,t.jsx)(n.p,{children:"NPipeline excels in scenarios requiring structured, high-throughput data processing. Common use cases include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ETL (Extract, Transform, Load) Workflows:"})," Building reliable data ingestion and transformation pipelines."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Real-time Data Processing:"})," Handling streaming data from various sources with low latency."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Validation and Cleansing:"})," Implementing complex validation rules and data quality checks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Event-Driven Architectures:"})," Processing events as they occur in a scalable manner."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Batch Processing:"})," Efficiently processing large volumes of historical data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Microservice Integration:"})," Facilitating data exchange and transformation between microservices."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"design-philosophy",children:"Design Philosophy"}),"\n",(0,t.jsx)(n.p,{children:"NPipeline's design is rooted in several core principles:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Simplicity and Clarity:"})," A clear, intuitive API that makes pipeline construction straightforward and understandable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance First:"})," Optimized for minimal memory allocations and high concurrency, crucial for demanding workloads."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Testability:"})," Designed from the ground up to be easily testable, promoting robust and reliable solutions."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extensibility:"})," A modular architecture that allows developers to easily extend functionality and integrate with external systems."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Modern .NET:"})," Embracing the latest C# features and asynchronous programming patterns for efficient and idiomatic code."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,t.jsx)(n.p,{children:"Performance is a cornerstone of NPipeline. It is built to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Minimize Allocations:"})," Judicious use of memory to reduce garbage collection overhead, leading to smoother operation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Maximize Throughput:"})," Efficient internal mechanisms and asynchronous processing ensure high data processing rates."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Low Latency:"})," Designed to process data items quickly, making it suitable for near real-time applications."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scalability:"})," The graph-based approach and efficient resource management allow pipelines to scale with increasing data volumes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zero-Allocation Fast Paths:"})," Transform operations with synchronous execution paths (cache hits, simple calculations) eliminate heap allocations entirely. In high-cache-hit scenarios, this can drastically reduce garbage collection pressure, cutting out thousands of allocations per second in high-throughput pipelines."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By focusing on these aspects, NPipeline provides a powerful foundation for building data pipelines that are not only functional but also performant and maintainable."}),"\n",(0,t.jsx)(n.h3,{id:"zero-allocation-fast-paths-a-competitive-advantage",children:"Zero-Allocation Fast Paths: A Competitive Advantage"}),"\n",(0,t.jsxs)(n.p,{children:["One of NPipeline's most powerful features for high-performance scenarios is its support for ",(0,t.jsx)(n.strong,{children:"zero-allocation fast paths"})," in transform nodes."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The Problem:"})," In typical async-first frameworks, even simple synchronous operations (like cache lookups or quick calculations) create heap-allocated ",(0,t.jsx)(n.code,{children:"Task<T>"})," objects. Processing millions of items per second, where many transforms are synchronous or have high cache hit rates, this creates millions of tiny allocations per second\u2014constant pressure on the garbage collector."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The Solution:"})," Using ",(0,t.jsx)(n.code,{children:"ValueTask<T>"}),", you can implement a two-path pattern:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fast Path (Synchronous):"})," Result available immediately \u2192 allocates on the stack, zero GC pressure"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Slow Path (Asynchronous):"})," Work required \u2192 transitions seamlessly to true async"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"The Impact:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"For a pipeline processing 100,000 items/second with 90% cache hits, you eliminate 90,000 Task allocations per second"}),"\n",(0,t.jsxs)(n.li,{children:["Measured reduction in garbage collection pressure: ",(0,t.jsx)(n.strong,{children:"up to 90%"})]}),"\n",(0,t.jsx)(n.li,{children:"Particularly effective for: data validation, filtering, cached enrichment (everyday pipeline tasks)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Learn how to implement this:"})," ",(0,t.jsx)(n.a,{href:"/docs/advanced-topics/synchronous-fast-paths",children:"Synchronous Fast Paths and ValueTask Optimization"})]}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/getting-started/installation",children:"Installation"})}),": Get NPipeline set up in your development environment"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/getting-started/quick-start",children:"Quick Start"})}),": Begin building your first pipeline"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts",children:"Core Concepts"})}),": Dive deeper into the fundamental building blocks of NPipeline"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/advanced-topics/synchronous-fast-paths",children:"High-Performance Optimization"})}),": Master zero-allocation fast paths for maximum throughput"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(6540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);