"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[7141],{22428:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-concepts/lambda-nodes","title":"Lambda-Based Node Syntax","description":"Using lambda functions to define simple nodes without creating separate classes.","source":"@site/docs/core-concepts/lambda-nodes.md","sourceDirName":"core-concepts","slug":"/core-concepts/lambda-nodes","permalink":"/docs/core-concepts/lambda-nodes","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Lambda-Based Node Syntax","description":"Using lambda functions to define simple nodes without creating separate classes.","sidebar_position":7},"sidebar":"docsSidebar","previous":{"title":"Execution Strategies","permalink":"/docs/core-concepts/pipeline-execution/execution-strategies"},"next":{"title":"Pipeline Context (PipelineContext)","permalink":"/docs/core-concepts/pipeline-context"}}');var r=s(74848),a=s(28453);const t={title:"Lambda-Based Node Syntax",description:"Using lambda functions to define simple nodes without creating separate classes.",sidebar_position:7},o="Lambda-Based Node Syntax",l={},c=[{value:"Overview",id:"overview",level:2},{value:"When to Use Lambda Nodes",id:"when-to-use-lambda-nodes",level:2},{value:"\u2705 Use Lambda Nodes For:",id:"-use-lambda-nodes-for",level:3},{value:"\u274c Use Class-Based Nodes For:",id:"-use-class-based-nodes-for",level:3},{value:"Synchronous Transform Nodes",id:"synchronous-transform-nodes",level:2},{value:"Asynchronous Transform Nodes",id:"asynchronous-transform-nodes",level:2},{value:"Source Nodes",id:"source-nodes",level:2},{value:"Synchronous Source (from collections)",id:"synchronous-source-from-collections",level:3},{value:"Asynchronous Source (from async operations)",id:"asynchronous-source-from-async-operations",level:3},{value:"Sink Nodes",id:"sink-nodes",level:2},{value:"Synchronous Sink (immediate processing)",id:"synchronous-sink-immediate-processing",level:3},{value:"Asynchronous Sink (async I/O)",id:"asynchronous-sink-async-io",level:3},{value:"Complete Example: Simple ETL Pipeline",id:"complete-example-simple-etl-pipeline",level:2},{value:"Testing Lambda-Based Transformations",id:"testing-lambda-based-transformations",level:2},{value:"Hybrid Approach: Named Delegates",id:"hybrid-approach-named-delegates",level:2},{value:"Cancellation Token Support",id:"cancellation-token-support",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Limitations and Best Practices",id:"limitations-and-best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"lambda-based-node-syntax",children:"Lambda-Based Node Syntax"})}),"\n",(0,r.jsx)(n.p,{children:"NPipeline provides a simplified syntax for creating nodes using lambda functions instead of defining separate classes. This approach reduces boilerplate code for simple, stateless transformations and is ideal for quick prototyping and simple operations."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The lambda-based syntax consists of three main patterns:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transform nodes"}),": Convert input data to output data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source nodes"}),": Produce data into the pipeline"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sink nodes"}),": Consume data from the pipeline"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For each pattern, NPipeline provides a single, unified method that supports both synchronous and asynchronous operations. The compiler automatically selects the correct overload based on the delegate signature you provide."}),"\n",(0,r.jsx)(n.h2,{id:"when-to-use-lambda-nodes",children:"When to Use Lambda Nodes"}),"\n",(0,r.jsx)(n.h3,{id:"-use-lambda-nodes-for",children:"\u2705 Use Lambda Nodes For:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simple, stateless transformations"}),": String manipulation, type conversion, basic calculations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Quick prototyping"}),": Getting a pipeline working quickly during development"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single-use operations"}),": Logic that won't be reused across pipelines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Testing and debugging"}),": Temporary nodes for diagnostic purposes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"External service calls"}),": Short HTTP requests or API calls"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"-use-class-based-nodes-for",children:"\u274c Use Class-Based Nodes For:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Complex business logic"}),": Multi-step transformations requiring comprehensive testing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stateful operations"}),": Nodes that maintain internal state across executions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reusable components"}),": Logic used across multiple pipelines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configuration"}),": Nodes with complex initialization or configuration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error handling"}),": Operations requiring sophisticated error recovery"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"synchronous-transform-nodes",children:"Synchronous Transform Nodes"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"AddTransform()"})," with a synchronous delegate for simple, CPU-bound transformations:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Simple transformation\nvar transform = builder.AddTransform(\n    (int x) => x * 2,\n    "double");\n\n// With complex objects\nvar transform = builder.AddTransform(\n    (Customer c) => new CustomerDto\n    {\n        Id = c.Id,\n        Name = c.Name.Trim()\n    },\n    "customerToDto");\n\n// String operations\nvar transform = builder.AddTransform(\n    (string s) => s.ToUpperInvariant(),\n    "uppercase");\n'})}),"\n",(0,r.jsx)(n.h2,{id:"asynchronous-transform-nodes",children:"Asynchronous Transform Nodes"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"AddTransform()"})," with an asynchronous delegate for I/O-bound transformations like HTTP requests or database lookups. The method name is the same\u2014the compiler automatically selects the correct overload:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// HTTP request transformation\nvar transform = builder.AddTransform(\n    async (string url, ct) =>\n    {\n        using var client = new HttpClient();\n        var response = await client.GetStringAsync(url, ct);\n        return response;\n    },\n    "fetchUrl");\n\n// Database lookup\nvar transform = builder.AddTransform(\n    async (int customerId, ct) =>\n    {\n        return await _db.GetCustomerAsync(customerId, ct);\n    },\n    "lookupCustomer");\n\n// File I/O\nvar transform = builder.AddTransform(\n    async (string path, ct) =>\n    {\n        return await File.ReadAllTextAsync(path, ct);\n    },\n    "readFile");\n'})}),"\n",(0,r.jsx)(n.h2,{id:"source-nodes",children:"Source Nodes"}),"\n",(0,r.jsx)(n.h3,{id:"synchronous-source-from-collections",children:"Synchronous Source (from collections)"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"AddSource()"})," with a synchronous delegate that returns an ",(0,r.jsx)(n.code,{children:"IEnumerable<T>"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// From array\nvar source = builder.AddSource(\n    () => new[] { 1, 2, 3, 4, 5 },\n    "numbers");\n\n// From list\nvar source = builder.AddSource(\n    () => _customers.ToList(),\n    "customers");\n\n// From LINQ query\nvar source = builder.AddSource(\n    () => File.ReadAllLines("/data/input.txt"),\n    "fileLines");\n'})}),"\n",(0,r.jsx)(n.h3,{id:"asynchronous-source-from-async-operations",children:"Asynchronous Source (from async operations)"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"AddSource()"})," with an asynchronous delegate that returns an ",(0,r.jsx)(n.code,{children:"IAsyncEnumerable<T>"}),". The method name is the same\u2014the compiler automatically selects the correct overload:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Async database query\nvar source = builder.AddSource(\n    async ct =>\n    {\n        return await _db.GetAllOrdersAsync(ct);\n    },\n    "orders");\n\n// Async file reading\nvar source = builder.AddSource(\n    async ct =>\n    {\n        var lines = await File.ReadAllLinesAsync("/data/input.txt", ct);\n        foreach (var line in lines)\n        {\n            yield return line;\n        }\n    },\n    "fileLines");\n\n// Async HTTP request\nvar source = builder.AddSource(\n    async ct =>\n    {\n        using var client = new HttpClient();\n        var json = await client.GetStringAsync("https://api.example.com/items", ct);\n        var items = JsonSerializer.Deserialize<List<Item>>(json);\n        foreach (var item in items!)\n        {\n            yield return item;\n        }\n    },\n    "apiItems");\n'})}),"\n",(0,r.jsx)(n.h2,{id:"sink-nodes",children:"Sink Nodes"}),"\n",(0,r.jsx)(n.h3,{id:"synchronous-sink-immediate-processing",children:"Synchronous Sink (immediate processing)"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"AddSink()"})," with a synchronous delegate that accepts a single argument:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Console output\nvar sink = builder.AddSink(\n    (string line) => Console.WriteLine(line),\n    "console");\n\n// Collection accumulation\nvar results = new List<int>();\nvar sink = builder.AddSink(\n    (int item) => results.Add(item),\n    "collect");\n\n// File appending\nvar sink = builder.AddSink(\n    (string line) => File.AppendAllText("/log.txt", line + Environment.NewLine),\n    "fileLog");\n'})}),"\n",(0,r.jsx)(n.h3,{id:"asynchronous-sink-async-io",children:"Asynchronous Sink (async I/O)"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"AddSink()"})," with an asynchronous delegate that accepts a value and ",(0,r.jsx)(n.code,{children:"CancellationToken"}),". The method name is the same\u2014the compiler automatically selects the correct overload:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Database insert\nvar sink = builder.AddSink(\n    async (Customer customer, ct) =>\n    {\n        await _db.InsertCustomerAsync(customer, ct);\n    },\n    "dbInsert");\n\n// File writing with async\nvar sink = builder.AddSink(\n    async (string line, ct) =>\n    {\n        await File.AppendAllTextAsync("/log.txt", line + Environment.NewLine, ct);\n    },\n    "asyncFileLog");\n\n// HTTP POST\nvar sink = builder.AddSink(\n    async (Order order, ct) =>\n    {\n        using var client = new HttpClient();\n        var json = JsonSerializer.Serialize(order);\n        var content = new StringContent(json, Encoding.UTF8, "application/json");\n        await client.PostAsync("https://api.example.com/orders", content, ct);\n    },\n    "apiPost");\n'})}),"\n",(0,r.jsx)(n.h2,{id:"complete-example-simple-etl-pipeline",children:"Complete Example: Simple ETL Pipeline"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public class SimpleCsvEtlPipeline : IPipelineDefinition\n{\n    private readonly string _inputFile;\n    private readonly string _outputFile;\n\n    public SimpleCsvEtlPipeline(string inputFile, string outputFile)\n    {\n        _inputFile = inputFile;\n        _outputFile = outputFile;\n    }\n\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        // Source: Read CSV file (async variant)\n        var source = builder.AddSource(\n            async ct =>\n            {\n                var lines = await File.ReadAllLinesAsync(_inputFile, ct);\n                foreach (var line in lines.Skip(1)) // Skip header\n                {\n                    yield return line;\n                }\n            },\n            "csvRead");\n\n        // Transform: Parse CSV and convert (sync variant)\n        var parse = builder.AddTransform(\n            (string line) =>\n            {\n                var parts = line.Split(\',\');\n                return new Customer\n                {\n                    Id = int.Parse(parts[0]),\n                    Name = parts[1].Trim(),\n                    Email = parts[2].Trim()\n                };\n            },\n            "csvParse");\n\n        // Transform: Validate and clean (async variant)\n        var validate = builder.AddTransform(\n            async (Customer customer, ct) =>\n            {\n                // Async validation (e.g., check against database)\n                var isValid = !string.IsNullOrWhiteSpace(customer.Email);\n                await Task.Delay(10, ct); // Simulate async validation\n\n                return isValid ? customer : null;\n            },\n            "validateCustomer");\n\n        // Sink: Write results (async variant)\n        var sink = builder.AddSink(\n            async (Customer? customer, ct) =>\n            {\n                if (customer != null)\n                {\n                    var csv = $"{customer.Id},{customer.Name},{customer.Email}";\n                    await File.AppendAllTextAsync(_outputFile, csv + Environment.NewLine, ct);\n                }\n            },\n            "csvWrite");\n\n        // Connect nodes\n        builder.Connect(source, parse);\n        builder.Connect(parse, validate);\n        builder.Connect(validate, sink);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"testing-lambda-based-transformations",children:"Testing Lambda-Based Transformations"}),"\n",(0,r.jsx)(n.p,{children:"Since lambda transformations are embedded in the pipeline definition, you can test them by extracting the logic into separate, testable methods:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public static class CustomerTransformations\n{\n    // Testable logic extracted from lambda\n    public static Customer ParseCsvLine(string line)\n    {\n        var parts = line.Split(\',\');\n        return new Customer\n        {\n            Id = int.Parse(parts[0]),\n            Name = parts[1].Trim(),\n            Email = parts[2].Trim()\n        };\n    }\n\n    // Use in pipeline\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var parse = builder.AddTransform(\n            CustomerTransformations.ParseCsvLine,\n            "csvParse");\n    }\n}\n\n// Tested separately\n[TestClass]\npublic class CustomerTransformationTests\n{\n    [TestMethod]\n    public void ParseCsvLine_WithValidInput_ReturnsCustomer()\n    {\n        var result = CustomerTransformations.ParseCsvLine("1,John Doe,john@example.com");\n        Assert.AreEqual(1, result.Id);\n        Assert.AreEqual("John Doe", result.Name);\n        Assert.AreEqual("john@example.com", result.Email);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"hybrid-approach-named-delegates",children:"Hybrid Approach: Named Delegates"}),"\n",(0,r.jsx)(n.p,{children:"For better testability, you can assign lambda functions to named variables that can be tested independently:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public class HybridApproachPipeline : IPipelineDefinition\n{\n    // Testable delegate\n    private static readonly Func<int, int> DoubleValue = x => x * 2;\n\n    private static readonly Func<int, CancellationToken, ValueTask<int>> AsyncEnrich = async (x, ct) =>\n    {\n        await Task.Delay(10, ct);\n        return x + 100;\n    };\n\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource(() => Enumerable.Range(1, 10), "range");\n        var double_val = builder.AddTransform(DoubleValue, "double");\n        var enrich = builder.AddTransformAsync(AsyncEnrich, "enrich");\n        var sink = builder.AddSink(Console.WriteLine, "console");\n\n        builder.Connect(source, double_val);\n        builder.Connect(double_val, enrich);\n        builder.Connect(enrich, sink);\n    }\n}\n\n// Test the delegates\n[TestClass]\npublic class HybridApproachTests\n{\n    [TestMethod]\n    public void DoubleValue_WithInput5_Returns10()\n    {\n        var result = HybridApproachPipeline.DoubleValue(5);\n        Assert.AreEqual(10, result);\n    }\n\n    [TestMethod]\n    public async Task AsyncEnrich_WithInput5_Returns105()\n    {\n        var result = await HybridApproachPipeline.AsyncEnrich(5, CancellationToken.None);\n        Assert.AreEqual(105, result);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"cancellation-token-support",children:"Cancellation Token Support"}),"\n",(0,r.jsx)(n.p,{children:"All asynchronous lambda nodes respect the cancellation token, allowing graceful shutdown:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'var transformAsync = builder.AddTransformAsync(\n    async (item, cancellationToken) =>\n    {\n        // Check cancellation token\n        cancellationToken.ThrowIfCancellationRequested();\n\n        // Perform async work with cancellation support\n        var result = await SomeAsyncOperation(item, cancellationToken);\n        return result;\n    },\n    "asyncWork");\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Synchronous lambdas"}),": Zero overhead compared to class-based nodes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Asynchronous lambdas"}),": Minimal overhead; naturally produces ",(0,r.jsx)(n.code,{children:"ValueTask"})," for synchronous completions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Value types"}),": Lambda nodes support value types efficiently without boxing overhead"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"limitations-and-best-practices",children:"Limitations and Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State Management"}),": Lambda nodes are stateless by design. For stateful operations, use class-based nodes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Handling"}),": Simple exceptions are propagated; use error handler middleware for complex recovery logic."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Logging"}),": Use dependency injection or static loggers within lambdas for diagnostic purposes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Documentation"}),": Include XML comments above extracted methods/delegates for clarity."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reusability"}),": Extract commonly-used transformations into extension methods or utility classes."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"./node-definition",children:"Node Definition"})," - Understanding node structure"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"./nodes/transform-nodes",children:"Custom Nodes"})," - Creating class-based nodes for complex scenarios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"./defining-pipelines",children:"Defining Pipelines"})," - Full pipeline builder API reference"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>o});var i=s(96540);const r={},a=i.createContext(r);function t(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);