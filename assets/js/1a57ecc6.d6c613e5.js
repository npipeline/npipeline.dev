"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[6630],{136:(e,i,r)=>{r.r(i),r.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"core-concepts/resilience/index","title":"Resilience Overview","description":"Understand resilience concepts in NPipeline and how to build fault-tolerant data pipelines that can recover from failures.","source":"@site/docs/core-concepts/resilience/index.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/","permalink":"/docs/core-concepts/resilience/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Resilience Overview","description":"Understand resilience concepts in NPipeline and how to build fault-tolerant data pipelines that can recover from failures.","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Sink Nodes","permalink":"/docs/core-concepts/nodes/sink-nodes"},"next":{"title":"Error Handling in NPipeline","permalink":"/docs/core-concepts/resilience/error-handling-guide"}}');var s=r(4848),t=r(8453);const l={title:"Resilience Overview",description:"Understand resilience concepts in NPipeline and how to build fault-tolerant data pipelines that can recover from failures.",sidebar_position:1},o="Resilience Overview",c={},a=[{value:"\u26a1 Quick Start: Node Restart",id:"-quick-start-node-restart",level:2},{value:"Why Resilience Matters",id:"why-resilience-matters",level:2},{value:"Resilience Strategy Comparison",id:"resilience-strategy-comparison",level:2},{value:"Choosing the Right Strategy",id:"choosing-the-right-strategy",level:3},{value:"Core Resilience Components",id:"core-resilience-components",level:2},{value:"\u26a0\ufe0f Critical Prerequisites for Node Restart (RestartNode)",id:"\ufe0f-critical-prerequisites-for-node-restart-restartnode",level:2},{value:"Mandatory Requirements Checklist",id:"mandatory-requirements-checklist",level:3},{value:"What Happens If You Miss These",id:"what-happens-if-you-miss-these",level:3},{value:"The Dependency Chain",id:"the-dependency-chain",level:2},{value:"Critical Dependency Rules",id:"critical-dependency-rules",level:3},{value:"Decision Flow for Choosing Resilience Strategies",id:"decision-flow-for-choosing-resilience-strategies",level:2},{value:"Key Scenarios",id:"key-scenarios",level:2},{value:"Scenario 1: Simple Retry Logic",id:"scenario-1-simple-retry-logic",level:3},{value:"Scenario 2: Node Restart Capability",id:"scenario-2-node-restart-capability",level:3},{value:"Scenario 3: Memory-Constrained Environment",id:"scenario-3-memory-constrained-environment",level:3},{value:"\u27a1\ufe0f Next Steps",id:"arrow_right-next-steps",level:2}];function d(e){const i={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",input:"input",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"resilience-overview",children:"Resilience Overview"})}),"\n",(0,s.jsx)(i.p,{children:"Resilience in NPipeline refers to the ability of your data pipelines to detect, handle, and recover from failures without complete system breakdown.\r\nThis section provides a comprehensive guide to building robust, fault-tolerant pipelines."}),"\n",(0,s.jsx)(i.h2,{id:"-quick-start-node-restart",children:"\u26a1 Quick Start: Node Restart"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsxs)(i.strong,{children:["If you want to enable node restarts, ",(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/node-restart-quickstart",children:"start here: Node Restart Quick Start Checklist"})]})}),"\n",(0,s.jsx)(i.p,{children:"Node restart requires three mandatory configuration steps. Missing any one causes silent failures. The quickstart guide ensures you configure all three correctly."}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"why-resilience-matters",children:"Why Resilience Matters"}),"\n",(0,s.jsx)(i.p,{children:"In production environments, pipelines inevitably encounter failures from various sources:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Transient infrastructure issues"}),": Network timeouts, database connection failures"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Data quality problems"}),": Invalid formats, missing values, unexpected data types"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Resource constraints"}),": Memory pressure, CPU saturation, I/O bottlenecks"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"External service dependencies"}),": API rate limits, service outages, authentication failures"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Without proper resilience mechanisms, these failures can cascade through your pipeline, causing data loss, system instability, and costly manual intervention."}),"\n",(0,s.jsx)(i.h2,{id:"resilience-strategy-comparison",children:"Resilience Strategy Comparison"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Strategy"}),(0,s.jsx)(i.th,{children:"Best For"}),(0,s.jsx)(i.th,{children:"Memory Requirements"}),(0,s.jsx)(i.th,{children:"Complexity"}),(0,s.jsx)(i.th,{children:"Key Benefits"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Simple Retry"})}),(0,s.jsx)(i.td,{children:"Transient failures (network timeouts, temporary service issues)"}),(0,s.jsx)(i.td,{children:"Low"}),(0,s.jsx)(i.td,{children:"Low"}),(0,s.jsx)(i.td,{children:"Quick recovery from temporary issues"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Node Restart"})}),(0,s.jsx)(i.td,{children:"Persistent node failures, resource exhaustion"}),(0,s.jsx)(i.td,{children:"Medium (requires materialization)"}),(0,s.jsx)(i.td,{children:"Medium"}),(0,s.jsx)(i.td,{children:"Complete recovery from node-level failures"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Circuit Breaker"})}),(0,s.jsx)(i.td,{children:"Protecting against cascading failures, external service dependencies"}),(0,s.jsx)(i.td,{children:"Low"}),(0,s.jsx)(i.td,{children:"Medium"}),(0,s.jsx)(i.td,{children:"Prevents system overload during outages"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Dead-Letter Queues"})}),(0,s.jsx)(i.td,{children:"Handling problematic items that can't be processed"}),(0,s.jsx)(i.td,{children:"Low"}),(0,s.jsx)(i.td,{children:"High"}),(0,s.jsx)(i.td,{children:"Preserves problematic data for manual review"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Combined Approach"})}),(0,s.jsx)(i.td,{children:"Production systems with multiple failure types"}),(0,s.jsx)(i.td,{children:"High"}),(0,s.jsx)(i.td,{children:"High"}),(0,s.jsx)(i.td,{children:"Comprehensive protection against all failure types"})]})]})]}),"\n",(0,s.jsx)(i.h3,{id:"choosing-the-right-strategy",children:"Choosing the Right Strategy"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"For simple pipelines with basic needs"}),": Start with Simple Retry"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"For streaming data processing"}),": Use Node Restart with materialization"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"For external service dependencies"}),": Add Circuit Breaker to prevent cascade failures"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"For critical data pipelines"}),": Implement Dead-Letter Queues to preserve failed items"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"For production systems"}),": Combine multiple strategies for comprehensive protection"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"core-resilience-components",children:"Core Resilience Components"}),"\n",(0,s.jsx)(i.p,{children:"NPipeline's resilience framework is built around several interconnected components:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Component"}),(0,s.jsx)(i.th,{children:"Role"}),(0,s.jsx)(i.th,{children:"Critical Dependency"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/execution-with-resilience",children:"ResilientExecutionStrategy"})})}),(0,s.jsx)(i.td,{children:"Wrapper that enables recovery capabilities for nodes"}),(0,s.jsx)(i.td,{children:"Prerequisite for all resilience features"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/materialization-and-buffering",children:"Materialization & Buffering"})})}),(0,s.jsx)(i.td,{children:"Buffers input items to enable replay during restarts"}),(0,s.jsxs)(i.td,{children:["Required for ",(0,s.jsx)(i.code,{children:"PipelineErrorDecision.RestartNode"})]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/error-handling-guide",children:"Error Handling"})})}),(0,s.jsx)(i.td,{children:"Determines how to respond to different types of failures"}),(0,s.jsx)(i.td,{children:"Provides decision logic for recovery actions"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/retry-configuration",children:"Retry Options"})})}),(0,s.jsx)(i.td,{children:"Configures retry limits and materialization caps"}),(0,s.jsx)(i.td,{children:"Controls resilience behavior boundaries"})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"\ufe0f-critical-prerequisites-for-node-restart-restartnode",children:"\u26a0\ufe0f Critical Prerequisites for Node Restart (RestartNode)"}),"\n",(0,s.jsxs)(i.p,{children:["If you intend to use ",(0,s.jsx)(i.code,{children:"PipelineErrorDecision.RestartNode"})," to recover from failures, ",(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/node-restart-quickstart",children:"read the Node Restart Quick Start Checklist"})})," first."]}),"\n",(0,s.jsxs)(i.p,{children:["You ",(0,s.jsx)(i.strong,{children:"must"})," configure all three of the following. Missing any one will cause silent failures:"]}),"\n",(0,s.jsxs)(i.blockquote,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"\ud83d\udca1 Pro Tip:"})," The NPipeline build-time analyzer (NP9002) detects incomplete resilience configurations at compile-time, preventing these silent failures. See ",(0,s.jsx)(i.a,{href:"/docs/analyzers/resilience",children:"Build-Time Resilience Analyzer"})," for details."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"mandatory-requirements-checklist",children:"Mandatory Requirements Checklist"}),"\n",(0,s.jsxs)(i.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(i.li,{className:"task-list-item",children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(i.strong,{children:"Requirement 1: ResilientExecutionStrategy"})]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["The node must be wrapped with ",(0,s.jsx)(i.code,{children:"ResilientExecutionStrategy"})]}),"\n",(0,s.jsx)(i.li,{children:"Without this: Restart decisions are ignored; node cannot recover"}),"\n",(0,s.jsxs)(i.li,{children:["Reference: ",(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/execution-with-resilience",children:"Resilient Execution Strategy"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{className:"task-list-item",children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(i.strong,{children:"Requirement 2: MaxMaterializedItems Configuration"})]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Set ",(0,s.jsx)(i.code,{children:"MaxMaterializedItems > 0"})," in ",(0,s.jsx)(i.code,{children:"PipelineRetryOptions"})," (for streaming inputs)"]}),"\n",(0,s.jsx)(i.li,{children:"This enables the input stream to be buffered/materialized for replay"}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Critical:"})," Without this, even if RestartNode is requested, the pipeline will fall back to ",(0,s.jsx)(i.code,{children:"FailPipeline"})]}),"\n",(0,s.jsxs)(i.li,{children:["Example: ",(0,s.jsx)(i.code,{children:"MaxMaterializedItems: 1000"})," buffers up to 1000 items for potential replay"]}),"\n",(0,s.jsxs)(i.li,{children:["Reference: ",(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/materialization-and-buffering",children:"Materialization and Buffering"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{className:"task-list-item",children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(i.strong,{children:"Requirement 3: Error Handler Decision"})]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Your error handler must return ",(0,s.jsx)(i.code,{children:"PipelineErrorDecision.RestartNode"})," (not ",(0,s.jsx)(i.code,{children:"FailPipeline"})," or ",(0,s.jsx)(i.code,{children:"ContinueWithoutNode"}),")"]}),"\n",(0,s.jsx)(i.li,{children:"Without this: Node restarts are never attempted"}),"\n",(0,s.jsxs)(i.li,{children:["Reference: ",(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/error-handling-guide",children:"Error Handling"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"what-happens-if-you-miss-these",children:"What Happens If You Miss These"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Missing Component"}),(0,s.jsx)(i.th,{children:"What Goes Wrong"}),(0,s.jsx)(i.th,{children:"Observable Behavior"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"ResilientExecutionStrategy"}),(0,s.jsx)(i.td,{children:"Restart capability disabled"}),(0,s.jsx)(i.td,{children:"Error handler decisions are ignored; pipeline always fails"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"MaxMaterializedItems"}),(0,s.jsx)(i.td,{children:"Input stream not buffered"}),(0,s.jsxs)(i.td,{children:["RestartNode falls back to ",(0,s.jsx)(i.code,{children:"FailPipeline"}),"; entire pipeline halts unexpectedly"]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Error Handler RestartNode"}),(0,s.jsx)(i.td,{children:"Restart never triggered"}),(0,s.jsx)(i.td,{children:"All errors result in pipeline failure, even recoverable ones"})]})]})]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Example of Silent Failure:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"// \u274c WRONG: Missing materialization\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxMaterializedItems: null  // \u2190 This is the problem!\r\n);\r\n\r\n// Developer expects RestartNode to work, but...\r\n// When an error occurs and handler returns RestartNode:\r\n// \u2192 Pipeline sees MaxMaterializedItems is not set\r\n// \u2192 Falls back to FailPipeline\r\n// \u2192 Entire pipeline halts (unexpected failure!)\n"})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Example Correct Configuration:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:'// \u2705 CORRECT: All three requirements met\r\nvar nodeHandle = builder\r\n    .AddTransform<MyTransform, Input, Output>("myNode")\r\n    .WithExecutionStrategy(builder, new ResilientExecutionStrategy(\r\n        new SequentialExecutionStrategy()\r\n    ));\r\n\r\nvar options = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    MaxMaterializedItems: 1000  // \u2190 Materialization enabled\r\n);\r\n\r\nvar context = PipelineContext.WithRetry(options);\r\ncontext.AddPipelineErrorHandler<MyErrorHandler>(); // Returns RestartNode for transient errors\n'})}),"\n",(0,s.jsx)(i.h2,{id:"the-dependency-chain",children:"The Dependency Chain"}),"\n",(0,s.jsx)(i.p,{children:"Understanding the dependency relationships between resilience components is crucial for proper configuration:"}),"\n",(0,s.jsx)(i.mermaid,{value:"graph TD\r\n    A[ResilientExecutionStrategy] --\x3e B[Materialization via MaxMaterializedItems]\r\n    B --\x3e C[PipelineErrorDecision.RestartNode]\r\n    C --\x3e D[Node Restart Functionality]\r\n\r\n    E[IPipelineErrorHandler] --\x3e F[Error Decision Logic]\r\n    F --\x3e C\r\n\r\n    G[PipelineRetryOptions] --\x3e H[Retry Limits]\r\n    G --\x3e I[Materialization Caps]\r\n    H --\x3e C\r\n    I --\x3e B\r\n\r\n    J[Streaming Input] --\x3e K{Materialization Required?}\r\n    K --\x3e|Yes| B\r\n    K --\x3e|No| L[Direct Processing]\r\n\r\n    style A fill:#e1f5fe\r\n    style B fill:#f3e5f5\r\n    style C fill:#ffecb3\r\n    style D fill:#e8f5e9\r\n    style E fill:#e1f5fe\r\n    style F fill:#f3e5f5\r\n    style G fill:#e1f5fe\r\n    style H fill:#f3e5f5\r\n    style I fill:#f3e5f5\r\n    style J fill:#e8f5e9\r\n    style K fill:#ffecb3\r\n    style L fill:#e8f5e9"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.em,{children:"Figure: The dependency chain showing how resilience components must be configured in the correct sequence."})}),"\n",(0,s.jsx)(i.h3,{id:"critical-dependency-rules",children:"Critical Dependency Rules"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"ResilientExecutionStrategy is mandatory"}),": All resilience features require this strategy to be applied to a node"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Materialization enables restarts"}),": ",(0,s.jsx)(i.code,{children:"PipelineErrorDecision.RestartNode"})," only works if the input stream is materialized via ",(0,s.jsx)(i.code,{children:"MaxMaterializedItems"})]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Buffer size matters"}),": The ",(0,s.jsx)(i.code,{children:"MaxMaterializedItems"})," value determines how many items can be replayed during a restart"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Streaming inputs need materialization"}),": Only streaming inputs require explicit materialization; already-buffered inputs work automatically"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"decision-flow-for-choosing-resilience-strategies",children:"Decision Flow for Choosing Resilience Strategies"}),"\n",(0,s.jsx)(i.p,{children:"Use this flow diagram to determine the appropriate resilience configuration for your use case:"}),"\n",(0,s.jsx)(i.mermaid,{value:"flowchart TD\r\n    A[Start: Node Configuration] --\x3e B{Is fault tolerance required?}\r\n    B --\x3e|No| C[Use standard execution strategy]\r\n    B --\x3e|Yes| D[Apply ResilientExecutionStrategy]\r\n\r\n    D --\x3e E{What type of failures to handle?}\r\n    E --\x3e|Individual item failures| F[Configure NodeErrorDecision]\r\n    E --\x3e|Node/stream failures| G[Configure PipelineErrorDecision]\r\n    E --\x3e|Both| H[Configure both error handlers]\r\n\r\n    F --\x3e I{Is RestartNode needed?}\r\n    G --\x3e I\r\n    H --\x3e I\r\n\r\n    I --\x3e|No| J[Standard resilience configuration]\r\n    I --\x3e|Yes| K{Is input streaming?}\r\n\r\n    K --\x3e|No| L[RestartNode will work automatically]\r\n    K --\x3e|Yes| M[Set MaxMaterializedItems > 0]\r\n\r\n    M --\x3e N{Memory constraints?}\r\n    N --\x3e|No| O[Set high MaxMaterializedItems]\r\n    N --\x3e|Yes| P[Set limited MaxMaterializedItems]\r\n\r\n    L --\x3e Q[Complete resilience configuration]\r\n    O --\x3e Q\r\n    P --\x3e R[Monitor for buffer overflows]\r\n    R --\x3e Q\r\n\r\n    C --\x3e S[Standard pipeline setup]\r\n    Q --\x3e S\r\n\r\n    style A fill:#e8f5e9\r\n    style D fill:#e1f5fe\r\n    style I fill:#ffecb3\r\n    style K fill:#f3e5f5\r\n    style N fill:#f3e5f5\r\n    style Q fill:#e8f5e9\r\n    style S fill:#e8f5e9"}),"\n",(0,s.jsx)(i.h2,{id:"key-scenarios",children:"Key Scenarios"}),"\n",(0,s.jsx)(i.h3,{id:"scenario-1-simple-retry-logic",children:"Scenario 1: Simple Retry Logic"}),"\n",(0,s.jsx)(i.p,{children:"For handling transient failures without node restarts:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Apply ",(0,s.jsx)(i.code,{children:"ResilientExecutionStrategy"})]}),"\n",(0,s.jsxs)(i.li,{children:["Configure ",(0,s.jsx)(i.code,{children:"NodeErrorDecision.Retry"})," or ",(0,s.jsx)(i.code,{children:"NodeErrorDecision.Skip"})]}),"\n",(0,s.jsx)(i.li,{children:"No materialization required"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"scenario-2-node-restart-capability",children:"Scenario 2: Node Restart Capability"}),"\n",(0,s.jsx)(i.p,{children:"For recovering from node-level failures:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Apply ",(0,s.jsx)(i.code,{children:"ResilientExecutionStrategy"})]}),"\n",(0,s.jsxs)(i.li,{children:["Configure ",(0,s.jsx)(i.code,{children:"PipelineErrorDecision.RestartNode"})]}),"\n",(0,s.jsxs)(i.li,{children:["Set ",(0,s.jsx)(i.code,{children:"MaxMaterializedItems"})," to enable replay (for streaming inputs)"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"scenario-3-memory-constrained-environment",children:"Scenario 3: Memory-Constrained Environment"}),"\n",(0,s.jsx)(i.p,{children:"For systems with limited memory:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Apply ",(0,s.jsx)(i.code,{children:"ResilientExecutionStrategy"})]}),"\n",(0,s.jsxs)(i.li,{children:["Set ",(0,s.jsx)(i.code,{children:"MaxMaterializedItems"})," to a conservative value"]}),"\n",(0,s.jsx)(i.li,{children:"Monitor for buffer overflow exceptions"}),"\n",(0,s.jsx)(i.li,{children:"Consider alternative recovery strategies"}),"\n"]}),"\n",(0,s.jsxs)(i.h2,{id:"arrow_right-next-steps",children:["\u27a1\ufe0f"," Next Steps"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/execution-with-resilience",children:"Resilient Execution Strategy"})}),": Learn about the core wrapper that enables resilience"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/materialization-and-buffering",children:"Materialization and Buffering"})}),": Understand how buffering enables replay functionality"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/dependency-chains",children:"Dependency Chains"})}),": Explore the critical prerequisite relationships in detail"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/configuration-guide",children:"Configuration Guide"})}),": Get practical implementation guidance with code examples"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/circuit-breaker-advanced-configuration",children:"Circuit Breaker Advanced Configuration"})}),": Learn when to tune circuit breaker memory cleanup and how defaults behave"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting"})}),": Diagnose and resolve common resilience issues"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,i,r)=>{r.d(i,{R:()=>l,x:()=>o});var n=r(6540);const s={},t=n.createContext(s);function l(e){const i=n.useContext(t);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),n.createElement(t.Provider,{value:i},e.children)}}}]);