"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[1615],{361:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"tooling/analyzers/best-practices","title":"Best Practice Analyzers","description":"Validate dependency injection, resource management, and framework contract compliance.","source":"@site/docs/tooling/analyzers/best-practices.md","sourceDirName":"tooling/analyzers","slug":"/tooling/analyzers/best-practices","permalink":"/docs/tooling/analyzers/best-practices","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Best Practice Analyzers","description":"Validate dependency injection, resource management, and framework contract compliance.","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Data Processing Analyzers","permalink":"/docs/tooling/analyzers/data-processing"},"next":{"title":"Configuration Analyzers","permalink":"/docs/tooling/analyzers/configuration"}}');var r=i(4848),c=i(8453);const s={title:"Best Practice Analyzers",description:"Validate dependency injection, resource management, and framework contract compliance.",sidebar_position:5},a=void 0,o={},l=[{value:"Best Practice Analyzers",id:"best-practice-analyzers",level:2},{value:"NP9303: Unsafe PipelineContext Access",id:"np9303-unsafe-pipelinecontext-access",level:3},{value:"Problematic Patterns",id:"problematic-patterns",level:4},{value:"Solution: Use Safe Access Patterns",id:"solution-use-safe-access-patterns",level:4},{value:"Safe Access Patterns Reference",id:"safe-access-patterns-reference",level:4},{value:"Why Safe Access Matters",id:"why-safe-access-matters",level:4},{value:"NP9401: Missing Dependency Injection for Services",id:"np9401-missing-dependency-injection-for-services",level:3},{value:"The Problem",id:"the-problem",level:4},{value:"Problematic Patterns",id:"problematic-patterns-1",level:4},{value:"Direct Service Instantiation",id:"direct-service-instantiation",level:5},{value:"Static Singleton Field Assignments",id:"static-singleton-field-assignments",level:5},{value:"Service Locator Pattern Usage",id:"service-locator-pattern-usage",level:5},{value:"Solution: Use Constructor Injection",id:"solution-use-constructor-injection",level:4},{value:"Advanced Patterns",id:"advanced-patterns",level:4},{value:"Dependency Injection with Factory Pattern",id:"dependency-injection-with-factory-pattern",level:5},{value:"Optional Dependencies",id:"optional-dependencies",level:5},{value:"Why This Matters",id:"why-this-matters",level:4},{value:"Testability",id:"testability",level:5},{value:"Flexibility and Configuration",id:"flexibility-and-configuration",level:5},{value:"Dependency Inversion Principle",id:"dependency-inversion-principle",level:5},{value:"Detection Strategy",id:"detection-strategy",level:4},{value:"Service vs DTO Detection",id:"service-vs-dto-detection",level:4},{value:"Best Practices",id:"best-practices",level:4},{value:"Implementation Guide",id:"implementation-guide",level:4},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"Configuration",id:"configuration",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"best-practice-analyzers",children:"Best Practice Analyzers"}),"\n",(0,r.jsx)(n.p,{children:"Best practice analyzers enforce architectural patterns that ensure your code is testable, maintainable, and follows the framework's design principles."}),"\n",(0,r.jsx)(n.h3,{id:"np9303-unsafe-pipelinecontext-access",children:"NP9303: Unsafe PipelineContext Access"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ID:"})," ",(0,r.jsx)(n.code,{children:"NP9303"}),"\n",(0,r.jsx)(n.strong,{children:"Severity:"})," Warning",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Category:"})," Best Practice"]}),"\n",(0,r.jsx)(n.p,{children:"This analyzer detects unsafe access patterns to nullable properties on PipelineContext. Accessing potentially null properties without null-safety checks can cause null reference exceptions at runtime."}),"\n",(0,r.jsx)(n.h4,{id:"problematic-patterns",children:"Problematic Patterns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// :x: PROBLEM: Direct access to potentially null property\npublic async Task HandleErrorAsync(PipelineContext context, Exception error)\n{\n    // NP9303: PipelineErrorHandler might be null\n    await context.PipelineErrorHandler.HandleNodeFailureAsync(\n        "nodeId", error, context, cancellationToken);\n}\n\n// :x: PROBLEM: Direct dictionary access without existence check\npublic string GetParameter(PipelineContext context, string key)\n{\n    // NP9303: Dictionary might not contain key, and Parameters might be null\n    return context.Parameters[key].ToString();\n}\n\n// :x: PROBLEM: Unsafe cast\npublic void ProcessConfig(PipelineContext context)\n{\n    // NP9303: Configuration might be null or wrong type\n    var config = (MyConfig)context.Configuration;\n    ProcessConfig(config);\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"solution-use-safe-access-patterns",children:"Solution: Use Safe Access Patterns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// :heavy_check_mark: CORRECT: Use null-conditional operator\npublic async Task HandleErrorAsync(PipelineContext context, Exception error, CancellationToken cancellationToken)\n{\n    // Safe access - operation only occurs if PipelineErrorHandler is not null\n    await context.PipelineErrorHandler?.HandleNodeFailureAsync(\n        "nodeId", error, context, cancellationToken);\n}\n\n// :heavy_check_mark: CORRECT: Explicit null check with comment\npublic async Task HandleErrorAsync(PipelineContext context, Exception error, CancellationToken cancellationToken)\n{\n    if (context.PipelineErrorHandler == null)\n    {\n        throw new InvalidOperationException("PipelineErrorHandler must be configured for this operation");\n    }\n    \n    await context.PipelineErrorHandler.HandleNodeFailureAsync(\n        "nodeId", error, context, cancellationToken);\n}\n\n// :heavy_check_mark: CORRECT: Use TryGetValue pattern for dictionary access\npublic bool TryGetParameter(PipelineContext context, string key, out object value)\n{\n    value = null;\n    return context.Parameters?.TryGetValue(key, out value) == true;\n}\n\n// :heavy_check_mark: CORRECT: Use pattern matching for type-safe access\npublic void ProcessConfig(PipelineContext context)\n{\n    if (context.Configuration is MyConfig config)\n    {\n        ProcessConfig(config);\n    }\n}\n\n// :heavy_check_mark: CORRECT: Use pattern matching with property access\npublic string GetValue(PipelineContext context)\n{\n    if (context.PipelineErrorHandler is { } handler)\n    {\n        return handler.GetType().Name;\n    }\n    \n    return "No error handler configured";\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"safe-access-patterns-reference",children:"Safe Access Patterns Reference"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Pattern"}),(0,r.jsx)(n.th,{children:"Example"}),(0,r.jsx)(n.th,{children:"When to Use"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Null-conditional operator"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"context.Property?.Method()"})}),(0,r.jsx)(n.td,{children:"When you can safely continue if the property is null"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Explicit null check"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"if (context.Property != null)"})}),(0,r.jsx)(n.td,{children:"When you need to handle the null case explicitly"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"TryGetValue pattern"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:'context.Parameters?.TryGetValue("key", out var value)'})}),(0,r.jsx)(n.td,{children:"For dictionary access with null safety"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Pattern matching"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"if (context.Property is { } value)"})}),(0,r.jsx)(n.td,{children:"For type-safe access with null checking"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Combined null and key check"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:'context.Parameters?.ContainsKey("key") == true'})}),(0,r.jsx)(n.td,{children:"When you need to verify both container and key existence"})]})]})]}),"\n",(0,r.jsx)(n.h4,{id:"why-safe-access-matters",children:"Why Safe Access Matters"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime Safety"}),": Prevents null reference exceptions from reaching production"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Graceful Degradation"}),": Code continues functioning with missing optional properties"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Explicit Intent"}),": Null checks make it clear which properties are optional"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Testability"}),": Easier to test code that handles null cases explicitly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Maintainability"}),": Future developers understand property optionality"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"np9401-missing-dependency-injection-for-services",children:"NP9401: Missing Dependency Injection for Services"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ID:"})," ",(0,r.jsx)(n.code,{children:"NP9401"}),"\n",(0,r.jsx)(n.strong,{children:"Severity:"})," Warning",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Category:"})," Best Practice"]}),"\n",(0,r.jsx)(n.p,{children:"This analyzer detects dependency injection anti-patterns in node implementations that can lead to tightly coupled code that is difficult to test and maintain. The analyzer identifies the following problematic patterns:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Direct service instantiation"})," using the ",(0,r.jsx)(n.code,{children:"new"})," keyword"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Static singleton field assignments"})," that create tightly coupled dependencies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service locator pattern usage"})," through GetService or GetRequiredService calls"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"the-problem",children:"The Problem"}),"\n",(0,r.jsx)(n.p,{children:"When node implementations directly instantiate their dependencies or use service locator patterns, they create tight coupling that makes the code difficult to test, maintain, and configure. This violates the Dependency Inversion Principle and makes it challenging to swap implementations or mock dependencies for testing."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// :x: PROBLEM: Direct service instantiation\npublic class BadTransformNode : TransformNode<string, string>\n{\n    private readonly BadService _badService = new BadService(); // NP9401: Direct instantiation\n\n    public override Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        return Task.FromResult(_badService.Process(item));\n    }\n}\n\n// :x: PROBLEM: Static singleton assignment\npublic class BadSourceNode : SourceNode<int>\n{\n    private static BadService _service; // Static field\n\n    public BadSourceNode()\n    {\n        _service = new BadService(); // NP9401: Static singleton assignment\n    }\n}\n\n// :x: PROBLEM: Service locator pattern\npublic class BadSinkNode : SinkNode<string>\n{\n    private readonly IServiceProvider _serviceProvider;\n\n    public BadSinkNode(IServiceProvider serviceProvider)\n    {\n        _serviceProvider = serviceProvider;\n    }\n\n    public override async Task ExecuteAsync(IDataPipe<string> input, PipelineContext context, CancellationToken cancellationToken)\n    {\n        var badService = _serviceProvider.GetService(typeof(BadService)) as BadService; // NP9401: Service locator\n        await foreach (var item in input.WithCancellation(cancellationToken))\n        {\n            // Process item\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"problematic-patterns-1",children:"Problematic Patterns"}),"\n",(0,r.jsx)(n.h5,{id:"direct-service-instantiation",children:"Direct Service Instantiation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// :x: PROBLEM: Direct instantiation with 'new'\npublic class TransformNodeWithDirectInstantiation : TransformNode<string, string>\n{\n    private readonly EmailService _emailService = new EmailService(); // NP9401\n    private readonly LoggingService _loggingService = new LoggingService(); // NP9401\n\n    public override async Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        await _emailService.SendEmailAsync(item);\n        _loggingService.Log(item);\n        return item.ToUpper();\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h5,{id:"static-singleton-field-assignments",children:"Static Singleton Field Assignments"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// :x: PROBLEM: Static singleton pattern\npublic class NodeWithStaticSingleton : TransformNode<int, int>\n{\n    private static DataService _dataService; // Static field\n\n    public NodeWithStaticSingleton()\n    {\n        _dataService = new DataService(); // NP9401: Static singleton assignment\n    }\n\n    public override Task<int> ExecuteAsync(int item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        return Task.FromResult(_dataService.Process(item));\n    }\n}\n\n// :x: PROBLEM: Static property assignment\npublic class NodeWithStaticProperty : TransformNode<string, bool>\n{\n    public static CacheService Cache { get; private set; }\n\n    static NodeWithStaticProperty()\n    {\n        Cache = new CacheService(); // NP9401: Static singleton assignment\n    }\n\n    public override Task<bool> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        return Task.FromResult(Cache.Contains(item));\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h5,{id:"service-locator-pattern-usage",children:"Service Locator Pattern Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// :x: PROBLEM: Service locator with GetService\npublic class NodeWithServiceLocator : TransformNode<string, string>\n{\n    private readonly IServiceProvider _provider;\n\n    public NodeWithServiceLocator(IServiceProvider provider)\n    {\n        _provider = provider;\n    }\n\n    public override Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        var processor = _provider.GetService(typeof(DataProcessor)) as DataProcessor; // NP9401\n        var validator = _provider.GetService<IValidator>(); // NP9401\n        return Task.FromResult(processor.Process(item));\n    }\n}\n\n// :x: PROBLEM: Service locator with GetRequiredService\npublic class NodeWithRequiredServiceLocator : TransformNode<double, double>\n{\n    private readonly IServiceProvider _provider;\n\n    public NodeWithRequiredServiceLocator(IServiceProvider provider)\n    {\n        _provider = provider;\n    }\n\n    public override Task<double> ExecuteAsync(double item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        var calculator = _provider.GetRequiredService<ICalculator>(); // NP9401\n        return Task.FromResult(calculator.Calculate(item));\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"solution-use-constructor-injection",children:"Solution: Use Constructor Injection"}),"\n",(0,r.jsx)(n.p,{children:"The recommended approach is to use constructor injection, which makes dependencies explicit, improves testability, and follows the Dependency Inversion Principle."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// :heavy_check_mark: CORRECT: Constructor injection\npublic class GoodTransformNode : TransformNode<string, string>\n{\n    private readonly BadService _badService;\n\n    public GoodTransformNode(BadService badService) // Constructor injection\n    {\n        _badService = badService;\n    }\n\n    public override Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        return Task.FromResult(_badService.Process(item));\n    }\n}\n\n// :heavy_check_mark: CORRECT: Multiple dependencies via constructor\npublic class GoodSinkNode : SinkNode<string>\n{\n    private readonly IEmailService _emailService;\n    private readonly ILoggingService _loggingService;\n    private readonly IDataRepository _repository;\n\n    public GoodSinkNode(\n        IEmailService emailService,\n        ILoggingService loggingService,\n        IDataRepository repository) // Multiple dependencies\n    {\n        _emailService = emailService;\n        _loggingService = loggingService;\n        _repository = repository;\n    }\n\n    public override async Task ExecuteAsync(IDataPipe<string> input, PipelineContext context, CancellationToken cancellationToken)\n    {\n        await foreach (var item in input.WithCancellation(cancellationToken))\n        {\n            var processed = await _repository.SaveAsync(item);\n            await _emailService.SendNotificationAsync(processed);\n            _loggingService.Log(processed);\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,r.jsx)(n.h5,{id:"dependency-injection-with-factory-pattern",children:"Dependency Injection with Factory Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// :heavy_check_mark: GOOD: Using factory for complex dependencies\npublic class NodeWithFactory : TransformNode<string, string>\n{\n    private readonly IServiceFactory _serviceFactory;\n\n    public NodeWithFactory(IServiceFactory serviceFactory)\n    {\n        _serviceFactory = serviceFactory;\n    }\n\n    public override Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        var processor = _serviceFactory.CreateProcessor(item.Type); // Factory creates appropriate service\n        return Task.FromResult(processor.Process(item));\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h5,{id:"optional-dependencies",children:"Optional Dependencies"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// :heavy_check_mark: GOOD: Optional dependencies with null checks\npublic class NodeWithOptionalDependency : TransformNode<string, string>\n{\n    private readonly ICacheService _cacheService;\n\n    public NodeWithOptionalDependency(ICacheService cacheService = null) // Optional dependency\n    {\n        _cacheService = cacheService;\n    }\n\n    public override Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        if (_cacheService != null)\n        {\n            var cached = _cacheService.Get(item);\n            if (cached != null)\n                return Task.FromResult(cached);\n        }\n\n        // Process without cache\n        return Task.FromResult(item.ToUpper());\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"why-this-matters",children:"Why This Matters"}),"\n",(0,r.jsx)(n.h5,{id:"testability",children:"Testability"}),"\n",(0,r.jsx)(n.p,{children:"Constructor injection makes it easy to mock dependencies for unit testing:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Easy to test with mocked dependencies\n[Fact]\npublic async Task ShouldProcessDataCorrectly()\n{\n    // Arrange\n    var mockService = new Mock<IBadService>();\n    mockService.Setup(s => s.Process("input")).Returns("OUTPUT");\n    \n    var node = new GoodTransformNode(mockService.Object);\n    \n    // Act\n    var result = await node.ExecuteAsync("input", new PipelineContext(), CancellationToken.None);\n    \n    // Assert\n    Assert.Equal("OUTPUT", result);\n}\n'})}),"\n",(0,r.jsx)(n.h5,{id:"flexibility-and-configuration",children:"Flexibility and Configuration"}),"\n",(0,r.jsx)(n.p,{children:"With dependency injection, you can easily swap implementations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Development\nservices.AddSingleton<IBadService, DevBadService>();\n\n// Production\nservices.AddSingleton<IBadService, ProdBadService>();\n\n// Testing\nservices.AddSingleton<IBadService, MockBadService>();\n"})}),"\n",(0,r.jsx)(n.h5,{id:"dependency-inversion-principle",children:"Dependency Inversion Principle"}),"\n",(0,r.jsx)(n.p,{children:"Constructor injection helps follow SOLID principles by depending on abstractions rather than concretions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// :heavy_check_mark: GOOD: Depends on abstraction\npublic class GoodNode : TransformNode<string, string>\n{\n    private readonly IDataProcessor _processor; // Interface, not concrete class\n\n    public GoodNode(IDataProcessor processor)\n    {\n        _processor = processor;\n    }\n\n    public override Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        return Task.FromResult(_processor.Process(item));\n    }\n}\n\n// :x: BAD: Depends on concrete implementation\npublic class BadNode : TransformNode<string, string>\n{\n    private readonly SpecificDataProcessor _processor = new SpecificDataProcessor(); // Concrete class\n    \n    public override Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        return Task.FromResult(_processor.Process(item));\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"detection-strategy",children:"Detection Strategy"}),"\n",(0,r.jsx)(n.p,{children:"The analyzer uses semantic analysis to detect dependency injection anti-patterns:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node Type Detection"}),": Identifies classes that inherit from node base types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service Type Recognition"}),": Distinguishes between services and DTOs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Anti-Pattern Detection"}),": Scans for direct instantiation, static assignments, and service locator calls"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Context Awareness"}),": Only analyzes code within node implementations"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"service-vs-dto-detection",children:"Service vs DTO Detection"}),"\n",(0,r.jsx)(n.p,{children:"The analyzer intelligently distinguishes between services and DTOs:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Services are identified by:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'Namespaces containing "Service", "Repository", "Provider", "Handler", "Manager"'}),"\n",(0,r.jsx)(n.li,{children:'Class names containing "Service", "Repository", "Provider", "Handler", "Manager"'}),"\n",(0,r.jsx)(n.li,{children:"Having non-static methods beyond the basic object methods"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"DTOs are identified by:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Being record types"}),"\n",(0,r.jsx)(n.li,{children:'Names containing "Dto", "Model", "ViewModel"'}),"\n",(0,r.jsx)(n.li,{children:'Namespaces containing "Model", "Dto", "ViewModel"'}),"\n",(0,r.jsx)(n.li,{children:"Having only properties and static methods"}),"\n",(0,r.jsx)(n.li,{children:"Being value types"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// This is OK - DTO instantiation is allowed\npublic record DataDto(string Value);\n\npublic class GoodNode : TransformNode<string, string>\n{\n    public override Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\n    {\n        var dto = new DataDto(item); // No warning - DTO instantiation is fine\n        return Task.FromResult(dto.Value);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Always use constructor injection"})," for services in node implementations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Depend on abstractions"})," (interfaces) rather than concrete implementations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Keep constructors focused"})," on dependency injection, not business logic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use factories"})," for complex dependency creation scenarios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Make dependencies explicit"})," - avoid optional dependencies when possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Register dependencies"})," in your DI container at application startup"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"implementation-guide",children:"Implementation Guide"}),"\n",(0,r.jsx)(n.p,{children:"To implement proper dependency injection instead of anti-patterns:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Identify direct instantiations"})," using the NP9401 analyzer"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Extract dependencies"})," to constructor parameters"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Register dependencies"})," in your DI container"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Update tests"})," to use mocked dependencies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Remove static singletons"})," and replace with proper DI"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Eliminate service locator"})," usage in favor of constructor injection"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Pattern"}),(0,r.jsx)(n.th,{children:"Recommendation"}),(0,r.jsx)(n.th,{children:"Reason"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Accessing nullable properties"}),(0,r.jsx)(n.td,{children:"Use null-conditional operators or explicit checks"}),(0,r.jsx)(n.td,{children:"Prevents null reference exceptions"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Injecting services"}),(0,r.jsx)(n.td,{children:"Always use constructor injection"}),(0,r.jsx)(n.td,{children:"Improves testability and maintainability"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Accessing context data"}),(0,r.jsx)(n.td,{children:"Use safe patterns like TryGetValue or pattern matching"}),(0,r.jsx)(n.td,{children:"Prevents runtime errors"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Handling optional properties"}),(0,r.jsx)(n.td,{children:"Document and handle null cases explicitly"}),(0,r.jsx)(n.td,{children:"Makes code intent clear"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Testing node implementations"}),(0,r.jsx)(n.td,{children:"Use mocked dependencies via constructor"}),(0,r.jsx)(n.td,{children:"Ensures good test isolation"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["Adjust analyzer severity in ",(0,r.jsx)(n.code,{children:".editorconfig"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ini",children:"# Treat unsafe context access as errors\ndotnet_diagnostic.NP9303.severity = error\n\n# Treat DI anti-patterns as errors\ndotnet_diagnostic.NP9401.severity = error\n"})}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/extensions/dependency-injection",children:"Dependency Injection Guide"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/extensions/testing/advanced-testing",children:"Testing Pipelines"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/architecture/design-principles",children:"SOLID Principles"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>a});var t=i(6540);const r={},c=t.createContext(r);function s(e){const n=t.useContext(c);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);