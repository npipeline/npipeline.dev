"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[8399],{6764:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"introduction/api-reference","title":"API Quick Reference","description":"Quick lookup for NPipeline\'s main APIs.","source":"@site/docs/introduction/api-reference.md","sourceDirName":"introduction","slug":"/introduction/api-reference","permalink":"/docs/introduction/api-reference","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"title":"API Quick Reference","description":"Quick lookup for NPipeline\'s main APIs.","sidebar_position":13},"sidebar":"docsSidebar","previous":{"title":"Troubleshooting Guide","permalink":"/docs/introduction/troubleshooting"},"next":{"title":"Learning Paths","permalink":"/docs/learning-paths"}}');var s=r(4848),l=r(8453);const c={title:"API Quick Reference",description:"Quick lookup for NPipeline's main APIs.",sidebar_position:13},t="API Quick Reference",d={},a=[{value:"Core Interfaces",id:"core-interfaces",level:2},{value:"IPipelineDefinition",id:"ipipelinedefinition",level:3},{value:"PipelineBuilder",id:"pipelinebuilder",level:3},{value:"INode",id:"inode",level:3},{value:"Base Node Classes",id:"base-node-classes",level:2},{value:"<code>SourceNode&lt;T&gt;</code>",id:"sourcenodet",level:3},{value:"<code>TransformNode&lt;TIn, TOut&gt;</code>",id:"transformnodetin-tout",level:3},{value:"<code>SinkNode&lt;T&gt;</code>",id:"sinknodet",level:3},{value:"Core Types",id:"core-types",level:2},{value:"PipelineContext",id:"pipelinecontext",level:3},{value:"IDataPipe",id:"idatapipe",level:3},{value:"StreamingDataPipe",id:"streamingdatapipe",level:3},{value:"Execution",id:"execution",level:2},{value:"PipelineRunner",id:"pipelinerunner",level:3},{value:"Dependency Injection",id:"dependency-injection",level:2},{value:"AddNPipeline Extension (Assembly Scanning)",id:"addnpipeline-extension-assembly-scanning",level:3},{value:"AddNPipeline Extension (Fluent Configuration)",id:"addnpipeline-extension-fluent-configuration",level:3},{value:"Testing Extension",id:"testing-extension",level:3},{value:"InMemorySourceNode",id:"inmemorysourcenode",level:4},{value:"<code>InMemorySinkNode&lt;T&gt;</code>",id:"inmemorysinknodet",level:4},{value:"Connectors",id:"connectors",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Create Pipeline and Run",id:"create-pipeline-and-run",level:3},{value:"Use with Dependency Injection",id:"use-with-dependency-injection",level:3},{value:"Handle Cancellation",id:"handle-cancellation",level:3},{value:"Share State Between Nodes",id:"share-state-between-nodes",level:3},{value:"Custom Error Handling",id:"custom-error-handling",level:3},{value:"Quick Lookup Table",id:"quick-lookup-table",level:2},{value:"Next Steps",id:"next-steps",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"api-quick-reference",children:"API Quick Reference"})}),"\n",(0,s.jsx)(n.h2,{id:"core-interfaces",children:"Core Interfaces"}),"\n",(0,s.jsx)(n.h3,{id:"ipipelinedefinition",children:"IPipelineDefinition"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Define pipeline structure and connections."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public interface IPipelineDefinition\r\n{\r\n    void Define(PipelineBuilder builder, PipelineContext context);\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Implement to:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Create custom pipelines"}),"\n",(0,s.jsx)(n.li,{children:"Define node connections"}),"\n",(0,s.jsx)(n.li,{children:"Configure pipeline topology"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using NPipeline.Pipeline;\r\n\r\npublic class MyPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var source = builder.AddSource<MySource, MyData>();\r\n        var transform = builder.AddTransform<MyTransform, MyData, ProcessedData>();\r\n        var sink = builder.AddSink<MySink, ProcessedData>();\r\n\r\n        builder.Connect(source, transform);\r\n        builder.Connect(transform, sink);\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"pipelinebuilder",children:"PipelineBuilder"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Build and connect nodes."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Method"}),(0,s.jsx)(n.th,{children:"Returns"}),(0,s.jsx)(n.th,{children:"Purpose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"AddSource<TNode, TOut>()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"SourceNodeHandle<TOut>"})}),(0,s.jsx)(n.td,{children:"Create and register a source node"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"AddTransform<TNode, TIn, TOut>()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"TransformNodeHandle<TIn, TOut>"})}),(0,s.jsx)(n.td,{children:"Create and register a transform node"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"AddSink<TNode, TIn>()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"SinkNodeHandle<TIn>"})}),(0,s.jsx)(n.td,{children:"Create and register a sink node"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Connect<TData>(SourceNodeHandle<TData>, TransformNodeHandle<TData, TOut>)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PipelineBuilder"})}),(0,s.jsx)(n.td,{children:"Connect two nodes"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var source = builder.AddSource<OrderSource, Order>();\r\nvar sink = builder.AddSink<OrderSink, Order>();\r\nbuilder.Connect(source, sink);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"inode",children:"INode"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Base interface for all pipeline nodes."]}),"\n",(0,s.jsxs)(n.p,{children:["All nodes implement ",(0,s.jsx)(n.code,{children:"INode"}),". Use specific base classes instead:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SourceNode<T>"})," - Data source"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TransformNode<TIn, TOut>"})," - Data transform"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SinkNode<T>"})," - Data consumer"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"base-node-classes",children:"Base Node Classes"}),"\n",(0,s.jsx)(n.h3,{id:"sourcenodet",children:(0,s.jsx)(n.code,{children:"SourceNode<T>"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Produce data to pipeline."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public abstract class SourceNode<T> : INode\r\n{\r\n    public abstract IDataPipe<T> Execute(\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Implement by:"})," Override ",(0,s.jsx)(n.code,{children:"Execute()"})," to return data synchronously."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class CsvSource : SourceNode<Customer>\r\n{\r\n    private readonly string _filePath;\r\n\r\n    public override IDataPipe<Customer> Execute(\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        static IAsyncEnumerable<Customer> ReadAsync(string path, CancellationToken ct)\r\n        {\r\n            return Read();\r\n\r\n            async IAsyncEnumerable<Customer> Read()\r\n            {\r\n                using var reader = new StreamReader(path);\r\n                string? line;\r\n                while ((line = await reader.ReadLineAsync(ct)) != null)\r\n                {\r\n                    ct.ThrowIfCancellationRequested();\r\n                    yield return ParseCsv(line);\r\n                }\r\n            }\r\n        }\r\n\r\n        return new StreamingDataPipe<Customer>(ReadAsync(_filePath, cancellationToken));\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"transformnodetin-tout",children:(0,s.jsx)(n.code,{children:"TransformNode<TIn, TOut>"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Transform data item-by-item."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public abstract class TransformNode<TIn, TOut> : INode\r\n{\r\n    public abstract Task<TOut> ExecuteAsync(\r\n        TIn item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Implement by:"})," Override ",(0,s.jsx)(n.code,{children:"ExecuteAsync()"})," for each item."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class OrderValidator : TransformNode<Order, ValidatedOrder>\r\n{\r\n    public override Task<ValidatedOrder> ExecuteAsync(\r\n        Order item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        if (item.Amount <= 0)\r\n            throw new ValidationException("Amount must be positive");\r\n\r\n        var validated = new ValidatedOrder(item.Id, item.Amount);\r\n        return Task.FromResult(validated);\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"sinknodet",children:(0,s.jsx)(n.code,{children:"SinkNode<T>"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Consume final data."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using NPipeline.Nodes;\r\nusing NPipeline.DataFlow;\r\nusing NPipeline.Observability.Tracing;\r\nusing NPipeline.Pipeline;\r\n\r\npublic abstract class SinkNode<T> : ISinkNode<T>\r\n{\r\n    public abstract Task ExecuteAsync(\r\n        IDataPipe<T> input,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Implement by:"})," Override ",(0,s.jsx)(n.code,{children:"ExecuteAsync()"})," to consume the data pipe."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class OrderSink : SinkNode<ValidatedOrder>\r\n{\r\n    private readonly IOrderRepository _repository;\r\n\r\n    public override async Task ExecuteAsync(\r\n        IDataPipe<ValidatedOrder> input,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        await foreach (var order in input.WithCancellation(cancellationToken))\r\n        {\r\n            await _repository.SaveAsync(order, cancellationToken);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"core-types",children:"Core Types"}),"\n",(0,s.jsx)(n.h3,{id:"pipelinecontext",children:"PipelineContext"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Shared runtime context for pipeline."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using NPipeline.Pipeline;\r\nusing NPipeline.Observability.Logging;\r\nusing NPipeline.Observability.Tracing;\r\n\r\npublic class PipelineContext\r\n{\r\n    public Dictionary<string, object> Items { get; }\r\n    public Dictionary<string, object> Parameters { get; }\r\n    public CancellationToken CancellationToken { get; }\r\n    public IPipelineLoggerFactory LoggerFactory { get; }\r\n    public IPipelineTracer Tracer { get; }\r\n    public IDeadLetterSink? DeadLetterSink { get; }\r\n    public IPipelineErrorHandler? PipelineErrorHandler { get; }\r\n    public Properties Properties { get; }\r\n    public IErrorHandlerFactory ErrorHandlerFactory { get; }\r\n    public ILineageFactory LineageFactory { get; }\r\n    public IObservabilityFactory ObservabilityFactory { get; }\r\n    public RetryOptions RetryOptions { get; }\r\n    public StateManager StateManager { get; }\r\n    public IExecutionObserver ExecutionObserver { get; }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Members:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Items"})," - Store and retrieve shared state between nodes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Parameters"})," - Input parameters for the pipeline"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CancellationToken"})," - For graceful cancellation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"LoggerFactory"})," - Factory to create loggers for nodes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Tracer"})," - For distributed tracing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DeadLetterSink"})," - Sink for failed items"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"PipelineErrorHandler"})," - Error handler for pipeline-level errors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Properties"})," - Pipeline properties"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ErrorHandlerFactory"})," - Factory for creating error handlers and dead-letter sinks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"LineageFactory"})," - Factory for creating lineage sinks and resolving lineage collectors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ObservabilityFactory"})," - Factory for resolving observability collectors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"RetryOptions"})," - Configuration for retry behavior"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"StateManager"})," - Manages pipeline state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ExecutionObserver"})," - Observer for execution events"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'var context = new PipelineContextBuilder()\r\n    .WithCancellation(cts.Token)\r\n    .Build();\r\n\r\n// In a node:\r\nvar logger = context.LoggerFactory.CreateLogger("MyNode");\r\nlogger.Log(LogLevel.Information, "Processing item");\r\n\r\n// Access shared state\r\nif (context.Items.TryGetValue("cache", out var cacheObj))\r\n{\r\n    var sharedState = cacheObj as MyCache;\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"idatapipe",children:"IDataPipe"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Represents streaming data flow."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using NPipeline.DataFlow;\r\n\r\npublic interface IDataPipe<out T> : IAsyncEnumerable<T>\r\n{\r\n    string StreamName { get; }\r\n    // IDataPipe<T> implements IAsyncEnumerable<T> directly\r\n    // Iterate using: await foreach (var item in dataPipe)\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var dataPipe = sourceNode.Execute(context, cancellationToken);\r\nawait foreach (var item in dataPipe.WithCancellation(cancellationToken))\r\n{\r\n    // Process item\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"streamingdatapipe",children:"StreamingDataPipe"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Default implementation of IDataPipe."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.DataFlow.DataPipes;\r\n\r\npublic class StreamingDataPipe<T> : IDataPipe<T>\r\n{\r\n    public StreamingDataPipe(IAsyncEnumerable<T> data, string streamName = "");\r\n    // Implements IAsyncEnumerable<T> directly\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Create in source nodes:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"static IAsyncEnumerable<Item> ReadAsync()\r\n{\r\n    return Read();\r\n\r\n    async IAsyncEnumerable<Item> Read()\r\n    {\r\n        // Yield items\r\n        yield return new Item();\r\n    }\r\n}\r\nreturn new StreamingDataPipe<Item>(ReadAsync());\n"})}),"\n",(0,s.jsx)(n.h2,{id:"execution",children:"Execution"}),"\n",(0,s.jsx)(n.h3,{id:"pipelinerunner",children:"PipelineRunner"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Execute pipelines."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using NPipeline.Execution;\r\n\r\npublic class PipelineRunner\r\n{\r\n    public Task RunAsync<TDefinition>(\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken = default)\r\n        where TDefinition : IPipelineDefinition, new();\r\n\r\n    public Task RunAsync<TDefinition>(\r\n        CancellationToken cancellationToken = default)\r\n        where TDefinition : IPipelineDefinition, new();\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var runner = PipelineRunner.Create();\r\nvar context = new PipelineContextBuilder()\r\n    .WithCancellation(cancellationToken)\r\n    .Build();\r\n\r\nawait runner.RunAsync<MyPipeline>(context, cancellationToken);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"dependency-injection",children:"Dependency Injection"}),"\n",(0,s.jsx)(n.h3,{id:"addnpipeline-extension-assembly-scanning",children:"AddNPipeline Extension (Assembly Scanning)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Register nodes and services with automatic discovery."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public static IServiceCollection AddNPipeline(\r\n    this IServiceCollection services,\r\n    params Assembly[] assembliesToScan);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"services.AddNPipeline(\r\n    Assembly.GetExecutingAssembly(),\r\n    typeof(ConnectorAssembly).Assembly\r\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Registers:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["All ",(0,s.jsx)(n.code,{children:"INode"})," implementations as Transient"]}),"\n",(0,s.jsxs)(n.li,{children:["All ",(0,s.jsx)(n.code,{children:"IPipelineDefinition"})," implementations"]}),"\n",(0,s.jsxs)(n.li,{children:["All ",(0,s.jsx)(n.code,{children:"IPipelineErrorHandler"})," and ",(0,s.jsx)(n.code,{children:"INodeErrorHandler"})," implementations"]}),"\n",(0,s.jsxs)(n.li,{children:["All ",(0,s.jsx)(n.code,{children:"IDeadLetterSink"}),", ",(0,s.jsx)(n.code,{children:"ILineageSink"}),", and ",(0,s.jsx)(n.code,{children:"IPipelineLineageSink"})," implementations"]}),"\n",(0,s.jsxs)(n.li,{children:["All ",(0,s.jsx)(n.code,{children:"IPipelineLineageSinkProvider"})," implementations"]}),"\n",(0,s.jsx)(n.li,{children:"Pipeline infrastructure services (IPipelineFactory, IPipelineRunner, etc.)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"addnpipeline-extension-fluent-configuration",children:"AddNPipeline Extension (Fluent Configuration)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Register nodes and services with fine-grained control using a fluent API."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public static IServiceCollection AddNPipeline(\r\n    this IServiceCollection services,\r\n    Action<NPipelineServiceBuilder> configure);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"services.AddNPipeline(builder => builder\r\n    .AddNode<MySourceNode>()\r\n    .AddNode<MyTransformNode>()\r\n    .AddNode<MySinkNode>(ServiceLifetime.Singleton)\r\n    .AddPipeline<MyPipelineDefinition>()\r\n    .AddErrorHandler<MyErrorHandler>()\r\n    .AddLineageSink<MyLineageSink>()\r\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"No reflection overhead - explicit component registration"}),"\n",(0,s.jsx)(n.li,{children:"Clear, discoverable API via IntelliSense"}),"\n",(0,s.jsx)(n.li,{children:"Type-safe registration with compile-time verification"}),"\n",(0,s.jsxs)(n.li,{children:["Flexible ",(0,s.jsx)(n.code,{children:"ServiceLifetime"})," control per component (Transient, Scoped, Singleton)"]}),"\n",(0,s.jsxs)(n.li,{children:["Can mix manual registration with assembly scanning via ",(0,s.jsx)(n.code,{children:"ScanAssemblies()"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"NPipelineServiceBuilder Methods:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Register nodes\r\nAddNode<TNode>()\r\nAddNode<TNode>(ServiceLifetime lifetime)\r\n\r\n// Register pipelines\r\nAddPipeline<TPipeline>()\r\nAddPipeline<TPipeline>(ServiceLifetime lifetime)\r\n\r\n// Register error handlers\r\nAddErrorHandler<THandler>()\r\nAddErrorHandler<THandler>(ServiceLifetime lifetime)\r\nAddPipelineErrorHandler<THandler>()\r\nAddPipelineErrorHandler<THandler>(ServiceLifetime lifetime)\r\n\r\n// Register sinks\r\nAddDeadLetterSink<TSink>()\r\nAddDeadLetterSink<TSink>(ServiceLifetime lifetime)\r\nAddLineageSink<TSink>()\r\nAddLineageSink<TSink>(ServiceLifetime lifetime)\r\nAddPipelineLineageSink<TSink>()\r\nAddPipelineLineageSink<TSink>(ServiceLifetime lifetime)\r\n\r\n// Register providers\r\nAddLineageSinkProvider<TProvider>()\r\nAddLineageSinkProvider<TProvider>(ServiceLifetime lifetime)\r\n\r\n// Scan assemblies for implementations\r\nScanAssemblies(params Assembly[] assemblies)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example - Mixed Approach:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"services.AddNPipeline(builder => builder\r\n    // Register high-performance or singleton components manually\r\n    .AddNode<SpecialCachedNode>(ServiceLifetime.Singleton)\r\n    .AddPipeline<MyPipeline>()\r\n    \r\n    // Then scan remaining components from assemblies\r\n    .ScanAssemblies(\r\n        Assembly.GetExecutingAssembly(),\r\n        typeof(PluginProvider).Assembly\r\n    )\r\n);\r\n\r\n## Extensions\r\n\r\n### Parallelism Extension\r\n\r\n**Package:** `NPipeline.Extensions.Parallelism`\r\n\r\n**Configure Parallel Execution:**\r\n\r\n```csharp\r\nusing NPipeline.Extensions.Parallelism;\r\nusing NPipeline.Pipeline;\r\n\r\npublic class MyPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var source = builder.AddSource<MySource, MyData>();\r\n        var transform = builder.AddTransform<MyTransform, MyData, ProcessedData>();\r\n        var sink = builder.AddSink<MySink, ProcessedData>();\r\n\r\n        builder.Connect(source, transform);\r\n        builder.Connect(transform, sink);\r\n\r\n        // Configure parallel execution for the transform\r\n        builder.WithParallelOptions(\r\n            new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount }\r\n        );\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Method:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public static PipelineBuilder WithParallelOptions(this PipelineBuilder builder, ParallelOptions options)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"testing-extension",children:"Testing Extension"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Package:"})," ",(0,s.jsx)(n.code,{children:"NPipeline.Extensions.Testing"})]}),"\n",(0,s.jsx)(n.h4,{id:"inmemorysourcenode",children:"InMemorySourceNode"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using NPipeline.Extensions.Testing;\r\n\r\npublic class InMemorySourceNode<T> : SourceNode<T>\r\n{\r\n    public T[] Data { get; set; }\r\n    public override IDataPipe<T> ExecuteAsync(\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var source = new InMemorySourceNode<int> { Data = new[] { 1, 2, 3 } };\n"})}),"\n",(0,s.jsx)(n.h4,{id:"inmemorysinknodet",children:(0,s.jsx)(n.code,{children:"InMemorySinkNode<T>"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class InMemorySinkNode<T> : SinkNode<T>\r\n{\r\n    public Task<List<T>> Completion { get; }\r\n    public override Task ExecuteAsync(\r\n        IDataPipe<T> input,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var sink = new InMemorySinkNode<int>();\r\n// ... run pipeline ...\r\nvar results = await sink.Completion;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"connectors",children:"Connectors"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"CSV Connector:"})," ",(0,s.jsx)(n.code,{children:"NPipeline.Connectors.Csv"})," (Available in initial release)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CsvSourceNode<T>"})," - Read CSV files"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CsvSinkNode<T>"})," - Write CSV files"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'var source = new CsvSourceNode<Customer>("customers.csv");\r\nvar sink = new CsvSinkNode<ProcessedCustomer>("output.csv");\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Excel Connector:"})," ",(0,s.jsx)(n.code,{children:"NPipeline.Connectors.Excel"})," (Planned for future release)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ExcelSourceNode<T>"})," - Read Excel files"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ExcelSinkNode<T>"})," - Write Excel files"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"AWS Connector:"})," ",(0,s.jsx)(n.code,{children:"NPipeline.Connectors.Aws"})," (Planned for future release)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"S3SourceNode<T>"})," - Read from S3"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SqsSourceNode<T>"})," - Read from SQS"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"S3SinkNode<T>"})," - Write to S3"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"create-pipeline-and-run",children:"Create Pipeline and Run"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using NPipeline.Execution;\r\nusing NPipeline.Pipeline;\r\n\r\npublic class MyPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var source = builder.AddSource<MySource, MyData>();\r\n        var transform = builder.AddTransform<MyTransform, MyData, ProcessedData>();\r\n        var sink = builder.AddSink<MySink, ProcessedData>();\r\n\r\n        builder.Connect(source, transform);\r\n        builder.Connect(transform, sink);\r\n    }\r\n}\r\n\r\n// Execute\r\nvar runner = PipelineRunner.Create();\r\nvar context = new PipelineContext();\r\nawait runner.RunAsync<MyPipeline>(context);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"use-with-dependency-injection",children:"Use with Dependency Injection"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using Microsoft.Extensions.DependencyInjection;\r\nusing NPipeline.Extensions.DependencyInjection;\r\n\r\n// Approach 1: Assembly Scanning (automatic discovery)\r\nvar services = new ServiceCollection();\r\nservices.AddLogging();\r\nservices.AddNPipeline(Assembly.GetExecutingAssembly());\r\n\r\nvar provider = services.BuildServiceProvider();\r\nvar runner = provider.GetRequiredService<IPipelineRunner>();\r\nawait runner.RunAsync<MyPipeline>();\r\n\r\n// Approach 2: Fluent Configuration (explicit registration)\r\nvar services = new ServiceCollection();\r\nservices.AddLogging();\r\nservices.AddNPipeline(builder => builder\r\n    .AddNode<MySourceNode>()\r\n    .AddNode<MyTransformNode>()\r\n    .AddNode<MySinkNode>()\r\n    .AddPipeline<MyPipeline>()\r\n);\r\n\r\nvar provider = services.BuildServiceProvider();\r\nvar runner = provider.GetRequiredService<IPipelineRunner>();\r\nawait runner.RunAsync<MyPipeline>();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"handle-cancellation",children:"Handle Cancellation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using var cts = new CancellationTokenSource(TimeSpan.FromMinutes(5));\r\n\r\nvar context = new PipelineContext\r\n{\r\n    CancellationToken = cts.Token\r\n};\r\n\r\ntry\r\n{\r\n    await runner.RunAsync<MyPipeline>(context, cts.Token);\r\n}\r\ncatch (OperationCanceledException)\r\n{\r\n    Console.WriteLine("Pipeline was cancelled");\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"share-state-between-nodes",children:"Share State Between Nodes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'var context = new PipelineContext();\r\ncontext.Items["cache"] = new Dictionary<int, Customer>();\r\ncontext.Items["stats"] = new ProcessingStats();\r\n\r\n// In nodes:\r\nif (context.Items.TryGetValue("cache", out var cacheObj))\r\n{\r\n    var cache = cacheObj as Dictionary<int, Customer>;\r\n}\r\nif (context.Items.TryGetValue("stats", out var statsObj))\r\n{\r\n    var stats = statsObj as ProcessingStats;\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"custom-error-handling",children:"Custom Error Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using NPipeline.Observability.Logging;\r\n\r\npublic override async Task<Item> ExecuteAsync(\r\n    Item item,\r\n    PipelineContext context,\r\n    CancellationToken cancellationToken)\r\n{\r\n    var logger = context.LoggerFactory.CreateLogger("MyTransform");\r\n\r\n    try\r\n    {\r\n        return await ProcessAsync(item, cancellationToken);\r\n    }\r\n    catch (ValidationException ex)\r\n    {\r\n        logger.Log(LogLevel.Warning, $"Validation failed: {ex.Message}");\r\n        throw;\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        logger.Log(LogLevel.Error, ex, "Unexpected error");\r\n        throw;\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"quick-lookup-table",children:"Quick Lookup Table"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Need"}),(0,s.jsx)(n.th,{children:"Class/Method"}),(0,s.jsx)(n.th,{children:"Package"}),(0,s.jsx)(n.th,{children:"Availability"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Define pipeline"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"IPipelineDefinition"})}),(0,s.jsx)(n.td,{children:"Core"}),(0,s.jsx)(n.td,{children:"Initial Release"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Create source"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"SourceNode<T>"})}),(0,s.jsx)(n.td,{children:"Core"}),(0,s.jsx)(n.td,{children:"Initial Release"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Create transform"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"TransformNode<TIn, TOut>"})}),(0,s.jsx)(n.td,{children:"Core"}),(0,s.jsx)(n.td,{children:"Initial Release"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Create sink"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"SinkNode<T>"})}),(0,s.jsx)(n.td,{children:"Core"}),(0,s.jsx)(n.td,{children:"Initial Release"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Run pipeline"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PipelineRunner.RunAsync<T>()"})}),(0,s.jsx)(n.td,{children:"Core"}),(0,s.jsx)(n.td,{children:"Initial Release"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Share state"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PipelineContext.Items"})}),(0,s.jsx)(n.td,{children:"Core"}),(0,s.jsx)(n.td,{children:"Initial Release"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Register nodes"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"AddNPipeline()"})}),(0,s.jsx)(n.td,{children:"Core"}),(0,s.jsx)(n.td,{children:"Initial Release"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Parallel execution"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"WithParallelOptions()"})}),(0,s.jsx)(n.td,{children:"Extensions.Parallelism"}),(0,s.jsx)(n.td,{children:"Initial Release"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Unit testing"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"InMemorySourceNode<T>"}),", ",(0,s.jsx)(n.code,{children:"InMemorySinkNode<T>"})]}),(0,s.jsx)(n.td,{children:"Extensions.Testing"}),(0,s.jsx)(n.td,{children:"Initial Release"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Read CSV"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"CsvSourceNode<T>"})}),(0,s.jsx)(n.td,{children:"Connectors.Csv"}),(0,s.jsx)(n.td,{children:"Initial Release"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Write CSV"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"CsvSinkNode<T>"})}),(0,s.jsx)(n.td,{children:"Connectors.Csv"}),(0,s.jsx)(n.td,{children:"Initial Release"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/common-patterns",children:"Common Patterns"})})," - Practical examples"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/architecture/",children:"Architecture"})})," - Deep dive into how NPipeline works"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/core-concepts/best-practices",children:"Best Practices"})})," - Design guidelines"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/getting-started/quick-start",children:"Getting Started"})})," - Installation and first pipeline"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>t});var i=r(6540);const s={},l=i.createContext(s);function c(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);