"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[2125],{6933:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"architecture/error-handling-architecture","title":"Error Handling Architecture","description":"How errors propagate and are handled throughout NPipeline.","source":"@site/docs/architecture/error-handling-architecture.md","sourceDirName":"architecture","slug":"/architecture/error-handling-architecture","permalink":"/docs/architecture/error-handling-architecture","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Error Handling Architecture","description":"How errors propagate and are handled throughout NPipeline.","sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Node Instantiation","permalink":"/docs/architecture/node-instantiation"},"next":{"title":"Cancellation Model","permalink":"/docs/architecture/cancellation-model"}}');var i=n(4848),a=n(8453);const o={title:"Error Handling Architecture",description:"How errors propagate and are handled throughout NPipeline.",sidebar_position:6},s="Error Handling Architecture",d={},l=[{value:"Error Propagation",id:"error-propagation",level:2},{value:"Error Containment",id:"error-containment",level:2},{value:"Dead-Letter Handling",id:"dead-letter-handling",level:2},{value:"Retry Patterns",id:"retry-patterns",level:2},{value:"Error Context and Lineage",id:"error-context-and-lineage",level:2},{value:"Supporting Components",id:"supporting-components",level:2},{value:"Materialization Node",id:"materialization-node",level:3},{value:"Stateful Registry",id:"stateful-registry",level:3},{value:"Error Handling Strategies",id:"error-handling-strategies",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"error-handling-architecture",children:"Error Handling Architecture"})}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"This page explains WHAT happens when errors occur in pipelines."})," For HOW TO implement error handling and resilience, see ",(0,i.jsx)(r.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling"})," and ",(0,i.jsx)(r.a,{href:"/docs/core-concepts/resilience/",children:"Resilience Overview"}),"."]}),"\n",(0,i.jsx)(r.p,{children:"NPipeline provides multiple strategies for handling errors that occur during pipeline execution, from early failure to graceful degradation."}),"\n",(0,i.jsx)(r.h2,{id:"error-propagation",children:"Error Propagation"}),"\n",(0,i.jsx)(r.p,{children:"By default, errors propagate up the pipeline and stop execution:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:"var sourcePipe = await source.Initialize(context, ct);      // Returns 100 items\r\nvar transformPipe = new TransformPipe(sourcePipe, transform); // Processing...\r\n\r\n// Error occurs on item #50\r\ntry\r\n{\r\n    await foreach (var item in transformPipe.WithCancellation(ct))\r\n    {\r\n        await sink.ProcessAsync(item);\r\n    }\r\n}\r\ncatch (InvalidOperationException ex)\r\n{\r\n    // Error caught here - items 51-100 never processed\r\n}\n"})}),"\n",(0,i.jsx)(r.h2,{id:"error-containment",children:"Error Containment"}),"\n",(0,i.jsx)(r.p,{children:"Contain errors within a node to prevent pipeline failure:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'public class SafeTransform : ITransformNode<Input, Output>\r\n{\r\n    private readonly ITransformNode<Input, Output> _inner;\r\n    private readonly ILogger<SafeTransform> _logger;\r\n\r\n    public SafeTransform(\r\n        ITransformNode<Input, Output> inner,\r\n        ILogger<SafeTransform> logger)\r\n    {\r\n        _inner = inner;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task<Output> ExecuteAsync(\r\n        Input item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        try\r\n        {\r\n            return await _inner.ExecuteAsync(item, context, cancellationToken);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Error processing item: {@input}", item);\r\n            // Rethrow or return default value depending on strategy\r\n            throw;\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"dead-letter-handling",children:"Dead-Letter Handling"}),"\n",(0,i.jsx)(r.p,{children:"Route failed items to a dead-letter sink configured in the pipeline context:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'// Configure dead-letter sink when building pipeline context\r\nvar deadLetterSink = new FileDeadLetterSink("dead-letters.json");\r\nvar context = PipelineContext.WithErrorHandling(deadLetterSink: deadLetterSink);\r\n\r\n// In a transform node, use INodeErrorHandler to route failed items\r\npublic class OrderTransform : ITransformNode<Order, ProcessedOrder>\r\n{\r\n    public INodeErrorHandler? ErrorHandler { get; set; }\r\n\r\n    public async Task<ProcessedOrder> ExecuteAsync(\r\n        Order item,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        try\r\n        {\r\n            // Validate and process order\r\n            if (item.Amount <= 0)\r\n                throw new InvalidOperationException("Invalid order amount");\r\n                \r\n            return new ProcessedOrder { /* ... */ };\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            // Error handler can route to dead-letter sink\r\n            ErrorHandler?.Handle(item, ex, context);\r\n            throw; // Or return default value depending on strategy\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"retry-patterns",children:"Retry Patterns"}),"\n",(0,i.jsxs)(r.p,{children:["Configure retry behavior using ",(0,i.jsx)(r.code,{children:"PipelineRetryOptions"}),":"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:"// Global retry configuration\r\nvar builder = new PipelineBuilder();\r\nbuilder.ConfigureRetry(new PipelineRetryOptions\r\n{\r\n    MaxRetries = 3,\r\n    InitialDelayMs = 100,\r\n    MaxDelayMs = 5000,\r\n    BackoffMultiplier = 2.0\r\n});\r\n\r\n// Or per-node retry configuration\r\nvar nodeRetryOptions = new PipelineRetryOptions\r\n{\r\n    MaxRetries = 3,\r\n    RetryDelay = TimeSpan.FromSeconds(1),\r\n    ShouldRetry = (exception) => \r\n        exception is TimeoutException or HttpRequestException\r\n};\r\nbuilder.ConfigureNodeRetry<FetchInventoryTransform>(nodeRetryOptions);\r\n\r\nvar pipeline = builder\r\n    .AddSourceNode<OrderSourceNode>()\r\n    .AddTransformNode<FetchInventoryTransform>()  // May fail temporarily\r\n    .AddTransformNode<ProcessOrderTransform>()\r\n    .AddSinkNode<OrderSinkNode>()\r\n    .BuildPipeline();\n"})}),"\n",(0,i.jsx)(r.h2,{id:"error-context-and-lineage",children:"Error Context and Lineage"}),"\n",(0,i.jsx)(r.p,{children:"Track errors using the current node ID and lineage tracking:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'// Access current node information during error handling\r\npublic override async Task<ProcessedOrder> ExecuteAsync(\r\n    Order item,\r\n    PipelineContext context,\r\n    CancellationToken cancellationToken)\r\n{\r\n    try\r\n    {\r\n        // Process order\r\n        return await ProcessAsync(item, cancellationToken);\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        var currentNodeId = context.CurrentNodeId;\r\n        \r\n        // Log complete error with context\r\n        logger.LogError(\r\n            ex,\r\n            "Error at node {nodeId}: {error}",\r\n            currentNodeId,\r\n            ex.Message);\r\n            \r\n        throw;\r\n    }\r\n}\r\n\r\n// Enable item-level lineage tracking to see all nodes that have processed an item\r\nvar builder = new PipelineBuilder();\r\nbuilder.EnableItemLevelLineage();\n'})}),"\n",(0,i.jsx)(r.h2,{id:"supporting-components",children:"Supporting Components"}),"\n",(0,i.jsx)(r.h3,{id:"materialization-node",children:"Materialization Node"}),"\n",(0,i.jsx)(r.p,{children:"Buffer entire streams to catch downstream errors early:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:"// Materialize (collect all items) to detect errors before processing\r\nvar materialized = new MaterializationNode<Order>();\r\nvar pipeline = PipelineBuilder\r\n    .AddSourceNode<OrderSourceNode>()\r\n    .AddNode(materialized) // Buffers all orders\r\n    .AddTransformNode<ValidateOrderTransform>()\r\n    .AddSinkNode<OrderSinkNode>()\r\n    .BuildPipeline();\n"})}),"\n",(0,i.jsx)(r.h3,{id:"stateful-registry",children:"Stateful Registry"}),"\n",(0,i.jsx)(r.p,{children:"Maintain error state across pipeline executions:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'var registry = new StatefulRegistry();\r\n\r\nfor (int i = 0; i < 5; i++)\r\n{\r\n    try\r\n    {\r\n        await runner.ExecuteAsync(pipeline, context);\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        registry.RecordError(ex);\r\n    }\r\n}\r\n\r\nvar stats = registry.GetErrorStatistics();\r\nlogger.LogInformation("Total errors: {count}", stats.ErrorCount);\n'})}),"\n",(0,i.jsx)(r.h2,{id:"error-handling-strategies",children:"Error Handling Strategies"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Strategy"}),(0,i.jsx)(r.th,{children:"Best For"}),(0,i.jsx)(r.th,{children:"Trade-offs"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Fail Fast"})}),(0,i.jsx)(r.td,{children:"Data quality critical"}),(0,i.jsx)(r.td,{children:"May lose unprocessed items"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Skip Errors"})}),(0,i.jsx)(r.td,{children:"Best-effort processing"}),(0,i.jsx)(r.td,{children:"Silent failures may hide bugs"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Dead-Letter"})}),(0,i.jsx)(r.td,{children:"Audit trail required"}),(0,i.jsx)(r.td,{children:"Added storage overhead"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Retry"})}),(0,i.jsx)(r.td,{children:"Transient failures"}),(0,i.jsx)(r.td,{children:"Delayed processing, retry storms"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Materialize First"})}),(0,i.jsx)(r.td,{children:"Need all data or nothing"}),(0,i.jsx)(r.td,{children:"Memory overhead"})]})]})]}),"\n",(0,i.jsx)(r.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/docs/architecture/cancellation-model",children:"Cancellation Model"})})," - Learn how cancellation interacts with error handling"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/docs/architecture/performance-characteristics",children:"Performance Characteristics"})})," - Understand error handling performance impact"]}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>s});var t=n(6540);const i={},a=t.createContext(i);function o(e){const r=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(a.Provider,{value:r},e.children)}}}]);