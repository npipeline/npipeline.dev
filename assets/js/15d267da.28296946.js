"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[6907],{1281:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"core-concepts/inode","title":"INode and its Derivatives","description":"Learn about the different types of nodes that form the building blocks of a pipeline.","source":"@site/docs/core-concepts/inode.md","sourceDirName":"core-concepts","slug":"/core-concepts/inode","permalink":"/docs/core-concepts/inode","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"INode and its Derivatives","description":"Learn about the different types of nodes that form the building blocks of a pipeline.","sidebar_position":3,"slug":"/core-concepts/inode"},"sidebar":"docsSidebar","previous":{"title":"Grouping Strategies - Batching vs Aggregation","permalink":"/docs/core-concepts/grouping-strategies"},"next":{"title":"Nodes (Source, Transform, Sink)","permalink":"/docs/core-concepts/nodes/"}}');var t=i(4848),s=i(8453);const o={title:"INode and its Derivatives",description:"Learn about the different types of nodes that form the building blocks of a pipeline.",sidebar_position:3,slug:"/core-concepts/inode"},a="INode and its Derivatives",c={},l=[{value:"The Node Hierarchy",id:"the-node-hierarchy",level:2},{value:"ISourceNode&lt;TOut&gt;",id:"isourcenodetout",level:2},{value:"Definition",id:"definition",level:3},{value:"Key Design Pattern: Synchronous Pipe Creation + Asynchronous Iteration",id:"key-design-pattern-synchronous-pipe-creation--asynchronous-iteration",level:3},{value:"Example",id:"example",level:3},{value:"ITransformNode&lt;TIn, TOut&gt;",id:"itransformnodetin-tout",level:2},{value:"Definition",id:"definition-1",level:3},{value:"Example",id:"example-1",level:3},{value:"ISinkNode&lt;TIn&gt;",id:"isinknodetin",level:2},{value:"Sink Definition",id:"sink-definition",level:3},{value:"Example",id:"example-2",level:3},{value:"\u27a1\ufe0f Next Steps",id:"arrow_right-next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"inode-and-its-derivatives",children:"INode and its Derivatives"})}),"\n",(0,t.jsxs)(n.p,{children:["In NPipeline, nodes are the fundamental units of work. Every operation in a pipeline, from data generation to transformation and final output, is performed by a node. All nodes inherit from the base ",(0,t.jsx)(n.code,{children:"INode"})," marker interface."]}),"\n",(0,t.jsx)(n.h2,{id:"the-node-hierarchy",children:"The Node Hierarchy"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"INode"})," interface is the common root for all pipeline nodes. It is a simple marker interface that also implements ",(0,t.jsx)(n.code,{children:"IAsyncDisposable"})," to allow for proper resource cleanup."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public interface INode : IAsyncDisposable { }\n"})}),"\n",(0,t.jsx)(n.p,{children:"There are three specialized types of nodes, each with a distinct role in the pipeline:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ISourceNode<TOut>"})}),": Produces data to start a pipeline."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ITransformNode<TIn, TOut>"})}),": Processes data from an upstream node and passes it to a downstream node."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ISinkNode<TIn>"})}),": Consumes data, typically at the end of a pipeline."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"isourcenodetout",children:"ISourceNode<TOut>"}),"\n",(0,t.jsx)(n.p,{children:"A source node is the starting point of a pipeline. It is responsible for generating or fetching the initial data that will be processed. A pipeline must have at least one source node."}),"\n",(0,t.jsx)(n.h3,{id:"definition",children:"Definition"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public interface ISourceNode<out TOut> : INode\r\n{\r\n    IDataPipe<TOut> ExecuteAsync(PipelineContext context, CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"TOut"})}),": The type of data that the source node produces (covariant)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ExecuteAsync"})}),": This method is called by the pipeline runner to start data production. It returns an ",(0,t.jsx)(n.code,{children:"IDataPipe<TOut>"})," synchronously, which is a channel through which data flows to the next node."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"key-design-pattern-synchronous-pipe-creation--asynchronous-iteration",children:"Key Design Pattern: Synchronous Pipe Creation + Asynchronous Iteration"}),"\n",(0,t.jsx)(n.p,{children:"NPipeline separates concerns into two distinct phases:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Phase 1 (Synchronous):"})," Pipe Creation"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ExecuteAsync()"})," creates and returns the pipe immediately (synchronously)"]}),"\n",(0,t.jsxs)(n.li,{children:["No ",(0,t.jsx)(n.code,{children:"await"})," needed when calling this method"]}),"\n",(0,t.jsx)(n.li,{children:"The pipeline reference is established without blocking"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Phase 2 (Asynchronous):"})," Data Consumption"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The returned pipe is an ",(0,t.jsx)(n.code,{children:"IAsyncEnumerable<T>"})]}),"\n",(0,t.jsx)(n.li,{children:"Data flows asynchronously when downstream nodes enumerate it"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"await foreach"})," is used when consuming data items"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Mental Model - File I/O Analogy:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// File I/O pattern:\r\nvar stream = File.OpenRead(path);           // Sync - open stream immediately\r\nvar bytes = await stream.ReadAsync(...);    // Async - read from stream\r\n\r\n// NPipeline pattern:\r\nvar pipe = source.ExecuteAsync(...);        // Sync - create pipe immediately  \r\nvar item = await pipe.FirstAsync();         // Async - read item from pipe\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why This Design?"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Clearer Intent:"}),' "ExecuteAsync" signals you\'re in the async execution system, but the pipe creation itself is fast and synchronous']}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Type Safety:"})," Covariant ",(0,t.jsx)(n.code,{children:"IDataPipe<T>"})," (not invariant ",(0,t.jsx)(n.code,{children:"Task<IDataPipe<T>>"}),") enables better type compatibility"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Performance:"})," No unnecessary ",(0,t.jsx)(n.code,{children:"Task"})," allocations for pipe creation"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Consistency:"})," Uniform pattern across all source nodes"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.p,{children:"Here is an example of a simple source node that produces a sequence of numbers:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public sealed class NumberSource : SourceNode<int>\r\n{\r\n    public override IDataPipe<int> ExecuteAsync(PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        return new StreamingDataPipe<int>(Stream());\r\n\r\n        static async IAsyncEnumerable<int> Stream()\r\n        {\r\n            for (int i = 1; i <= 10; i++)\r\n            {\r\n                yield return i;\r\n                await Task.Delay(100); // Simulate work\r\n            }\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"itransformnodetin-tout",children:"ITransformNode<TIn, TOut>"}),"\n",(0,t.jsx)(n.p,{children:"A transform node sits between a source and a sink (or between other transforms). It receives data, performs an operation on it, and then outputs the modified data."}),"\n",(0,t.jsx)(n.h3,{id:"definition-1",children:"Definition"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public interface ITransformNode : INode\r\n{\r\n    IExecutionStrategy ExecutionStrategy { get; set; }\r\n    INodeErrorHandler? ErrorHandler { get; set; }\r\n}\r\n\r\npublic interface ITransformNode<in TIn, TOut> : ITransformNode\r\n{\r\n    Task<TOut> ExecuteAsync(TIn item, PipelineContext context, CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"TIn"})}),": The type of data the node receives."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"TOut"})}),": The type of data the node outputs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ExecuteAsync"})}),": This method is called for each individual item that flows into the node."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ExecutionStrategy"})}),": Gets or sets the execution strategy for this node."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ErrorHandler"})}),": Gets or sets the error handler for this node."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,t.jsx)(n.p,{children:"This transform takes an integer, squares it, and returns the result as a string."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public sealed class SquareAndStringifyTransform : ITransformNode<int, string>\r\n{\r\n    public IExecutionStrategy ExecutionStrategy { get; set; } = new SequentialExecutionStrategy();\r\n    public INodeErrorHandler? ErrorHandler { get; set; }\r\n\r\n    public Task<string> ExecuteAsync(int item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        int squared = item * item;\r\n        return Task.FromResult($"The square is {squared}");\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"isinknodetin",children:"ISinkNode<TIn>"}),"\n",(0,t.jsx)(n.p,{children:"A sink node is a terminal point in a pipeline. It receives data but does not produce any output for other nodes. Its purpose is to perform a final action, such as writing to a database, logging to the console, or sending data to an external API."}),"\n",(0,t.jsx)(n.h3,{id:"sink-definition",children:"Sink Definition"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public interface ISinkNode<in TIn> : INode\r\n{\r\n    Task ExecuteAsync(IDataPipe<TIn> input, PipelineContext context, CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"TIn"})}),": The type of data the node receives (contravariant)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ExecuteAsync"})}),": This method receives the ",(0,t.jsx)(n.code,{children:"IDataPipe<TIn>"})," containing all the data from the upstream node and is responsible for consuming it."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-2",children:"Example"}),"\n",(0,t.jsx)(n.p,{children:"This sink node simply prints the incoming strings to the console."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public sealed class ConsoleSink : ISinkNode<string>\r\n{\r\n    public async Task ExecuteAsync(IDataPipe<string> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            Console.WriteLine(item);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"arrow_right-next-steps",children:["\u27a1\ufe0f"," Next Steps"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Learn how to connect these nodes together using the ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/pipelinebuilder",children:"PipelineBuilder"})}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["See how to create a runnable ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/ipipeline",children:"Pipeline"})})," instance."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var r=i(6540);const t={},s=r.createContext(t);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);