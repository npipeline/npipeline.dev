"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[1128],{5169:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"core-concepts/pipeline-definition","title":"Pipeline Definition (IPipelineDefinition, PipelineBuilder)","description":"Learn how to define and construct your data pipelines using IPipelineDefinition and fluent PipelineBuilder API.","source":"@site/docs/core-concepts/pipeline-definition.md","sourceDirName":"core-concepts","slug":"/core-concepts/pipeline-definition","permalink":"/docs/core-concepts/pipeline-definition","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Pipeline Definition (IPipelineDefinition, PipelineBuilder)","description":"Learn how to define and construct your data pipelines using IPipelineDefinition and fluent PipelineBuilder API.","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Dead-Letter Queues","permalink":"/docs/core-concepts/resilience/dead-letter-queues"},"next":{"title":"PipelineBuilder","permalink":"/docs/core-concepts/pipelinebuilder"}}');var l=i(4848),t=i(8453);const s={title:"Pipeline Definition (IPipelineDefinition, PipelineBuilder)",description:"Learn how to define and construct your data pipelines using IPipelineDefinition and fluent PipelineBuilder API.",sidebar_position:5},o="Pipeline Definition: IPipelineDefinition and PipelineBuilder",d={},c=[{value:"<code>IPipelineDefinition</code>: Class-based Pipeline Definition",id:"ipipelinedefinition-class-based-pipeline-definition",level:2},{value:"Interface Definition",id:"interface-definition",level:3},{value:"Implementation Example",id:"implementation-example",level:3},{value:"Executing with PipelineRunner",id:"executing-with-pipelinerunner",level:3},{value:"<code>PipelineBuilder</code>: Fluent API for Direct Construction",id:"pipelinebuilder-fluent-api-for-direct-construction",level:2},{value:"Key Methods",id:"key-methods",level:3},{value:"Example Usage",id:"example-usage",level:3},{value:"Choosing Your Approach",id:"choosing-your-approach",level:2},{value:"When to Use IPipelineDefinition",id:"when-to-use-ipipelinedefinition",level:2},{value:"Related Topics",id:"related-topics",level:2}];function a(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsxs)(n.h1,{id:"pipeline-definition-ipipelinedefinition-and-pipelinebuilder",children:["Pipeline Definition: ",(0,l.jsx)(n.code,{children:"IPipelineDefinition"})," and ",(0,l.jsx)(n.code,{children:"PipelineBuilder"})]})}),"\n",(0,l.jsxs)(n.p,{children:["Defining a pipeline in NPipeline involves specifying the sequence of nodes and how they connect. NPipeline provides two primary ways to achieve this: implementing ",(0,l.jsx)(n.code,{children:"IPipelineDefinition"})," interface for a class-based approach, or using the fluent ",(0,l.jsx)(n.code,{children:"PipelineBuilder"})," API for direct construction."]}),"\n",(0,l.jsxs)(n.h2,{id:"ipipelinedefinition-class-based-pipeline-definition",children:[(0,l.jsx)(n.code,{children:"IPipelineDefinition"}),": Class-based Pipeline Definition"]}),"\n",(0,l.jsxs)(n.p,{children:["For more complex or reusable pipeline structures, you can define your pipeline by implementing ",(0,l.jsx)(n.code,{children:"IPipelineDefinition"})," interface. This allows you to encapsulate the pipeline's structure within a dedicated class, making it easier to manage and test. It is particularly useful for complex pipelines or when using dependency injection."]}),"\n",(0,l.jsx)(n.h3,{id:"interface-definition",children:"Interface Definition"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"public interface IPipelineDefinition\r\n{\r\n    void Define(PipelineBuilder builder, PipelineContext context);\r\n}\n"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"Define"})}),": This method is where you add your sources, transforms, and sinks to the provided ",(0,l.jsx)(n.code,{children:"builder"}),". The ",(0,l.jsx)(n.code,{children:"context"})," parameter allows for more dynamic pipeline construction based on runtime parameters."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"implementation-example",children:"Implementation Example"}),"\n",(0,l.jsx)(n.p,{children:"Let's define a pipeline that sources strings, transforms them to uppercase, and then sinks them to the console:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n// Re-using nodes from Quick Start\r\npublic sealed class HelloWorldSource : ISourceNode<string>\r\n{\r\n    public IDataPipe<string> Initialize(PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        static IAsyncEnumerable<string> Stream()\r\n        {\r\n            return Generate();\r\n\r\n            async IAsyncEnumerable<string> Generate()\r\n            {\r\n                yield return "Hello World!";\r\n            }\r\n        }\r\n\r\n        return new StreamingDataPipe<string>(Stream());\r\n    }\r\n}\r\n\r\npublic sealed class UppercaseTransform : ITransformNode<string, string>\r\n{\r\n    public async Task<string> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        return item.ToUpperInvariant();\r\n    }\r\n}\r\n\r\npublic sealed class ConsoleSink : ISinkNode<string>\r\n{\r\n    public async Task ExecuteAsync(IDataPipe<string> input, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            Console.WriteLine(item);\r\n        }\r\n    }\r\n}\r\n\r\npublic sealed class MyHelloWorldPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<HelloWorldSource, string>();\r\n        var transformHandle = builder.AddTransform<UppercaseTransform, string, string>();\r\n        var sinkHandle = builder.AddSink<ConsoleSink, string>();\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n    }\r\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"executing-with-pipelinerunner",children:"Executing with PipelineRunner"}),"\n",(0,l.jsxs)(n.p,{children:["Instead of calling ",(0,l.jsx)(n.code,{children:"Build()"})," yourself, you pass the definition type to a ",(0,l.jsx)(n.code,{children:"PipelineRunner"}),". The runner is responsible for creating the pipeline from your definition and executing it."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'public static async Task Main(string[] args)\r\n{\r\n    var runner = PipelineRunner.Create();\r\n\r\n    Console.WriteLine("Starting pipeline from definition...");\r\n    await runner.RunAsync<MyHelloWorldPipelineDefinition>();\r\n    Console.WriteLine("Pipeline finished.");\r\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["This approach separates the ",(0,l.jsx)(n.em,{children:"definition"})," of the pipeline from its ",(0,l.jsx)(n.em,{children:"execution"}),", leading to cleaner, more maintainable code."]}),"\n",(0,l.jsxs)(n.h2,{id:"pipelinebuilder-fluent-api-for-direct-construction",children:[(0,l.jsx)(n.code,{children:"PipelineBuilder"}),": Fluent API for Direct Construction"]}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"PipelineBuilder"})," offers a fluent, expressive API for constructing pipelines directly in your code. This is often preferred for simpler pipelines or when you want to define a pipeline ad-hoc."]}),"\n",(0,l.jsx)(n.h3,{id:"key-methods",children:"Key Methods"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"new PipelineBuilder()"}),": Creates a new pipeline builder instance."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"AddSource<TNode, TOut>()"}),": Adds a source node to the pipeline and returns a handle."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"AddTransform<TNode, TIn, TOut>()"}),": Adds a transform node and returns a handle. The input type ",(0,l.jsx)(n.code,{children:"TIn"})," must match the output type of the connected source."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"AddSink<TNode, TIn>()"}),": Adds a sink node and returns a handle. The input type ",(0,l.jsx)(n.code,{children:"TIn"})," must match the output type of the connected node."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Connect(handle1, handle2)"}),": Connects two node handles in the pipeline."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Build()"}),": Finalizes the pipeline definition and returns a ",(0,l.jsx)(n.code,{children:"Pipeline"})," instance ready for execution."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"example-usage",children:"Example Usage"}),"\n",(0,l.jsx)(n.p,{children:"Here's how to use PipelineBuilder to create and execute a pipeline:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n// Assume HelloWorldSource, UppercaseTransform, and ConsoleSink are defined as above\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var runner = PipelineRunner.Create();\r\n\r\n        // Execute the pipeline definition\r\n        await runner.RunAsync<HelloWorldPipelineDefinition>();\r\n\r\n        Console.WriteLine("Pipeline finished.");\r\n    }\r\n}\r\n\r\n// Pipeline definition that uses PipelineBuilder\r\npublic sealed class HelloWorldPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<HelloWorldSource, string>();\r\n        var transformHandle = builder.AddTransform<UppercaseTransform, string, string>();\r\n        var sinkHandle = builder.AddSink<ConsoleSink, string>();\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n    }\r\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"The key insight is that even when using PipelineBuilder directly, you still need to wrap it in an IPipelineDefinition class to execute it with PipelineRunner. This provides a consistent execution model while still allowing you to use the fluent PipelineBuilder API."}),"\n",(0,l.jsx)(n.p,{children:"Alternatively, you can create the pipeline manually using PipelineFactory:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n// Assume HelloWorldSource, UppercaseTransform, and ConsoleSink are defined as above\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        // Create a pipeline manually\r\n        var context = new PipelineContext();\r\n        var factory = new PipelineFactory();\r\n        var builder = new PipelineBuilder();\r\n\r\n        var sourceHandle = builder.AddSource<HelloWorldSource, string>();\r\n        var transformHandle = builder.AddTransform<UppercaseTransform, string, string>();\r\n        var sinkHandle = builder.AddSink<ConsoleSink, string>();\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n\r\n        var pipeline = builder.Build();\r\n\r\n        // Execute using a custom runner that accepts a Pipeline instance\r\n        var runner = PipelineRunner.Create();\r\n\r\n        // Since PipelineRunner only works with IPipelineDefinition,\r\n        // we need to create a wrapper definition\r\n        await runner.RunAsync(() => pipeline);\r\n\r\n        Console.WriteLine("Pipeline finished.");\r\n    }\r\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"choosing-your-approach",children:"Choosing Your Approach"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"IPipelineDefinition"}),":"]})," Ideal for complex, multi-stage pipelines that benefit from being defined in their own class, promoting reusability and separation of concerns. Useful when integrating with dependency injection frameworks where pipeline definitions can be registered and resolved."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"PipelineBuilder"})," within ",(0,l.jsx)(n.code,{children:"IPipelineDefinition"}),":"]})," Excellent for simple, straightforward pipelines or when you want to use the fluent API. Even when using PipelineBuilder directly, you still need to wrap it in an IPipelineDefinition class for execution."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Both approaches ultimately use the ",(0,l.jsx)(n.code,{children:"PipelineRunner"})," with an ",(0,l.jsx)(n.code,{children:"IPipelineDefinition"})," for execution, but differ in how you structure your pipeline definition code."]}),"\n",(0,l.jsx)(n.h2,{id:"when-to-use-ipipelinedefinition",children:"When to Use IPipelineDefinition"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Complex Pipelines"}),": For pipelines with many nodes or complex branching and joining logic, encapsulating the definition in a class improves organization."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Dependency Injection"}),": When your nodes have dependencies that need to be injected, ",(0,l.jsx)(n.code,{children:"IPipelineDefinition"})," is the preferred approach as it integrates cleanly with DI containers."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Reusability"}),": If you have common pipeline structures that you want to reuse, you can create base definition classes."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.a,{href:"/docs/core-concepts/pipeline-execution",children:"Pipeline Execution"})}),": Learn how to run your defined pipelines."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.a,{href:"/docs/core-concepts/pipeline-context",children:"Pipeline Context"})}),": Understand how to pass state and configuration to your pipeline nodes."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.a,{href:"/docs/core-concepts/ipipeline",children:"Pipeline"})}),": Learn about the executable instance of your data pipeline."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.a,{href:"/docs/core-concepts/node-definition",children:"Node Definition Structure"})}),": Learn about the nested configuration structure of NodeDefinition."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var r=i(6540);const l={},t=r.createContext(l);function s(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);