"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[1624],{1170:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"core-concepts/pipeline-execution/ipipelinerunner","title":"IPipelineRunner","description":"Learn about the IPipelineRunner interface, the core component for executing NPipeline data flows.","source":"@site/docs/core-concepts/pipeline-execution/ipipelinerunner.md","sourceDirName":"core-concepts/pipeline-execution","slug":"/core-concepts/pipeline-execution/ipipelinerunner","permalink":"/docs/core-concepts/pipeline-execution/ipipelinerunner","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"IPipelineRunner","description":"Learn about the IPipelineRunner interface, the core component for executing NPipeline data flows.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Pipeline Execution","permalink":"/docs/core-concepts/pipeline-execution"},"next":{"title":"Execution Strategies","permalink":"/docs/core-concepts/pipeline-execution/execution-strategies"}}');var t=i(4848),o=i(8453);const l={title:"IPipelineRunner",description:"Learn about the IPipelineRunner interface, the core component for executing NPipeline data flows.",sidebar_position:2},c="IPipelineRunner",s={},a=[{value:"Key Responsibilities",id:"key-responsibilities",level:2},{value:"<code>RunAsync</code> Method",id:"runasync-method",level:2},{value:"Example: Basic Pipeline Execution",id:"example-basic-pipeline-execution",level:3},{value:"Output",id:"output",level:3},{value:"Cancellation",id:"cancellation",level:2},{value:"Example: Cancelling a Pipeline",id:"example-cancelling-a-pipeline",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"ipipelinerunner",children:(0,t.jsx)(n.code,{children:"IPipelineRunner"})})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"../../../src/NPipeline/Execution/IPipelineRunner.cs",children:(0,t.jsx)(n.code,{children:"IPipelineRunner"})})," interface is the central component responsible for initiating and managing the execution of a defined NPipeline. After constructing a pipeline using the ",(0,t.jsx)(n.a,{href:"../../../src/NPipeline/Pipeline/PipelineBuilder.cs",children:(0,t.jsx)(n.code,{children:"PipelineBuilder"})}),", you interact with an implementation of ",(0,t.jsx)(n.a,{href:"../../../src/NPipeline/Execution/IPipelineRunner.cs",children:(0,t.jsx)(n.code,{children:"IPipelineRunner"})})," to bring your data flow to life."]}),"\n",(0,t.jsx)(n.h2,{id:"key-responsibilities",children:"Key Responsibilities"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"../../../src/NPipeline/Execution/IPipelineRunner.cs",children:(0,t.jsx)(n.code,{children:"IPipelineRunner"})})," handles:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pipeline Initialization"}),": Setting up the necessary infrastructure before data processing begins."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Flow Management"}),": Orchestrating the movement of data items through connected nodes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Asynchronous Execution"}),": Managing the asynchronous nature of data processing within the pipeline."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cancellation"}),": Providing mechanisms to gracefully stop pipeline execution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Propagation"}),": Ensuring that errors are handled according to the pipeline's configuration."]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"runasync-method",children:[(0,t.jsx)(n.code,{children:"RunAsync"})," Method"]}),"\n",(0,t.jsxs)(n.p,{children:["The primary method for executing a pipeline is ",(0,t.jsx)(n.code,{children:"RunAsync"}),", which takes a ",(0,t.jsx)(n.a,{href:"../../../src/NPipeline/Pipeline/PipelineContext.cs",children:(0,t.jsx)(n.code,{children:"PipelineContext"})})," parameter and requires the pipeline definition type to have a parameterless constructor."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public interface IPipelineRunner\r\n{\r\n    Task RunAsync<TDefinition>(PipelineContext context) where TDefinition : IPipelineDefinition, new();\r\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"TDefinition"})}),": The type of pipeline definition to run. Must implement ",(0,t.jsx)(n.a,{href:"../../../src/NPipeline/Abstractions/Pipeline/IPipelineDefinition.cs",children:(0,t.jsx)(n.code,{children:"IPipelineDefinition"})})," and have a parameterless constructor (indicated by the ",(0,t.jsx)(n.code,{children:"new()"})," constraint)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"context"})}),": The ",(0,t.jsx)(n.a,{href:"../../../src/NPipeline/Pipeline/PipelineContext.cs",children:(0,t.jsx)(n.code,{children:"PipelineContext"})})," containing runtime configuration, shared state, and cancellation tokens."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"new()"})," constraint"]}),": This ensures the pipeline definition can be instantiated without parameters, allowing the runner to create an instance of the definition."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-basic-pipeline-execution",children:"Example: Basic Pipeline Execution"}),"\n",(0,t.jsxs)(n.p,{children:["Here's a simple example demonstrating how to build and run a basic pipeline using ",(0,t.jsx)(n.code,{children:"RunAsync"})," with the correct signature."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Extensions.Testing;\r\n\r\npublic sealed record MyData(int Value);\r\n\r\npublic sealed class MySource : SourceNode<MyData>\r\n{\r\n    private readonly int _start;\r\n    private readonly int _count;\r\n\r\n    public MySource(int start, int count)\r\n    {\r\n        _start = start;\r\n        _count = count;\r\n    }\r\n\r\n    public async IAsyncEnumerable<MyData> ExecuteAsync(CancellationToken cancellationToken = default)\r\n    {\r\n        for (int i = 0; i < _count; i++)\r\n        {\r\n            if (cancellationToken.IsCancellationRequested) yield break;\r\n            var data = new MyData(_start + i);\r\n            Console.WriteLine($"Source produced: {data.Value}");\r\n            yield return data;\r\n            await Task.Delay(50, cancellationToken); // Simulate some work\r\n        }\r\n    }\r\n}\r\n\r\npublic sealed class MyTransform : TransformNode<MyData, MyData>\r\n{\r\n    public async IAsyncEnumerable<MyData> ExecuteAsync(IAsyncEnumerable<MyData> input, CancellationToken cancellationToken = default)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            if (cancellationToken.IsCancellationRequested) yield break;\r\n            var transformedData = new MyData(item.Value * 2);\r\n            Console.WriteLine($"Transform processed: {item.Value} -> {transformedData.Value}");\r\n            yield return transformedData;\r\n        }\r\n    }\r\n}\r\n\r\npublic sealed class MySink : SinkNode<MyData>\r\n{\r\n    public async Task ExecuteAsync(IAsyncEnumerable<MyData> input, CancellationToken cancellationToken = default)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            if (cancellationToken.IsCancellationRequested) break;\r\n            Console.WriteLine($"Sink consumed: {item.Value}");\r\n        }\r\n    }\r\n}\r\n\r\n// Pipeline definition with parameterless constructor\r\npublic sealed class MyPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<MySource, int>("source");\r\n        var transformHandle = builder.AddTransform<MyTransform, int, string>("transform");\r\n        var sinkHandle = builder.AddSink<MySink, string>("sink");\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var runner = PipelineRunner.Create();\r\n        var context = PipelineContext.Default;\r\n\r\n        Console.WriteLine("Starting pipeline execution...");\r\n        await runner.RunAsync<MyPipelineDefinition>(context);\r\n        Console.WriteLine("Pipeline execution finished.");\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"output",children:"Output"}),"\n",(0,t.jsx)(n.p,{children:"Running the above program would produce output similar to:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"Starting pipeline execution...\r\nSource produced: 1\r\nTransform processed: 1 -> 2\r\nSink consumed: 2\r\nSource produced: 2\r\nTransform processed: 2 -> 4\r\nSink consumed: 4\r\nSource produced: 3\r\nTransform processed: 3 -> 6\r\nSink consumed: 6\r\nSource produced: 4\r\nTransform processed: 4 -> 8\r\nSink consumed: 8\r\nSource produced: 5\r\nTransform processed: 5 -> 10\r\nSink consumed: 10\r\nPipeline execution finished.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"cancellation",children:"Cancellation"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken",children:(0,t.jsx)(n.code,{children:"CancellationToken"})})," provided through the ",(0,t.jsx)(n.a,{href:"../../../src/NPipeline/Pipeline/PipelineContext.cs",children:(0,t.jsx)(n.code,{children:"PipelineContext"})})," is crucial for managing the lifecycle of long-running pipelines. When cancellation is requested, NPipeline attempts to gracefully shut down all active nodes, allowing them to complete any in-flight operations or clean up resources before terminating."]}),"\n",(0,t.jsx)(n.h3,{id:"example-cancelling-a-pipeline",children:"Example: Cancelling a Pipeline"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Extensions.Testing;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n// ... (MyData, MySource, MyTransform, MySink, MyPipelineDefinition definitions as above) ...\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var runner = PipelineRunner.Create();\r\n        using var cts = new CancellationTokenSource();\r\n\r\n        // Create context with cancellation token\r\n        var context = PipelineContext.WithCancellation(cts.Token);\r\n\r\n        // Start the pipeline in the background\r\n        var pipelineTask = runner.RunAsync<MyPipelineDefinition>(context);\r\n\r\n        Console.WriteLine("Pipeline started. Press any key to cancel...");\r\n        Console.ReadKey(); // Wait for user input\r\n\r\n        Console.WriteLine("Cancellation requested.");\r\n        cts.Cancel(); // Request cancellation\r\n\r\n        try\r\n        {\r\n            await pipelineTask; // Wait for the pipeline to complete or cancel\r\n            Console.WriteLine("Pipeline execution finished gracefully.");\r\n        }\r\n        catch (OperationCanceledException)\r\n        {\r\n            Console.WriteLine("Pipeline execution was cancelled.");\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine($"Pipeline execution encountered an error: {ex.Message}");\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, the pipeline starts producing and processing data. When a key is pressed, cancellation is requested via the ",(0,t.jsx)(n.code,{children:"CancellationTokenSource"}),". The ",(0,t.jsx)(n.code,{children:"RunAsync"})," method will then propagate this cancellation request through the ",(0,t.jsx)(n.code,{children:"PipelineContext"})," to all nodes, allowing them to react accordingly."]}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/pipeline-context",children:"Pipeline Context"})}),": Understand how ",(0,t.jsx)(n.code,{children:"PipelineContext"})," provides runtime information and shared resources to nodes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-concepts/resilience/error-handling-guide",children:"Error Handling"})}),": Dive deeper into strategies for managing errors within your pipelines."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>c});var r=i(6540);const t={},o=r.createContext(t);function l(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);