"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[1702],{7213:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"extensions/composition/nested-composition","title":"Nested Composition","description":"Overview","source":"@site/docs/extensions/composition/nested-composition.md","sourceDirName":"extensions/composition","slug":"/extensions/composition/nested-composition","permalink":"/docs/extensions/composition/nested-composition","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Error Handling in Composite Pipelines","permalink":"/docs/extensions/composition/error-handling"},"next":{"title":"Performance Optimization","permalink":"/docs/extensions/composition/performance"}}');var r=i(74848),l=i(28453);const o={},s="Nested Composition",a={},d=[{value:"Overview",id:"overview",level:2},{value:"Basic Nesting",id:"basic-nesting",level:2},{value:"Two-Level Nesting",id:"two-level-nesting",level:3},{value:"Execution Flow",id:"execution-flow",level:3},{value:"Deep Nesting",id:"deep-nesting",level:2},{value:"Three or More Levels",id:"three-or-more-levels",level:3},{value:"Context Propagation",id:"context-propagation",level:2},{value:"Inheritance Through Levels",id:"inheritance-through-levels",level:3},{value:"Selective Propagation",id:"selective-propagation",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Pattern 1: Layered Architecture",id:"pattern-1-layered-architecture",level:3},{value:"Pattern 2: Recursive Processing",id:"pattern-2-recursive-processing",level:3},{value:"Pattern 3: Pipeline Templates",id:"pattern-3-pipeline-templates",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Nesting Depth Impact",id:"nesting-depth-impact",level:3},{value:"Optimization Strategies",id:"optimization-strategies",level:3},{value:"1. Flatten When Possible",id:"1-flatten-when-possible",level:4},{value:"2. Cache Composite Definitions",id:"2-cache-composite-definitions",level:4},{value:"3. Minimize Context Inheritance",id:"3-minimize-context-inheritance",level:4},{value:"Testing Nested Pipelines",id:"testing-nested-pipelines",level:2},{value:"Test Each Level Independently",id:"test-each-level-independently",level:3},{value:"Test Integration Between Levels",id:"test-integration-between-levels",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Limit Nesting Depth",id:"1-limit-nesting-depth",level:3},{value:"2. Name Levels Clearly",id:"2-name-levels-clearly",level:3},{value:"3. Document Hierarchy",id:"3-document-hierarchy",level:3},{value:"4. Use Composition for Reusability",id:"4-use-composition-for-reusability",level:3},{value:"5. Balance Isolation and Integration",id:"5-balance-isolation-and-integration",level:3},{value:"Summary",id:"summary",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"nested-composition",children:"Nested Composition"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Nested composition allows composite nodes to contain other composite nodes, creating deep hierarchical pipeline structures. This enables building complex workflows from layers of simpler sub-pipelines."}),"\n",(0,r.jsx)(n.h2,{id:"basic-nesting",children:"Basic Nesting"}),"\n",(0,r.jsx)(n.h3,{id:"two-level-nesting",children:"Two-Level Nesting"}),"\n",(0,r.jsx)(n.p,{children:"The simplest form of nesting - a composite node within a parent pipeline:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Level 2: Inner sub-pipeline (multiplies by 2)\npublic class DoubleTransformPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<int>, int>("input");\n        var transform = builder.AddTransform<DoubleTransform, int, int>("double");\n        var output = builder.AddSink<PipelineOutputSink<int>, int>("output");\n        \n        builder.Connect(input, transform);\n        builder.Connect(transform, output);\n    }\n}\n\n// Level 1: Outer sub-pipeline (contains composite)\npublic class ProcessingPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<int>, int>("input");\n        \n        // Nested composite node\n        var double = builder.AddComposite<int, int, DoubleTransformPipeline>("double");\n        \n        var output = builder.AddSink<PipelineOutputSink<int>, int>("output");\n        \n        builder.Connect(input, double);\n        builder.Connect(double, output);\n    }\n}\n\n// Level 0: Main pipeline\npublic class MainPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<IntSource, int>("source");\n        \n        // Top-level composite node\n        var process = builder.AddComposite<int, int, ProcessingPipeline>("process");\n        \n        var sink = builder.AddSink<IntSink, int>("sink");\n        \n        builder.Connect(source, process);\n        builder.Connect(process, sink);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"execution-flow",children:"Execution Flow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"MainPipeline:\n  [Source: 1, 2, 3] \u2192 [ProcessingPipeline] \u2192 [Sink]\n                           \u2193\n                   ProcessingPipeline:\n                     [Input] \u2192 [DoubleTransformPipeline] \u2192 [Output]\n                                        \u2193\n                               DoubleTransformPipeline:\n                                 [Input] \u2192 [Transform x2] \u2192 [Output]\n\nResult: 2, 4, 6\n"})}),"\n",(0,r.jsx)(n.h2,{id:"deep-nesting",children:"Deep Nesting"}),"\n",(0,r.jsx)(n.h3,{id:"three-or-more-levels",children:"Three or More Levels"}),"\n",(0,r.jsx)(n.p,{children:"Unlimited nesting depth is supported:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Level 3: Core processing\npublic class CorePipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<Data>, Data>("input");\n        var process = builder.AddTransform<CoreTransform, Data, Data>("process");\n        var output = builder.AddSink<PipelineOutputSink<Data>, Data>("output");\n        \n        builder.Connect(input, process);\n        builder.Connect(process, output);\n    }\n}\n\n// Level 2: Validation + Core\npublic class ValidationProcessingPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<Data>, Data>("input");\n        \n        var validate = builder.AddTransform<Validator, Data, Data>("validate");\n        var core = builder.AddComposite<Data, Data, CorePipeline>("core");\n        \n        var output = builder.AddSink<PipelineOutputSink<Data>, Data>("output");\n        \n        builder.Connect(input, validate);\n        builder.Connect(validate, core);\n        builder.Connect(core, output);\n    }\n}\n\n// Level 1: Enrichment + Validation + Core\npublic class EnrichmentPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<Data>, Data>("input");\n        \n        var enrich = builder.AddTransform<Enricher, Data, Data>("enrich");\n        var validateAndProcess = builder.AddComposite<Data, Data, ValidationProcessingPipeline>("validate-process");\n        \n        var output = builder.AddSink<PipelineOutputSink<Data>, Data>("output");\n        \n        builder.Connect(input, enrich);\n        builder.Connect(enrich, validateAndProcess);\n        builder.Connect(validateAndProcess, output);\n    }\n}\n\n// Level 0: Main pipeline\npublic class MainPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<DataSource, Data>("source");\n        var process = builder.AddComposite<Data, Data, EnrichmentPipeline>("process");\n        var sink = builder.AddSink<DataSink, Data>("sink");\n        \n        builder.Connect(source, process);\n        builder.Connect(process, sink);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"context-propagation",children:"Context Propagation"}),"\n",(0,r.jsx)(n.h3,{id:"inheritance-through-levels",children:"Inheritance Through Levels"}),"\n",(0,r.jsx)(n.p,{children:"Context inheritance can be configured at each level:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Level 2: Core - no inheritance\npublic class CorePipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        // Uses Default context - isolated\n        var input = builder.AddSource<PipelineInputSource<T>, T>("input");\n        var transform = builder.AddTransform<CoreTransform, T, T>("core");\n        var output = builder.AddSink<PipelineOutputSink<T>, T>("output");\n        \n        builder.Connect(input, transform);\n        builder.Connect(transform, output);\n    }\n}\n\n// Level 1: Middle - inherits from Level 0\npublic class MiddlePipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<T>, T>("input");\n        \n        // Pass context to Level 2 with inheritance\n        var core = builder.AddComposite<T, T, CorePipeline>(\n            contextConfiguration: CompositeContextConfiguration.InheritAll);\n        \n        var output = builder.AddSink<PipelineOutputSink<T>, T>("output");\n        \n        builder.Connect(input, core);\n        builder.Connect(core, output);\n    }\n}\n\n// Level 0: Main - sets up initial context\npublic class MainPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<DataSource, T>("source");\n        \n        // Inherit context to Level 1\n        var middle = builder.AddComposite<T, T, MiddlePipeline>(\n            contextConfiguration: CompositeContextConfiguration.InheritAll);\n        \n        var sink = builder.AddSink<DataSink, T>("sink");\n        \n        builder.Connect(source, middle);\n        builder.Connect(middle, sink);\n    }\n}\n\n// Usage\nvar context = new PipelineContext();\ncontext.Parameters["Config"] = "value";\n\n// Config propagates: Level 0 \u2192 Level 1 \u2192 Level 2\nawait runner.RunAsync<MainPipeline>(context);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"selective-propagation",children:"Selective Propagation"}),"\n",(0,r.jsx)(n.p,{children:"Different inheritance at each level:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Level 1: Inherits parameters only\nbuilder.AddComposite<T, T, MiddlePipeline>(\n    contextConfiguration: new CompositeContextConfiguration\n    {\n        InheritParentParameters = true,  // Pass params down\n        InheritParentItems = false,      // Don't pass items\n        InheritParentProperties = false\n    });\n\n// In MiddlePipeline, Level 2: Inherits everything from Level 1\nbuilder.AddComposite<T, T, CorePipeline>(\n    contextConfiguration: CompositeContextConfiguration.InheritAll);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"pattern-1-layered-architecture",children:"Pattern 1: Layered Architecture"}),"\n",(0,r.jsx)(n.p,{children:"Organize pipelines by responsibility layers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Layer 3: Business Logic\npublic class BusinessLogicPipeline : IPipelineDefinition { }\n\n// Layer 2: Validation + Business Logic\npublic class ValidationLayerPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<T>, T>("input");\n        var validate = builder.AddTransform<Validator, T, T>("validate");\n        var business = builder.AddComposite<T, T, BusinessLogicPipeline>("business");\n        var output = builder.AddSink<PipelineOutputSink<T>, T>("output");\n        \n        builder.Connect(input, validate);\n        builder.Connect(validate, business);\n        builder.Connect(business, output);\n    }\n}\n\n// Layer 1: Enrichment + Validation + Business Logic\npublic class EnrichmentLayerPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<T>, T>("input");\n        var enrich = builder.AddTransform<Enricher, T, T>("enrich");\n        var validateAndProcess = builder.AddComposite<T, T, ValidationLayerPipeline>("validate-process");\n        var output = builder.AddSink<PipelineOutputSink<T>, T>("output");\n        \n        builder.Connect(input, enrich);\n        builder.Connect(enrich, validateAndProcess);\n        builder.Connect(validateAndProcess, output);\n    }\n}\n\n// Layer 0: Orchestration\npublic class OrchestrationPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<DataSource, T>("source");\n        var process = builder.AddComposite<T, T, EnrichmentLayerPipeline>("process");\n        var sink = builder.AddSink<DataSink, T>("sink");\n        \n        builder.Connect(source, process);\n        builder.Connect(process, sink);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-2-recursive-processing",children:"Pattern 2: Recursive Processing"}),"\n",(0,r.jsx)(n.p,{children:"Process hierarchical data structures:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Process node and children\npublic class TreeProcessingPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<TreeNode>, TreeNode>("input");\n        \n        // Process current node\n        var processNode = builder.AddTransform<NodeProcessor, TreeNode, TreeNode>("process-node");\n        \n        // Process children (recursive composite)\n        var processChildren = builder.AddTransform<ChildrenProcessor, TreeNode, TreeNode>("process-children");\n        \n        var output = builder.AddSink<PipelineOutputSink<TreeNode>, TreeNode>("output");\n        \n        builder.Connect(input, processNode);\n        builder.Connect(processNode, processChildren);\n        builder.Connect(processChildren, output);\n    }\n}\n\n// ChildrenProcessor creates composite nodes for each child\npublic class ChildrenProcessor : TransformNode<TreeNode, TreeNode>\n{\n    public override async Task<TreeNode> ExecuteAsync(TreeNode node, PipelineContext context, CancellationToken ct)\n    {\n        if (!node.HasChildren)\n            return node;\n            \n        // Process each child with a nested pipeline\n        foreach (var child in node.Children)\n        {\n            // Create and run sub-pipeline for child\n            // (Implementation details omitted for brevity)\n        }\n        \n        return node;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-3-pipeline-templates",children:"Pattern 3: Pipeline Templates"}),"\n",(0,r.jsx)(n.p,{children:"Reusable pipeline templates with different core logic:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Template structure\npublic class PipelineTemplate<TCoreLogic> : IPipelineDefinition\n    where TCoreLogic : IPipelineDefinition, new()\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var input = builder.AddSource<PipelineInputSource<Data>, Data>("input");\n        \n        // Common preprocessing\n        var preprocess = builder.AddTransform<Preprocessor, Data, Data>("preprocess");\n        \n        // Core logic (varies)\n        var core = builder.AddComposite<Data, Data, TCoreLogic>("core");\n        \n        // Common postprocessing\n        var postprocess = builder.AddTransform<Postprocessor, Data, Data>("postprocess");\n        \n        var output = builder.AddSink<PipelineOutputSink<Data>, Data>("output");\n        \n        builder.Connect(input, preprocess);\n        builder.Connect(preprocess, core);\n        builder.Connect(core, postprocess);\n        builder.Connect(postprocess, output);\n    }\n}\n\n// Different core implementations\npublic class ValidationCorePipeline : IPipelineDefinition { }\npublic class TransformationCorePipeline : IPipelineDefinition { }\n\n// Usage\nbuilder.AddComposite<Data, Data, PipelineTemplate<ValidationCorePipeline>>("validate");\nbuilder.AddComposite<Data, Data, PipelineTemplate<TransformationCorePipeline>>("transform");\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"nesting-depth-impact",children:"Nesting Depth Impact"}),"\n",(0,r.jsx)(n.p,{children:"Each nesting level adds overhead:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"Impact per Level"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Context Creation"}),(0,r.jsx)(n.td,{children:"~1-2\u03bcs"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Memory"}),(0,r.jsx)(n.td,{children:"~1-5KB (depending on context)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Stack Depth"}),(0,r.jsx)(n.td,{children:"Minimal (async execution)"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Practical Limit:"})," 5-10 levels before performance degrades noticeably."]}),"\n",(0,r.jsx)(n.h3,{id:"optimization-strategies",children:"Optimization Strategies"}),"\n",(0,r.jsx)(n.h4,{id:"1-flatten-when-possible",children:"1. Flatten When Possible"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"\u274c Avoid excessive nesting:\n[Composite A] \u2192 [Composite B] \u2192 [Composite C] \u2192 [Transform]\n\n\u2705 Prefer flatter structure:\n[Composite ABC] \u2192 [Transform]\n"})}),"\n",(0,r.jsx)(n.h4,{id:"2-cache-composite-definitions",children:"2. Cache Composite Definitions"}),"\n",(0,r.jsx)(n.p,{children:"Reuse sub-pipeline definitions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Define once, use many times\nvar validationConfig = CompositeContextConfiguration.Default;\n\nbuilder.AddComposite<T, T, ValidationPipeline>("validate-1", validationConfig);\nbuilder.AddComposite<T, T, ValidationPipeline>("validate-2", validationConfig);\n'})}),"\n",(0,r.jsx)(n.h4,{id:"3-minimize-context-inheritance",children:"3. Minimize Context Inheritance"}),"\n",(0,r.jsx)(n.p,{children:"Only inherit at necessary levels:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"\u2705 Good: Selective inheritance\n// Level 0 \u2192 Level 1: InheritAll\n// Level 1 \u2192 Level 2: Default (no inheritance)\n\n\u274c Bad: Unnecessary inheritance\n// Level 0 \u2192 Level 1: InheritAll\n// Level 1 \u2192 Level 2: InheritAll\n// Level 2 \u2192 Level 3: InheritAll\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing-nested-pipelines",children:"Testing Nested Pipelines"}),"\n",(0,r.jsx)(n.h3,{id:"test-each-level-independently",children:"Test Each Level Independently"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"[Fact]\npublic async Task Level3_CorePipeline_ShouldProcess()\n{\n    // Test deepest level first\n    var context = new PipelineContext();\n    await runner.RunAsync<CorePipeline>(context);\n    // Assert\n}\n\n[Fact]\npublic async Task Level2_MiddlePipeline_ShouldProcess()\n{\n    // Test middle level\n    var context = new PipelineContext();\n    await runner.RunAsync<MiddlePipeline>(context);\n    // Assert\n}\n\n[Fact]\npublic async Task Level1_MainPipeline_ShouldProcess()\n{\n    // Test full hierarchy\n    var context = new PipelineContext();\n    await runner.RunAsync<MainPipeline>(context);\n    // Assert\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"test-integration-between-levels",children:"Test Integration Between Levels"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'[Fact]\npublic async Task NestedPipelines_ShouldPassDataCorrectly()\n{\n    var context = new PipelineContext();\n    context.Parameters["Input"] = "test";\n    \n    await runner.RunAsync<MainPipeline>(context);\n    \n    // Verify data flowed through all levels\n    var result = context.Parameters["Output"];\n    Assert.Equal("expected", result);\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-limit-nesting-depth",children:"1. Limit Nesting Depth"}),"\n",(0,r.jsx)(n.p,{children:"Keep nesting to 2-3 levels for most use cases:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"\u2705 Good: 2-3 levels\nMain \u2192 Processing \u2192 Validation\n\n\u274c Excessive: 5+ levels\nMain \u2192 Orchestration \u2192 Processing \u2192 Transformation \u2192 Validation \u2192 Core\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-name-levels-clearly",children:"2. Name Levels Clearly"}),"\n",(0,r.jsx)(n.p,{children:"Use clear, hierarchical naming:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'\u2705 Good names:\n"order-processing"\n  \u21b3 "validation"\n    \u21b3 "schema-validation"\n\n\u274c Bad names:\n"pipeline1"\n  \u21b3 "pipeline2"\n    \u21b3 "pipeline3"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-document-hierarchy",children:"3. Document Hierarchy"}),"\n",(0,r.jsx)(n.p,{children:"Document the pipeline structure:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"/// <summary>\n/// Order processing pipeline with nested validation.\n/// </summary>\n/// <remarks>\n/// Pipeline Structure:\n/// - Level 0: OrderProcessingPipeline\n///   - Level 1: ValidationPipeline\n///     - Level 2: SchemaValidationPipeline\n///   - Level 1: TransformationPipeline\n/// </remarks>\npublic class OrderProcessingPipeline : IPipelineDefinition\n{\n    // ...\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-use-composition-for-reusability",children:"4. Use Composition for Reusability"}),"\n",(0,r.jsx)(n.p,{children:"Nest when reusing sub-pipelines:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'\u2705 Good: Reusable validation\npublic class OrderPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var validate = builder.AddComposite<Order, ValidatedOrder, OrderValidationPipeline>("validate");\n        // Use same validation in multiple pipelines\n    }\n}\n\npublic class InvoicePipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var validate = builder.AddComposite<Invoice, ValidatedInvoice, InvoiceValidationPipeline>("validate");\n        // Reuse validation logic\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"5-balance-isolation-and-integration",children:"5. Balance Isolation and Integration"}),"\n",(0,r.jsx)(n.p,{children:"Choose appropriate inheritance at each level:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Level 0: Set up shared config\ncontext.Parameters["ApiKey"] = key;\n\n// Level 1: Inherit config, isolate processing\nbuilder.AddComposite<T, T, ProcessingPipeline>(\n    contextConfiguration: new CompositeContextConfiguration\n    {\n        InheritParentParameters = true  // Get config\n    });\n\n// In ProcessingPipeline, Level 2: Full isolation for core logic\nbuilder.AddComposite<T, T, CorePipeline>(\n    contextConfiguration: CompositeContextConfiguration.Default);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Nested composition enables building complex pipelines from simple building blocks:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unlimited depth"})," supported (practical limit 5-10 levels)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Context propagation"})," configurable at each level"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Independent testing"})," of each level"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance impact"})," increases with depth"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Best practices"})," favor 2-3 levels for most use cases"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Use nesting when it improves modularity, reusability, and maintainability - but avoid excessive depth that adds complexity without benefit."})]})}function p(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>s});var t=i(96540);const r={},l=t.createContext(r);function o(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);