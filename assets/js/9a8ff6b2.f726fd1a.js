"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3043],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var r=i(96540);const t={},s=r.createContext(t);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(s.Provider,{value:n},e.children)}},43662:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"extensions/observability/examples","title":"Observability Usage Examples","description":"Complete code examples demonstrating various scenarios for using NPipeline Observability extension, from basic setup to advanced monitoring patterns.","source":"@site/docs/extensions/observability/examples.md","sourceDirName":"extensions/observability","slug":"/extensions/observability/examples","permalink":"/docs/extensions/observability/examples","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Observability Usage Examples","description":"Complete code examples demonstrating various scenarios for using NPipeline Observability extension, from basic setup to advanced monitoring patterns."},"sidebar":"docsSidebar","previous":{"title":"Observability Configuration","permalink":"/docs/extensions/observability/configuration"},"next":{"title":"Metrics Reference","permalink":"/docs/extensions/observability/metrics"}}');var t=i(74848),s=i(28453);const o={title:"Observability Usage Examples",description:"Complete code examples demonstrating various scenarios for using NPipeline Observability extension, from basic setup to advanced monitoring patterns."},a="Observability Usage Examples",l={},c=[{value:"Basic Usage with Automatic Metrics Collection",id:"basic-usage-with-automatic-metrics-collection",level:2},{value:"Example 1: Quick Start with Automatic Metrics",id:"example-1-quick-start-with-automatic-metrics",level:3},{value:"Custom Metrics Sink Example",id:"custom-metrics-sink-example",level:2},{value:"Example 2: Application Insights Integration",id:"example-2-application-insights-integration",level:3},{value:"Example 3: Prometheus Metrics Exporter",id:"example-3-prometheus-metrics-exporter",level:3},{value:"Dependency Injection Integration Example",id:"dependency-injection-integration-example",level:2},{value:"Example 4: Pipeline with Scoped Services",id:"example-4-pipeline-with-scoped-services",level:3},{value:"Advanced Scenarios",id:"advanced-scenarios",level:2},{value:"Example 5: Multiple Observers (Composite Pattern)",id:"example-5-multiple-observers-composite-pattern",level:3},{value:"Example 6: Custom Metrics Collection with Enrichment",id:"example-6-custom-metrics-collection-with-enrichment",level:3},{value:"Example 7: Performance Monitoring with Alerts",id:"example-7-performance-monitoring-with-alerts",level:3},{value:"Example 8: Error Tracking and Analysis",id:"example-8-error-tracking-and-analysis",level:3},{value:"Complete Working Example",id:"complete-working-example",level:2},{value:"Example 9: End-to-End ETL Pipeline with Observability",id:"example-9-end-to-end-etl-pipeline-with-observability",level:3},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"observability-usage-examples",children:"Observability Usage Examples"})}),"\n",(0,t.jsx)(n.p,{children:"This section provides complete, working code examples for common scenarios when using the NPipeline Observability extension."}),"\n",(0,t.jsx)(n.h2,{id:"basic-usage-with-automatic-metrics-collection",children:"Basic Usage with Automatic Metrics Collection"}),"\n",(0,t.jsxs)(n.p,{children:["The simplest way to enable observability is using the ",(0,t.jsx)(n.code,{children:"IObservablePipelineContextFactory"})," with the default registration."]}),"\n",(0,t.jsx)(n.h3,{id:"example-1-quick-start-with-automatic-metrics",children:"Example 1: Quick Start with Automatic Metrics"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing NPipeline.DataFlow;\nusing NPipeline.DataFlow.DataPipes;\nusing NPipeline.Nodes;\nusing NPipeline.Observability;\nusing NPipeline.Observability.DependencyInjection;\nusing NPipeline.Extensions.DependencyInjection;\nusing NPipeline.Pipeline;\n\n// Define a simple pipeline\npublic class SimplePipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<NumberSource, int>();\n        var transform = builder.AddTransform<DoubleTransform, int, int>();\n        var sink = builder.AddSink<NumberSink, int>();\n\n        builder.Connect(source, transform);\n        builder.Connect(transform, sink);\n    }\n}\n\n// Source node that generates numbers\npublic sealed class NumberSource : SourceNode<int>\n{\n    public IDataPipe<int> ExecuteAsync(PipelineContext context, CancellationToken cancellationToken = default)\n    {\n        static async IAsyncEnumerable<int> Generate()\n        {\n            for (int i = 1; i <= 100; i++)\n            {\n                yield return i;\n            }\n        }\n\n        return new StreamingDataPipe<int>(Generate());\n    }\n}\n\n// Transform node that doubles numbers\npublic sealed class DoubleTransform : TransformNode<int, int>\n{\n    public override Task<int> ExecuteAsync(int item, PipelineContext context, CancellationToken cancellationToken = default)\n    {\n        return Task.FromResult(item * 2);\n    }\n}\n\n// Sink node that outputs numbers\npublic sealed class NumberSink : SinkNode<int>\n{\n    public async Task ExecuteAsync(IDataPipe<int> input, PipelineContext context, IPipelineActivity parentActivity, CancellationToken cancellationToken = default)\n    {\n        await foreach (var item in input.WithCancellation(cancellationToken))\n        {\n            Console.WriteLine($"Received: {item}");\n        }\n    }\n}\n\n// Program setup\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var host = Host.CreateDefaultBuilder()\n            .ConfigureServices((context, services) =>\n            {\n                // Add logging\n                services.AddLogging(loggingBuilder => loggingBuilder.AddConsole());\n\n                // Add observability - automatically sets up metrics collection\n                services.AddNPipelineObservability();\n\n                // Register NPipeline core services\n                services.AddNPipeline(typeof(Program).Assembly);\n            })\n            .Build();\n\n        // Create an async scope for proper resource management\n        await using var scope = host.Services.CreateAsyncScope();\n        var runner = scope.ServiceProvider.GetRequiredService<IPipelineRunner>();\n        var contextFactory = scope.ServiceProvider.GetRequiredService<IObservablePipelineContextFactory>();\n        var collector = scope.ServiceProvider.GetRequiredService<IObservabilityCollector>();\n\n        // Create context with automatic observability enabled\n        await using var pipelineContext = contextFactory.Create();\n\n        // Run the pipeline - metrics are automatically collected!\n        await runner.RunAsync<SimplePipeline>(pipelineContext);\n\n        // Display metrics\n        Console.WriteLine("\\n=== Metrics Collected ===");\n        foreach (var metric in collector.GetNodeMetrics())\n        {\n            Console.WriteLine($"Node {metric.NodeId}:");\n            Console.WriteLine($"  Duration: {metric.DurationMs}ms");\n            Console.WriteLine($"  Items Processed: {metric.ItemsProcessed}");\n            Console.WriteLine($"  Success: {metric.Success}");\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"What happens automatically:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"IObservablePipelineContextFactory"})," creates a context with ",(0,t.jsx)(n.code,{children:"ExecutionObserver"})," pre-configured"]}),"\n",(0,t.jsxs)(n.li,{children:["No need to manually create ",(0,t.jsx)(n.code,{children:"MetricsCollectingExecutionObserver"})," or wire it up"]}),"\n",(0,t.jsx)(n.li,{children:"Metrics are collected by the framework during node execution"}),"\n",(0,t.jsx)(n.li,{children:"Default logging sink outputs metrics to the configured logger"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"custom-metrics-sink-example",children:"Custom Metrics Sink Example"}),"\n",(0,t.jsx)(n.p,{children:"Create a custom metrics sink to send metrics to external monitoring systems like Application Insights, Prometheus, or a custom API."}),"\n",(0,t.jsx)(n.h3,{id:"example-2-application-insights-integration",children:"Example 2: Application Insights Integration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Microsoft.ApplicationInsights;\nusing Microsoft.ApplicationInsights.DataContracts;\nusing Microsoft.Extensions.DependencyInjection;\nusing NPipeline.Observability.Metrics;\n\n\n// Custom sink for Application Insights\npublic sealed class ApplicationInsightsMetricsSink : IMetricsSink\n{\n    private readonly TelemetryClient _telemetryClient;\n\n    public ApplicationInsightsMetricsSink(TelemetryClient telemetryClient)\n    {\n        _telemetryClient = telemetryClient ?? throw new ArgumentNullException(nameof(telemetryClient));\n    }\n\n    public Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        // Create a custom event with metrics\n        var properties = new Dictionary<string, string>\n        {\n            ["NodeId"] = nodeMetrics.NodeId,\n            ["Success"] = nodeMetrics.Success.ToString(),\n            ["HasException"] = (nodeMetrics.Exception != null).ToString()\n        };\n\n        var metrics = new Dictionary<string, double>\n        {\n            ["DurationMs"] = nodeMetrics.DurationMs ?? 0,\n            ["ItemsProcessed"] = nodeMetrics.ItemsProcessed,\n            ["ItemsEmitted"] = nodeMetrics.ItemsEmitted,\n            ["ThroughputItemsPerSec"] = nodeMetrics.ThroughputItemsPerSec ?? 0,\n            ["RetryCount"] = nodeMetrics.RetryCount\n        };\n\n        if (nodeMetrics.PeakMemoryUsageMb.HasValue)\n        {\n            metrics["PeakMemoryUsageMb"] = nodeMetrics.PeakMemoryUsageMb.Value;\n        }\n\n        if (nodeMetrics.ProcessorTimeMs.HasValue)\n        {\n            metrics["ProcessorTimeMs"] = nodeMetrics.ProcessorTimeMs.Value;\n        }\n\n        _telemetryClient.TrackEvent("NodeCompleted", properties, metrics);\n\n        // If node failed, track the exception\n        if (!nodeMetrics.Success && nodeMetrics.Exception != null)\n        {\n            _telemetryClient.TrackException(nodeMetrics.Exception, properties);\n        }\n\n        return Task.CompletedTask;\n    }\n}\n\n// Custom pipeline metrics sink\npublic sealed class ApplicationInsightsPipelineMetricsSink : IPipelineMetricsSink\n{\n    private readonly TelemetryClient _telemetryClient;\n\n    public ApplicationInsightsPipelineMetricsSink(TelemetryClient telemetryClient)\n    {\n        _telemetryClient = telemetryClient ?? throw new ArgumentNullException(nameof(telemetryClient));\n    }\n\n    public Task RecordAsync(IPipelineMetrics pipelineMetrics, CancellationToken cancellationToken)\n    {\n        var properties = new Dictionary<string, string>\n        {\n            ["PipelineName"] = pipelineMetrics.PipelineName,\n            ["RunId"] = pipelineMetrics.RunId.ToString(),\n            ["Success"] = pipelineMetrics.Success.ToString(),\n            ["NodeCount"] = pipelineMetrics.NodeMetrics.Count.ToString()\n        };\n\n        var metrics = new Dictionary<string, double>\n        {\n            ["DurationMs"] = pipelineMetrics.DurationMs ?? 0,\n            ["TotalItemsProcessed"] = pipelineMetrics.TotalItemsProcessed\n        };\n\n        // Calculate overall throughput\n        if (pipelineMetrics.DurationMs.HasValue && pipelineMetrics.DurationMs.Value > 0)\n        {\n            var throughput = (double)pipelineMetrics.TotalItemsProcessed / (pipelineMetrics.DurationMs.Value / 1000.0);\n            metrics["ThroughputItemsPerSec"] = throughput;\n        }\n\n        _telemetryClient.TrackEvent("PipelineCompleted", properties, metrics);\n\n        if (!pipelineMetrics.Success && pipelineMetrics.Exception != null)\n        {\n            _telemetryClient.TrackException(pipelineMetrics.Exception, properties);\n        }\n\n        return Task.CompletedTask;\n    }\n}\n\n// Registration\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var services = new ServiceCollection();\n\n        // Configure Application Insights\n        var telemetryConfig = TelemetryConfiguration.CreateDefault();\n        telemetryConfig.ConnectionString = "InstrumentationKey=YOUR_KEY";\n        var telemetryClient = new TelemetryClient(telemetryConfig);\n        services.AddSingleton(telemetryClient);\n\n        // Register custom sinks\n        services.AddNPipelineObservability<ApplicationInsightsMetricsSink, ApplicationInsightsPipelineMetricsSink>();\n\n        // Register NPipeline\n        services.AddNPipeline(typeof(Program).Assembly);\n\n        var serviceProvider = services.BuildServiceProvider();\n\n        await serviceProvider.RunPipelineAsync<MyPipeline>();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"example-3-prometheus-metrics-exporter",children:"Example 3: Prometheus Metrics Exporter"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Prometheus;\nusing NPipeline.Observability.Metrics;\n\n// Prometheus metrics definitions\npublic sealed class PrometheusMetricsSink : IMetricsSink\n{\n    private static readonly Counter NodeExecutions = Metrics\n        .CreateCounter("npipeline_node_executions_total", "Total number of node executions", "node_id", "success");\n\n    private static readonly Histogram NodeDuration = Metrics\n        .CreateHistogram("npipeline_node_duration_seconds", "Node execution duration in seconds", "node_id");\n\n    private static readonly Gauge NodeThroughput = Metrics\n        .CreateGauge("npipeline_node_throughput_items_per_second", "Node throughput in items per second", "node_id");\n\n    private static readonly Counter NodeRetries = Metrics\n        .CreateCounter("npipeline_node_retries_total", "Total number of node retries", "node_id");\n\n    public Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        // Record execution count\n        NodeExecutions.WithLabels(nodeMetrics.NodeId, nodeMetrics.Success.ToString()).Inc();\n\n        // Record duration\n        if (nodeMetrics.DurationMs.HasValue)\n        {\n            NodeDuration.WithLabels(nodeMetrics.NodeId).Observe(nodeMetrics.DurationMs.Value / 1000.0);\n        }\n\n        // Record throughput\n        if (nodeMetrics.ThroughputItemsPerSec.HasValue)\n        {\n            NodeThroughput.WithLabels(nodeMetrics.NodeId).Set(nodeMetrics.ThroughputItemsPerSec.Value);\n        }\n\n        // Record retries\n        if (nodeMetrics.RetryCount > 0)\n        {\n            NodeRetries.WithLabels(nodeMetrics.NodeId).Inc(nodeMetrics.RetryCount);\n        }\n\n        return Task.CompletedTask;\n    }\n}\n\n// Registration\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var services = new ServiceCollection();\n\n        // Start Prometheus metrics server\n        var metricServer = new KestrelMetricServer(port: 9090);\n        metricServer.Start();\n\n        services.AddNPipelineObservability<PrometheusMetricsSink, LoggingPipelineMetricsSink>();\n        services.AddNPipeline(typeof(Program).Assembly);\n\n        var serviceProvider = services.BuildServiceProvider();\n\n        await serviceProvider.RunPipelineAsync<MyPipeline>();\n\n        metricServer.Stop();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"dependency-injection-integration-example",children:"Dependency Injection Integration Example"}),"\n",(0,t.jsx)(n.p,{children:"Integrate observability with complex DI scenarios, including scoped services and constructor injection."}),"\n",(0,t.jsx)(n.h3,{id:"example-4-pipeline-with-scoped-services",children:"Example 4: Pipeline with Scoped Services"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Microsoft.Extensions.DependencyInjection;\nusing NPipeline;\nusing NPipeline.DataFlow;\nusing NPipeline.Nodes;\nusing NPipeline.Observability.DependencyInjection;\n\n// Scoped service for database access\npublic interface IDataRepository\n{\n    Task SaveAsync<T>(T item);\n}\n\npublic class DataRepository : IDataRepository\n{\n    private readonly ILogger<DataRepository> _logger;\n\n    public DataRepository(ILogger<DataRepository> logger)\n    {\n        _logger = logger;\n    }\n\n    public async Task SaveAsync<T>(T item)\n    {\n        _logger.LogInformation("Saving item of type {ItemType}", typeof(T).Name);\n        await Task.Delay(10); // Simulate database operation\n    }\n}\n\n// Node that uses scoped service\npublic sealed class DatabaseSink<T> : SinkNode<T>\n{\n    private readonly IDataRepository _repository;\n\n    public DatabaseSink(IDataRepository repository)\n    {\n        _repository = repository ?? throw new ArgumentNullException(nameof(repository));\n    }\n\n    public async Task ExecuteAsync(IDataPipe<T> input, PipelineContext context, IPipelineActivity parentActivity, CancellationToken cancellationToken = default)\n    {\n        await foreach (var item in input.WithCancellation(cancellationToken))\n        {\n            await _repository.SaveAsync(item);\n        }\n    }\n}\n\n// Pipeline definition\npublic class DataProcessingPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<DataSource, DataItem>();\n        var transform = builder.AddTransform<DataTransform, DataItem, ProcessedData>();\n        var sink = builder.AddSink<DatabaseSink<ProcessedData>, ProcessedData>();\n\n        builder.Connect(source, transform);\n        builder.Connect(transform, sink);\n    }\n}\n\n// Program setup\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var services = new ServiceCollection();\n\n        // Add logging\n        services.AddLogging(loggingBuilder => loggingBuilder.AddConsole());\n\n        // Add observability\n        services.AddNPipelineObservability();\n\n        // Register scoped services\n        services.AddScoped<IDataRepository, DataRepository>();\n\n        // Register NPipeline with DI\n        services.AddNPipeline(typeof(Program).Assembly);\n\n        var serviceProvider = services.BuildServiceProvider();\n\n        // Run pipeline - each run gets its own scoped services\n        await serviceProvider.RunPipelineAsync<DataProcessingPipeline>();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-scenarios",children:"Advanced Scenarios"}),"\n",(0,t.jsx)(n.h3,{id:"example-5-multiple-observers-composite-pattern",children:"Example 5: Multiple Observers (Composite Pattern)"}),"\n",(0,t.jsx)(n.p,{children:"Use multiple observers to collect different types of metrics or send metrics to multiple destinations."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Microsoft.Extensions.DependencyInjection;\nusing NPipeline.Execution;\nusing NPipeline.Observability;\nusing NPipeline.Observability.DependencyInjection;\n\n// Custom observer for error tracking\npublic sealed class ErrorTrackingObserver : IExecutionObserver\n{\n    private readonly ILogger _logger;\n\n    public ErrorTrackingObserver(ILogger<ErrorTrackingObserver> logger)\n    {\n        _logger = logger;\n    }\n\n    public void OnNodeStarted(NodeExecutionStarted e)\n    {\n        // No action needed\n    }\n\n    public void OnNodeCompleted(NodeExecutionCompleted e)\n    {\n        if (!e.Success && e.Error != null)\n        {\n            _logger.LogError(e.Error, "Node {NodeId} failed after {Duration}ms", e.NodeId, e.Duration.TotalMilliseconds);\n        }\n    }\n\n    public void OnRetry(NodeRetryEvent e)\n    {\n        _logger.LogWarning("Node {NodeId} retry attempt {Attempt}. Last error: {Error}", \n            e.NodeId, e.Attempt, e.LastException?.Message);\n    }\n\n    public void OnDrop(QueueDropEvent e)\n    {\n        _logger.LogWarning("Dropped {ItemCount} items from queue {QueueId} due to backpressure", \n            e.ItemCount, e.QueueId);\n    }\n\n    public void OnQueueMetrics(QueueMetricsEvent e)\n    {\n        // Track queue depth\n        _logger.LogDebug("Queue {QueueId} depth: {Depth}", e.QueueId, e.Depth);\n    }\n}\n\n// Composite observer that combines multiple observers\npublic sealed class CompositeObserver : IExecutionObserver\n{\n    private readonly IEnumerable<IExecutionObserver> _observers;\n\n    public CompositeObserver(IEnumerable<IExecutionObserver> observers)\n    {\n        _observers = observers ?? throw new ArgumentNullException(nameof(observers));\n    }\n\n    public void OnNodeStarted(NodeExecutionStarted e)\n    {\n        foreach (var observer in _observers)\n        {\n            observer.OnNodeStarted(e);\n        }\n    }\n\n    public void OnNodeCompleted(NodeExecutionCompleted e)\n    {\n        foreach (var observer in _observers)\n        {\n            observer.OnNodeCompleted(e);\n        }\n    }\n\n    public void OnRetry(NodeRetryEvent e)\n    {\n        foreach (var observer in _observers)\n        {\n            observer.OnRetry(e);\n        }\n    }\n\n    public void OnDrop(QueueDropEvent e)\n    {\n        foreach (var observer in _observers)\n        {\n            observer.OnDrop(e);\n        }\n    }\n\n    public void OnQueueMetrics(QueueMetricsEvent e)\n    {\n        foreach (var observer in _observers)\n        {\n            observer.OnQueueMetrics(e);\n        }\n    }\n}\n\n// Registration\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var services = new ServiceCollection();\n\n        services.AddLogging(loggingBuilder => loggingBuilder.AddConsole());\n\n        // Add observability\n        services.AddNPipelineObservability();\n\n        // Register custom observers\n        services.AddSingleton<IExecutionObserver, ErrorTrackingObserver>();\n        services.AddSingleton<IExecutionObserver, MetricsCollectingExecutionObserver>();\n        services.AddSingleton<IExecutionObserver, CompositeObserver>();\n\n        services.AddNPipeline(typeof(Program).Assembly);\n\n        var serviceProvider = services.BuildServiceProvider();\n\n        await serviceProvider.RunPipelineAsync<MyPipeline>();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"example-6-custom-metrics-collection-with-enrichment",children:"Example 6: Custom Metrics Collection with Enrichment"}),"\n",(0,t.jsx)(n.p,{children:"Create a custom collector that enriches metrics with additional context."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Microsoft.Extensions.DependencyInjection;\nusing NPipeline.Observability;\nusing NPipeline.Observability.Metrics;\n\n// Custom collector that enriches metrics\npublic sealed class EnrichedObservabilityCollector : IObservabilityCollector\n{\n    private readonly ObservabilityCollector _baseCollector;\n    private readonly IHttpContextAccessor _httpContextAccessor;\n    private readonly ILogger _logger;\n\n    public EnrichedObservabilityCollector(\n        IHttpContextAccessor httpContextAccessor,\n        ILogger<EnrichedObservabilityCollector> logger)\n    {\n        _baseCollector = new ObservabilityCollector();\n        _httpContextAccessor = httpContextAccessor;\n        _logger = logger;\n    }\n\n    public void RecordNodeStart(string nodeId, DateTimeOffset timestamp, int? threadId = null, long? initialMemoryMb = null)\n    {\n        var correlationId = _httpContextAccessor.HttpContext?.TraceIdentifier;\n        _logger.LogInformation("Node {NodeId} started. CorrelationId: {CorrelationId}", nodeId, correlationId);\n        _baseCollector.RecordNodeStart(nodeId, timestamp, threadId, initialMemoryMb);\n    }\n\n    public void RecordNodeEnd(string nodeId, DateTimeOffset timestamp, bool success, Exception? exception = null, \n        long? peakMemoryMb = null, long? processorTimeMs = null)\n    {\n        _baseCollector.RecordNodeEnd(nodeId, timestamp, success, exception, peakMemoryMb, processorTimeMs);\n    }\n\n    public void RecordItemMetrics(string nodeId, long itemsProcessed, long itemsEmitted)\n    {\n        _baseCollector.RecordItemMetrics(nodeId, itemsProcessed, itemsEmitted);\n    }\n\n    public void RecordRetry(string nodeId, int retryCount, string? reason = null)\n    {\n        _logger.LogWarning("Node {NodeId} retry {RetryCount}. Reason: {Reason}", nodeId, retryCount, reason);\n        _baseCollector.RecordRetry(nodeId, retryCount, reason);\n    }\n\n    public void RecordPerformanceMetrics(string nodeId, double throughputItemsPerSec, double averageItemProcessingMs)\n    {\n        _baseCollector.RecordPerformanceMetrics(nodeId, throughputItemsPerSec, averageItemProcessingMs);\n    }\n\n    public IReadOnlyList<INodeMetrics> GetNodeMetrics()\n    {\n        return _baseCollector.GetNodeMetrics();\n    }\n\n    public INodeMetrics? GetNodeMetrics(string nodeId)\n    {\n        return _baseCollector.GetNodeMetrics(nodeId);\n    }\n\n    public IPipelineMetrics CreatePipelineMetrics(string pipelineName, Guid runId, DateTimeOffset startTime, \n        DateTimeOffset? endTime, bool success, Exception? exception = null)\n    {\n        var baseMetrics = _baseCollector.CreatePipelineMetrics(pipelineName, runId, startTime, endTime, success, exception);\n        \n        // Enrich with additional context\n        var correlationId = _httpContextAccessor.HttpContext?.TraceIdentifier;\n        _logger.LogInformation("Pipeline {PipelineName} completed. CorrelationId: {CorrelationId}", \n            pipelineName, correlationId);\n        \n        return baseMetrics;\n    }\n}\n\n// Registration\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var services = new ServiceCollection();\n\n        services.AddLogging(loggingBuilder => loggingBuilder.AddConsole());\n        services.AddHttpContextAccessor();\n\n        // Register custom collector\n        services.AddNPipelineObservability<EnrichedObservabilityCollector, LoggingMetricsSink, LoggingPipelineMetricsSink>();\n\n        services.AddNPipeline(typeof(Program).Assembly);\n\n        var serviceProvider = services.BuildServiceProvider();\n\n        await serviceProvider.RunPipelineAsync<MyPipeline>();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"example-7-performance-monitoring-with-alerts",children:"Example 7: Performance Monitoring with Alerts"}),"\n",(0,t.jsx)(n.p,{children:"Create a metrics sink that monitors performance and triggers alerts when thresholds are exceeded."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Microsoft.Extensions.DependencyInjection;\nusing NPipeline.Observability.Metrics;\n\n// Configuration for performance thresholds\npublic sealed class PerformanceThresholds\n{\n    public double MaxNodeDurationMs { get; set; } = 5000;\n    public double MinThroughputItemsPerSec { get; set; } = 100;\n    public int MaxRetryCount { get; set; } = 3;\n}\n\n// Metrics sink with alerting\npublic sealed class AlertingMetricsSink : IMetricsSink\n{\n    private readonly PerformanceThresholds _thresholds;\n    private readonly ILogger _logger;\n\n    public AlertingMetricsSink(PerformanceThresholds thresholds, ILogger<AlertingMetricsSink> logger)\n    {\n        _thresholds = thresholds ?? throw new ArgumentNullException(nameof(thresholds));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n\n    public Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        // Check for slow nodes\n        if (nodeMetrics.DurationMs.HasValue && nodeMetrics.DurationMs.Value > _thresholds.MaxNodeDurationMs)\n        {\n            _logger.LogWarning(\n                "PERFORMANCE ALERT: Node {NodeId} exceeded duration threshold. " +\n                "Actual: {ActualMs}ms, Threshold: {ThresholdMs}ms",\n                nodeMetrics.NodeId,\n                nodeMetrics.DurationMs.Value,\n                _thresholds.MaxNodeDurationMs);\n        }\n\n        // Check for low throughput\n        if (nodeMetrics.ThroughputItemsPerSec.HasValue && \n            nodeMetrics.ThroughputItemsPerSec.Value < _thresholds.MinThroughputItemsPerSec)\n        {\n            _logger.LogWarning(\n                "PERFORMANCE ALERT: Node {NodeId} below throughput threshold. " +\n                "Actual: {ActualItems}/sec, Threshold: {ThresholdItems}/sec",\n                nodeMetrics.NodeId,\n                nodeMetrics.ThroughputItemsPerSec.Value,\n                _thresholds.MinThroughputItemsPerSec);\n        }\n\n        // Check for excessive retries\n        if (nodeMetrics.RetryCount > _thresholds.MaxRetryCount)\n        {\n            _logger.LogWarning(\n                "RELIABILITY ALERT: Node {NodeId} exceeded retry threshold. " +\n                "Actual: {ActualRetries}, Threshold: {ThresholdRetries}",\n                nodeMetrics.NodeId,\n                nodeMetrics.RetryCount,\n                _thresholds.MaxRetryCount);\n        }\n\n        return Task.CompletedTask;\n    }\n}\n\n// Registration\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var services = new ServiceCollection();\n\n        services.AddLogging(loggingBuilder => loggingBuilder.AddConsole());\n\n        // Configure thresholds\n        var thresholds = new PerformanceThresholds\n        {\n            MaxNodeDurationMs = 3000,\n            MinThroughputItemsPerSec = 50,\n            MaxRetryCount = 2\n        };\n        services.AddSingleton(thresholds);\n\n        // Register alerting sink\n        services.AddNPipelineObservability<AlertingMetricsSink, LoggingPipelineMetricsSink>();\n\n        services.AddNPipeline(typeof(Program).Assembly);\n\n        var serviceProvider = services.BuildServiceProvider();\n\n        await serviceProvider.RunPipelineAsync<MyPipeline>();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"example-8-error-tracking-and-analysis",children:"Example 8: Error Tracking and Analysis"}),"\n",(0,t.jsx)(n.p,{children:"Track and analyze errors across pipeline executions to identify patterns."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Microsoft.Extensions.DependencyInjection;\nusing NPipeline.Observability.Metrics;\nusing System.Collections.Concurrent;\n\n// Error tracker for analyzing patterns\npublic sealed class ErrorTracker\n{\n    private readonly ConcurrentDictionary<string, ErrorStats> _errorStats = new();\n\n    public void TrackError(string nodeId, Exception exception)\n    {\n        var errorType = exception.GetType().Name;\n        var stats = _errorStats.GetOrAdd(errorType, _ => new ErrorStats());\n        stats.Increment(nodeId);\n    }\n\n    public IEnumerable<ErrorStats> GetErrorStats()\n    {\n        return _errorStats.Values.OrderByDescending(s => s.Count);\n    }\n}\n\npublic sealed class ErrorStats\n{\n    private readonly ConcurrentDictionary<string, int> _nodeCounts = new();\n\n    public int Count { get; private set; }\n    public string? MostFrequentNode { get; private set; }\n\n    public void Increment(string nodeId)\n    {\n        Interlocked.Increment(ref Count);\n        _nodeCounts.AddOrUpdate(nodeId, 1, (_, count) => count + 1);\n\n        MostFrequentNode = _nodeCounts\n            .OrderByDescending(kvp => kvp.Value)\n            .FirstOrDefault().Key;\n    }\n}\n\n// Metrics sink that tracks errors\npublic sealed class ErrorTrackingMetricsSink : IMetricsSink\n{\n    private readonly ErrorTracker _errorTracker;\n    private readonly ILogger _logger;\n\n    public ErrorTrackingMetricsSink(ErrorTracker errorTracker, ILogger<ErrorTrackingMetricsSink> logger)\n    {\n        _errorTracker = errorTracker ?? throw new ArgumentNullException(nameof(errorTracker));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n\n    public Task RecordAsync(INodeMetrics nodeMetrics, CancellationToken cancellationToken)\n    {\n        if (!nodeMetrics.Success && nodeMetrics.Exception != null)\n        {\n            _errorTracker.TrackError(nodeMetrics.NodeId, nodeMetrics.Exception);\n            _logger.LogError(\n                nodeMetrics.Exception,\n                "Error in node {NodeId}: {ErrorMessage}",\n                nodeMetrics.NodeId,\n                nodeMetrics.Exception.Message);\n        }\n\n        return Task.CompletedTask;\n    }\n}\n\n// Registration\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var services = new ServiceCollection();\n\n        services.AddLogging(loggingBuilder => loggingBuilder.AddConsole());\n\n        // Register error tracker as singleton to persist across runs\n        services.AddSingleton<ErrorTracker>();\n\n        // Register error tracking sink\n        services.AddNPipelineObservability<ErrorTrackingMetricsSink, LoggingPipelineMetricsSink>();\n\n        services.AddNPipeline(typeof(Program).Assembly);\n\n        var serviceProvider = services.BuildServiceProvider();\n\n        // Run pipeline multiple times to collect error patterns\n        for (int i = 0; i < 10; i++)\n        {\n            await serviceProvider.RunPipelineAsync<MyPipeline>();\n        }\n\n        // Analyze error patterns\n        var errorTracker = serviceProvider.GetRequiredService<ErrorTracker>();\n        foreach (var errorStat in errorTracker.GetErrorStats())\n        {\n            Console.WriteLine($"Error Type: {errorStat.GetType().Name}, Count: {errorStat.Count}, " +\n                $"Most Frequent Node: {errorStat.MostFrequentNode}");\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"complete-working-example",children:"Complete Working Example"}),"\n",(0,t.jsx)(n.h3,{id:"example-9-end-to-end-etl-pipeline-with-observability",children:"Example 9: End-to-End ETL Pipeline with Observability"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing NPipeline;\nusing NPipeline.DataFlow;\nusing NPipeline.DataFlow.DataPipes;\nusing NPipeline.Nodes;\nusing NPipeline.Observability.DependencyInjection;\nusing NPipeline.Pipeline;\n\n// Data models\npublic sealed record RawData(int Id, string Value);\npublic sealed record ProcessedData(int Id, string Value, DateTime ProcessedAt);\n\n// Pipeline definition\npublic sealed class EtlPipeline : IPipelineDefinition\n{\n    public void Define(PipelineBuilder builder, PipelineContext context)\n    {\n        var source = builder.AddSource<CsvDataSource, RawData>();\n        var validate = builder.AddTransform<DataValidationTransform, RawData, RawData>();\n        var transform = builder.AddTransform<DataTransform, RawData, ProcessedData>();\n        var sink = builder.AddSink<DatabaseSink, ProcessedData>();\n\n        builder.Connect(source, validate);\n        builder.Connect(validate, transform);\n        builder.Connect(transform, sink);\n    }\n}\n\n// Source: Read from CSV\npublic sealed class CsvDataSource : SourceNode<RawData>\n{\n    public IDataPipe<RawData> ExecuteAsync(PipelineContext context, CancellationToken cancellationToken = default)\n    {\n        static async IAsyncEnumerable<RawData> ReadFromCsv()\n        {\n            // Simulate reading from CSV file\n            for (int i = 1; i <= 1000; i++)\n            {\n                await Task.Delay(1, cancellationToken);\n                yield return new RawData(i, $"Value_{i}");\n            }\n        }\n\n        return new StreamingDataPipe<RawData>(ReadFromCsv());\n    }\n}\n\n// Transform: Validate data\npublic sealed class DataValidationTransform : TransformNode<RawData, RawData>\n{\n    public override Task<RawData> ExecuteAsync(RawData item, PipelineContext context, CancellationToken cancellationToken = default)\n    {\n        // Simulate validation\n        if (item.Id <= 0)\n        {\n            throw new ArgumentException($"Invalid ID: {item.Id}");\n        }\n\n        return Task.FromResult(item);\n    }\n}\n\n// Transform: Process data\npublic sealed class DataTransform : TransformNode<RawData, ProcessedData>\n{\n    public override Task<ProcessedData> ExecuteAsync(RawData item, PipelineContext context, CancellationToken cancellationToken = default)\n    {\n        var processed = new ProcessedData(\n            item.Id,\n            item.Value.ToUpper(),\n            DateTime.UtcNow);\n\n        return Task.FromResult(processed);\n    }\n}\n\n// Sink: Write to database\npublic sealed class DatabaseSink : SinkNode<ProcessedData>\n{\n    private readonly ILogger<DatabaseSink> _logger;\n\n    public DatabaseSink(ILogger<DatabaseSink> logger)\n    {\n        _logger = logger;\n    }\n\n    public async Task ExecuteAsync(IDataPipe<ProcessedData> input, PipelineContext context, \n        IPipelineActivity parentActivity, CancellationToken cancellationToken = default)\n    {\n        int count = 0;\n        await foreach (var item in input.WithCancellation(cancellationToken))\n        {\n            // Simulate database write\n            await Task.Delay(1, cancellationToken);\n            count++;\n        }\n\n        _logger.LogInformation("Wrote {Count} items to database", count);\n    }\n}\n\n// Program\npublic sealed class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var services = new ServiceCollection();\n\n        // Configure logging\n        services.AddLogging(loggingBuilder =>\n        {\n            loggingBuilder.AddConsole();\n            loggingBuilder.SetMinimumLevel(LogLevel.Information);\n        });\n\n        // Add observability with default logging sinks\n        services.AddNPipelineObservability();\n\n        // Register NPipeline\n        services.AddNPipeline(typeof(Program).Assembly);\n\n        var serviceProvider = services.BuildServiceProvider();\n\n        Console.WriteLine("Starting ETL Pipeline with Observability...");\n        Console.WriteLine();\n\n        // Run the pipeline\n        await serviceProvider.RunPipelineAsync<EtlPipeline>();\n\n        Console.WriteLine();\n        Console.WriteLine("Pipeline execution completed. Check logs for detailed metrics.");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/extensions/observability/",children:"Observability Overview"})}),": Introduction to observability features"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/extensions/observability/configuration",children:"Configuration Guide"})}),": Setup and configuration options"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/extensions/observability/metrics",children:"Metrics Reference"})}),": Detailed metrics documentation"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);