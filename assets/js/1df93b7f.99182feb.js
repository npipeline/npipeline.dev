"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[4583],{8198:(e,i,t)=>{t.r(i),t.d(i,{default:()=>x});var s=t(8774),a=t(4586),n=t(9139),r=t(1107);const o={hero:"hero_aEcG",heroContent:"heroContent_mKPX",heroTitle:"heroTitle_qg2I",heroTagline:"heroTagline_QIlK",heroDescription:"heroDescription_UJGW",heroButtons:"heroButtons_r52D",primaryButton:"primaryButton_r1SK",secondaryButton:"secondaryButton_uRtX",featuresSection:"featuresSection_Y0uK",sectionTitle:"sectionTitle_Ut5p",sectionSubtitle:"sectionSubtitle_AZuW",featuresGrid:"featuresGrid_cNCB",featureCard:"featureCard_Jbd_",featureTitle:"featureTitle_cv5G",featureDescription:"featureDescription_dZoZ",benefitsSection:"benefitsSection_TaDQ",benefitsGrid:"benefitsGrid__Kw_",benefitItem:"benefitItem_LZuK",benefitNumber:"benefitNumber_DUbJ",benefitLabel:"benefitLabel_DqWJ",benefitDescription:"benefitDescription_zZh_",imagePlaceholder:"imagePlaceholder_RQPD",useCasesSection:"useCasesSection__Osl",useCasesGrid:"useCasesGrid_PM67",useCaseCard:"useCaseCard_t5pd",useCaseTitle:"useCaseTitle_AjwH",useCaseDescription:"useCaseDescription_TqlS",useCaseDetails:"useCaseDetails_TtoR",useCaseLink:"useCaseLink_jKt0",codeExample:"codeExample_BekQ",whySection:"whySection_dpBx",whyGrid:"whyGrid_RYCj",whyCard:"whyCard_ytll",whyCardTitle:"whyCardTitle_W6CV",whyCardDescription:"whyCardDescription_MM48",ctaSection:"ctaSection_bmsv",ctaContent:"ctaContent_bC4x",ctaTitle:"ctaTitle_arch",ctaDescription:"ctaDescription_HswS",ctaButton:"ctaButton_g0jw",imageSection:"imageSection_UAHD",imageSectionContent:"imageSectionContent_zrXY",imageSectionText:"imageSectionText_a6Zv",imageSectionImage:"imageSectionImage_J05g"};var c=t(4848);function l(){const{siteConfig:e}=(0,a.A)();return(0,c.jsx)("section",{className:o.hero,children:(0,c.jsxs)("div",{className:o.heroContent,children:[(0,c.jsx)(r.A,{as:"h1",className:o.heroTitle,children:e.title}),(0,c.jsx)("p",{className:o.heroTagline,children:e.tagline}),(0,c.jsx)("p",{className:o.heroDescription,children:"High-performance, zero-allocation data pipelines built for .NET developers. Process millions of records per second with minimal GC pressure using modern async patterns and fluent APIs that integrate seamlessly with your existing .NET ecosystem."}),(0,c.jsxs)("div",{className:o.heroButtons,children:[(0,c.jsx)(s.A,{className:o.primaryButton,to:"/docs/getting-started/quick-start",children:"Build Your First Pipeline"}),(0,c.jsx)(s.A,{className:o.secondaryButton,to:"/docs/introduction/why-npipeline",children:"See Performance Benchmarks"})]})]})})}function d(){return(0,c.jsx)("section",{className:o.featuresSection,children:(0,c.jsxs)("div",{className:"container",children:[(0,c.jsx)(r.A,{as:"h2",className:o.sectionTitle,children:"The .NET Performance Challenge"}),(0,c.jsx)("p",{className:o.sectionSubtitle,children:"Traditional data processing in .NET faces fundamental performance barriers"}),(0,c.jsxs)("div",{className:o.featuresGrid,children:[(0,c.jsxs)("div",{className:o.featureCard,children:[(0,c.jsx)("h3",{className:o.featureTitle,children:"GC Pressure & Allocations"}),(0,c.jsx)("p",{className:o.featureDescription,children:"Conventional pipelines allocate objects at every stage, triggering frequent garbage collection that introduces latency spikes and unpredictable performance in high-throughput scenarios."})]}),(0,c.jsxs)("div",{className:o.featureCard,children:[(0,c.jsx)("h3",{className:o.featureTitle,children:"Blocking I/O Patterns"}),(0,c.jsx)("p",{className:o.featureDescription,children:"Synchronous processing blocks threads, limiting scalability. Modern .NET async/await patterns are often poorly implemented in data processing libraries, squandering the benefits of async I/O."})]}),(0,c.jsxs)("div",{className:o.featureCard,children:[(0,c.jsx)("h3",{className:o.featureTitle,children:"Reflection Overhead"}),(0,c.jsx)("p",{className:o.featureDescription,children:"Many frameworks rely on runtime reflection for type conversion and serialization, adding significant CPU overhead that becomes critical when processing millions of records."})]}),(0,c.jsxs)("div",{className:o.featureCard,children:[(0,c.jsx)("h3",{className:o.featureTitle,children:"Memory Bloat"}),(0,c.jsx)("p",{className:o.featureDescription,children:"Eager loading and buffering strategies consume excessive memory, forcing trade-offs between performance and resource utilization in production environments."})]}),(0,c.jsxs)("div",{className:o.featureCard,children:[(0,c.jsx)("h3",{className:o.featureTitle,children:"Complex Error Propagation"}),(0,c.jsx)("p",{className:o.featureDescription,children:"Traditional approaches struggle with async error handling, making resilience patterns difficult to implement correctly and leading to fragile production systems."})]}),(0,c.jsxs)("div",{className:o.featureCard,children:[(0,c.jsx)("h3",{className:o.featureTitle,children:"Testing Complexity"}),(0,c.jsx)("p",{className:o.featureDescription,children:"Tightly coupled components and hidden dependencies make unit testing challenging, reducing code quality and making refactoring risky in complex data processing scenarios."})]})]})]})})}function m(){return(0,c.jsx)("section",{className:o.imageSection,children:(0,c.jsx)("div",{className:"container",children:(0,c.jsxs)("div",{className:o.imageSectionContent,children:[(0,c.jsxs)("div",{className:o.imageSectionText,children:[(0,c.jsx)("h2",{children:"Zero-Allocation Architecture"}),(0,c.jsx)("p",{children:"NPipeline eliminates runtime allocations through pre-compiled delegates and memory pooling strategies. Our pre-compiled execution plans create optimized code paths at initialization time, eliminating reflection overhead during execution. Combined with ValueTask optimization for synchronous operations, this reduces garbage collection pressure by up to 95% in high-throughput scenarios."}),(0,c.jsx)("p",{children:"Process millions of records with predictable latency patterns. The streaming design processes data as it flows without materializing entire datasets in memory, making it ideal for high-throughput scenarios where performance matters."}),(0,c.jsx)(s.A,{className:o.primaryButton,to:"/docs/advanced-topics/performance-hygiene",children:"Explore Performance Techniques"})]}),(0,c.jsx)("div",{className:o.imageSectionImage,children:"[Performance Metrics Visualization]"})]})})})}function h(){return(0,c.jsx)("section",{className:o.benefitsSection,children:(0,c.jsxs)("div",{className:"container",children:[(0,c.jsx)(r.A,{as:"h2",className:o.sectionTitle,children:"Graph-Based Architecture"}),(0,c.jsx)("p",{className:o.sectionSubtitle,children:"Visual, maintainable pipelines that scale with complexity"}),(0,c.jsxs)("div",{className:o.benefitsGrid,children:[(0,c.jsxs)("div",{children:[(0,c.jsxs)("div",{className:o.benefitItem,children:[(0,c.jsx)("div",{className:o.benefitNumber,children:"1"}),(0,c.jsx)("div",{className:o.benefitLabel,children:"Declarative Pipeline Definition"}),(0,c.jsx)("p",{className:o.benefitDescription,children:"Express complex data flows with a fluent, intuitive API. Each node represents a discrete operation that can be developed, tested, and optimized independently."})]}),(0,c.jsxs)("div",{className:o.benefitItem,children:[(0,c.jsx)("div",{className:o.benefitNumber,children:"2"}),(0,c.jsx)("div",{className:o.benefitLabel,children:"Dependency Injection Integration"}),(0,c.jsx)("p",{className:o.benefitDescription,children:"Seamless integration with Microsoft.Extensions.DependencyInjection. Register pipeline components as services and leverage .NET's built-in DI container for clean, testable code."})]}),(0,c.jsxs)("div",{className:o.benefitItem,children:[(0,c.jsx)("div",{className:o.benefitNumber,children:"3"}),(0,c.jsx)("div",{className:o.benefitLabel,children:"Compile-Time Validation"}),(0,c.jsx)("p",{className:o.benefitDescription,children:"Source generators analyze your pipeline at build time, catching configuration errors before they reach production. No more runtime surprises from misconfigured connections."})]})]}),(0,c.jsx)("div",{className:o.imagePlaceholder,children:"[Graph Architecture Visualization]"})]})]})})}function u(){return(0,c.jsx)("section",{className:o.featuresSection,children:(0,c.jsxs)("div",{className:"container",children:[(0,c.jsx)(r.A,{as:"h2",className:o.sectionTitle,children:"Resilience Without Compromise"}),(0,c.jsx)("p",{className:o.sectionSubtitle,children:"Production-grade resilience patterns built into the framework"}),(0,c.jsx)("div",{className:o.featuresGrid,children:[{title:"Circuit Breaker Pattern",description:"Automatically failing fast when downstream systems are unavailable, with configurable recovery strategies."},{title:"Retry Policies",description:"Exponential backoff and jitter algorithms for handling transient failures in external dependencies."},{title:"Dead Letter Queues",description:"Automatic isolation of problematic records for later analysis without stopping pipeline execution."},{title:"Graceful Degradation",description:"Continue processing with reduced functionality when non-critical components fail."},{title:"Timeout Management",description:"Configurable timeouts at the node level to prevent cascading failures."},{title:"Health Monitoring",description:"Built-in health checks and metrics for integration with ASP.NET Core health endpoints."}].map((e,i)=>(0,c.jsxs)("div",{className:o.featureCard,children:[(0,c.jsx)("h3",{className:o.featureTitle,children:e.title}),(0,c.jsx)("p",{className:o.featureDescription,children:e.description})]},i))})]})})}function p(){return(0,c.jsx)("section",{className:o.useCasesSection,children:(0,c.jsxs)("div",{className:"container",children:[(0,c.jsx)(r.A,{as:"h2",className:o.sectionTitle,children:"Built For Your Role"}),(0,c.jsx)("p",{className:o.sectionSubtitle,children:"Tailored patterns and examples for every .NET developer persona"}),(0,c.jsx)("div",{className:o.useCasesGrid,children:[{title:"For Backend Engineers",description:"Build high-throughput APIs and services that process data streams efficiently. Integrate with Entity Framework Core and other ORMs without performance penalties.",details:"Create responsive APIs that handle thousands of concurrent requests with minimal resource usage. Process real-time data feeds, implement caching strategies, and build scalable microservices that maintain low latency even under heavy load."},{title:"For Data Engineers",description:"Create ETL pipelines that process millions of records without memory bloat. Perfect for data warehousing, migration, and transformation tasks.",details:"Design data transformation workflows that handle massive datasets efficiently. Implement complex data validation, enrichment, and aggregation operations. Build reliable data pipelines that can process both batch and streaming workloads with minimal operational overhead."},{title:"For Microservice Developers",description:"Implement event-driven architectures with reliable message processing. Handle async workflows across service boundaries with confidence.",details:"Build robust event-driven systems with guaranteed message delivery. Implement saga patterns for distributed transactions, create event sourcing solutions, and design message routing topologies that maintain consistency across microservice boundaries."},{title:"For Performance Engineers",description:"Optimize critical paths with zero-allocation processing. Monitor and tune performance with built-in metrics and diagnostics.",details:"Fine-tune pipeline performance with detailed observability features. Implement custom memory pooling strategies, optimize throughput with parallel processing, and leverage built-in performance counters to identify and eliminate bottlenecks in high-throughput scenarios."}].map((e,i)=>(0,c.jsxs)("div",{className:o.useCaseCard,children:[(0,c.jsx)("h3",{className:o.useCaseTitle,children:e.title}),(0,c.jsx)("p",{className:o.useCaseDescription,children:e.description}),(0,c.jsx)("p",{className:o.useCaseDetails,children:e.details}),(0,c.jsx)(s.A,{className:o.useCaseLink,to:"/docs/samples-guide",children:"View Full Examples \u2192"})]},i))})]})})}function f(){return(0,c.jsx)("section",{className:o.imageSection,style:{backgroundColor:"#f0f6f7"},children:(0,c.jsx)("div",{className:"container",children:(0,c.jsxs)("div",{className:o.imageSectionContent,children:[(0,c.jsx)("div",{className:o.imageSectionImage,children:"[Quick Start Code Visualization]"}),(0,c.jsxs)("div",{className:o.imageSectionText,children:[(0,c.jsx)("h2",{children:"Implementation Quick Start"}),(0,c.jsx)("p",{children:"Get NPipeline running in minutes with our streamlined installation process. Built as a set of NuGet packages that integrate seamlessly with your existing .NET projects."}),(0,c.jsx)("p",{children:"Start with our pre-built components for common scenarios, then extend with custom nodes as your requirements evolve. Our comprehensive documentation and sample projects accelerate development from prototype to production."}),(0,c.jsx)(s.A,{className:o.primaryButton,to:"/docs/getting-started/quick-start",children:"5-Minute Quick Start Guide"})]})]})})})}function g(){return(0,c.jsx)("section",{className:o.whySection,children:(0,c.jsxs)("div",{className:"container",children:[(0,c.jsx)(r.A,{as:"h2",className:o.sectionTitle,children:"Trusted by .NET Developers"}),(0,c.jsx)("div",{className:o.whyGrid,children:[{quote:"NPipeline reduced our data processing time by 70% while cutting memory usage in half. The zero-allocation architecture is a game-changer for high-throughput scenarios.",author:"Senior Software Engineer",company:"FinTech Company"},{quote:"The graph-based design made our complex ETL processes maintainable. New team members can understand data flows in minutes, not days.",author:"Data Platform Lead",company:"E-commerce Platform"},{quote:"Finally, a data pipeline library that embraces modern .NET patterns. The dependency injection integration and async-first design fit perfectly with our architecture.",author:"Principal Architect",company:"Enterprise Software"}].map((e,i)=>(0,c.jsxs)("div",{className:o.whyCard,children:[(0,c.jsxs)("p",{className:o.whyCardDescription,children:['"',e.quote,'"']}),(0,c.jsx)("p",{className:o.whyCardTitle,style:{marginTop:"1rem",fontSize:"0.9rem"},children:e.author}),(0,c.jsx)("p",{style:{color:"#666",fontSize:"0.85rem"},children:e.company})]},i))}),(0,c.jsxs)("div",{style:{textAlign:"center",marginTop:"3rem"},children:[(0,c.jsx)(r.A,{as:"h3",style:{fontSize:"1.5rem",marginBottom:"1rem"},children:"Join Our Growing Community"}),(0,c.jsx)("p",{style:{color:"#666",marginBottom:"2rem",maxWidth:"600px",margin:"0 auto 2rem"},children:"Connect with fellow .NET developers building high-performance data pipelines. Get help, share patterns, and contribute to the project."}),(0,c.jsxs)("div",{style:{display:"flex",gap:"1rem",justifyContent:"center",flexWrap:"wrap"},children:[(0,c.jsx)(s.A,{className:o.primaryButton,to:"https://github.com/npipeline/npipeline",children:"View on GitHub"}),(0,c.jsx)(s.A,{className:o.secondaryButton,to:"/docs/introduction/faq",children:"Read FAQ"})]})]})]})})}function x(){const{siteConfig:e}=(0,a.A)();return(0,c.jsxs)(n.A,{title:`${e.title} - ${e.tagline}`,description:"High-performance, zero-allocation data pipelines for .NET. Build ETL workflows, real-time data processing, and event-driven systems with modern async patterns and production-grade resilience.",children:[(0,c.jsx)(l,{}),(0,c.jsx)(d,{}),(0,c.jsx)(m,{}),(0,c.jsx)(h,{}),(0,c.jsx)(u,{}),(0,c.jsx)(p,{}),(0,c.jsx)(f,{}),(0,c.jsx)(g,{})]})}}}]);