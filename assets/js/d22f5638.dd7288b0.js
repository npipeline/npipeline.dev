"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[7745],{28453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>o});var i=n(96540);const t={},s=i.createContext(t);function a(e){const r=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:r},e.children)}},67843:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-concepts/resilience/retries","title":"Retry Configuration","description":"Learn how to configure retry behavior in NPipeline using PipelineRetryOptions to manage item retries and node restarts.","source":"@site/docs/core-concepts/resilience/retries.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/retries","permalink":"/docs/core-concepts/resilience/retries","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Retry Configuration","description":"Learn how to configure retry behavior in NPipeline using PipelineRetryOptions to manage item retries and node restarts.","sidebar_position":7},"sidebar":"docsSidebar","previous":{"title":"Troubleshooting","permalink":"/docs/core-concepts/resilience/troubleshooting"},"next":{"title":"Retry Delays","permalink":"/docs/core-concepts/resilience/retry-delays"}}');var t=n(74848),s=n(28453);const a={title:"Retry Configuration",description:"Learn how to configure retry behavior in NPipeline using PipelineRetryOptions to manage item retries and node restarts.",sidebar_position:7},o="Retry Configuration",l={},c=[{value:"Overview",id:"overview",level:2},{value:"PipelineRetryOptions",id:"pipelineretryoptions",level:2},{value:"Basic Retry Configuration",id:"basic-retry-configuration",level:2},{value:"Global Retry Options",id:"global-retry-options",level:3},{value:"Per-Node Retry Options",id:"per-node-retry-options",level:3},{value:"Use Cases for Per-Node Retry Configuration",id:"use-cases-for-per-node-retry-configuration",level:4},{value:"Precedence Rules",id:"precedence-rules",level:4},{value:"Related Documentation",id:"related-documentation",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2},{value:"Why Backoff and Jitter Matter",id:"why-backoff-and-jitter-matter",level:3},{value:"Available Backoff Strategies",id:"available-backoff-strategies",level:3},{value:"Exponential Backoff",id:"exponential-backoff",level:4},{value:"Linear Backoff",id:"linear-backoff",level:4},{value:"Fixed Delay",id:"fixed-delay",level:4},{value:"Available Jitter Strategies",id:"available-jitter-strategies",level:3},{value:"Decorrelated Jitter",id:"decorrelated-jitter",level:4},{value:"No Jitter",id:"no-jitter",level:4},{value:"Recommended Strategy Combinations",id:"recommended-strategy-combinations",level:3},{value:"Configuration at Initialization",id:"configuration-at-initialization",level:3},{value:"Related Documentation",id:"related-documentation-1",level:2},{value:"Best Practices",id:"best-practices-1",level:2},{value:"See Also",id:"see-also-1",level:2},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"retry-configuration",children:"Retry Configuration"})}),"\n",(0,t.jsx)(r.p,{children:"Retry configuration in NPipeline allows you to define how the pipeline should respond to transient failures by retrying operations. This is essential for building resilient pipelines that can recover from temporary issues without manual intervention."}),"\n",(0,t.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(r.p,{children:"NPipeline provides configurable retry options that control both individual item retries (for node-level errors) and node restart attempts (for pipeline-level errors). These options can be set globally for the entire pipeline or overridden for specific nodes."}),"\n",(0,t.jsx)(r.h2,{id:"pipelineretryoptions",children:"PipelineRetryOptions"}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.a,{href:"../../src/NPipeline/Configuration/PipelineRetryOptions.cs",children:(0,t.jsx)(r.code,{children:"PipelineRetryOptions"})})," record configures retry behavior for items and node restarts."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public sealed record PipelineRetryOptions(\r\n    int MaxItemRetries,\r\n    int MaxNodeRestartAttempts,\r\n    int MaxSequentialNodeAttempts,\r\n    int? MaxMaterializedItems = null) // Null => unbounded (no cap)\r\n{\r\n    public static PipelineRetryOptions Default { get; } = new(0, 3, 5);\r\n\r\n    public PipelineRetryOptions With(\r\n        int? maxItemRetries = null,\r\n        int? maxNodeRestartAttempts = null,\r\n        int? maxSequentialNodeAttempts = null,\r\n        int? maxMaterializedItems = null)\r\n    {\r\n        return new PipelineRetryOptions(\r\n            maxItemRetries ?? MaxItemRetries,\r\n            maxNodeRestartAttempts ?? MaxNodeRestartAttempts,\r\n            maxSequentialNodeAttempts ?? MaxSequentialNodeAttempts,\r\n            maxMaterializedItems ?? MaxMaterializedItems);\r\n    }\r\n}\n"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"MaxItemRetries"})}),": The maximum number of times an individual item will be re-processed by a node's execution strategy if its ",(0,t.jsx)(r.code,{children:"INodeErrorHandler"})," returns ",(0,t.jsx)(r.code,{children:"NodeErrorDecision.Retry"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"MaxNodeRestartAttempts"})}),": The maximum number of times a node's entire stream will be re-executed by ",(0,t.jsx)(r.code,{children:"ResilientExecutionStrategy"})," if ",(0,t.jsx)(r.code,{children:"IPipelineErrorHandler"})," returns ",(0,t.jsx)(r.code,{children:"PipelineErrorDecision.RestartNode"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"MaxSequentialNodeAttempts"})}),": (Used by ",(0,t.jsx)(r.code,{children:"SequentialExecutionStrategy"})," for node restarts) The maximum number of attempts for a node in a sequential pipeline."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"MaxMaterializedItems"})}),": An optional cap on the number of items to materialize (buffer) for replay when using ",(0,t.jsx)(r.code,{children:"ResilientExecutionStrategy"}),".","\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["When ",(0,t.jsx)(r.code,{children:"null"})," (default): Unbounded materialization - all items are buffered"]}),"\n",(0,t.jsx)(r.li,{children:"When has a value: Limited materialization - only the specified number of items are buffered, after which new items replace the oldest ones"}),"\n",(0,t.jsx)(r.li,{children:"This parameter prevents excessive memory consumption in case of large streams and is particularly important for long-running pipelines with high throughput"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"basic-retry-configuration",children:"Basic Retry Configuration"}),"\n",(0,t.jsx)(r.h3,{id:"global-retry-options",children:"Global Retry Options"}),"\n",(0,t.jsx)(r.p,{children:"Retry options can be set globally for the pipeline:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\npublic sealed class RetryPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<DataSource, string>();\r\n        var transformHandle = builder.AddTransform<DataTransform, string, string>();\r\n        var sinkHandle = builder.AddSink<DataSink, string>();\r\n\r\n        builder.Connect(sourceHandle, transformHandle);\r\n        builder.Connect(transformHandle, sinkHandle);\r\n\r\n        // Configure retry policy using PipelineRetryOptions\r\n        builder.WithRetryOptions(new PipelineRetryOptions(\r\n            MaxItemRetries: 3,\r\n            MaxNodeRestartAttempts: 2,\r\n            MaxSequentialNodeAttempts: 5\r\n        ));\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var runner = PipelineRunner.Create();\r\n        await runner.RunAsync<RetryPipelineDefinition>();\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"per-node-retry-options",children:"Per-Node Retry Options"}),"\n",(0,t.jsxs)(r.p,{children:["Override the global retry options for a specific node using the ",(0,t.jsx)(r.code,{children:"WithRetryOptions"})," method that accepts a ",(0,t.jsx)(r.code,{children:"NodeHandle"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\npublic sealed class PerNodeRetryPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var sourceHandle = builder.AddSource<DataSource, string>("source");\r\n        var criticalTransformHandle = builder.AddTransform<CriticalDataTransform, string, string>("critical-transform");\r\n        var normalTransformHandle = builder.AddTransform<NormalDataTransform, string, string>("normal-transform");\r\n        var sinkHandle = builder.AddSink<DataSink, string>("sink");\r\n\r\n        builder.Connect(sourceHandle, criticalTransformHandle);\r\n        builder.Connect(criticalTransformHandle, normalTransformHandle);\r\n        builder.Connect(normalTransformHandle, sinkHandle);\r\n\r\n        // Configure global retry options (default for all nodes)\r\n        builder.WithRetryOptions(new PipelineRetryOptions(\r\n            MaxItemRetries: 2,\r\n            MaxNodeRestartAttempts: 3,\r\n            MaxSequentialNodeAttempts: 5\r\n        ));\r\n\r\n        // Override retry options for the critical transform\r\n        builder.WithRetryOptions(criticalTransformHandle, new PipelineRetryOptions(\r\n            MaxItemRetries: 5,              // More retries for critical processing\r\n            MaxNodeRestartAttempts: 10,      // More restart attempts\r\n            MaxSequentialNodeAttempts: 15,   // Higher total attempt limit\r\n            MaxMaterializedItems: 1000       // Higher memory limit for replay\r\n        ));\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h4,{id:"use-cases-for-per-node-retry-configuration",children:"Use Cases for Per-Node Retry Configuration"}),"\n",(0,t.jsx)(r.p,{children:"Per-node retry options are useful in scenarios where different parts of your pipeline have different resilience requirements:"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"1. External API Calls vs. Internal Processing"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// More aggressive retries for external API calls\r\nbuilder.WithRetryOptions(apiTransformHandle, new PipelineRetryOptions(\r\n    MaxItemRetries: 5,\r\n    MaxNodeRestartAttempts: 3,\r\n    MaxSequentialNodeAttempts: 10\r\n));\r\n\r\n// Conservative retries for internal data processing\r\nbuilder.WithRetryOptions(internalTransformHandle, new PipelineRetryOptions(\r\n    MaxItemRetries: 1,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 3\r\n));\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"2. Critical vs. Non-Critical Processing"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Maximum resilience for critical business logic\r\nbuilder.WithRetryOptions(criticalProcessorHandle, new PipelineRetryOptions(\r\n    MaxItemRetries: 10,\r\n    MaxNodeRestartAttempts: 5,\r\n    MaxSequentialNodeAttempts: 20,\r\n    MaxMaterializedItems: 5000\r\n));\r\n\r\n// Best-effort processing for non-critical data\r\nbuilder.WithRetryOptions(loggingProcessorHandle, new PipelineRetryOptions(\r\n    MaxItemRetries: 0,  // No retries for logging\r\n    MaxNodeRestartAttempts: 1,\r\n    MaxSequentialNodeAttempts: 2\r\n));\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"3. Resource-Intensive Operations"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Limited retries for memory-intensive operations\r\nbuilder.WithRetryOptions(memoryIntensiveHandle, new PipelineRetryOptions(\r\n    MaxItemRetries: 1,\r\n    MaxNodeRestartAttempts: 1,\r\n    MaxSequentialNodeAttempts: 2,\r\n    MaxMaterializedItems: 100  // Strict memory limit\r\n));\n"})}),"\n",(0,t.jsx)(r.h4,{id:"precedence-rules",children:"Precedence Rules"}),"\n",(0,t.jsx)(r.p,{children:"When both global and per-node retry options are configured:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Per-node options take precedence"})," over global options"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Unspecified properties"})," in per-node options inherit from global options"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Global options"})," apply to all nodes without specific overrides"]}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Global configuration\r\nbuilder.WithRetryOptions(new PipelineRetryOptions(\r\n    MaxItemRetries: 2,\r\n    MaxNodeRestartAttempts: 3,\r\n    MaxSequentialNodeAttempts: 5\r\n));\r\n\r\n// Per-node override (only MaxItemRetries is overridden)\r\nbuilder.WithRetryOptions(specificNodeHandle, new PipelineRetryOptions(\r\n    MaxItemRetries: 5,              // Overridden\r\n    MaxNodeRestartAttempts: 3,       // Inherited from global\r\n    MaxSequentialNodeAttempts: 5      // Inherited from global\r\n));\n"})}),"\n",(0,t.jsx)(r.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,t.jsxs)(r.p,{children:["For delay strategies and advanced configuration patterns, see ",(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/retry-delays",children:"Retry Delay Strategies"}),"."]}),"\n",(0,t.jsx)(r.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Start conservative"}),": Begin with low retry counts and increase only if needed."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Consider resource impact"}),": Each retry consumes resources. Set reasonable limits."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Use per-node configuration"}),": Different nodes often need different retry strategies."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Monitor retry metrics"}),": Track how often retries occur to identify persistent issues."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Combine with error handlers"}),": Use retry options with error handlers for comprehensive resilience."]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling"})," - Configure what happens on errors (retry, skip, dead-letter)"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/retry-delays",children:"Retry Delay Strategies"})," - Configure delays between retry attempts"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/circuit-breakers",children:"Circuit Breakers"})," - Prevent cascading failures"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/getting-started",children:"Getting Started with Resilience"})," - Quick guide to resilience features"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"why-backoff-and-jitter-matter",children:"Why Backoff and Jitter Matter"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"The Thundering Herd Problem:"})," When multiple pipeline instances encounter failures simultaneously and retry immediately, they can overwhelm a recovering service, causing cascading failures. Backoff strategies prevent this by increasing delays between retries, and jitter adds randomness to prevent synchronized retries."]}),"\n",(0,t.jsx)(r.h3,{id:"available-backoff-strategies",children:"Available Backoff Strategies"}),"\n",(0,t.jsx)(r.h4,{id:"exponential-backoff",children:"Exponential Backoff"}),"\n",(0,t.jsx)(r.p,{children:"Delays grow exponentially, ideal for distributed systems with transient failures:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Configuration approach\r\nvar config = new ExponentialBackoffConfiguration(\r\n    baseDelay: TimeSpan.FromSeconds(1),\r\n    multiplier: 2.0,\r\n    maxDelay: TimeSpan.FromMinutes(1));\r\n\r\n// Runtime configuration via PipelineContext\r\ncontext.UseExponentialBackoffDelay(\r\n    baseDelay: TimeSpan.FromSeconds(1),\r\n    multiplier: 2.0,\r\n    maxDelay: TimeSpan.FromMinutes(1));\r\n\r\n// Direct delegate creation\r\nvar exponentialBackoff = BackoffStrategies.ExponentialBackoff(\r\n    baseDelay: TimeSpan.FromSeconds(1),\r\n    multiplier: 2.0,\r\n    maxDelay: TimeSpan.FromMinutes(1));\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Delay progression:"})," 1s \u2192 2s \u2192 4s \u2192 8s \u2192 16s \u2192 32s \u2192 60s (capped)"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Use cases:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Web API calls with transient network failures"}),"\n",(0,t.jsx)(r.li,{children:"Database connections during temporary overload"}),"\n",(0,t.jsx)(r.li,{children:"Microservice communication during partial outages"}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"linear-backoff",children:"Linear Backoff"}),"\n",(0,t.jsx)(r.p,{children:"Delays grow linearly, providing predictable recovery:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Configuration approach\r\nvar config = new LinearBackoffConfiguration(\r\n    baseDelay: TimeSpan.FromSeconds(1),\r\n    increment: TimeSpan.FromSeconds(2),\r\n    maxDelay: TimeSpan.FromSeconds(30));\r\n\r\n// Runtime configuration\r\ncontext.UseLinearBackoffDelay(\r\n    baseDelay: TimeSpan.FromSeconds(1),\r\n    increment: TimeSpan.FromSeconds(2),\r\n    maxDelay: TimeSpan.FromSeconds(30));\r\n\r\n// Direct delegate creation\r\nvar linearBackoff = BackoffStrategies.LinearBackoff(\r\n    baseDelay: TimeSpan.FromSeconds(1),\r\n    increment: TimeSpan.FromSeconds(2),\r\n    maxDelay: TimeSpan.FromSeconds(30));\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Delay progression:"})," 1s \u2192 3s \u2192 5s \u2192 7s \u2192 9s \u2192 ... \u2192 30s (capped)"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Use cases:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"File processing with temporary resource contention"}),"\n",(0,t.jsx)(r.li,{children:"Batch operations with predictable recovery patterns"}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"fixed-delay",children:"Fixed Delay"}),"\n",(0,t.jsx)(r.p,{children:"Constant delay between all retries:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Configuration approach\r\nvar config = new FixedDelayConfiguration(\r\n    delay: TimeSpan.FromSeconds(5));\r\n\r\n// Runtime configuration\r\ncontext.UseFixedDelay(\r\n    delay: TimeSpan.FromSeconds(5));\r\n\r\n// Direct delegate creation\r\nvar fixedBackoff = BackoffStrategies.FixedDelay(\r\n    delay: TimeSpan.FromSeconds(5));\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Delay progression:"})," 5s \u2192 5s \u2192 5s \u2192 5s \u2192 ..."]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Use cases:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Testing and debugging scenarios"}),"\n",(0,t.jsx)(r.li,{children:"Known recovery times"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"available-jitter-strategies",children:"Available Jitter Strategies"}),"\n",(0,t.jsx)(r.p,{children:"Jitter strategies are now implemented as delegates rather than interfaces, providing a more streamlined API:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Jitter strategy delegate type\r\nusing JitterStrategy = Func<TimeSpan, Random, TimeSpan>;\r\n\r\n// Built-in jitter strategies\r\nJitterStrategy fullJitter = JitterStrategies.FullJitter();\r\nJitterStrategy equalJitter = JitterStrategies.EqualJitter();\r\nJitterStrategy decorrelatedJitter = JitterStrategies.DecorrelatedJitter();\r\nJitterStrategy noJitter = JitterStrategies.NoJitter();\n"})}),"\n",(0,t.jsx)(r.p,{children:"This delegate approach reduces complexity while maintaining the same functionality. Each jitter strategy takes a base delay and a Random instance, and returns a jittered delay."}),"\n",(0,t.jsx)(r.h4,{id:"decorrelated-jitter",children:"Decorrelated Jitter"}),"\n",(0,t.jsx)(r.p,{children:"Adapts based on previous delays:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"var config = new DecorrelatedJitterConfiguration(\r\n    maxDelay: TimeSpan.FromMinutes(1),\r\n    multiplier: 3.0);\r\n\r\n// Direct delegate creation\r\nvar decorrelatedJitter = JitterStrategies.DecorrelatedJitter();\n"})}),"\n",(0,t.jsx)(r.h4,{id:"no-jitter",children:"No Jitter"}),"\n",(0,t.jsx)(r.p,{children:"Deterministic timing (useful for testing):"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"var config = new NoJitterConfiguration();\r\n\r\n// Direct delegate creation\r\nvar noJitter = JitterStrategies.NoJitter();\n"})}),"\n",(0,t.jsx)(r.h3,{id:"recommended-strategy-combinations",children:"Recommended Strategy Combinations"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Web APIs (Recommended):"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"context.UseExponentialBackoffDelay(\r\n    baseDelay: TimeSpan.FromSeconds(1),\r\n    multiplier: 2.0,\r\n    maxDelay: TimeSpan.FromMinutes(1));\r\n\r\n// Or using delegates directly\r\nvar backoff = BackoffStrategies.ExponentialBackoff(\r\n    TimeSpan.FromSeconds(1), 2.0, TimeSpan.FromMinutes(1));\r\nvar jitter = JitterStrategies.FullJitter();\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Database Operations:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"context.UseLinearBackoffDelay(\r\n    baseDelay: TimeSpan.FromMilliseconds(100),\r\n    increment: TimeSpan.FromMilliseconds(200),\r\n    maxDelay: TimeSpan.FromSeconds(5));\r\n\r\n// Or using delegates directly\r\nvar backoff = BackoffStrategies.LinearBackoff(\r\n    TimeSpan.FromMilliseconds(100), \r\n    TimeSpan.FromMilliseconds(200), \r\n    TimeSpan.FromSeconds(5));\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"File Processing:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"context.UseFixedDelay(\r\n    delay: TimeSpan.FromSeconds(2));\r\n\r\n// Or using delegates directly\r\nvar backoff = BackoffStrategies.FixedDelay(TimeSpan.FromSeconds(2));\n"})}),"\n",(0,t.jsx)(r.h3,{id:"configuration-at-initialization",children:"Configuration at Initialization"}),"\n",(0,t.jsx)(r.p,{children:"Configure delay strategies when building your pipeline:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"var retryOptions = new PipelineRetryOptions(\r\n    MaxItemRetries: 3,\r\n    MaxNodeRestartAttempts: 2,\r\n    MaxSequentialNodeAttempts: 5,\r\n    delayStrategyConfiguration: new RetryDelayStrategyConfiguration(\r\n        new ExponentialBackoffConfiguration(\r\n            TimeSpan.FromSeconds(1), 2.0, TimeSpan.FromMinutes(1)),\r\n        new FullJitterConfiguration()));\r\n\r\nbuilder.WithRetryOptions(retryOptions);\n"})}),"\n",(0,t.jsx)(r.h2,{id:"related-documentation-1",children:"Related Documentation"}),"\n",(0,t.jsxs)(r.p,{children:["For delay strategies and advanced configuration patterns, see ",(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/retry-delays",children:"Retry Delay Strategies"}),"."]}),"\n",(0,t.jsx)(r.h2,{id:"best-practices-1",children:"Best Practices"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Start conservative"}),": Begin with low retry counts and increase only if needed."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Consider resource impact"}),": Each retry consumes resources. Set reasonable limits."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Use per-node configuration"}),": Different nodes often need different retry strategies."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Monitor retry metrics"}),": Track how often retries occur to identify persistent issues."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Combine with error handlers"}),": Use retry options with error handlers for comprehensive resilience."]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"see-also-1",children:"See Also"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/",children:"Resilience Overview"})}),": Comprehensive guide to building fault-tolerant pipelines"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/materialization",children:"Materialization and Buffering"})}),": Understanding buffer requirements for resilience"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling Guide"})}),": Comprehensive error handling patterns and practical implementation guidance"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/troubleshooting",children:"Troubleshooting"})}),": Diagnose and resolve common resilience issues"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Node-level Error Handling"})}),": Learn about handling errors for individual items."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Pipeline-level Error Handling"})}),": Learn about handling errors that affect entire node streams."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/circuit-breakers",children:"Circuit Breakers"})}),": Configure circuit breaker patterns."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/dead-letter-queues",children:"Dead-Letter Queues"})}),": Implement dead-letter queues for problematic items."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/resilience/error-handling",children:"Error Handling Overview"})}),": Return to the error handling overview."]}),"\n"]})]})}function p(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);