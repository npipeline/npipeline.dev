"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[5344],{6732:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>t,metadata:()=>a,toc:()=>s});const a=JSON.parse('{"id":"architecture/cancellation-model","title":"Cancellation Model","description":"How cancellation tokens propagate through NPipeline.","source":"@site/docs/architecture/cancellation-model.md","sourceDirName":"architecture","slug":"/architecture/cancellation-model","permalink":"/npipeline.dev/docs/architecture/cancellation-model","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Cancellation Model","description":"How cancellation tokens propagate through NPipeline.","sidebar_position":7},"sidebar":"docsSidebar","previous":{"title":"Error Handling Architecture","permalink":"/npipeline.dev/docs/architecture/error-handling-architecture"},"next":{"title":"Performance Characteristics","permalink":"/npipeline.dev/docs/architecture/performance-characteristics"}}');var i=r(4848),c=r(8453);const t={title:"Cancellation Model",description:"How cancellation tokens propagate through NPipeline.",sidebar_position:7},o="Cancellation Model",l={},s=[{value:"Token Propagation",id:"token-propagation",level:2},{value:"Node Responsibilities",id:"node-responsibilities",level:2},{value:"Source Node",id:"source-node",level:3},{value:"Transform Node",id:"transform-node",level:3},{value:"Sink Node",id:"sink-node",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Cancellation with Error Handling",id:"cancellation-with-error-handling",level:2},{value:"Performance Implications",id:"performance-implications",level:2},{value:"\u27a1\ufe0f Next Steps",id:"arrow_right-next-steps",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"cancellation-model",children:"Cancellation Model"})}),"\n",(0,i.jsx)(e.p,{children:"Cancellation in NPipeline is cooperative and propagates through all nodes, allowing graceful shutdown at any point."}),"\n",(0,i.jsx)(e.h2,{id:"token-propagation",children:"Token Propagation"}),"\n",(0,i.jsx)(e.p,{children:"Cancellation tokens flow from the top-level execution down to every node:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"PipelineRunner.ExecuteAsync(cancellationToken)\r\n        \u2193\r\n    Source.ExecuteAsync(cancellationToken)\r\n        \u2193\r\n    Transform.ProcessAsync(item, cancellationToken)\r\n        \u2193\r\n    Sink.ProcessAsync(item, cancellationToken)\r\n        \u2193\r\n    [Cancellation propagates when token is cancelled]\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Implementation:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:"// User initiates cancellation\r\nvar cts = new CancellationTokenSource();\r\nvar executionTask = runner.ExecuteAsync(pipeline, context, cts.Token);\r\n\r\n// Later, request cancellation\r\ncts.Cancel();\r\n\r\n// Each node receives cancellation token\r\ntry\r\n{\r\n    await executionTask;\r\n}\r\ncatch (OperationCanceledException)\r\n{\r\n    // Graceful shutdown\r\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"node-responsibilities",children:"Node Responsibilities"}),"\n",(0,i.jsx)(e.p,{children:"Each node must respect the cancellation token:"}),"\n",(0,i.jsx)(e.h3,{id:"source-node",children:"Source Node"}),"\n",(0,i.jsx)(e.p,{children:"Check token before reading each batch:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'public class FileSourceNode : ISourceNode<string>\r\n{\r\n    public async IAsyncEnumerable<string> ExecuteAsync(\r\n        PipelineContext context,\r\n        [EnumeratorCancellation] CancellationToken cancellationToken = default)\r\n    {\r\n        using var file = File.OpenRead("data.txt");\r\n        using var reader = new StreamReader(file);\r\n        \r\n        while (!reader.EndOfStream)\r\n        {\r\n            cancellationToken.ThrowIfCancellationRequested(); // Check token\r\n            \r\n            var line = await reader.ReadLineAsync();\r\n            if (line != null)\r\n            {\r\n                yield return line;\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"transform-node",children:"Transform Node"}),"\n",(0,i.jsx)(e.p,{children:"Check token and pass it forward:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:"public class TransformNode : ITransformNode<string, int>\r\n{\r\n    public async IAsyncEnumerable<int> ProcessAsync(\r\n        string input,\r\n        [EnumeratorCancellation] CancellationToken cancellationToken = default)\r\n    {\r\n        cancellationToken.ThrowIfCancellationRequested(); // Check token\r\n        \r\n        var result = await LongRunningProcessAsync(cancellationToken); // Pass token\r\n        yield return result;\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"sink-node",children:"Sink Node"}),"\n",(0,i.jsx)(e.p,{children:"Respect token during processing:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:"public class SinkNode : ISinkNode<int>\r\n{\r\n    public async Task ExecuteAsync(\r\n        IAsyncEnumerable<int> input,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken = default)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            cancellationToken.ThrowIfCancellationRequested(); // Check token\r\n            \r\n            await ProcessAsync(item, cancellationToken);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Timeout:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:"var cts = CancellationTokenSource.CreateLinkedTokenSource(\r\n    existingToken,\r\n    new CancellationTokenSource(TimeSpan.FromSeconds(30)).Token);\r\n\r\nawait runner.ExecuteAsync(pipeline, context, cts.Token);\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Manual Cancellation:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:"var cts = new CancellationTokenSource();\r\n\r\nvar executionTask = runner.ExecuteAsync(pipeline, context, cts.Token);\r\n\r\nawait Task.Delay(5000);\r\ncts.Cancel(); // Stop after 5 seconds\r\n\r\nawait executionTask; // Wait for graceful shutdown\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Partial Processing:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:"var cts = new CancellationTokenSource();\r\n\r\n_ = Task.Run(async () =>\r\n{\r\n    await foreach (var result in runner.StreamAsync(pipeline, context, cts.Token))\r\n    {\r\n        if (result.ShouldStop)\r\n        {\r\n            cts.Cancel();\r\n        }\r\n    }\r\n});\n"})}),"\n",(0,i.jsx)(e.h2,{id:"cancellation-with-error-handling",children:"Cancellation with Error Handling"}),"\n",(0,i.jsx)(e.p,{children:"Cancellation and errors work together:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'try\r\n{\r\n    await foreach (var item in pipeline.WithCancellation(cancellationToken))\r\n    {\r\n        // Process item\r\n    }\r\n}\r\ncatch (OperationCanceledException)\r\n{\r\n    // Cancellation requested\r\n    logger.LogInformation("Pipeline cancelled");\r\n}\r\ncatch (Exception ex)\r\n{\r\n    // Error occurred\r\n    logger.LogError(ex, "Pipeline failed");\r\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"performance-implications",children:"Performance Implications"}),"\n",(0,i.jsx)(e.p,{children:"Frequent cancellation checks have minimal overhead:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:"// Efficient - part of cancellation token implementation\r\ncancellationToken.ThrowIfCancellationRequested();\r\n\r\n// Avoid in hot loops if performance critical\r\nfor (int i = 0; i < 1_000_000; i++)\r\n{\r\n    // Check outside loop if possible\r\n    cancellationToken.ThrowIfCancellationRequested();\r\n    \r\n    // Expensive work...\r\n}\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"arrow_right-next-steps",children:["\u27a1\ufe0f"," Next Steps"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.a,{href:"/npipeline.dev/docs/architecture/performance-characteristics",children:"Performance Characteristics"})})," - Understand cancellation performance impact"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.a,{href:"/npipeline.dev/docs/architecture/extension-points",children:"Extension Points"})})," - Implement custom cancellation strategies"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,c.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>t,x:()=>o});var a=r(6540);const i={},c=a.createContext(i);function t(n){const e=a.useContext(c);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:t(n.components),a.createElement(c.Provider,{value:e},n.children)}}}]);