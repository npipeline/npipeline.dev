"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[5581],{8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>s});var a=r(6540);const o={},t=a.createContext(o);function i(e){const n=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(t.Provider,{value:n},e.children)}},8804:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"core-concepts/nodes/transform-nodes","title":"Transform Nodes","description":"Learn how to implement transform nodes and optimize for high performance using ValueTask<T>.","source":"@site/docs/core-concepts/nodes/transform-nodes.md","sourceDirName":"core-concepts/nodes","slug":"/core-concepts/nodes/transform-nodes","permalink":"/docs/core-concepts/nodes/transform-nodes","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Transform Nodes","description":"Learn how to implement transform nodes and optimize for high performance using ValueTask<T>.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Source Nodes","permalink":"/docs/core-concepts/nodes/source-nodes"},"next":{"title":"Sink Nodes","permalink":"/docs/core-concepts/nodes/sink-nodes"}}');var o=r(4848),t=r(8453);const i={title:"Transform Nodes",description:"Learn how to implement transform nodes and optimize for high performance using ValueTask<T>.",sidebar_position:2},s="Transform Nodes (ITransformNode<TIn, TOut>)",c={},l=[{value:"Interface Definition",id:"interface-definition",level:2},{value:"Implementation Example",id:"implementation-example",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Common Transform Patterns",id:"common-transform-patterns",level:2},{value:"Data Enrichment",id:"data-enrichment",level:3},{value:"Validation and Filtering",id:"validation-and-filtering",level:3},{value:"Type Conversion",id:"type-conversion",level:3},{value:"\u27a1\ufe0f Next Steps",id:"arrow_right-next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsxs)(n.h1,{id:"transform-nodes-itransformnodetin-tout",children:["Transform Nodes (",(0,o.jsx)(n.code,{children:"ITransformNode<TIn, TOut>"}),")"]})}),"\n",(0,o.jsxs)(n.p,{children:["Transform nodes take an input stream of ",(0,o.jsx)(n.code,{children:"TInput"})," items, perform some operation on them, and then produce an output stream of ",(0,o.jsx)(n.code,{children:"TOutput"})," items. They are the workhorses of data manipulation within a pipeline."]}),"\n",(0,o.jsx)(n.h2,{id:"interface-definition",children:"Interface Definition"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public interface ITransformNode<TIn, TOut> : INode\r\n{\r\n    Task<TOut> ExecuteAsync(TIn item, PipelineContext context, CancellationToken cancellationToken);\r\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"implementation-example",children:"Implementation Example"}),"\n",(0,o.jsx)(n.p,{children:"A transform that squares each incoming number:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Basic transform that squares each incoming integer.\r\n/// Demonstrates the simplest possible transform implementation\r\n/// with synchronous work using Task.FromResult to avoid async overhead.\r\n/// </summary>\r\npublic sealed class SquareTransform : ITransformNode<int, int>\r\n{\r\n    /// <summary>\r\n    /// Processes each integer by squaring it.\r\n    /// Uses Task.FromResult for synchronous work to avoid unnecessary Task allocation.\r\n    /// </summary>\r\n    public Task<int> ExecuteAsync(int item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Synchronous calculation - no async work needed\r\n        return Task.FromResult(item * item);\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Transform that enriches order data with customer information.\r\n/// Demonstrates async transform pattern with external service dependency.\r\n/// </summary>\r\npublic sealed class EnrichmentTransform : ITransformNode<Order, EnrichedOrder>\r\n{\r\n    private readonly ILookupService _lookupService;\r\n\r\n    public EnrichmentTransform(ILookupService lookupService)\r\n    {\r\n        _lookupService = lookupService;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Enriches each order with customer information from lookup service.\r\n    /// Uses async/await pattern as external service call is inherently asynchronous.\r\n    /// </summary>\r\n    public async Task<EnrichedOrder> ExecuteAsync(Order order, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Fetch customer data from external service (async operation)\r\n        var customerInfo = await _lookupService.GetCustomerAsync(order.CustomerId, cancellationToken);\r\n        \r\n        // Create enriched order with customer details\r\n        return new EnrichedOrder\r\n        {\r\n            OrderId = order.OrderId,\r\n            CustomerId = order.CustomerId,\r\n            CustomerName = customerInfo.Name,\r\n            Total = order.Total\r\n        };\r\n    }\r\n}\r\n\r\n// Supporting types for the example\r\npublic record Order(string OrderId, string CustomerId, decimal Total);\r\npublic record EnrichedOrder(string OrderId, string CustomerId, string CustomerName, decimal Total);\r\npublic interface ILookupService\r\n{\r\n    Task<CustomerInfo> GetCustomerAsync(string customerId, CancellationToken cancellationToken);\r\n}\r\npublic record CustomerInfo(string Name);\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Transform that validates input data and converts to output format.\r\n/// Demonstrates ValueTask optimization for synchronous validation scenarios.\r\n/// In pipelines with high throughput, this eliminates Task allocations for validation.\r\n/// </summary>\r\npublic sealed class ValidationTransform : ITransformNode<RawData, ValidatedData>\r\n{\r\n    /// <summary>\r\n    /// Validates raw data and converts to validated format.\r\n    /// Uses ValueTask for synchronous validation to avoid heap allocation.\r\n    /// </summary>\r\n    public ValueTask<ValidatedData> ExecuteAsync(RawData item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Synchronous validation - check for empty or null values\r\n        if (string.IsNullOrWhiteSpace(item.Value))\r\n        {\r\n            throw new InvalidOperationException("Value cannot be empty or null");\r\n        }\r\n\r\n        // Create validated data with trimmed value\r\n        var validated = new ValidatedData\r\n        {\r\n            Id = item.Id,\r\n            Value = item.Value.Trim()\r\n        };\r\n\r\n        // Return via ValueTask - no heap allocation for synchronous work\r\n        return new ValueTask<ValidatedData>(validated);\r\n    }\r\n}\r\n\r\n// Supporting types for the example\r\npublic record RawData(string Id, string Value);\r\npublic record ValidatedData(string Id, string Value);\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"using NPipeline;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\n/// <summary>\r\n/// Transform that converts string values to integers.\r\n/// Demonstrates ValueTask pattern for simple type conversions\r\n/// that can fail and throw exceptions.\r\n/// </summary>\r\npublic sealed class ConversionTransform : ITransformNode<string, int>\r\n{\r\n    /// <summary>\r\n    /// Converts string to integer with validation.\r\n    /// Uses ValueTask to avoid allocation when conversion succeeds synchronously.\r\n    /// </summary>\r\n    public ValueTask<int> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Try to parse the string to integer\r\n        if (int.TryParse(item, out var result))\r\n        {\r\n            // Success case: return immediately via ValueTask (no allocation)\r\n            return new ValueTask<int>(result);\r\n        }\r\n\r\n        // Failure case: throw exception for invalid format\r\n        throw new FormatException($\"Cannot convert '{item}' to integer\");\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,o.jsxs)(n.p,{children:["Transform nodes support both ",(0,o.jsx)(n.code,{children:"Task<T>"})," and ",(0,o.jsx)(n.code,{children:"ValueTask<T>"})," return types. For high-throughput\r\nscenarios where transforms often complete synchronously (cache hits, simple calculations),\r\n",(0,o.jsx)(n.code,{children:"ValueTask<T>"})," can eliminate up to 90% of garbage collection pressure."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"See:"})," ",(0,o.jsx)(n.a,{href:"/docs/advanced-topics/synchronous-fast-paths",children:"Synchronous Fast Paths and ValueTask Optimization"}),"\r\nfor complete implementation guide."]}),"\n",(0,o.jsx)(n.h2,{id:"common-transform-patterns",children:"Common Transform Patterns"}),"\n",(0,o.jsx)(n.h3,{id:"data-enrichment",children:"Data Enrichment"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public sealed class EnrichmentTransform : ITransformNode<Order, EnrichedOrder>\r\n{\r\n    private readonly ILookupService _lookupService;\r\n\r\n    public EnrichmentTransform(ILookupService lookupService)\r\n    {\r\n        _lookupService = lookupService;\r\n    }\r\n\r\n    public async Task<EnrichedOrder> ExecuteAsync(Order order, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        var customerInfo = await _lookupService.GetCustomerAsync(order.CustomerId, cancellationToken);\r\n        return new EnrichedOrder\r\n        {\r\n            OrderId = order.OrderId,\r\n            CustomerId = order.CustomerId,\r\n            CustomerName = customerInfo.Name,\r\n            Total = order.Total\r\n        };\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"validation-and-filtering",children:"Validation and Filtering"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public sealed class ValidationTransform : ITransformNode<RawData, ValidatedData>\r\n{\r\n    public ValueTask<ValidatedData> ExecuteAsync(RawData item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        // Synchronous validation - use ValueTask to avoid allocation\r\n        if (string.IsNullOrWhiteSpace(item.Value))\r\n        {\r\n            throw new InvalidOperationException("Value cannot be empty");\r\n        }\r\n\r\n        var validated = new ValidatedData\r\n        {\r\n            Id = item.Id,\r\n            Value = item.Value.Trim()\r\n        };\r\n\r\n        return new ValueTask<ValidatedData>(validated);\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"type-conversion",children:"Type Conversion"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public sealed class ConversionTransform : ITransformNode<string, int>\r\n{\r\n    public ValueTask<int> ExecuteAsync(string item, PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        if (int.TryParse(item, out var result))\r\n        {\r\n            return new ValueTask<int>(result);\r\n        }\r\n\r\n        throw new FormatException($\"Cannot convert '{item}' to int\");\r\n    }\r\n}\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"arrow_right-next-steps",children:["\u27a1\ufe0f"," Next Steps"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"/docs/core-concepts/nodes/sink-nodes",children:"Sink Nodes"})}),": Learn how to consume and finalize data at the end of your pipeline"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"/docs/advanced-topics/performance-hygiene",children:"Performance Hygiene"})}),": Dive deeper into optimization techniques"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"/docs/advanced-topics/synchronous-fast-paths",children:"Synchronous Fast Paths"})}),": Master the ",(0,o.jsx)(n.code,{children:"ValueTask<T>"})," pattern in detail"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);