"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3916],{8227:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"core-concepts/resilience/circuit-breaker-advanced-configuration","title":"Circuit Breaker Advanced Configuration","description":"Advanced circuit breaker configuration patterns and examples for production scenarios in NPipeline.","source":"@site/docs/core-concepts/resilience/circuit-breaker-advanced-configuration.md","sourceDirName":"core-concepts/resilience","slug":"/core-concepts/resilience/circuit-breaker-advanced-configuration","permalink":"/npipeline.dev/docs/core-concepts/resilience/circuit-breaker-advanced-configuration","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Circuit Breaker Advanced Configuration","description":"Advanced circuit breaker configuration patterns and examples for production scenarios in NPipeline.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Resilient Execution Strategy","permalink":"/npipeline.dev/docs/core-concepts/resilience/resilient-execution-strategy"},"next":{"title":"Materialization and Buffering","permalink":"/npipeline.dev/docs/core-concepts/resilience/materialization-and-buffering"}}');var a=i(4848),s=i(8453);const t={title:"Circuit Breaker Advanced Configuration",description:"Advanced circuit breaker configuration patterns and examples for production scenarios in NPipeline.",sidebar_position:3},o="Circuit Breaker Advanced Configuration",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Basic Configuration",id:"basic-configuration",level:2},{value:"Circuit Breaker Threshold Types",id:"circuit-breaker-threshold-types",level:2},{value:"1. Consecutive Failures (Default)",id:"1-consecutive-failures-default",level:3},{value:"2. Rolling Window Count",id:"2-rolling-window-count",level:3},{value:"3. Rolling Window Rate",id:"3-rolling-window-rate",level:3},{value:"4. Hybrid",id:"4-hybrid",level:3},{value:"Recovery Configuration",id:"recovery-configuration",level:2},{value:"Real-World Scenarios",id:"real-world-scenarios",level:2},{value:"Scenario 1: High-Throughput API Integration",id:"scenario-1-high-throughput-api-integration",level:3},{value:"Scenario 2: Critical Database Operations",id:"scenario-2-critical-database-operations",level:3},{value:"Scenario 3: Bursty Service with Degradation Tolerance",id:"scenario-3-bursty-service-with-degradation-tolerance",level:3},{value:"Scenario 4: Multi-Level Protection",id:"scenario-4-multi-level-protection",level:3},{value:"Memory Management and Cleanup",id:"memory-management-and-cleanup",level:2},{value:"Default Behavior",id:"default-behavior",level:3},{value:"When to Customize Memory Management",id:"when-to-customize-memory-management",level:3},{value:"Configuration Examples",id:"configuration-examples",level:3},{value:"Scenario 1: Short-Lived Nodes (e.g., Request-Based Pipelines)",id:"scenario-1-short-lived-nodes-eg-request-based-pipelines",level:4},{value:"Scenario 2: Large Pipelines with Many Nodes",id:"scenario-2-large-pipelines-with-many-nodes",level:4},{value:"Scenario 3: Disable Automatic Cleanup",id:"scenario-3-disable-automatic-cleanup",level:4},{value:"Scenario 4: Aggressive Memory Management",id:"scenario-4-aggressive-memory-management",level:4},{value:"Cleanup Behavior",id:"cleanup-behavior",level:3},{value:"Monitoring Cleanup",id:"monitoring-cleanup",level:3},{value:"Performance Impact",id:"performance-impact",level:3},{value:"Memory Management Notes",id:"memory-management-notes",level:3},{value:"Disabling Circuit Breaker",id:"disabling-circuit-breaker",level:2},{value:"Important Notes",id:"important-notes",level:2},{value:"Distinction from Retry Options",id:"distinction-from-retry-options",level:3},{value:"Thread Safety",id:"thread-safety",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"circuit-breaker-advanced-configuration",children:"Circuit Breaker Advanced Configuration"})}),"\n",(0,a.jsxs)(n.p,{children:["This guide covers advanced circuit breaker configuration patterns for production scenarios. For basic configuration, see ",(0,a.jsx)(n.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/circuit-breaker-configuration",children:"Circuit Breaker Configuration"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"Circuit breakers in NPipeline protect your pipelines from cascading failures by temporarily blocking operations when failure thresholds are exceeded. This guide shows how to configure breakers for different scenarios."}),"\n",(0,a.jsx)(n.h2,{id:"basic-configuration",children:"Basic Configuration"}),"\n",(0,a.jsx)(n.p,{children:"The simplest way to add circuit breaker protection is with the fluent API:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"var builder = new PipelineBuilder();\n\n// Simple configuration: trip after 3 consecutive failures\nbuilder.WithCircuitBreaker(\n    failureThreshold: 3,\n    openDuration: TimeSpan.FromMinutes(1),\n    samplingWindow: TimeSpan.FromMinutes(5)\n);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"circuit-breaker-threshold-types",children:"Circuit Breaker Threshold Types"}),"\n",(0,a.jsx)(n.p,{children:"NPipeline supports four different threshold types for detecting failures:"}),"\n",(0,a.jsx)(n.h3,{id:"1-consecutive-failures-default",children:"1. Consecutive Failures (Default)"}),"\n",(0,a.jsx)(n.p,{children:"Tracks consecutive failures without considering time:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Trip after any 3 consecutive failures\nbuilder.WithCircuitBreaker(\n    failureThreshold: 3,\n    openDuration: TimeSpan.FromMinutes(1),\n    samplingWindow: TimeSpan.FromMinutes(5)\n);\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use when:"})," You want simple, immediate failure detection. Best for services where even a few failures indicate a problem."]}),"\n",(0,a.jsx)(n.h3,{id:"2-rolling-window-count",children:"2. Rolling Window Count"}),"\n",(0,a.jsx)(n.p,{children:"Tracks total failures within a time window:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Trip after 10 failures within a 5-minute window\nvar options = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 10,\n    OpenDuration: TimeSpan.FromMinutes(2),\n    SamplingWindow: TimeSpan.FromMinutes(5),\n    Enabled: true,\n    ThresholdType: CircuitBreakerThresholdType.RollingWindowCount\n);\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use when:"})," You care about the absolute number of failures in a time period, regardless of how they're distributed."]}),"\n",(0,a.jsx)(n.h3,{id:"3-rolling-window-rate",children:"3. Rolling Window Rate"}),"\n",(0,a.jsx)(n.p,{children:"Tracks failure rate (failures/total operations) within a time window:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Trip if more than 10% of operations fail in a 5-minute window\nvar options = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 100,  // Minimum operations before rate is evaluated\n    OpenDuration: TimeSpan.FromMinutes(2),\n    SamplingWindow: TimeSpan.FromMinutes(5),\n    Enabled: true,\n    ThresholdType: CircuitBreakerThresholdType.RollingWindowRate,\n    FailureRateThreshold: 0.1  // 10% failure rate\n);\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use when:"})," You want to tolerate occasional failures but trip on consistent degradation."]}),"\n",(0,a.jsx)(n.h3,{id:"4-hybrid",children:"4. Hybrid"}),"\n",(0,a.jsx)(n.p,{children:"Combines count and rate thresholds - trips if either is exceeded:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Trip if EITHER 5 failures in window OR 30% failure rate\nvar options = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 5,\n    OpenDuration: TimeSpan.FromMinutes(1),\n    SamplingWindow: TimeSpan.FromMinutes(5),\n    Enabled: true,\n    ThresholdType: CircuitBreakerThresholdType.Hybrid,\n    FailureRateThreshold: 0.3  // 30% failure rate\n);\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use when:"})," You want comprehensive protection against both sudden failures and gradual degradation."]}),"\n",(0,a.jsx)(n.h2,{id:"recovery-configuration",children:"Recovery Configuration"}),"\n",(0,a.jsx)(n.p,{children:"Control how your circuit breaker recovers after tripping:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 3,\n    OpenDuration: TimeSpan.FromMinutes(1),\n    SamplingWindow: TimeSpan.FromMinutes(5),\n    Enabled: true,\n    HalfOpenSuccessThreshold: 2,     // Require 2 consecutive successes\n    HalfOpenMaxAttempts: 5            // Allow up to 5 attempts in Half-Open\n);\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"State transitions:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Closed \u2192 Open"}),": Failure threshold exceeded"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Open \u2192 Half-Open"}),": After ",(0,a.jsx)(n.code,{children:"OpenDuration"})," expires"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Half-Open \u2192 Closed"}),": After ",(0,a.jsx)(n.code,{children:"HalfOpenSuccessThreshold"})," consecutive successes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Half-Open \u2192 Open"}),": On any failure, or exceeding ",(0,a.jsx)(n.code,{children:"HalfOpenMaxAttempts"})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"real-world-scenarios",children:"Real-World Scenarios"}),"\n",(0,a.jsx)(n.h3,{id:"scenario-1-high-throughput-api-integration",children:"Scenario 1: High-Throughput API Integration"}),"\n",(0,a.jsx)(n.p,{children:"For operations calling external APIs with occasional glitches:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"builder.WithCircuitBreaker(\n    failureThreshold: 50,  // Allow some failures before tripping\n    openDuration: TimeSpan.FromSeconds(30),  // Quick recovery window\n    samplingWindow: TimeSpan.FromMinutes(5)\n);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"scenario-2-critical-database-operations",children:"Scenario 2: Critical Database Operations"}),"\n",(0,a.jsx)(n.p,{children:"For operations where any failure indicates a serious problem:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 2,\n    OpenDuration: TimeSpan.FromSeconds(10),\n    SamplingWindow: TimeSpan.FromMinutes(1),\n    Enabled: true,\n    ThresholdType: CircuitBreakerThresholdType.ConsecutiveFailures,\n    HalfOpenSuccessThreshold: 1,\n    HalfOpenMaxAttempts: 2\n);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"scenario-3-bursty-service-with-degradation-tolerance",children:"Scenario 3: Bursty Service with Degradation Tolerance"}),"\n",(0,a.jsx)(n.p,{children:"For services that can tolerate occasional failures but need protection from persistent issues:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 100,\n    OpenDuration: TimeSpan.FromMinutes(2),\n    SamplingWindow: TimeSpan.FromMinutes(5),\n    Enabled: true,\n    ThresholdType: CircuitBreakerThresholdType.RollingWindowRate,\n    FailureRateThreshold: 0.2  // 20% failure rate threshold\n);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"scenario-4-multi-level-protection",children:"Scenario 4: Multi-Level Protection"}),"\n",(0,a.jsx)(n.p,{children:"Combine multiple strategies across pipeline:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"var builder = new PipelineBuilder();\n\n// Strict protection on critical transform\nvar criticalOptions = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 2,\n    OpenDuration: TimeSpan.FromSeconds(30),\n    SamplingWindow: TimeSpan.FromMinutes(1),\n    Enabled: true\n);\n\n// Lenient protection on resilient transform\nvar resilientOptions = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 100,\n    OpenDuration: TimeSpan.FromMinutes(5),\n    SamplingWindow: TimeSpan.FromMinutes(10),\n    Enabled: true,\n    ThresholdType: CircuitBreakerThresholdType.RollingWindowRate,\n    FailureRateThreshold: 0.25\n);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"memory-management-and-cleanup",children:"Memory Management and Cleanup"}),"\n",(0,a.jsx)(n.p,{children:"Circuit breaker instances are cached per node ID to maintain state across calls. In long-running applications or pipelines with many dynamic nodes, inactive breakers should be cleaned up to prevent memory leaks."}),"\n",(0,a.jsx)(n.h3,{id:"default-behavior",children:"Default Behavior"}),"\n",(0,a.jsx)(n.p,{children:"By default, NPipeline automatically manages circuit breaker memory:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cleanup interval"}),": 5 minutes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Inactivity threshold"}),": 30 minutes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Max tracked breakers"}),": 1,000"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Automatic cleanup"}),": Enabled"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"A circuit breaker is considered inactive if it hasn't been accessed (checked or updated) within the inactivity threshold. Inactive breakers are removed automatically."}),"\n",(0,a.jsx)(n.h3,{id:"when-to-customize-memory-management",children:"When to Customize Memory Management"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Customize cleanup for these scenarios:"})}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Scenario"}),(0,a.jsx)(n.th,{children:"Issue"}),(0,a.jsx)(n.th,{children:"Solution"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Many short-lived nodes"}),(0,a.jsx)(n.td,{children:"Memory grows unbounded"}),(0,a.jsxs)(n.td,{children:["Lower ",(0,a.jsx)(n.code,{children:"InactivityThreshold"})," and ",(0,a.jsx)(n.code,{children:"MaxTrackedCircuitBreakers"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"High-frequency cleanup overhead"}),(0,a.jsx)(n.td,{children:"Cleanup CPU cost too high"}),(0,a.jsxs)(n.td,{children:["Increase ",(0,a.jsx)(n.code,{children:"CleanupInterval"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Rapid node creation/destruction"}),(0,a.jsx)(n.td,{children:"Eviction happens too often"}),(0,a.jsxs)(n.td,{children:["Increase ",(0,a.jsx)(n.code,{children:"MaxTrackedCircuitBreakers"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Long-running pipelines"}),(0,a.jsx)(n.td,{children:"Need stricter memory control"}),(0,a.jsx)(n.td,{children:"Enable aggressive cleanup with lower thresholds"})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,a.jsx)(n.h4,{id:"scenario-1-short-lived-nodes-eg-request-based-pipelines",children:"Scenario 1: Short-Lived Nodes (e.g., Request-Based Pipelines)"}),"\n",(0,a.jsx)(n.p,{children:"For pipelines where nodes are created per request and disposed after:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"builder.ConfigureCircuitBreakerMemoryManagement(opts =>\n    opts with\n    {\n        InactivityThreshold = TimeSpan.FromMinutes(5),    // Clean up faster\n        MaxTrackedCircuitBreakers = 100,                  // Limit tracked breakers\n        CleanupInterval = TimeSpan.FromSeconds(30)        // Check frequently\n    }\n);\n"})}),"\n",(0,a.jsx)(n.p,{children:"When the limit is reached, the least-recently-used breaker is evicted."}),"\n",(0,a.jsx)(n.h4,{id:"scenario-2-large-pipelines-with-many-nodes",children:"Scenario 2: Large Pipelines with Many Nodes"}),"\n",(0,a.jsx)(n.p,{children:"For pipelines with hundreds of nodes that may or may not be accessed:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"builder.ConfigureCircuitBreakerMemoryManagement(opts =>\n    opts with\n    {\n        MaxTrackedCircuitBreakers = 5000,                 // Allow more breakers\n        InactivityThreshold = TimeSpan.FromHours(1),      // Longer inactivity window\n        CleanupInterval = TimeSpan.FromMinutes(10)        // Less frequent cleanup\n    }\n);\n"})}),"\n",(0,a.jsx)(n.h4,{id:"scenario-3-disable-automatic-cleanup",children:"Scenario 3: Disable Automatic Cleanup"}),"\n",(0,a.jsx)(n.p,{children:"For controlled scenarios where you manage cleanup manually:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'builder.ConfigureCircuitBreakerMemoryManagement(opts =>\n    opts with\n    {\n        EnableAutomaticCleanup = false\n    }\n);\n\n// Later, manually trigger cleanup when appropriate\n// (Requires access to CircuitBreakerManager from pipeline context)\nif (context.Items.TryGetValue(PipelineContextKeys.CircuitBreakerManager, out var manager) &&\n    manager is ICircuitBreakerManager cbManager)\n{\n    int removedCount = cbManager.TriggerCleanup();\n    logger.LogInformation("Cleaned up {Count} inactive circuit breakers", removedCount);\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"scenario-4-aggressive-memory-management",children:"Scenario 4: Aggressive Memory Management"}),"\n",(0,a.jsx)(n.p,{children:"For memory-constrained environments:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"builder.ConfigureCircuitBreakerMemoryManagement(opts =>\n    opts with\n    {\n        MaxTrackedCircuitBreakers = 50,                   // Very strict limit\n        InactivityThreshold = TimeSpan.FromMinutes(2),    // Aggressive cleanup\n        CleanupInterval = TimeSpan.FromSeconds(10),       // Frequent checks\n        EnableAutomaticCleanup = true\n    }\n);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"cleanup-behavior",children:"Cleanup Behavior"}),"\n",(0,a.jsx)(n.p,{children:"When cleanup runs, NPipeline:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Identifies inactive breakers"}),": Breakers not accessed within ",(0,a.jsx)(n.code,{children:"InactivityThreshold"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Removes inactive breakers"}),": Disposes stale circuit breaker instances"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Evicts if necessary"}),": If ",(0,a.jsx)(n.code,{children:"MaxTrackedCircuitBreakers"})," is exceeded, removes least-recently-used (LRU) breaker"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Logs activity"}),": Records cleanup events at DEBUG/WARNING levels"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"monitoring-cleanup",children:"Monitoring Cleanup"}),"\n",(0,a.jsx)(n.p,{children:"Track circuit breaker lifecycle in your observability infrastructure:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// Get current tracking count\nif (context.Items.TryGetValue(PipelineContextKeys.CircuitBreakerManager, out var manager) &&\n    manager is ICircuitBreakerManager cbManager)\n{\n    int trackedCount = cbManager.GetTrackedCircuitBreakerCount();\n    metrics.Gauge("circuitbreaker.tracked_count", trackedCount);\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"performance-impact",children:"Performance Impact"}),"\n",(0,a.jsx)(n.p,{children:"Memory management is designed to be lightweight:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cleanup operation"}),": O(n) where n = tracked breakers; typically < 10ms"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Tracking overhead"}),": ~100 bytes per circuit breaker (timestamp + node ID)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"LRU eviction"}),": O(n) scan to find least-recently-used"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"For most applications, defaults provide good balance. Customize only if:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Monitoring shows excessive memory growth"}),"\n",(0,a.jsx)(n.li,{children:"Cleanup CPU cost is significant (> 5% of pipeline execution time)"}),"\n",(0,a.jsx)(n.li,{children:"You have specific memory constraints"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"memory-management-notes",children:"Memory Management Notes"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Access updates"}),": Any access (check or state change) updates the breaker's last-accessed timestamp"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Persistent state"}),": Circuit breaker state is ",(0,a.jsx)(n.strong,{children:"not"})," restored after removal and recreation\u2014it starts as Closed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Thread-safe"}),": All cleanup operations are thread-safe; no synchronization needed"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"disabling-circuit-breaker",children:"Disabling Circuit Breaker"}),"\n",(0,a.jsx)(n.p,{children:"If needed, you can disable circuit breaking:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"var options = new PipelineCircuitBreakerOptions(\n    FailureThreshold: 5,\n    OpenDuration: TimeSpan.FromMinutes(1),\n    SamplingWindow: TimeSpan.FromMinutes(5),\n    Enabled: false  // Disabled - no circuit breaker checks\n);\n"})}),"\n",(0,a.jsx)(n.p,{children:"Or use the predefined disabled option:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"var disabledOptions = PipelineCircuitBreakerOptions.Disabled;\n"})}),"\n",(0,a.jsx)(n.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,a.jsx)(n.h3,{id:"distinction-from-retry-options",children:"Distinction from Retry Options"}),"\n",(0,a.jsxs)(n.p,{children:["Circuit breaker configuration is ",(0,a.jsx)(n.strong,{children:"separate"})," from retry configuration:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"WithCircuitBreaker()"})}),": Prevents repeated attempts when failure threshold is reached"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"WithRetryOptions()"})}),": Controls how many retries are allowed per item or per node"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Both can be used together for comprehensive resilience:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"var builder = new PipelineBuilder();\n\n// Control retries at the item/node level\nbuilder.WithRetryOptions(o => o.With(maxNodeRestartAttempts: 3));\n\n// Prevent cascade failures across the pipeline\nbuilder.WithCircuitBreaker(failureThreshold: 5);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,a.jsx)(n.p,{children:"Circuit breakers are fully thread-safe and designed for concurrent pipeline execution. Multiple threads can safely check and update breaker state simultaneously."}),"\n",(0,a.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Circuit breakers add minimal overhead (~50-100ns per check in Closed state)"}),"\n",(0,a.jsx)(n.li,{children:"Operation tracking uses efficient rolling windows with automatic cleanup"}),"\n",(0,a.jsx)(n.li,{children:"No significant memory overhead for typical usage patterns"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Circuit breaker trips too frequently:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Increase ",(0,a.jsx)(n.code,{children:"FailureThreshold"})," to tolerate more failures"]}),"\n",(0,a.jsxs)(n.li,{children:["Use ",(0,a.jsx)(n.code,{children:"RollingWindowRate"})," to tolerate occasional failures"]}),"\n",(0,a.jsxs)(n.li,{children:["Extend ",(0,a.jsx)(n.code,{children:"SamplingWindow"})," to smooth out bursty failures"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Circuit breaker never trips:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Reduce ",(0,a.jsx)(n.code,{children:"FailureThreshold"})]}),"\n",(0,a.jsxs)(n.li,{children:["Use ",(0,a.jsx)(n.code,{children:"ConsecutiveFailures"})," for immediate detection"]}),"\n",(0,a.jsxs)(n.li,{children:["Reduce ",(0,a.jsx)(n.code,{children:"SamplingWindow"})," for faster detection"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Slow recovery:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Reduce ",(0,a.jsx)(n.code,{children:"OpenDuration"})]}),"\n",(0,a.jsxs)(n.li,{children:["Lower ",(0,a.jsx)(n.code,{children:"HalfOpenSuccessThreshold"})," to recover faster"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/npipeline.dev/docs/core-concepts/pipeline-execution/circuit-breaker-configuration",children:"Circuit Breaker Configuration"})," - Configuration reference"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/npipeline.dev/docs/core-concepts/resilience/",children:"Resilience Patterns"})," - General resilience patterns"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/npipeline.dev/docs/architecture/error-handling-architecture",children:"Error Handling"})," - Error handling strategies"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>o});var r=i(6540);const a={},s=r.createContext(a);function t(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);