"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[3996],{7362:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"core-concepts/data-pipes","title":"Data Pipes (IDataPipe)","description":"Understand how data flows through NPipeline using IDataPipe and IDataPipe&lt;T&gt;.","source":"@site/docs/core-concepts/data-pipes.md","sourceDirName":"core-concepts","slug":"/core-concepts/data-pipes","permalink":"/docs/core-concepts/data-pipes","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Data Pipes (IDataPipe)","description":"Understand how data flows through NPipeline using IDataPipe and IDataPipe&lt;T&gt;.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Pipeline","permalink":"/docs/core-concepts/ipipeline"},"next":{"title":"Nodes (Source, Transform, Sink, and Specialized)","permalink":"/docs/core-concepts/nodes/"}}');var r=i(4848),t=i(8453);const s={title:"Data Pipes (IDataPipe)",description:"Understand how data flows through NPipeline using IDataPipe and IDataPipe&lt;T&gt;.",sidebar_position:3},o="Data Pipes (IDataPipe and IDataPipe<T>)",c={},l=[{value:"<code>IDataPipe</code> and <code>IDataPipe&lt;T&gt;</code>",id:"idatapipe-and-idatapipet",level:2},{value:"Key Characteristics",id:"key-characteristics",level:2},{value:"Example Usage (Conceptual)",id:"example-usage-conceptual",level:2},{value:"Consuming a Data Pipe",id:"consuming-a-data-pipe",level:2},{value:"Creating a Data Pipe",id:"creating-a-data-pipe",level:2},{value:"Synchronous Pipe Creation + Asynchronous Iteration",id:"synchronous-pipe-creation--asynchronous-iteration",level:2},{value:"Data Flow in a Pipeline",id:"data-flow-in-a-pipeline",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsxs)(n.h1,{id:"data-pipes-idatapipe-and-idatapipet",children:["Data Pipes (",(0,r.jsx)(n.code,{children:"IDataPipe"})," and ",(0,r.jsx)(n.code,{children:"IDataPipe<T>"}),")"]})}),"\n",(0,r.jsxs)(n.p,{children:["In NPipeline, data flows between nodes through ",(0,r.jsx)(n.strong,{children:"Data Pipes"}),". These pipes are the fundamental mechanism for transferring items from one processing stage to the next. At their core, data pipes implement the ",(0,r.jsx)(n.code,{children:"IDataPipe"})," interface, with generic variations for typed data."]}),"\n",(0,r.jsxs)(n.h2,{id:"idatapipe-and-idatapipet",children:[(0,r.jsx)(n.code,{children:"IDataPipe"})," and ",(0,r.jsx)(n.code,{children:"IDataPipe<T>"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"IDataPipe"})," is the non-generic interface representing a data channel. It's primarily used internally for untyped operations or when the data type is not relevant to the pipe's management."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public interface IDataPipe : IAsyncDisposable\r\n{\r\n    string StreamName { get; }\r\n    Type GetDataType();\r\n    \r\n    // Internal method for framework use - not part of public API\r\n    IAsyncEnumerable<object?> ToAsyncEnumerable(CancellationToken cancellationToken = default);\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note:"})," The ",(0,r.jsx)(n.code,{children:"ToAsyncEnumerable()"})," method is an internal framework API and should not be called by external code. External APIs should use the typed ",(0,r.jsx)(n.code,{children:"IDataPipe<T>"})," interface directly, which implements ",(0,r.jsx)(n.code,{children:"IAsyncEnumerable<T>"})," and is both type-safe and zero-overhead."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"IDataPipe<T>"})," is the generic interface, where ",(0,r.jsx)(n.code,{children:"T"})," represents the type of data item flowing through that specific pipe. This is the interface you will most commonly interact with when defining the connections between your nodes. It provides methods for asynchronously producing and consuming streams of data."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public interface IDataPipe<out T> : IDataPipe, IAsyncEnumerable<T> { }\n"})}),"\n",(0,r.jsx)(n.p,{children:"Conceptually, a data pipe acts as a conduit:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["An upstream node (a Source or a Transform) ",(0,r.jsx)(n.strong,{children:"produces"})," data into the pipe."]}),"\n",(0,r.jsxs)(n.li,{children:["A downstream node (a Transform or a Sink) ",(0,r.jsx)(n.strong,{children:"consumes"})," data from the pipe."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"NPipeline handles the mechanics of buffering, backpressure, and asynchronous transfer, allowing you to focus on the business logic of your nodes."}),"\n",(0,r.jsx)(n.h2,{id:"key-characteristics",children:"Key Characteristics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Asynchronous Streaming:"})," Data pipes are designed for asynchronous operations, leveraging ",(0,r.jsx)(n.code,{children:"IAsyncEnumerable<T>"})," to efficiently stream data items without blocking threads."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Decoupling:"})," They decouple the producing node from the consuming node, allowing for independent development and testing of pipeline stages."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flow Control:"})," NPipeline's internal implementation of data pipes manages the flow of data, preventing downstream nodes from being overwhelmed and upstream nodes from producing too quickly."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Strongly Typed:"})," ",(0,r.jsx)(n.code,{children:"IDataPipe<T>"})," ensures type safety throughout your pipeline, reducing runtime errors."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stream Identification:"})," Each data pipe has a ",(0,r.jsx)(n.code,{children:"StreamName"})," property for identification and debugging purposes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type Information:"})," The ",(0,r.jsx)(n.code,{children:"GetDataType()"})," method allows runtime discovery of the data type flowing through the pipe."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example-usage-conceptual",children:"Example Usage (Conceptual)"}),"\n",(0,r.jsxs)(n.p,{children:["While you typically don't interact directly with ",(0,r.jsx)(n.code,{children:"IDataPipe<T>"})," instances when building a pipeline with ",(0,r.jsx)(n.code,{children:"PipelineBuilder"}),", it's the underlying mechanism. When you connect nodes, NPipeline implicitly creates and manages these pipes."]}),"\n",(0,r.jsxs)(n.p,{children:["Consider a ",(0,r.jsx)(n.code,{children:"Transform"})," that takes ",(0,r.jsx)(n.code,{children:"string"})," and outputs ",(0,r.jsx)(n.code,{children:"int"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"using NPipeline.Nodes;\r\n\r\npublic sealed class StringToIntTransform : TransformNode<string, int>\r\n{\r\n    public async IAsyncEnumerable<int> ExecuteAsync(IAsyncEnumerable<string> input, CancellationToken cancellationToken = default)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            if (int.TryParse(item, out var number))\r\n            {\r\n                yield return number;\r\n            }\r\n            // Optionally handle parsing errors or log them\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this example, the ",(0,r.jsx)(n.code,{children:"input"})," parameter is an ",(0,r.jsx)(n.code,{children:"IAsyncEnumerable<string>"}),", which is backed by an ",(0,r.jsx)(n.code,{children:"IDataPipe<string>"}),". The ",(0,r.jsx)(n.code,{children:"yield return number;"})," effectively pushes data into the output ",(0,r.jsx)(n.code,{children:"IDataPipe<int>"})," managed by NPipeline."]}),"\n",(0,r.jsx)(n.h2,{id:"consuming-a-data-pipe",children:"Consuming a Data Pipe"}),"\n",(0,r.jsxs)(n.p,{children:["When you implement a node (typically a Sink or Transform), you receive data from upstream nodes via an ",(0,r.jsx)(n.code,{children:"IDataPipe<T>"}),". You can consume the data using a standard ",(0,r.jsx)(n.code,{children:"await foreach"})," loop:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.DataFlow;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Observability.Tracing;\r\nusing NPipeline.Pipeline;\r\n\r\npublic class MySinkNode : SinkNode<MyData>\r\n{\r\n    public async Task ExecuteAsync(\r\n        IDataPipe<MyData> input,\r\n        PipelineContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        await foreach (var item in input.WithCancellation(cancellationToken))\r\n        {\r\n            // Process each item\r\n            Console.WriteLine($"Received: {item}");\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"WithCancellation"})," extension method is a convenient way to ensure that the enumeration respects the pipeline's cancellation token."]}),"\n",(0,r.jsx)(n.h2,{id:"creating-a-data-pipe",children:"Creating a Data Pipe"}),"\n",(0,r.jsxs)(n.p,{children:["In a source node, you are responsible for creating the initial data pipe. NPipeline provides helpers to easily create a pipe from an ",(0,r.jsx)(n.code,{children:"IAsyncEnumerable<T>"})," or a simple ",(0,r.jsx)(n.code,{children:"IEnumerable<T>"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.DataFlow;\r\nusing NPipeline.DataFlow.DataPipes;\r\nusing NPipeline.Nodes;\r\nusing NPipeline.Pipeline;\r\n\r\npublic class MySourceNode : SourceNode<MyData>\r\n{\r\n    public IDataPipe<MyData> ExecuteAsync(PipelineContext context, CancellationToken cancellationToken)\r\n    {\r\n        static IAsyncEnumerable<MyData> Stream()\r\n        {\r\n            return Generate();\r\n\r\n            async IAsyncEnumerable<MyData> Generate()\r\n            {\r\n                var data = new[]\r\n                {\r\n                    new MyData { Id = 1, Name = "First" },\r\n                    new MyData { Id = 2, Name = "Second" }\r\n                };\r\n\r\n                foreach (var item in data)\r\n                {\r\n                    yield return item;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Create a data pipe from an async stream\r\n        return new StreamingDataPipe<MyData>(Stream());\r\n    }\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["By abstracting the data flow into ",(0,r.jsx)(n.code,{children:"IDataPipe<T>"}),", NPipeline allows you to build complex, high-performance streaming workflows with a simple and consistent programming model."]}),"\n",(0,r.jsx)(n.h2,{id:"synchronous-pipe-creation--asynchronous-iteration",children:"Synchronous Pipe Creation + Asynchronous Iteration"}),"\n",(0,r.jsxs)(n.p,{children:["A key architectural insight of NPipeline is the separation of concerns between ",(0,r.jsx)(n.strong,{children:"creating a pipe"})," and ",(0,r.jsx)(n.strong,{children:"iterating over a pipe"}),":"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Synchronous Creation Phase:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Source creates and returns the pipe synchronously\r\nvar pipe = source.Execute(context, cancellationToken);  // Returns immediately\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["No ",(0,r.jsx)(n.code,{children:"await"})," is needed"]}),"\n",(0,r.jsx)(n.li,{children:"Pipeline structure is established instantly"}),"\n",(0,r.jsx)(n.li,{children:"No Task allocations overhead"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Asynchronous Iteration Phase:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Downstream nodes iterate asynchronously\r\nawait foreach (var item in pipe.WithCancellation(cancellationToken))\r\n{\r\n    // Process each item as it arrives\r\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Data flows asynchronously"}),"\n",(0,r.jsx)(n.li,{children:"Backpressure is managed automatically"}),"\n",(0,r.jsx)(n.li,{children:"Handles cancellation gracefully"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Why Separate These Phases?"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clarity:"})," It's immediately clear when work is synchronous (pipe setup) vs. asynchronous (data flow)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type Safety:"})," Enables covariance on ",(0,r.jsx)(n.code,{children:"IDataPipe<T>"})," (not possible with ",(0,r.jsx)(n.code,{children:"Task<T>"})," wrapper)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance:"})," No unnecessary Task allocations for pipe creation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consistency:"})," All source nodes follow the same pattern"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Analogy - File I/O:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Creating a stream is fast and synchronous\r\nvar stream = File.OpenRead(filePath);\r\n\r\n// Reading from a stream is asynchronous\r\nvar buffer = new byte[1024];\r\nint bytesRead = await stream.ReadAsync(buffer, 0, 1024);\r\n\r\n// Similarly in NPipeline:\r\nvar pipe = source.Execute(...);      // Fast, synchronous\r\nawait foreach (var item in pipe) { ... }  // Asynchronous streaming\n"})}),"\n",(0,r.jsx)(n.h2,{id:"data-flow-in-a-pipeline",children:"Data Flow in a Pipeline"}),"\n",(0,r.jsx)(n.p,{children:"When you define a pipeline like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"var pipeline = new PipelineBuilder()\r\n    .AddSource<MyStringSource, string>()\r\n    .AddTransform<StringToIntTransform, string, int>()\r\n    .AddSink<MyIntSink, int>()\r\n    .Build();\n"})}),"\n",(0,r.jsx)(n.p,{children:"NPipeline creates:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["An ",(0,r.jsx)(n.code,{children:"IDataPipe<string>"})," between ",(0,r.jsx)(n.code,{children:"MyStringSource"})," and ",(0,r.jsx)(n.code,{children:"StringToIntTransform"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["An ",(0,r.jsx)(n.code,{children:"IDataPipe<int>"})," between ",(0,r.jsx)(n.code,{children:"StringToIntTransform"})," and ",(0,r.jsx)(n.code,{children:"MyIntSink"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The data items produced by the source flow through the first pipe, are transformed, and then flow through the second pipe to the sink."}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-concepts/nodes/",children:"Nodes"})}),": Learn about the different types of nodes (Source, Transform, Sink) that interact with data pipes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-concepts/pipeline-definition",children:"Pipeline Definition"})}),": Understand how to connect nodes and define the overall structure of your data flow."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var a=i(6540);const r={},t=a.createContext(r);function s(e){const n=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);