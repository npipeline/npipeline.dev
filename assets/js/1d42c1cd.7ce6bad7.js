"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[8611],{28453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>d});var i=n(96540);const t={},o=i.createContext(t);function s(e){const r=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(o.Provider,{value:r},e.children)}},72524:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"core-concepts/nodes/join","title":"Join Nodes","description":"Merge data from multiple input streams based on common keys or time windows using NPipeline\'s Join Nodes.","source":"@site/docs/core-concepts/nodes/join.md","sourceDirName":"core-concepts/nodes","slug":"/core-concepts/nodes/join","permalink":"/docs/core-concepts/nodes/join","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Join Nodes","description":"Merge data from multiple input streams based on common keys or time windows using NPipeline\'s Join Nodes.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Transform Nodes","permalink":"/docs/core-concepts/nodes/transform-nodes"},"next":{"title":"Sink Nodes","permalink":"/docs/core-concepts/nodes/sink-nodes"}}');var t=n(74848),o=n(28453);const s={title:"Join Nodes",description:"Merge data from multiple input streams based on common keys or time windows using NPipeline's Join Nodes.",sidebar_position:3},d="Join Nodes",l={},a=[{value:"<code>IJoinNode</code>",id:"ijoinnode",level:2},{value:"Keyed Join Nodes",id:"keyed-join-nodes",level:2},{value:"<code>KeyedJoinNode&lt;TKey, TIn1, TIn2, TOut&gt;</code>",id:"keyedjoinnodetkey-tin1-tin2-tout",level:3},{value:"Required Method Overrides",id:"required-method-overrides",level:4},{value:"Key Selection",id:"key-selection",level:4},{value:"Join Types",id:"join-types",level:4},{value:"Inner Join",id:"inner-join",level:5},{value:"Left Outer Join",id:"left-outer-join",level:5},{value:"Right Outer Join",id:"right-outer-join",level:5},{value:"Full Outer Join",id:"full-outer-join",level:5},{value:"Configuring Capacity Limits",id:"configuring-capacity-limits",level:4},{value:"Example: Joining Orders with Customer Data",id:"example-joining-orders-with-customer-data",level:3},{value:"Example: Composite Key Join",id:"example-composite-key-join",level:3},{value:"Time-Windowed Join Nodes",id:"time-windowed-join-nodes",level:2},{value:"<code>TimeWindowedJoinNode&lt;TLeft, TRight, TKey, TOutput&gt;</code>",id:"timewindowedjoinnodetleft-tright-tkey-toutput",level:3},{value:"Example: Correlating Events within a Time Window",id:"example-correlating-events-within-a-time-window",level:3},{value:"Self-Join",id:"self-join",level:2},{value:"Why Self-Join is Needed",id:"why-self-join-is-needed",level:3},{value:"When to Use Self-Join",id:"when-to-use-self-join",level:3},{value:"<code>AddSelfJoin</code> Extension Method",id:"addselfjoin-extension-method",level:3},{value:"Method Signature",id:"method-signature",level:4},{value:"Parameters",id:"parameters",level:4},{value:"Return Type",id:"return-type",level:4},{value:"How Self-Join Works",id:"how-self-join-works",level:4},{value:"Example 1: Simple Inner Join with Same Key Selector",id:"example-1-simple-inner-join-with-same-key-selector",level:3},{value:"Example 2: Left Outer Join with Fallback",id:"example-2-left-outer-join-with-fallback",level:3},{value:"Example 3: Different Key Selectors",id:"example-3-different-key-selectors",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"When to Use Self-Join vs Regular Join",id:"when-to-use-self-join-vs-regular-join",level:4},{value:"Performance Considerations",id:"performance-considerations",level:4},{value:"Common Pitfalls",id:"common-pitfalls",level:4},{value:"Key Configuration with <code>KeySelectorAttribute</code>",id:"key-configuration-with-keyselectorattribute",level:2},{value:"Delegate Types",id:"delegate-types",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const r={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"join-nodes",children:"Join Nodes"})}),"\n",(0,t.jsx)(r.p,{children:"Join nodes in NPipeline allow you to combine data from two or more independent input streams into a single output stream. This is a common operation in data processing, enabling the enrichment of data or the correlation of related events."}),"\n",(0,t.jsx)(r.p,{children:"NPipeline offers different types of join nodes to cater to various joining strategies, including keyed joins and time-windowed joins."}),"\n",(0,t.jsx)(r.h2,{id:"ijoinnode",children:(0,t.jsx)(r.code,{children:"IJoinNode"})}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.a,{href:"src/NPipeline/Interfaces/IJoinNode.cs",children:(0,t.jsx)(r.code,{children:"IJoinNode"})})," interface represents the contract for any node that performs a join operation. Implementations will typically take multiple input streams and produce a single output stream containing the combined data."]}),"\n",(0,t.jsx)(r.h2,{id:"keyed-join-nodes",children:"Keyed Join Nodes"}),"\n",(0,t.jsx)(r.p,{children:"Keyed join nodes merge items from different streams based on a common key. When an item arrives on any input stream, it is matched with existing items from other streams that share the same key."}),"\n",(0,t.jsx)(r.h3,{id:"keyedjoinnodetkey-tin1-tin2-tout",children:(0,t.jsx)(r.code,{children:"KeyedJoinNode<TKey, TIn1, TIn2, TOut>"})}),"\n",(0,t.jsxs)(r.p,{children:["This node performs a join based on a key selector and extends the ",(0,t.jsx)(r.a,{href:"src/NPipeline/Nodes/Join/BaseJoinNode.cs",children:(0,t.jsx)(r.code,{children:"BaseJoinNode<TKey, TIn1, TIn2, TOut>"})})," abstract base class, which provides common functionality for processing two input streams. You need to define how to extract the key from the left and right input items."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"TKey"}),": The type of the join key."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"TIn1"}),": The type of items from the first input stream."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"TIn2"}),": The type of items from the second input stream."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"TOut"}),": The type of the combined output item."]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"required-method-overrides",children:"Required Method Overrides"}),"\n",(0,t.jsx)(r.p,{children:"To implement a custom keyed join, you must override the following methods:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"CreateOutput(TLeft leftItem, TRight rightItem)"})}),": Creates the output item when a match is found between left and right items."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Purpose"}),": Defines how to combine matching items from both streams into a single output item."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Called when"}),": A matching pair of items (one from each stream with the same key) is found."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Returns"}),": The combined output item."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"CreateOutputFromLeft(TLeft leftItem)"})})," (Optional override): Creates an output item when there's no matching right item."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Purpose"}),": Handles unmatched items from the left stream in left outer and full outer joins."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Called when"}),": The stream ends and there are still unmatched left items."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Default behavior"}),": Attempts to automatically project the left item to the output type, but may throw ",(0,t.jsx)(r.code,{children:"NotSupportedException"})," if unable to do so."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Returns"}),": An output item based solely on the left item."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"CreateOutputFromRight(TRight rightItem)"})})," (Optional override): Creates an output item when there's no matching left item."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Purpose"}),": Handles unmatched items from the right stream in right outer and full outer joins."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Called when"}),": The stream ends and there are still unmatched right items."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Default behavior"}),": Attempts to automatically project the right item to the output type, but may throw ",(0,t.jsx)(r.code,{children:"NotSupportedException"})," if unable to do so."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Returns"}),": An output item based solely on the right item."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"key-selection",children:"Key Selection"}),"\n",(0,t.jsx)(r.p,{children:"Key extraction for the join can be defined in two ways:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Using KeySelectorAttribute"})," (Recommended): Apply the ",(0,t.jsx)(r.a,{href:"src/NPipeline/Attributes/Nodes/KeySelectorAttribute.cs",children:(0,t.jsx)(r.code,{children:"KeySelectorAttribute"})})," to your join class to specify which properties to use as keys for each input type."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Custom key extraction"}),": For more complex key extraction logic, you can override the key selection process."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"join-types",children:"Join Types"}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.a,{href:"src/NPipeline/Nodes/Join/JoinType.cs",children:(0,t.jsx)(r.code,{children:"JoinType"})})," property controls how unmatched items are handled:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"Inner"}),": Only produces output when there's a match in both streams (default)."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"LeftOuter"}),": Produces all left items, with matching right items when available."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"RightOuter"}),": Produces all right items, with matching left items when available."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"FullOuter"}),": Produces all items from both streams, matching when possible."]}),"\n"]}),"\n",(0,t.jsx)(r.h5,{id:"inner-join",children:"Inner Join"}),"\n",(0,t.jsx)(r.mermaid,{value:'graph TD\r\n    subgraph "Input Streams"\r\n        L[Left Stream<br/>A, B, C, D]\r\n        R[Right Stream<br/>B, C, E]\r\n    end\r\n\r\n    subgraph "Inner Join"\r\n        direction LR\r\n        LI[Left: A, B, C, D] --\x3e IJ{Join on Key}\r\n        RI[Right: B, C, E] --\x3e IJ\r\n        IJ --\x3e IO[Output: B, C<br/>Only matching items]\r\n    end\r\n\r\n    style L fill:#e1f5fe\r\n    style R fill:#e8f5e9\r\n    style IO fill:#fff3e0'}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.em,{children:"Figure: Inner join produces output only when there's a match in both streams."})}),"\n",(0,t.jsx)(r.h5,{id:"left-outer-join",children:"Left Outer Join"}),"\n",(0,t.jsx)(r.mermaid,{value:'graph TD\r\n    subgraph "Input Streams"\r\n        L[Left Stream<br/>A, B, C, D]\r\n        R[Right Stream<br/>B, C, E]\r\n    end\r\n\r\n    subgraph "Left Outer Join"\r\n        direction LR\r\n        LL[Left: A, B, C, D] --\x3e LJ{Join on Key}\r\n        RL[Right: B, C, E] --\x3e LJ\r\n        LJ --\x3e LO[Output: A, B, C, D<br/>All left items<br/>with null for non-matches]\r\n    end\r\n\r\n    style L fill:#e1f5fe\r\n    style R fill:#e8f5e9\r\n    style LO fill:#f3e5f5'}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.em,{children:"Figure: Left outer join produces all left items, with matching right items when available."})}),"\n",(0,t.jsx)(r.h5,{id:"right-outer-join",children:"Right Outer Join"}),"\n",(0,t.jsx)(r.mermaid,{value:'graph TD\r\n    subgraph "Input Streams"\r\n        L[Left Stream<br/>A, B, C, D]\r\n        R[Right Stream<br/>B, C, E]\r\n    end\r\n\r\n    subgraph "Right Outer Join"\r\n        direction LR\r\n        LR2[Left: A, B, C, D] --\x3e RJ{Join on Key}\r\n        RR[Right: B, C, E] --\x3e RJ\r\n        RJ --\x3e RO[Output: B, C, E<br/>All right items<br/>with null for non-matches]\r\n    end\r\n\r\n    style L fill:#e1f5fe\r\n    style R fill:#e8f5e9\r\n    style RO fill:#e0f2f1'}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.em,{children:"Figure: Right outer join produces all right items, with matching left items when available."})}),"\n",(0,t.jsx)(r.h5,{id:"full-outer-join",children:"Full Outer Join"}),"\n",(0,t.jsx)(r.mermaid,{value:'graph TD\r\n    subgraph "Input Streams"\r\n        L[Left Stream<br/>A, B, C, D]\r\n        R[Right Stream<br/>B, C, E]\r\n    end\r\n\r\n    subgraph "Full Outer Join"\r\n        direction LR\r\n        LF[Left: A, B, C, D] --\x3e FJ{Join on Key}\r\n        RF[Right: B, C, E] --\x3e FJ\r\n        FJ --\x3e FO[Output: A, B, C, D, E<br/>All items from both streams<br/>with null for non-matches]\r\n    end\r\n\r\n    style L fill:#e1f5fe\r\n    style R fill:#e8f5e9\r\n    style FO fill:#fce4ec'}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.em,{children:"Figure: Full outer join produces all items from both streams, matching when possible."})}),"\n",(0,t.jsx)(r.h4,{id:"configuring-capacity-limits",children:"Configuring Capacity Limits"}),"\n",(0,t.jsxs)(r.p,{children:["To prevent unbounded memory growth when streams are unbalanced, you can configure the ",(0,t.jsx)(r.code,{children:"MaxCapacity"})," property on keyed join nodes:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"[KeySelector(typeof(Order), nameof(Order.CustomerId))]\r\n[KeySelector(typeof(Customer), nameof(Customer.CustomerId))]\r\npublic sealed class CustomerOrderJoinNode : KeyedJoinNode<int, Order, Customer, EnrichedOrder>\r\n{\r\n    public CustomerOrderJoinNode()\r\n    {\r\n        // Set maximum capacity for unmatched items to prevent memory exhaustion\r\n        // When capacity is exceeded, new unmatched items will be discarded\r\n        MaxCapacity = 10000;\r\n    }\r\n\r\n    protected override EnrichedOrder CreateOutput(Order leftItem, Customer rightItem) { /*...*/ }\r\n}\n"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Default behavior"})," (",(0,t.jsx)(r.code,{children:"MaxCapacity = null"}),"): No limit on the number of unmatched items stored. Use this when streams are well-balanced."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Limited capacity"})," (e.g., ",(0,t.jsx)(r.code,{children:"MaxCapacity = 10000"}),"): When either waiting list reaches this capacity, new unmatched items will be discarded. This prevents unbounded memory growth but may result in unmatched items not producing output."]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"example-joining-orders-with-customer-data",children:"Example: Joining Orders with Customer Data"}),"\n",(0,t.jsxs)(r.p,{children:["Let's imagine we have a stream of ",(0,t.jsx)(r.code,{children:"Order"})," items and a separate stream of ",(0,t.jsx)(r.code,{children:"Customer"})," items. We want to enrich the ",(0,t.jsx)(r.code,{children:"Order"})," with ",(0,t.jsx)(r.code,{children:"Customer"})," details."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\n\r\n// Define input data structures\r\npublic sealed record Order(int OrderId, int CustomerId, decimal Amount);\r\npublic sealed record Customer(int CustomerId, string Name, string Email);\r\npublic sealed record EnrichedOrder(int OrderId, int CustomerId, string CustomerName, decimal Amount);\r\n\r\n// Define the join node with KeySelectorAttributes\r\n[KeySelector(typeof(Order), nameof(Order.CustomerId))]\r\n[KeySelector(typeof(Customer), nameof(Customer.CustomerId))]\r\npublic sealed class CustomerOrderJoinNode : KeyedJoinNode<int, Order, Customer, EnrichedOrder>\r\n{\r\n    // Required: Combine matching items\r\n    protected override EnrichedOrder CreateOutput(Order leftItem, Customer rightItem)\r\n    {\r\n        return new EnrichedOrder(\r\n            leftItem.OrderId,\r\n            leftItem.CustomerId,\r\n            rightItem.Name,\r\n            leftItem.Amount\r\n        );\r\n    }\r\n\r\n    // Optional: Handle unmatched orders (for left outer or full outer joins)\r\n    protected override EnrichedOrder CreateOutputFromLeft(Order leftItem)\r\n    {\r\n        // Create an enriched order with placeholder customer data\r\n        return new EnrichedOrder(\r\n            leftItem.OrderId,\r\n            leftItem.CustomerId,\r\n            "Unknown Customer",\r\n            leftItem.Amount\r\n        );\r\n    }\r\n\r\n    // Optional: Handle unmatched customers (for right outer or full outer joins)\r\n    protected override EnrichedOrder CreateOutputFromRight(Customer rightItem)\r\n    {\r\n        // Create a placeholder order with just the customer information\r\n        return new EnrichedOrder(\r\n            0, // No OrderId\r\n            rightItem.CustomerId,\r\n            rightItem.Name,\r\n            0m // No amount\r\n        );\r\n    }\r\n}\r\n\r\npublic static class Program\r\n{\r\n    public static async Task Main(string[] args)\r\n    {\r\n        var orderSource = new InMemorySourceNode<Order>(\r\n            new Order(101, 1, 100.00m),\r\n            new Order(102, 2, 250.00m),\r\n            new Order(103, 1, 50.00m),\r\n            new Order(104, 3, 75.00m) // This customer doesn\'t exist in our data\r\n        );\r\n\r\n        var customerSource = new InMemorySourceNode<Customer>(\r\n            new Customer(1, "Alice", "alice@example.com"),\r\n            new Customer(2, "Bob", "bob@example.com")\r\n            // Note: Customer 3 is missing\r\n        );\r\n\r\n        // Example with inner join (default)\r\n        var innerJoinContext = PipelineContext.Default;\r\n        var innerJoinRunner = PipelineRunner.Create();\r\n        Console.WriteLine("Running inner join pipeline...");\r\n        await innerJoinRunner.RunAsync<InnerJoinPipelineDefinition>(innerJoinContext);\r\n\r\n        // Example with left outer join\r\n        var leftOuterContext = PipelineContext.Default;\r\n        var leftOuterRunner = PipelineRunner.Create();\r\n        Console.WriteLine("\\nRunning left outer join pipeline...");\r\n        await leftOuterRunner.RunAsync<LeftOuterJoinPipelineDefinition>(leftOuterContext);\r\n\r\n        // Example with full outer join\r\n        var fullOuterContext = PipelineContext.Default;\r\n        var fullOuterRunner = PipelineRunner.Create();\r\n        Console.WriteLine("\\nRunning full outer join pipeline...");\r\n        await fullOuterRunner.RunAsync<FullOuterJoinPipelineDefinition>(fullOuterContext);\r\n    }\r\n}\r\n\r\npublic sealed class InnerJoinPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var orderSourceHandle = builder.AddSource<InMemorySourceNode<Order>, Order>("orderSource");\r\n        var customerSourceHandle = builder.AddSource<InMemorySourceNode<Customer>, Customer>("customerSource");\r\n        var joinHandle = builder.AddJoin<CustomerOrderJoinNode, Order, Customer, EnrichedOrder>("correlator");\r\n        var sinkHandle = builder.AddSink<ConsoleSink<EnrichedOrder>, EnrichedOrder>("sink");\r\n\r\n        builder.Connect(orderSourceHandle, joinHandle);\r\n        builder.Connect(customerSourceHandle, joinHandle);\r\n        builder.Connect(joinHandle, sinkHandle);\r\n    }\r\n}\r\n\r\npublic sealed class LeftOuterJoinPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var orderSourceHandle = builder.AddSource<InMemorySourceNode<Order>, Order>("orderSource");\r\n        var customerSourceHandle = builder.AddSource<InMemorySourceNode<Customer>, Customer>("customerSource");\r\n        var joinHandle = builder.AddJoin<CustomerOrderJoinNode, Order, Customer, EnrichedOrder>("correlator");\r\n        var sinkHandle = builder.AddSink<ConsoleSink<EnrichedOrder>, EnrichedOrder>("sink");\r\n\r\n        builder.Connect(orderSourceHandle, joinHandle);\r\n        builder.Connect(customerSourceHandle, joinHandle);\r\n        builder.Connect(joinHandle, sinkHandle);\r\n    }\r\n}\r\n\r\npublic sealed class FullOuterJoinPipelineDefinition : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        var orderSourceHandle = builder.AddSource<InMemorySourceNode<Order>, Order>("orderSource");\r\n        var customerSourceHandle = builder.AddSource<InMemorySourceNode<Customer>, Customer>("customerSource");\r\n        var joinHandle = builder.AddJoin<CustomerOrderJoinNode, Order, Customer, EnrichedOrder>("correlator");\r\n        var sinkHandle = builder.AddSink<ConsoleSink<EnrichedOrder>, EnrichedOrder>("sink");\r\n\r\n        builder.Connect(orderSourceHandle, joinHandle);\r\n        builder.Connect(customerSourceHandle, joinHandle);\r\n        builder.Connect(joinHandle, sinkHandle);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Expected Output:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-text",children:'Running inner join pipeline...\r\nSink received: EnrichedOrder { OrderId = 101, CustomerId = 1, CustomerName = "Alice", Amount = 100.00 }\r\nSink received: EnrichedOrder { OrderId = 102, CustomerId = 2, CustomerName = "Bob", Amount = 250.00 }\r\nSink received: EnrichedOrder { OrderId = 103, CustomerId = 1, CustomerName = "Alice", Amount = 50.00 }\r\n\r\nRunning left outer join pipeline...\r\nSink received: EnrichedOrder { OrderId = 101, CustomerId = 1, CustomerName = "Alice", Amount = 100.00 }\r\nSink received: EnrichedOrder { OrderId = 102, CustomerId = 2, CustomerName = "Bob", Amount = 250.00 }\r\nSink received: EnrichedOrder { OrderId = 103, CustomerId = 1, CustomerName = "Alice", Amount = 50.00 }\r\nSink received: EnrichedOrder { OrderId = 104, CustomerId = 3, CustomerName = "Unknown Customer", Amount = 75.00 }\r\n\r\nRunning full outer join pipeline...\r\nSink received: EnrichedOrder { OrderId = 101, CustomerId = 1, CustomerName = "Alice", Amount = 100.00 }\r\nSink received: EnrichedOrder { OrderId = 102, CustomerId = 2, CustomerName = "Bob", Amount = 250.00 }\r\nSink received: EnrichedOrder { OrderId = 103, CustomerId = 1, CustomerName = "Alice", Amount = 50.00 }\r\nSink received: EnrichedOrder { OrderId = 104, CustomerId = 3, CustomerName = "Unknown Customer", Amount = 75.00 }\n'})}),"\n",(0,t.jsx)(r.h3,{id:"example-composite-key-join",children:"Example: Composite Key Join"}),"\n",(0,t.jsx)(r.p,{children:"For more complex scenarios, you can use composite keys:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\n\r\n// Define input data structures with composite keys\r\npublic sealed record OrderItem(int OrderId, string ProductCode, int Quantity, decimal Price);\r\npublic sealed record Product(string ProductCode, string Category, string Name);\r\npublic sealed record EnrichedOrderItem(int OrderId, string ProductCode, string ProductName, string Category, int Quantity, decimal Price);\r\n\r\n// Define a composite key type\r\npublic sealed record OrderProductKey(int OrderId, string ProductCode);\r\n\r\n// Define the join node with composite key selectors\r\n[KeySelector(typeof(OrderItem), nameof(OrderItem.OrderId), nameof(OrderItem.ProductCode))]\r\n[KeySelector(typeof(Product), nameof(Product.ProductCode))]\r\npublic sealed class OrderItemProductJoinNode : KeyedJoinNode<(int, string), OrderItem, Product, EnrichedOrderItem>\r\n{\r\n    protected override EnrichedOrderItem CreateOutput(OrderItem leftItem, Product rightItem)\r\n    {\r\n        return new EnrichedOrderItem(\r\n            leftItem.OrderId,\r\n            leftItem.ProductCode,\r\n            rightItem.Name,\r\n            rightItem.Category,\r\n            leftItem.Quantity,\r\n            leftItem.Price\r\n        );\r\n    }\r\n\r\n    protected override EnrichedOrderItem CreateOutputFromLeft(OrderItem leftItem)\r\n    {\r\n        // Handle order items with unknown products\r\n        return new EnrichedOrderItem(\r\n            leftItem.OrderId,\r\n            leftItem.ProductCode,\r\n            "Unknown Product",\r\n            "Unknown Category",\r\n            leftItem.Quantity,\r\n            leftItem.Price\r\n        );\r\n    }\r\n}\r\n\r\n// Alternative using ValueTuple for composite key\r\n[KeySelector(typeof(OrderItem), nameof(OrderItem.OrderId), nameof(OrderItem.ProductCode))]\r\n[KeySelector(typeof(Product), nameof(Product.ProductCode))]\r\npublic sealed class OrderItemProductJoinNodeWithTuple : KeyedJoinNode<(int OrderId, string ProductCode), OrderItem, Product, EnrichedOrderItem>\r\n{\r\n    protected override EnrichedOrderItem CreateOutput(OrderItem leftItem, Product rightItem)\r\n    {\r\n        return new EnrichedOrderItem(\r\n            leftItem.OrderId,\r\n            leftItem.ProductCode,\r\n            rightItem.Name,\r\n            rightItem.Category,\r\n            leftItem.Quantity,\r\n            leftItem.Price\r\n        );\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"time-windowed-join-nodes",children:"Time-Windowed Join Nodes"}),"\n",(0,t.jsx)(r.p,{children:"Time-windowed join nodes combine items from different streams that occur within a specified time window. This is common in real-time stream processing where events need to be correlated based on their temporal proximity."}),"\n",(0,t.jsx)(r.h3,{id:"timewindowedjoinnodetleft-tright-tkey-toutput",children:(0,t.jsx)(r.code,{children:"TimeWindowedJoinNode<TLeft, TRight, TKey, TOutput>"})}),"\n",(0,t.jsxs)(r.p,{children:["This node extends ",(0,t.jsx)(r.a,{href:"src/NPipeline/Nodes/Join/KeyedJoinNode.cs",children:(0,t.jsx)(r.code,{children:"KeyedJoinNode"})})," by adding a time window constraint. Items are considered for joining only if their timestamps fall within the defined window and their keys match."]}),"\n",(0,t.jsx)(r.h3,{id:"example-correlating-events-within-a-time-window",children:"Example: Correlating Events within a Time Window"}),"\n",(0,t.jsxs)(r.p,{children:["The repository includes time-windowed join support (see ",(0,t.jsx)(r.code,{children:"TimeWindowedJoinNode"})," and windowing primitives such as ",(0,t.jsx)(r.code,{children:"WindowAssigner"}),"). Higher-level extension packages may provide convenience helpers in the future, but basic time-windowed join patterns are available in core today."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"// Assuming EventA and EventB have a Timestamp property and a common CorrelationId\r\npublic sealed record EventA(Guid CorrelationId, DateTime Timestamp, string DataA);\r\npublic sealed record EventB(Guid CorrelationId, DateTime Timestamp, string DataB);\r\npublic sealed record CorrelatedEvent(Guid CorrelationId, DateTime Timestamp, string DataA, string DataB);\r\n\r\npublic sealed class EventCorrelationJoinNode : TimeWindowedJoinNode<EventA, EventB, Guid, CorrelatedEvent>\r\n{\r\n    public EventCorrelationJoinNode(TimeSpan windowSize) : base(windowSize) { }\r\n\r\n    protected override Guid GetLeftKey(EventA leftItem) => leftItem.CorrelationId;\r\n    protected override DateTime GetLeftTimestamp(EventA leftItem) => leftItem.Timestamp;\r\n\r\n    protected override Guid GetRightKey(EventB rightItem) => rightItem.CorrelationId;\r\n    protected override DateTime GetRightTimestamp(EventB rightItem) => rightItem.Timestamp;\r\n\r\n    protected override CorrelatedEvent JoinItems(EventA leftItem, EventB rightItem)\r\n    {\r\n        return new CorrelatedEvent(\r\n            leftItem.CorrelationId,\r\n            leftItem.Timestamp, // or rightItem.Timestamp, depending on logic\r\n            leftItem.DataA,\r\n            rightItem.DataB\r\n        );\r\n    }\r\n}\r\n\r\n// Pipeline construction would involve adding sources and a join node\r\n// var pipeline = new PipelineBuilder()\r\n//     .AddSource(new EventASource())\r\n//     .AddSource(new EventBSource())\r\n//     .Join(new EventCorrelationJoinNode(TimeSpan.FromSeconds(5))) // Join events within 5 seconds\r\n//     .AddSink(new ConsoleSink<CorrelatedEvent>())\r\n//     .Build();\n"})}),"\n",(0,t.jsx)(r.h2,{id:"self-join",children:"Self-Join"}),"\n",(0,t.jsx)(r.p,{children:"Self-join enables joining two streams containing items of the same type from different sources. This is particularly useful when you need to correlate items of identical types but from distinct data sources, such as comparing orders from different regions, events from different time periods, or matching records from multiple databases."}),"\n",(0,t.jsx)(r.h3,{id:"why-self-join-is-needed",children:"Why Self-Join is Needed"}),"\n",(0,t.jsxs)(r.p,{children:["The standard ",(0,t.jsx)(r.a,{href:"src/NPipeline/Nodes/Join/KeyedJoinNode.cs",children:(0,t.jsx)(r.code,{children:"KeyedJoinNode<TKey, TIn1, TIn2, TOut>"})})," uses runtime type checking (",(0,t.jsx)(r.code,{children:"item is TIn1"}),", ",(0,t.jsx)(r.code,{children:"item is TIn2"}),") to distinguish between items from the left and right input streams. When ",(0,t.jsx)(r.code,{children:"TIn1"})," and ",(0,t.jsx)(r.code,{children:"TIn2"}),' are the same type, this type checking fails because items from both streams are indistinguishable at runtime. This is known as the "BaseJoinNode Secondary Input Type Erasure" issue.']}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.a,{href:"src/NPipeline/SelfJoinExtensions.cs",children:(0,t.jsx)(r.code,{children:"AddSelfJoin"})})," extension method solves this by internally wrapping items from each stream with distinct wrapper types (",(0,t.jsx)(r.a,{href:"src/NPipeline/Nodes/Internal/SelfJoinTransform.cs",children:(0,t.jsx)(r.code,{children:"LeftWrapper<T>"})})," and ",(0,t.jsx)(r.a,{href:"src/NPipeline/Nodes/Internal/SelfJoinTransform.cs",children:(0,t.jsx)(r.code,{children:"RightWrapper<T>"})}),"), allowing the join node to differentiate between items from the left and right streams even though they have the same underlying type. The join node unwraps items before applying your output factory, so you work with the original unwrapped items."]}),"\n",(0,t.jsx)(r.h3,{id:"when-to-use-self-join",children:"When to Use Self-Join"}),"\n",(0,t.jsx)(r.p,{children:"Common use cases for self-joins include:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Time-based comparisons"}),": Comparing data from different time periods (e.g., year-over-year sales analysis)"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Multi-source aggregation"}),": Combining data from different regions, systems, or databases"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Change detection"}),": Identifying differences between current and historical data"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Cross-reference validation"}),": Validating data integrity across multiple sources"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Pattern matching"}),": Finding correlations in similar data streams"]}),"\n"]}),"\n",(0,t.jsxs)(r.h3,{id:"addselfjoin-extension-method",children:[(0,t.jsx)(r.code,{children:"AddSelfJoin"})," Extension Method"]}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.a,{href:"src/NPipeline/SelfJoinExtensions.cs",children:(0,t.jsx)(r.code,{children:"AddSelfJoin"})})," extension method provides a convenient way to add self-join nodes to your pipeline without manually creating wrapper types."]}),"\n",(0,t.jsx)(r.h4,{id:"method-signature",children:"Method Signature"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public static IOutputNodeHandle<TOut> AddSelfJoin<TItem, TKey, TOut>(\r\n    this PipelineBuilder builder,\r\n    IOutputNodeHandle<TItem> leftSource,\r\n    IOutputNodeHandle<TItem> rightSource,\r\n    string nodeName,\r\n    Func<TItem, TItem, TOut> outputFactory,\r\n    Func<TItem, TKey> leftKeySelector,\r\n    Func<TItem, TKey>? rightKeySelector = null,\r\n    JoinType joinType = JoinType.Inner,\r\n    Func<TItem, TOut>? leftFallback = null,\r\n    Func<TItem, TOut>? rightFallback = null)\r\n    where TKey : notnull\n"})}),"\n",(0,t.jsx)(r.h4,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"builder"})}),": The pipeline builder instance."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"leftSource"})}),": Handle to the left source node."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"rightSource"})}),": Handle to the right source node."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"nodeName"})}),": Name for the join node."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"outputFactory"})}),": Function that creates an output item from matched left and right items. Receives the original unwrapped items."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"leftKeySelector"})}),": Function to extract the join key from left stream items."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"rightKeySelector"})}),": Optional function to extract the join key from right stream items. If null, uses the same selector as the left stream."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"joinType"})}),": Type of join to perform. Defaults to ",(0,t.jsx)(r.code,{children:"JoinType.Inner"}),". Supports all join types: ",(0,t.jsx)(r.code,{children:"Inner"}),", ",(0,t.jsx)(r.code,{children:"LeftOuter"}),", ",(0,t.jsx)(r.code,{children:"RightOuter"}),", ",(0,t.jsx)(r.code,{children:"FullOuter"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"leftFallback"})}),": Optional function to create output from unmatched left items. Used for left outer and full outer joins."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"rightFallback"})}),": Optional function to create output from unmatched right items. Used for right outer and full outer joins."]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"return-type",children:"Return Type"}),"\n",(0,t.jsxs)(r.p,{children:["Returns an ",(0,t.jsx)(r.a,{href:"src/NPipeline/Graph/IOutputNodeHandle.cs",children:(0,t.jsx)(r.code,{children:"IOutputNodeHandle<TOut>"})})," to the newly added join node, which can be connected to downstream nodes."]}),"\n",(0,t.jsx)(r.h4,{id:"how-self-join-works",children:"How Self-Join Works"}),"\n",(0,t.jsx)(r.mermaid,{value:'graph TD\r\n    subgraph "Input Streams"\r\n        L[Left Source<br/>Type: TItem]\r\n        R[Right Source<br/>Type: TItem]\r\n    end\r\n    \r\n    subgraph "Wrapper Layer"\r\n        LW[Left Wrapper Transform<br/>Type: LeftWrapper&lt;TItem&gt;]\r\n        RW[Right Wrapper Transform<br/>Type: RightWrapper&lt;TItem&gt;]\r\n    end\r\n    \r\n    subgraph "Join Node"\r\n        JN[SelfJoinNode<br/>Distinguishes wrapped types]\r\n    end\r\n    \r\n    subgraph "Output"\r\n        O[Output Stream<br/>Type: TOut]\r\n    end\r\n    \r\n    L --\x3e|wraps| LW\r\n    R --\x3e|wraps| RW\r\n    LW --\x3e|LeftWrapper&lt;TItem&gt;| JN\r\n    RW --\x3e|RightWrapper&lt;TItem&gt;| JN\r\n    JN --\x3e|unwraps & combines| O\r\n    \r\n    style L fill:#e1f5fe\r\n    style R fill:#e8f5e9\r\n    style LW fill:#fff3e0\r\n    style RW fill:#f3e5f5\r\n    style JN fill:#e0f2f1\r\n    style O fill:#fce4ec'}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.em,{children:"Figure: Self-join uses wrapper types to distinguish items from the left and right streams before joining."})}),"\n",(0,t.jsx)(r.h3,{id:"example-1-simple-inner-join-with-same-key-selector",children:"Example 1: Simple Inner Join with Same Key Selector"}),"\n",(0,t.jsx)(r.p,{children:"Join orders from two different years by customer ID to analyze year-over-year growth:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\n\r\n// Define the order type\r\npublic sealed record Order(int OrderId, int CustomerId, decimal Amount, int Year);\r\n\r\n// Define the output type for year-over-year comparison\r\npublic sealed record OrderComparison(int CustomerId, decimal Amount2024, decimal Amount2023, decimal Growth);\r\n\r\npublic sealed class YearOverYearComparisonPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        // Orders from 2024\r\n        var orders2024 = builder.AddInMemorySource(\r\n            new[]\r\n            {\r\n                new Order(1, 101, 1000.00m, 2024),\r\n                new Order(2, 102, 1500.00m, 2024),\r\n                new Order(3, 103, 2000.00m, 2024)\r\n            },\r\n            "orders_2024"\r\n        );\r\n\r\n        // Orders from 2023\r\n        var orders2023 = builder.AddInMemorySource(\r\n            new[]\r\n            {\r\n                new Order(4, 101, 800.00m, 2023),\r\n                new Order(5, 102, 1200.00m, 2023),\r\n                new Order(6, 104, 900.00m, 2023) // Customer 104 not in 2024\r\n            },\r\n            "orders_2023"\r\n        );\r\n\r\n        // Join orders from both years by customer ID\r\n        var comparison = builder.AddSelfJoin(\r\n            leftSource: orders2024,\r\n            rightSource: orders2023,\r\n            nodeName: "yoy_comparison",\r\n            outputFactory: (order2024, order2023) => new OrderComparison(\r\n                order2024.CustomerId,\r\n                order2024.Amount,\r\n                order2023.Amount,\r\n                order2024.Amount - order2023.Amount\r\n            ),\r\n            leftKeySelector: order => order.CustomerId,\r\n            rightKeySelector: order => order.CustomerId,\r\n            joinType: JoinType.Inner\r\n        );\r\n\r\n        var sink = builder.AddSink<ConsoleSink<OrderComparison>, OrderComparison>("output");\r\n        builder.Connect(comparison, sink);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Expected Output:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-text",children:"OrderComparison { CustomerId = 101, Amount2024 = 1000.00, Amount2023 = 800.00, Growth = 200.00 }\r\nOrderComparison { CustomerId = 102, Amount2024 = 1500.00, Amount2023 = 1200.00, Growth = 300.00 }\n"})}),"\n",(0,t.jsx)(r.h3,{id:"example-2-left-outer-join-with-fallback",children:"Example 2: Left Outer Join with Fallback"}),"\n",(0,t.jsx)(r.p,{children:"Compare product prices between two catalogs, including products that only exist in the primary catalog:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\n\r\n// Define the product type\r\npublic sealed record Product(string ProductCode, string Name, decimal Price);\r\n\r\n// Define the output type for price comparison\r\npublic sealed record PriceComparison(string ProductCode, string Name, decimal PrimaryPrice, decimal? SecondaryPrice, decimal? Difference);\r\n\r\npublic sealed class PriceComparisonPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        // Primary catalog products\r\n        var primaryCatalog = builder.AddInMemorySource(\r\n            new[]\r\n            {\r\n                new Product("P001", "Widget A", 10.00m),\r\n                new Product("P002", "Widget B", 20.00m),\r\n                new Product("P003", "Widget C", 30.00m)\r\n            },\r\n            "primary_catalog"\r\n        );\r\n\r\n        // Secondary catalog products\r\n        var secondaryCatalog = builder.AddInMemorySource(\r\n            new[]\r\n            {\r\n                new Product("P001", "Widget A", 12.00m),\r\n                new Product("P002", "Widget B", 18.00m),\r\n                new Product("P004", "Widget D", 25.00m) // Not in primary catalog\r\n            },\r\n            "secondary_catalog"\r\n        );\r\n\r\n        // Compare prices with left outer join to include all primary products\r\n        var priceComparison = builder.AddSelfJoin(\r\n            leftSource: primaryCatalog,\r\n            rightSource: secondaryCatalog,\r\n            nodeName: "price_comparison",\r\n            outputFactory: (primary, secondary) => new PriceComparison(\r\n                primary.ProductCode,\r\n                primary.Name,\r\n                primary.Price,\r\n                secondary.Price,\r\n                secondary.Price - primary.Price\r\n            ),\r\n            leftKeySelector: product => product.ProductCode,\r\n            rightKeySelector: product => product.ProductCode,\r\n            joinType: JoinType.LeftOuter,\r\n            leftFallback: primary => new PriceComparison(\r\n                primary.ProductCode,\r\n                primary.Name,\r\n                primary.Price,\r\n                null,\r\n                null\r\n            )\r\n        );\r\n\r\n        var sink = builder.AddSink<ConsoleSink<PriceComparison>, PriceComparison>("output");\r\n        builder.Connect(priceComparison, sink);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Expected Output:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-text",children:'PriceComparison { ProductCode = "P001", Name = "Widget A", PrimaryPrice = 10.00, SecondaryPrice = 12.00, Difference = 2.00 }\r\nPriceComparison { ProductCode = "P002", Name = "Widget B", PrimaryPrice = 20.00, SecondaryPrice = 18.00, Difference = -2.00 }\r\nPriceComparison { ProductCode = "P003", Name = "Widget C", PrimaryPrice = 30.00, SecondaryPrice = null, Difference = null }\n'})}),"\n",(0,t.jsx)(r.h3,{id:"example-3-different-key-selectors",children:"Example 3: Different Key Selectors"}),"\n",(0,t.jsx)(r.p,{children:"Match events from different systems using different key properties:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'using NPipeline;\r\nusing NPipeline.Nodes;\r\n\r\n// Define the event type\r\npublic sealed record SystemEvent(string EventId, string CorrelationId, DateTime Timestamp, string System, string Data);\r\n\r\n// Define the output type for event correlation\r\npublic sealed record CorrelatedEvents(string CorrelationId, DateTime Timestamp, string SystemAData, string SystemBData, TimeSpan TimeDifference);\r\n\r\npublic sealed class EventCorrelationPipeline : IPipelineDefinition\r\n{\r\n    public void Define(PipelineBuilder builder, PipelineContext context)\r\n    {\r\n        // Events from System A (using EventId as key)\r\n        var systemAEvents = builder.AddInMemorySource(\r\n            new[]\r\n            {\r\n                new SystemEvent("E001", "CORR-001", DateTime.Parse("2024-01-01T10:00:00Z"), "SystemA", "Data from A"),\r\n                new SystemEvent("E002", "CORR-002", DateTime.Parse("2024-01-01T10:05:00Z"), "SystemA", "More data from A")\r\n            },\r\n            "system_a_events"\r\n        );\r\n\r\n        // Events from System B (using CorrelationId as key)\r\n        var systemBEvents = builder.AddInMemorySource(\r\n            new[]\r\n            {\r\n                new SystemEvent("E101", "CORR-001", DateTime.Parse("2024-01-01T10:00:05Z"), "SystemB", "Data from B"),\r\n                new SystemEvent("E102", "CORR-003", DateTime.Parse("2024-01-01T10:10:00Z"), "SystemB", "Unmatched data")\r\n            },\r\n            "system_b_events"\r\n        );\r\n\r\n        // Correlate events using different key selectors\r\n        var correlatedEvents = builder.AddSelfJoin(\r\n            leftSource: systemAEvents,\r\n            rightSource: systemBEvents,\r\n            nodeName: "event_correlation",\r\n            outputFactory: (eventA, eventB) => new CorrelatedEvents(\r\n                eventA.CorrelationId,\r\n                eventA.Timestamp,\r\n                eventA.Data,\r\n                eventB.Data,\r\n                eventB.Timestamp - eventA.Timestamp\r\n            ),\r\n            leftKeySelector: evt => evt.EventId,\r\n            rightKeySelector: evt => evt.CorrelationId,\r\n            joinType: JoinType.Inner\r\n        );\r\n\r\n        var sink = builder.AddSink<ConsoleSink<CorrelatedEvents>, CorrelatedEvents>("output");\r\n        builder.Connect(correlatedEvents, sink);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Expected Output:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-text",children:'CorrelatedEvents { CorrelationId = "CORR-001", Timestamp = 2024-01-01T10:00:00Z, SystemAData = "Data from A", SystemBData = "Data from B", TimeDifference = 00:00:05 }\n'})}),"\n",(0,t.jsx)(r.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(r.h4,{id:"when-to-use-self-join-vs-regular-join",children:"When to Use Self-Join vs Regular Join"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Use Self-Join"})," when both input streams contain items of the same type but from different sources. This is the only way to correctly join same-type items due to the type erasure issue."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Use Regular Join"})," (",(0,t.jsx)(r.a,{href:"src/NPipeline/Nodes/Join/KeyedJoinNode.cs",children:(0,t.jsx)(r.code,{children:"KeyedJoinNode"})}),") when joining items of different types, such as joining ",(0,t.jsx)(r.code,{children:"Order"})," with ",(0,t.jsx)(r.code,{children:"Customer"})," or ",(0,t.jsx)(r.code,{children:"Product"})," with ",(0,t.jsx)(r.code,{children:"Category"}),"."]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Memory Usage"}),": Like all keyed joins, self-joins maintain waiting lists for unmatched items. For unbalanced streams, you can prevent unbounded memory growth by setting the ",(0,t.jsx)(r.code,{children:"MaxCapacity"})," property on ",(0,t.jsx)(r.code,{children:"KeyedJoinNode<TKey, TIn1, TIn2, TOut>"})," (or ",(0,t.jsx)(r.code,{children:"SelfJoinNode<TKey, TIn>"})," for self-joins). When capacity is exceeded, new unmatched items will be discarded. Alternatively, consider using time-windowed joins to automatically discard old unmatched items."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Key Selector Complexity"}),": Keep key selectors simple and efficient, as they are called for every item. Avoid complex computations or I/O operations in key selectors."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Multiple Matches"}),": If multiple items in both streams share the same key, the join produces all possible combinations (Cartesian product for that key). Be aware of this behavior when designing your data model."]}),"\n"]}),"\n",(0,t.jsx)(r.h4,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Forgetting Fallback Functions"}),": When using outer joins (",(0,t.jsx)(r.code,{children:"LeftOuter"}),", ",(0,t.jsx)(r.code,{children:"RightOuter"}),", ",(0,t.jsx)(r.code,{children:"FullOuter"}),"), always provide appropriate fallback functions to handle unmatched items. Without fallbacks, the join may throw exceptions or produce unexpected results."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Key Selector Mismatch"}),": Ensure that key selectors return compatible types. If using different key selectors, verify that the keys can be correctly compared and matched."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Null Key Handling"}),": The key type ",(0,t.jsx)(r.code,{children:"TKey"})," is constrained to be non-null (",(0,t.jsx)(r.code,{children:"where TKey : notnull"}),"). Ensure your key selectors never return null values, as this will cause runtime exceptions."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Stream Ordering"}),": Self-joins process items as they arrive. If ordering matters for your use case, ensure streams are properly ordered before the join or implement additional logic to handle ordering requirements."]}),"\n"]}),"\n",(0,t.jsxs)(r.h2,{id:"key-configuration-with-keyselectorattribute",children:["Key Configuration with ",(0,t.jsx)(r.a,{href:"src/NPipeline/Attributes/Nodes/KeySelectorAttribute.cs",children:(0,t.jsx)(r.code,{children:"KeySelectorAttribute"})})]}),"\n",(0,t.jsxs)(r.p,{children:["Some join nodes may utilize the ",(0,t.jsx)(r.code,{children:"KeySelectorAttribute"})," to automatically infer key extraction logic based on property names or custom functions. This provides a declarative way to specify join keys."]}),"\n",(0,t.jsx)(r.h2,{id:"delegate-types",children:"Delegate Types"}),"\n",(0,t.jsxs)(r.p,{children:["Join operations use the following delegate types located in the ",(0,t.jsx)(r.code,{children:"NPipeline.Graph.PipelineDelegates"})," namespace:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"CustomMergeDelegate"}),": For custom merge logic in join nodes"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"JoinKeySelectorDelegate"}),": For extracting join keys"]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"When using these delegates, ensure you import the correct namespace:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"using NPipeline.Graph.PipelineDelegates;\r\n\r\n// Use the delegates in your join implementation\r\nCustomMergeDelegate? myCustomMerge = (node, dataPipes, cancellationToken) => {\r\n    // Custom merge implementation\r\n    return mergedDataPipe;\r\n};\n"})}),"\n",(0,t.jsx)(r.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/nodes/lookup",children:"Lookup Nodes"})}),": Discover how to enrich data by querying external sources."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"/docs/core-concepts/nodes/branch",children:"Branch Nodes"})}),": Learn about duplicating data streams to multiple downstream paths."]}),"\n"]})]})}function u(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);