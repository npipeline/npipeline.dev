"use strict";(self.webpackChunknpipeline=self.webpackChunknpipeline||[]).push([[98],{12605:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>o});const l=JSON.parse('{"id":"extensions/lineage/architecture","title":"Lineage Architecture","description":"Internal architecture and design decisions of NPipeline Lineage extension.","source":"@site/docs/extensions/lineage/architecture.md","sourceDirName":"extensions/lineage","slug":"/extensions/lineage/architecture","permalink":"/docs/extensions/lineage/architecture","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Lineage Architecture","description":"Internal architecture and design decisions of NPipeline Lineage extension."},"sidebar":"docsSidebar","previous":{"title":"NPipeline Lineage Extension","permalink":"/docs/extensions/lineage"},"next":{"title":"Lineage Configuration","permalink":"/docs/extensions/lineage/configuration"}}');var a=i(74848),s=i(28453);const r={title:"Lineage Architecture",description:"Internal architecture and design decisions of NPipeline Lineage extension."},t="Lineage Architecture",c={},o=[{value:"System Architecture",id:"system-architecture",level:2},{value:"Core Components",id:"core-components",level:2},{value:"LineageCollector",id:"lineagecollector",level:3},{value:"LineagePacket",id:"lineagepacket",level:3},{value:"LineageInfo",id:"lineageinfo",level:3},{value:"PipelineLineageReport",id:"pipelinelineagereport",level:3},{value:"Design Decisions",id:"design-decisions",level:2},{value:"1. Transparent Integration",id:"1-transparent-integration",level:3},{value:"2. Sampling at Collection Time",id:"2-sampling-at-collection-time",level:3},{value:"3. Thread-Safe by Default",id:"3-thread-safe-by-default",level:3},{value:"4. Materialization Cap",id:"4-materialization-cap",level:3},{value:"5. Sink Abstraction",id:"5-sink-abstraction",level:3},{value:"Data Flow",id:"data-flow",level:2},{value:"Item Flow with Lineage",id:"item-flow-with-lineage",level:3},{value:"Collection Flow",id:"collection-flow",level:3},{value:"Sampling Implementation",id:"sampling-implementation",level:2},{value:"Deterministic Sampling",id:"deterministic-sampling",level:3},{value:"Sampling Granularity",id:"sampling-granularity",level:3},{value:"Overflow Handling",id:"overflow-handling",level:2},{value:"Materialize Policy",id:"materialize-policy",level:3},{value:"Degrade Policy (Default)",id:"degrade-policy-default",level:3},{value:"Drop Policy",id:"drop-policy",level:3},{value:"Sink Architecture",id:"sink-architecture",level:2},{value:"ILineageSink",id:"ilineagesink",level:3},{value:"IPipelineLineageSink",id:"ipipelinelineagesink",level:3},{value:"Sink Lifetime",id:"sink-lifetime",level:3},{value:"Integration Points",id:"integration-points",level:2},{value:"PipelineBuilder Extensions",id:"pipelinebuilder-extensions",level:3},{value:"Dependency Injection Integration",id:"dependency-injection-integration",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Memory Allocation",id:"memory-allocation",level:3},{value:"CPU Impact",id:"cpu-impact",level:3},{value:"Scalability",id:"scalability",level:3},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"lineage-architecture",children:"Lineage Architecture"})}),"\n",(0,a.jsx)(n.p,{children:"This guide covers the internal architecture, design decisions, and implementation details of the NPipeline Lineage extension."}),"\n",(0,a.jsx)(n.h2,{id:"system-architecture",children:"System Architecture"}),"\n",(0,a.jsx)(n.p,{children:"The Lineage extension follows a layered architecture for separation of concerns:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Pipeline Execution          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u251c\u2500> Lineage Tracking (per item)\n               \u2502   - CreateLineagePacket at source\n               \u2502   - RecordHop at each node\n               \u2502   - ShouldCollectLineage (sampling)\n               \u2502\n               \u2193\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502  ILineageCollector       \u2502\n        \u2502  (Thread-safe)           \u2502\n        \u2502  - ConcurrentDictionary  \u2502\n        \u2502  - Per-item LineageTrail \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n                   \u251c\u2500> LineageInfo (per item)\n                   \u2502   - TraversalPath\n                   \u2502   - LineageHops\n                   \u2502   - Data (optional)\n                   \u2502\n                   \u251c\u2500> PipelineLineageReport\n                   \u2502   - Nodes, Edges\n                   \u2502   - Run Metadata\n                   \u2502\n                   \u2193\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502   Lineage Sinks      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n                   \u251c\u2500> LoggingPipelineLineageSink\n                   \u251c\u2500> Custom ILineageSink\n                   \u251c\u2500> Custom IPipelineLineageSink\n                   \u2514\u2500> External Systems\n"})}),"\n",(0,a.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,a.jsx)(n.h3,{id:"lineagecollector",children:"LineageCollector"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"../../../src/NPipeline.Extensions.Lineage/LineageCollector.cs",children:(0,a.jsx)(n.code,{children:"LineageCollector"})})," is the central component for collecting and storing lineage data:"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Key Responsibilities:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Thread-safe collection of lineage data"}),"\n",(0,a.jsx)(n.li,{children:"Sampling logic implementation"}),"\n",(0,a.jsx)(n.li,{children:"Materialization cap enforcement"}),"\n",(0,a.jsx)(n.li,{children:"Overflow policy management"}),"\n",(0,a.jsx)(n.li,{children:"Query interface for collected data"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Thread-Safety Guarantees:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Uses ",(0,a.jsx)(n.code,{children:"ConcurrentDictionary<string, LineageTrail>"})," for storage"]}),"\n",(0,a.jsx)(n.li,{children:"Fine-grained locking for individual trail updates"}),"\n",(0,a.jsx)(n.li,{children:"Atomic operations for counters"}),"\n",(0,a.jsx)(n.li,{children:"Safe for parallel and concurrent pipeline executions"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Storage Structure:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Per-item lineage trail\ninternal sealed record LineageTrail(\n    Guid LineageId,\n    List<string> TraversalPath,\n    List<LineageHop> Hops,\n    object? Data\n);\n\n// Per-hop lineage information\npublic sealed record LineageHop(\n    string NodeId,\n    string Outcome,\n    Cardinality Cardinality,\n    int InputCount,\n    int OutputCount,\n    int[]? AncestryIndices,\n    bool Truncated\n);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"lineagepacket",children:"LineagePacket"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"LineagePacket"})," is the data structure that flows through the pipeline with each item:"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Purpose:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Carries lineage metadata alongside actual data"}),"\n",(0,a.jsx)(n.li,{children:"Enables automatic lineage tracking without node modifications"}),"\n",(0,a.jsx)(n.li,{children:"Transparent to pipeline execution"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Structure:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"internal sealed record LineagePacket<T>(\n    T Data,\n    Guid LineageId,\n    LineageTrail? Trail\n);\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Flow:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Created at source node with new ",(0,a.jsx)(n.code,{children:"LineageId"})]}),"\n",(0,a.jsx)(n.li,{children:"Updated at each node with hop information"}),"\n",(0,a.jsx)(n.li,{children:"Removed before reaching sink nodes"}),"\n",(0,a.jsx)(n.li,{children:"Final lineage stored in collector"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"lineageinfo",children:"LineageInfo"}),"\n",(0,a.jsx)(n.p,{children:"The public-facing record representing complete lineage for an item:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public sealed record LineageInfo(\n    object? Data,                           // Final data (nullable when redacted)\n    Guid LineageId,                         // Unique identifier\n    IReadOnlyList<string> TraversalPath,    // Node IDs passed through\n    IReadOnlyList<LineageHop> LineageHops   // Per-hop details\n);\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Design Rationale:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Immutable for thread-safety"}),"\n",(0,a.jsx)(n.li,{children:"Read-only collections for safe sharing"}),"\n",(0,a.jsx)(n.li,{children:"Nullable data field for redaction support"}),"\n",(0,a.jsx)(n.li,{children:"Complete history of item's journey"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"pipelinelineagereport",children:"PipelineLineageReport"}),"\n",(0,a.jsx)(n.p,{children:"High-level report containing pipeline structure and execution summary:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public sealed record PipelineLineageReport(\n    string PipelineName,\n    Guid RunId,\n    DateTimeOffset StartTime,\n    DateTimeOffset? EndTime,\n    IReadOnlyList<NodeInfo> Nodes,\n    IReadOnlyList<EdgeInfo> Edges,\n    IReadOnlyList<ILineageInfo> LineageInfo\n);\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Components:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Nodes"}),": All nodes in pipeline with types and configurations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Edges"}),": Connections between nodes showing data flow"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"LineageInfo"}),": All collected item-level lineage"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Metadata"}),": Pipeline name, run ID, timestamps"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"design-decisions",children:"Design Decisions"}),"\n",(0,a.jsx)(n.h3,{id:"1-transparent-integration",children:"1. Transparent Integration"}),"\n",(0,a.jsx)(n.p,{children:"Lineage tracking is designed to be completely transparent to node implementations:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Approach:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Wraps data in ",(0,a.jsx)(n.code,{children:"LineagePacket<T>"})," at source"]}),"\n",(0,a.jsx)(n.li,{children:"Unwraps before reaching sink nodes"}),"\n",(0,a.jsx)(n.li,{children:"Nodes operate on original data type"}),"\n",(0,a.jsx)(n.li,{children:"No modifications to node logic required"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Zero code changes to existing nodes"}),"\n",(0,a.jsx)(n.li,{children:"Works with any node implementation"}),"\n",(0,a.jsx)(n.li,{children:"Easy to enable/disable"}),"\n",(0,a.jsx)(n.li,{children:"No performance impact when disabled"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"2-sampling-at-collection-time",children:"2. Sampling at Collection Time"}),"\n",(0,a.jsx)(n.p,{children:"Sampling decisions are made when lineage data is collected, not when items flow:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Approach:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"ShouldCollectLineage()"})," called at each hop"]}),"\n",(0,a.jsx)(n.li,{children:"Consistent decision across entire item journey"}),"\n",(0,a.jsx)(n.li,{children:"Either all hops collected or none"}),"\n",(0,a.jsx)(n.li,{children:"Simplifies sampling logic"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Consistent lineage for sampled items"}),"\n",(0,a.jsx)(n.li,{children:"No partial lineage records"}),"\n",(0,a.jsx)(n.li,{children:"Easier to query and analyze"}),"\n",(0,a.jsx)(n.li,{children:"Predictable memory usage"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"3-thread-safe-by-default",children:"3. Thread-Safe by Default"}),"\n",(0,a.jsx)(n.p,{children:"All lineage operations are designed for concurrent execution:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Approach:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"ConcurrentDictionary"})," for storage"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Interlocked"})," operations for counters"]}),"\n",(0,a.jsx)(n.li,{children:"Immutable data structures"}),"\n",(0,a.jsx)(n.li,{children:"Scoped collector instances"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Safe for parallel pipeline execution"}),"\n",(0,a.jsx)(n.li,{children:"No race conditions"}),"\n",(0,a.jsx)(n.li,{children:"No locks for most operations"}),"\n",(0,a.jsx)(n.li,{children:"Scales with concurrency"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"4-materialization-cap",children:"4. Materialization Cap"}),"\n",(0,a.jsx)(n.p,{children:"Memory usage is controlled through materialization caps:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Approach:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Default cap of 10,000 items"}),"\n",(0,a.jsx)(n.li,{children:"Configurable overflow policies"}),"\n",(0,a.jsx)(n.li,{children:"Streaming mode when cap reached"}),"\n",(0,a.jsx)(n.li,{children:"Automatic cleanup of old data"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Prevents out-of-memory errors"}),"\n",(0,a.jsx)(n.li,{children:"Predictable memory usage"}),"\n",(0,a.jsx)(n.li,{children:"Configurable for different scenarios"}),"\n",(0,a.jsx)(n.li,{children:"Graceful degradation"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"5-sink-abstraction",children:"5. Sink Abstraction"}),"\n",(0,a.jsx)(n.p,{children:"Separate abstractions for item-level and pipeline-level lineage:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Interfaces:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public interface ILineageSink\n{\n    Task RecordAsync(LineageInfo lineageInfo, CancellationToken cancellationToken);\n}\n\npublic interface IPipelineLineageSink\n{\n    Task RecordAsync(PipelineLineageReport report, CancellationToken cancellationToken);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Flexible export destinations"}),"\n",(0,a.jsx)(n.li,{children:"Separate concerns (item vs pipeline)"}),"\n",(0,a.jsx)(n.li,{children:"Easy to extend"}),"\n",(0,a.jsx)(n.li,{children:"Multiple sinks supported"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"data-flow",children:"Data Flow"}),"\n",(0,a.jsx)(n.h3,{id:"item-flow-with-lineage",children:"Item Flow with Lineage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"Source Node\n  \u2193\n  Create LineagePacket<T> with new LineageId\n  \u2193\nTransform Node 1\n  \u2193\n  Update LineagePacket with Hop 1\n  \u2193\nTransform Node 2\n  \u2193\n  Update LineagePacket with Hop 2\n  \u2193\n...\n  \u2193\nSink Node\n  \u2193\n  Unwrap LineagePacket\n  \u2193\n  Store final LineageInfo in collector\n"})}),"\n",(0,a.jsx)(n.h3,{id:"collection-flow",children:"Collection Flow"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"1. Item enters pipeline\n   \u2193\n2. Create LineagePacket with LineageId\n   \u2193\n3. ShouldCollectLineage()? (Sampling check)\n   \u251c\u2500 Yes \u2192 Continue tracking\n   \u2514\u2500 No \u2192 Skip collection\n   \u2193\n4. At each node:\n   - Record hop information\n   - Update traversal path\n   - Check materialization cap\n   \u2193\n5. At sink:\n   - Unwrap packet\n   - Store LineageInfo\n   \u2193\n6. Pipeline complete:\n   - Generate PipelineLineageReport\n   - Send to IPipelineLineageSink\n"})}),"\n",(0,a.jsx)(n.h2,{id:"sampling-implementation",children:"Sampling Implementation"}),"\n",(0,a.jsx)(n.h3,{id:"deterministic-sampling",children:"Deterministic Sampling"}),"\n",(0,a.jsx)(n.p,{children:"Uses hash-based approach for consistent item selection:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"private bool ShouldCollectLineage(Guid lineageId)\n{\n    if (_options.SampleEvery <= 1)\n        return true;  // Collect all\n    \n    if (_options.DeterministicSampling)\n    {\n        // Hash-based: same items always selected\n        var hash = lineageId.GetHashCode();\n        return Math.Abs(hash % _options.SampleEvery) == 0;\n    }\n    else\n    {\n        // Random: different items each run\n        return Random.Shared.Next(_options.SampleEvery) == 0;\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Why Hash-Based:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Consistent across runs"}),"\n",(0,a.jsx)(n.li,{children:"No random number generator state issues"}),"\n",(0,a.jsx)(n.li,{children:"Deterministic for debugging"}),"\n",(0,a.jsx)(n.li,{children:"Fair distribution"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"sampling-granularity",children:"Sampling Granularity"}),"\n",(0,a.jsx)(n.p,{children:"Sampling is applied at the item level, not hop level:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Rationale:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Complete lineage or no lineage for an item"}),"\n",(0,a.jsx)(n.li,{children:"Easier to understand item journey"}),"\n",(0,a.jsx)(n.li,{children:"Consistent memory usage"}),"\n",(0,a.jsx)(n.li,{children:"Simpler querying"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"overflow-handling",children:"Overflow Handling"}),"\n",(0,a.jsx)(n.h3,{id:"materialize-policy",children:"Materialize Policy"}),"\n",(0,a.jsx)(n.p,{children:"Continues collecting without limits:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"private void RecordLineageInternal(LineageInfo lineageInfo)\n{\n    // No cap check\n    _lineageData[lineageInfo.LineageId] = lineageInfo;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Case:"})," Development, debugging, small datasets"]}),"\n",(0,a.jsx)(n.h3,{id:"degrade-policy-default",children:"Degrade Policy (Default)"}),"\n",(0,a.jsx)(n.p,{children:"Switches to streaming mode when cap reached:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"private void RecordLineageInternal(LineageInfo lineageInfo)\n{\n    if (_lineageData.Count >= _options.MaterializationCap)\n    {\n        // Stream to sink instead of storing\n        _lineageSink?.RecordAsync(lineageInfo, _cancellationToken);\n    }\n    else\n    {\n        _lineageData[lineageInfo.LineageId] = lineageInfo;\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Case:"})," Production, compliance, most scenarios"]}),"\n",(0,a.jsx)(n.h3,{id:"drop-policy",children:"Drop Policy"}),"\n",(0,a.jsx)(n.p,{children:"Stops collecting when cap reached:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"private void RecordLineageInternal(LineageInfo lineageInfo)\n{\n    if (_lineageData.Count >= _options.MaterializationCap)\n        return;  // Drop\n    \n    _lineageData[lineageInfo.LineageId] = lineageInfo;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Case:"})," High-volume monitoring, memory-constrained"]}),"\n",(0,a.jsx)(n.h2,{id:"sink-architecture",children:"Sink Architecture"}),"\n",(0,a.jsx)(n.h3,{id:"ilineagesink",children:"ILineageSink"}),"\n",(0,a.jsx)(n.p,{children:"Handles item-level lineage export:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Responsibilities:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Receive ",(0,a.jsx)(n.code,{children:"LineageInfo"})," for each collected item"]}),"\n",(0,a.jsx)(n.li,{children:"Export to external systems"}),"\n",(0,a.jsx)(n.li,{children:"Handle errors gracefully"}),"\n",(0,a.jsx)(n.li,{children:"Respect cancellation tokens"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Implementation Example:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public sealed class DatabaseLineageSink : ILineageSink\n{\n    public async Task RecordAsync(LineageInfo lineageInfo, CancellationToken cancellationToken)\n    {\n        await _repository.SaveLineageAsync(lineageInfo, cancellationToken);\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"ipipelinelineagesink",children:"IPipelineLineageSink"}),"\n",(0,a.jsx)(n.p,{children:"Handles pipeline-level lineage export:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Responsibilities:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Receive ",(0,a.jsx)(n.code,{children:"PipelineLineageReport"})," at pipeline completion"]}),"\n",(0,a.jsx)(n.li,{children:"Export pipeline structure and summary"}),"\n",(0,a.jsx)(n.li,{children:"Handle errors gracefully"}),"\n",(0,a.jsx)(n.li,{children:"Respect cancellation tokens"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Implementation Example:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public sealed class JsonFileLineageSink : IPipelineLineageSink\n{\n    public async Task RecordAsync(PipelineLineageReport report, CancellationToken cancellationToken)\n    {\n        var json = JsonSerializer.Serialize(report);\n        await File.WriteAllTextAsync(_filePath, json, cancellationToken);\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"sink-lifetime",children:"Sink Lifetime"}),"\n",(0,a.jsx)(n.p,{children:"Sinks are created per pipeline run:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Rationale:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Scoped lifetime for isolation"}),"\n",(0,a.jsx)(n.li,{children:"No state sharing between runs"}),"\n",(0,a.jsx)(n.li,{children:"Automatic disposal"}),"\n",(0,a.jsx)(n.li,{children:"Thread-safe by design"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,a.jsx)(n.h3,{id:"pipelinebuilder-extensions",children:"PipelineBuilder Extensions"}),"\n",(0,a.jsx)(n.p,{children:"Extension methods for enabling lineage:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public static class PipelineBuilderLineageExtensions\n{\n    public static PipelineBuilder EnableItemLevelLineage(\n        this PipelineBuilder builder,\n        Action<LineageOptions>? configureOptions = null);\n    \n    public static PipelineBuilder UseLoggingPipelineLineageSink(\n        this PipelineBuilder builder);\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"dependency-injection-integration",children:"Dependency Injection Integration"}),"\n",(0,a.jsx)(n.p,{children:"Service registration for DI containers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public static class LineageServiceCollectionExtensions\n{\n    public static IServiceCollection AddNPipelineLineage<TLineageSink>(\n        this IServiceCollection services)\n        where TLineageSink : class, ILineageSink;\n    \n    public static IServiceCollection AddNPipelineLineage<TLineageSink, TPipelineLineageSink>(\n        this IServiceCollection services)\n        where TLineageSink : class, ILineageSink\n        where TPipelineLineageSink : class, IPipelineLineageSink;\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(n.h3,{id:"memory-allocation",children:"Memory Allocation"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Per-item overhead"}),": Memory usage scales with data size and number of hops"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Per-pipeline overhead"}),": Fixed overhead for collector initialization"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Transient storage"}),": Cleared after pipeline execution"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"cpu-impact",children:"CPU Impact"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Hash calculation"}),": Fast operation per item"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dictionary lookup"}),": Efficient lookup per hop"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Lock-free operations"}),": Most operations are lock-free"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Async sinks"}),": Non-blocking to pipeline execution"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"scalability",children:"Scalability"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Linear scaling"}),": Memory usage scales with the number of items processed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Efficient lookups"}),": Dictionary operations provide fast access"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parallel-safe"}),": No contention with concurrent execution"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Configurable overhead"}),": Sampling reduces overall impact"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/extensions/lineage/getting-started",children:"Getting Started"})})," - Installation and basic setup"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/extensions/lineage/configuration",children:"Configuration"})})," - Configuration options and settings"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/extensions/lineage/performance",children:"Performance"})})," - Performance characteristics and optimization"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/extensions/lineage/use-cases",children:"Use Cases"})})," - Common use cases and examples"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>t});var l=i(96540);const a={},s=l.createContext(a);function r(e){const n=l.useContext(s);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),l.createElement(s.Provider,{value:n},e.children)}}}]);